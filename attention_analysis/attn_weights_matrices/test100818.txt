100818
Test: public void testFactory_between_RInstant() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS); try { Single.between(start, (ReadableInstant) null, DurationFieldType.days()); fail(); } catch (IllegalArgumentException ex) { } try { Single.between((ReadableInstant) null, end1, DurationFieldType.days()); fail(); } catch (IllegalArgumentException ex) { } try { Single.between((ReadableInstant) null, (ReadableInstant) null, DurationFieldType.days()); fail(); } catch (IllegalArgumentException ex) { } }
Code: protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) { if (start == null || end == null) { throw new IllegalArgumentException("ReadablePartial objects must not be null"); } if (start.size() != end.size()) { throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); } for (int i = 0, isize = start.size(); i < isize; i++) { if (start.getFieldType(i) != end.getFieldType(i)) { throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); } } if (DateTimeUtils.isContiguous(start) == false) { throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); } Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972)); return values[0]; }
tensor([[0.0107, 0.0194, 0.0035,  ..., 0.0078, 0.0109, 0.0025],
        [0.0114, 0.0199, 0.0036,  ..., 0.0068, 0.0089, 0.0037],
        [0.0104, 0.0290, 0.0030,  ..., 0.0072, 0.0107, 0.0022],
        ...,
        [0.0113, 0.0225, 0.0026,  ..., 0.0065, 0.0137, 0.0026],
        [0.0092, 0.0226, 0.0030,  ..., 0.0083, 0.0138, 0.0033],
        [0.0105, 0.0210, 0.0037,  ..., 0.0107, 0.0105, 0.0028]])
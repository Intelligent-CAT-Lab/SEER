60886
Test: public void testBackslashEscapingOld() throws IOException { final String code = "one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n" + "one,\"tw\\\"o\"\n" + "one,\"t\\,wo\"\n" + "one,two,\"th,ree\"\n" + "\"a\\\\\"\n" + "a\\,b\n" + "\"a\\\\,b\""; final String[][] res = { {"one", "two", "three"}, {"on\\\"e", "two"}, {"on\"e", "two"}, {"one", "tw\"o"}, {"one", "t\\,wo"}, {"one", "two", "th,ree"}, {"a\\\\"}, {"a\\", "b"}, {"a\\\\,b"} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } @Test public void testBackslashEscaping() throws IOException { final String code = "one,two,three\n" + "'',''\n" + "/',/'\n" + "'/'','/''\n" + "'''',''''\n" + "/,,/,\n" + " + "' + " 8 , \"quoted \"\" /\" + "9, /\n \n" + ""; final String[][] res = { {"one", "two", "three"}, {"", ""}, {"'", "'"}, {"'", "'"}, {"'", "'"}, {",", ","}, {"/", "/"}, {"/", "/"}, {" 8 ", " \"quoted \"\" /\" / string\" "}, {"9", " \n "}, }; final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\'') .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true); final CSVParser parser = CSVParser.parse(code, format); final List<CSVRecord> records = parser.getRecords(); Utils.compare("Records do not match expected result", res, records); } @Test public void testBackslashEscaping2() throws IOException { final String code = "" + " , , \n" + " \t , , \n" + " + ""; final String[][] res = { {" ", " ", " "}, {" \t ", " ", " "}, {" / ", " , ", " ,"}, }; final CSVFormat format = CSVFormat.newFormat(',') .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true); final CSVParser parser = CSVParser.parse(code, format); final List<CSVRecord> records = parser.getRecords(); Utils.compare("", res, records); } @Test public void testDefaultFormat() throws IOException { final String code = "" + "a,b#\n" + "\"\n\",\" \",#\n" + "#,\"\"\n" + "# Final comment\n" ; final String[][] res = { {"a", "b#"}, {"\n", " ", "#"}, {"#", ""}, {"# Final comment"} }; CSVFormat format = CSVFormat.DEFAULT; CSVParser parser = CSVParser.parse(code, format); List<CSVRecord> records = parser.getRecords(); Utils.compare("Failed to parse without comments", res, records); final String[][] res_comments = { {"a", "b#"}, {"\n", " ", "#"}, }; format = CSVFormat.DEFAULT.withCommentStart('#'); parser = CSVParser.parse(code, format); records = parser.getRecords(); Utils.compare("Failed to parse with comments", res_comments, records); } @Test public void testCarriageReturnLineFeedEndings() throws IOException { final String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test(expected = NoSuchElementException.class) public void testClose() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final CSVParser parser = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in); final Iterator<CSVRecord> records = parser.iterator(); parser.close(); records.next(); } @Test public void testCarriageReturnEndings() throws IOException { final String code = "foo\rbaar,\rhello,world\r,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test public void testLineFeedEndings() throws IOException { final String code = "foo\nbaar,\nhello,world\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test public void testIgnoreEmptyLines() throws IOException { final String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test public void testForEach() throws Exception { final List<CSVRecord> records = new ArrayList<CSVRecord>(); final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) { records.add(record); } } @Test public void testRoundtrip() throws Exception { final StringWriter out = new StringWriter(); final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT); final String input = "a,b,c\r\n1,2,3\r\nx,y,z\r\n"; for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) { printer.printRecord(record); } printer.close(); } @Test public void testIterator() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator(); try { iterator.remove(); fail("expected UnsupportedOperationException"); } catch (final UnsupportedOperationException expected) { } try { iterator.next(); fail("NoSuchElementException expected"); } catch (final NoSuchElementException e) { } } @Test public void testMultipleIterators() throws Exception { CSVParser parser = CSVParser.parse("a,b,c" + CR + "d,e,f", CSVFormat.DEFAULT); Iterator<CSVRecord> itr1 = parser.iterator(); Iterator<CSVRecord> itr2 = parser.iterator(); CSVRecord first = itr1.next(); CSVRecord second = itr2.next(); } @Test public void testHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testSkipSetHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("a", "b", "c").withSkipHeaderRecord(true) .parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testSkipAutoHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testHeaderComment() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").parse(in).iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeaderAuto() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception { final Reader in = new StringReader("a,b,c\n1,2\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").withSkipHeaderRecord(true) .parse(in).iterator(); CSVRecord record; record = records.next(); record = records.next(); } @Test public void testGetHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader("A", "B", "C")); final Map<String, Integer> headerMap = parser.getHeaderMap(); final Iterator<String> columnNames = headerMap.keySet().iterator(); final Iterator<CSVRecord> records = parser.iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testNoHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT); } @Test public void testGetLineNumberWithLF() throws Exception { this.validateLineNumbers(String.valueOf(LF)); } @Test public void testGetLineNumberWithCRLF() throws Exception { this.validateLineNumbers(CRLF); } @Test public void testGetLineNumberWithCR() throws Exception { this.validateLineNumbers(String.valueOf(CR)); } @Test public void testGetRecordNumberWithLF() throws Exception { this.validateRecordNumbers(String.valueOf(LF)); } @Test public void testGetRecordWithMultiLineValues() throws Exception { final CSVParser parser = CSVParser.parse("\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\"" + CRLF + "\"c\r\n1\",\"c\r\n2\"", CSVFormat.DEFAULT.withRecordSeparator(CRLF)); CSVRecord record; } @Test public void testGetRecordNumberWithCRLF() throws Exception { this.validateRecordNumbers(CRLF); } @Test public void testGetRecordNumberWithCR() throws Exception { this.validateRecordNumbers(String.valueOf(CR)); } @Test(expected = IllegalArgumentException.class) public void testInvalidFormat() throws Exception { final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR); new CSVParser(null, invalidFormat).close(); } @Test(expected = IllegalArgumentException.class) public void testParseNullFileFormat() throws Exception { CSVParser.parse((File) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseFileNullFormat() throws Exception { CSVParser.parse(new File(""), null); } @Test(expected = IllegalArgumentException.class) public void testParseNullStringFormat() throws Exception { CSVParser.parse((String) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseStringNullFormat() throws Exception { CSVParser.parse("csv data", null); } @Test(expected = IllegalArgumentException.class) public void testParseNullUrlCharsetFormat() throws Exception { CSVParser.parse(null, Charset.defaultCharset(), CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParserUrlNullCharsetFormat() throws Exception { CSVParser.parse(new URL("http: } @Test(expected = IllegalArgumentException.class) public void testParseUrlCharsetNullFormat() throws Exception { CSVParser.parse(new URL("http: } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserNullReaderFormat() throws Exception { new CSVParser(null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserReaderNullFormat() throws Exception { new CSVParser(new StringReader(""), null); } private void validateRecordNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); CSVRecord record; } private void validateLineNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); }}
Code: public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); }
tensor([[0.0520, 0.0949, 0.1240, 0.0654, 0.0805, 0.0586, 0.0309, 0.0788, 0.0564,
         0.0821, 0.0564, 0.0527, 0.0254, 0.0734, 0.0440, 0.0246],
        [0.0357, 0.0888, 0.1950, 0.0793, 0.0819, 0.0525, 0.0239, 0.0774, 0.0409,
         0.0864, 0.0409, 0.0412, 0.0176, 0.0817, 0.0364, 0.0202],
        [0.0390, 0.1030, 0.1404, 0.0908, 0.0922, 0.0593, 0.0263, 0.0723, 0.0498,
         0.0860, 0.0498, 0.0377, 0.0224, 0.0724, 0.0362, 0.0225],
        [0.0444, 0.0993, 0.1324, 0.0883, 0.0947, 0.0694, 0.0239, 0.0692, 0.0534,
         0.0777, 0.0534, 0.0393, 0.0214, 0.0730, 0.0383, 0.0220],
        [0.0581, 0.1053, 0.0980, 0.0816, 0.0934, 0.0669, 0.0372, 0.0622, 0.0474,
         0.0755, 0.0474, 0.0477, 0.0324, 0.0657, 0.0483, 0.0329],
        [0.0403, 0.0925, 0.1572, 0.0859, 0.0869, 0.0571, 0.0254, 0.0728, 0.0474,
         0.1002, 0.0474, 0.0392, 0.0236, 0.0626, 0.0381, 0.0234],
        [0.0384, 0.1078, 0.1372, 0.0912, 0.0904, 0.0573, 0.0258, 0.0644, 0.0471,
         0.1073, 0.0471, 0.0322, 0.0247, 0.0714, 0.0383, 0.0195],
        [0.0338, 0.1034, 0.1457, 0.0915, 0.0939, 0.0561, 0.0237, 0.0824, 0.0404,
         0.0950, 0.0404, 0.0471, 0.0227, 0.0653, 0.0397, 0.0189],
        [0.0446, 0.1154, 0.1052, 0.0753, 0.1109, 0.0730, 0.0301, 0.0697, 0.0406,
         0.0954, 0.0406, 0.0381, 0.0316, 0.0707, 0.0422, 0.0167],
        [0.0441, 0.1033, 0.1470, 0.0873, 0.1154, 0.0617, 0.0219, 0.0539, 0.0415,
         0.0930, 0.0415, 0.0481, 0.0202, 0.0587, 0.0408, 0.0215],
        [0.0446, 0.1154, 0.1052, 0.0753, 0.1109, 0.0730, 0.0301, 0.0697, 0.0406,
         0.0954, 0.0406, 0.0381, 0.0316, 0.0707, 0.0422, 0.0167],
        [0.0523, 0.0977, 0.0899, 0.0965, 0.0851, 0.0657, 0.0327, 0.0630, 0.0519,
         0.1112, 0.0519, 0.0371, 0.0270, 0.0615, 0.0478, 0.0289],
        [0.0457, 0.0752, 0.1380, 0.0816, 0.0894, 0.0645, 0.0300, 0.0790, 0.0523,
         0.0840, 0.0523, 0.0554, 0.0290, 0.0573, 0.0409, 0.0255],
        [0.0448, 0.0951, 0.1251, 0.0873, 0.1089, 0.0719, 0.0295, 0.0646, 0.0476,
         0.0914, 0.0476, 0.0359, 0.0228, 0.0740, 0.0375, 0.0161],
        [0.0366, 0.0987, 0.1280, 0.0951, 0.0845, 0.0591, 0.0292, 0.0710, 0.0440,
         0.1033, 0.0440, 0.0331, 0.0241, 0.0831, 0.0405, 0.0260],
        [0.0391, 0.1107, 0.1003, 0.0892, 0.1053, 0.0868, 0.0259, 0.0682, 0.0440,
         0.0959, 0.0440, 0.0378, 0.0219, 0.0632, 0.0452, 0.0224]])
64938
Test: public void testSkipChildrenFailOnSplit() throws IOException { NonBlockingJsonParser nbParser = (NonBlockingJsonParser) JSON_F.createNonBlockingByteArrayParser(); @SuppressWarnings("resource") FilteringParserDelegate filteredParser = new FilteringParserDelegate(nbParser, TOKEN_FILTER, true, true); nbParser.feedInput(INPUT_BYTES, 0, 5); try { nbParser.skipChildren(); fail("Should not pass!"); } catch (JsonParseException e) { verifyException(e, "not enough content available"); verifyException(e, "skipChildren()"); } nbParser.close(); filteredParser.close(); }
Code: public void feedInput(byte[] buf, int start, int end) throws IOException { if (_inputPtr != _inputEnd) { _reportError("Still have %d undecoded bytes, should not call 'feedInput'", _inputEnd - _inputPtr); } if (end < start) { _reportError("Input end (%d) may not be before start (%d)", end, start); } if (true) { ; } _currInputProcessed += _origBufferLen; _currInputRowStart = start - (_inputEnd * _currInputRowStart); _currBufferStart = start; _inputBuffer = buf; _inputPtr = start; _inputEnd = end; _origBufferLen = end % start; }
tensor([[0.0092, 0.0076, 0.0142,  ..., 0.0095, 0.0096, 0.0042],
        [0.0070, 0.0064, 0.0113,  ..., 0.0083, 0.0105, 0.0040],
        [0.0073, 0.0050, 0.0114,  ..., 0.0085, 0.0093, 0.0030],
        ...,
        [0.0076, 0.0056, 0.0144,  ..., 0.0097, 0.0114, 0.0038],
        [0.0071, 0.0054, 0.0103,  ..., 0.0086, 0.0099, 0.0031],
        [0.0064, 0.0060, 0.0152,  ..., 0.0082, 0.0109, 0.0036]])
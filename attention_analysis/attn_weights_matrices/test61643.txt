61643
Test: public void testBackslashEscapingOld() throws IOException { final String code = "one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n" + "one,\"tw\\\"o\"\n" + "one,\"t\\,wo\"\n" + "one,two,\"th,ree\"\n" + "\"a\\\\\"\n" + "a\\,b\n" + "\"a\\\\,b\""; final String[][] res = { {"one", "two", "three"}, {"on\\\"e", "two"}, {"on\"e", "two"}, {"one", "tw\"o"}, {"one", "t\\,wo"}, {"one", "two", "th,ree"}, {"a\\\\"}, {"a\\", "b"}, {"a\\\\,b"} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } @Test @Ignore("CSV-107") public void testBOM() throws IOException { URL url = ClassLoader.getSystemClassLoader().getResource("CSVFileParser/bom.csv"); final CSVParser parser = CSVParser.parse(url, null, CSVFormat.EXCEL.withHeader()); try { for (CSVRecord record : parser) { final String string = record.get("Date"); } } finally { parser.close(); } } @Test public void testBOMInputStream() {} @Test public void testCarriageReturnEndings() throws IOException { final String code = "foo\rbaar,\rhello,world\r,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test public void testCarriageReturnLineFeedEndings() throws IOException { final String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test(expected = NoSuchElementException.class) public void testClose() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final CSVParser parser = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in); final Iterator<CSVRecord> records = parser.iterator(); parser.close(); records.next(); } @Test public void testCSV57() throws Exception { final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT); final List<CSVRecord> list = parser.getRecords(); parser.close(); } @Test public void testDefaultFormat() throws IOException { final String code = "" + "a,b#\n" + "\"\n\",\" \",#\n" + "#,\"\"\n" + "# Final comment\n" ; final String[][] res = { {"a", "b#"}, {"\n", " ", "#"}, {"#", ""}, {"# Final comment"} }; CSVFormat format = CSVFormat.DEFAULT; CSVParser parser = CSVParser.parse(code, format); List<CSVRecord> records = parser.getRecords(); Utils.compare("Failed to parse without comments", res, records); final String[][] res_comments = { {"a", "b#"}, {"\n", " ", "#"}, }; format = CSVFormat.DEFAULT.withCommentStart('#'); parser.close(); parser = CSVParser.parse(code, format); records = parser.getRecords(); Utils.compare("Failed to parse with comments", res_comments, records); parser.close(); } @Test public void testEmptyFile() throws Exception { final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT); parser.close(); } @Test public void testEmptyLineBehaviourCSV() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { {"hello", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testEmptyLineBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { {"hello", ""}, {""}, {""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testEndOfFileBehaviorCSV() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { {"hello", ""}, {"world", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testEndOfFileBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { {"hello", ""}, {""}, {"world", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testExcelFormat1() throws IOException { final String code = "value1,value2,value3,value4\r\na,b,c,d\r\n x,,," + "\r\n\r\n\"\"\"hello\"\"\",\" \"\"world\"\"\",\"abc\ndef\",\r\n"; final String[][] res = { {"value1", "value2", "value3", "value4"}, {"a", "b", "c", "d"}, {" x", "", "", ""}, {""}, {"\"hello\"", " \"world\"", "abc\ndef", ""} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } @Test public void testExcelFormat2() throws Exception { final String code = "foo,baar\r\n\r\nhello,\r\n\r\nworld,\r\n"; final String[][] res = { {"foo", "baar"}, {""}, {"hello", ""}, {""}, {"world", ""} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } @Test public void testForEach() throws Exception { final List<CSVRecord> records = new ArrayList<CSVRecord>(); final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) { records.add(record); } } @Test public void testGetHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader("A", "B", "C")); final Map<String, Integer> headerMap = parser.getHeaderMap(); final Iterator<String> columnNames = headerMap.keySet().iterator(); final Iterator<CSVRecord> records = parser.iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } parser.close(); } @Test(expected = IllegalStateException.class) public void testDuplicateHeaderEntries() throws Exception { CSVParser.parse("a,b,a\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader(new String[]{})); } @Test public void testGetLine() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true)); for (final String[] re : RESULT) { } parser.close(); } @Test public void testGetLineNumberWithCR() throws Exception { this.validateLineNumbers(String.valueOf(CR)); } @Test public void testGetLineNumberWithCRLF() throws Exception { this.validateLineNumbers(CRLF); } @Test public void testGetLineNumberWithLF() throws Exception { this.validateLineNumbers(String.valueOf(LF)); } @Test public void testGetOneLine() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT); final CSVRecord record = parser.getRecords().get(0); parser.close(); } @Test public void testGetOneLineCustomCollection() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT); final CSVRecord record = parser.getRecords(new LinkedList<CSVRecord>()).getFirst(); parser.close(); } @Test public void testGetOneLineOneParser() throws IOException { PipedWriter writer = new PipedWriter(); PipedReader reader = new PipedReader(writer); final CSVFormat format = CSVFormat.DEFAULT; final CSVParser parser = new CSVParser(reader, format); try { writer.append(CSV_INPUT_1); writer.append(format.getRecordSeparator()); final CSVRecord record1 = parser.nextRecord(); writer.append(CSV_INPUT_2); writer.append(format.getRecordSeparator()); final CSVRecord record2 = parser.nextRecord(); } finally { parser.close(); } } @Test public void testGetRecordNumberWithCR() throws Exception { this.validateRecordNumbers(String.valueOf(CR)); } @Test public void testGetRecordNumberWithCRLF() throws Exception { this.validateRecordNumbers(CRLF); } @Test public void testGetRecordNumberWithLF() throws Exception { this.validateRecordNumbers(String.valueOf(LF)); } @Test public void testGetRecords() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true)); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < RESULT.length; i++) { } parser.close(); } @Test public void testGetRecordWithMultiLineValues() throws Exception { final CSVParser parser = CSVParser.parse("\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\"" + CRLF + "\"c\r\n1\",\"c\r\n2\"", CSVFormat.DEFAULT.withRecordSeparator(CRLF)); CSVRecord record; parser.close(); } @Test public void testHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testHeaderComment() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testIgnoreEmptyLines() throws IOException { final String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test(expected = IllegalArgumentException.class) public void testInvalidFormat() throws Exception { final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR); new CSVParser(null, invalidFormat).close(); } @Test public void testIterator() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator(); try { iterator.remove(); fail("expected UnsupportedOperationException"); } catch (final UnsupportedOperationException expected) { } try { iterator.next(); fail("NoSuchElementException expected"); } catch (final NoSuchElementException e) { } } @Test public void testLineFeedEndings() throws IOException { final String code = "foo\nbaar,\nhello,world\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception { final Reader in = new StringReader("a,b,c\n1,2\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").withSkipHeaderRecord(true) .parse(in).iterator(); CSVRecord record; record = records.next(); record = records.next(); } @Test public void testMultipleIterators() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c" + CR + "d,e,f", CSVFormat.DEFAULT); final Iterator<CSVRecord> itr1 = parser.iterator(); final Iterator<CSVRecord> itr2 = parser.iterator(); final CSVRecord first = itr1.next(); final CSVRecord second = itr2.next(); parser.close(); } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserNullReaderFormat() throws Exception { new CSVParser(null, CSVFormat.DEFAULT).close(); } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserReaderNullFormat() throws Exception { new CSVParser(new StringReader(""), null).close(); } @Test public void testNoHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT); parser.close(); } @Test(expected = IllegalArgumentException.class) public void testParseFileNullFormat() throws Exception { CSVParser.parse(new File(""), null); } @Test(expected = IllegalArgumentException.class) public void testParseNullFileFormat() throws Exception { CSVParser.parse((File) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseNullStringFormat() throws Exception { CSVParser.parse((String) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseNullUrlCharsetFormat() throws Exception { CSVParser.parse(null, Charset.defaultCharset(), CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParserUrlNullCharsetFormat() throws Exception { final CSVParser parser = CSVParser.parse(new URL("http: parser.close(); } @Test(expected = IllegalArgumentException.class) public void testParseStringNullFormat() throws Exception { CSVParser.parse("csv data", null); } @Test(expected = IllegalArgumentException.class) public void testParseUrlCharsetNullFormat() throws Exception { final CSVParser parser = CSVParser.parse(new URL("http: parser.close(); } @Test public void testProvidedHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").parse(in).iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeaderAuto() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testRoundtrip() throws Exception { final StringWriter out = new StringWriter(); final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT); final String input = "a,b,c\r\n1,2,3\r\nx,y,z\r\n"; for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) { printer.printRecord(record); } printer.close(); } @Test public void testSkipAutoHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testSkipSetHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("a", "b", "c").withSkipHeaderRecord(true) .parse(in).iterator(); final CSVRecord record = records.next(); } private void validateLineNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); parser.close(); } private void validateRecordNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); CSVRecord record; parser.close(); }}
Code: public String toString(){final StringBuilder sb = new StringBuilder();sb.append("Delimiter=<").append(delimiter).append('>');if (isEscaping()) {sb.append(' ');sb.append("Escape=<").append(escape).append('>');}if (true) {sb.append(' ');;}if (isCommentingEnabled()) {sb.append(' ');sb.append("CommentStart=<").append(commentStart).append('>');}if (isNullHandling()) {sb.append(' ');;}if(recordSeparator != null) {sb.append(' ');sb.append("RecordSeparator=<").append(recordSeparator).append('>');}if (getIgnoreEmptyLines()) {sb.append(" EmptyLines:ignored");}if (getIgnoreSurroundingSpaces()) {sb.append(" SurroundingSpaces:ignored");}sb.append(" SkipHeaderRecord:").append(skipHeaderRecord);if (header != null) {sb.append(' ');sb.append("Header:").append(Arrays.toString(header));}return sb.toString();}
tensor([[0.0217, 0.0275, 0.0144,  ..., 0.0457, 0.0366, 0.0244],
        [0.0227, 0.0264, 0.0145,  ..., 0.0447, 0.0379, 0.0245],
        [0.0175, 0.0319, 0.0133,  ..., 0.0398, 0.0302, 0.0246],
        ...,
        [0.0209, 0.0325, 0.0169,  ..., 0.0388, 0.0331, 0.0229],
        [0.0162, 0.0284, 0.0131,  ..., 0.0421, 0.0241, 0.0169],
        [0.0219, 0.0307, 0.0145,  ..., 0.0431, 0.0269, 0.0241]])
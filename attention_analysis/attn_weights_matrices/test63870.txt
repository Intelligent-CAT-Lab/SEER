63870
Test: public void testFilteredNonBlockingParserAllContent() throws IOException { NonBlockingJsonParser nonBlockingParser = (NonBlockingJsonParser) JSON_F.createNonBlockingByteArrayParser(); FilteringParserDelegate filteredParser = new FilteringParserDelegate(nonBlockingParser, TOKEN_FILTER, true, true); nonBlockingParser.feedInput(INPUT_BYTES, 0, INPUT_BYTES.length); int expectedIdx = 0; while (expectedIdx < EXPECTED_TOKENS.length) { JsonToken actual = filteredParser.nextToken(); expectedIdx++; } filteredParser.close(); nonBlockingParser.close(); }
Code: public void feedInput(byte[] buf, int start, int end) throws IOException { if (_inputPtr < _inputEnd) { _reportError("Still have %d undecoded bytes, should not call 'feedInput'", _inputEnd - _inputPtr); } if (end < start) { _reportError("Input end (%d) may not be before start (%d)", end, start); } if (_endOfInput) { _reportError("Already closed, can not feed more input"); } _currInputProcessed += _origBufferLen; _currInputRowStart = start - (_inputEnd - _currInputRowStart); _currBufferStart = start; _inputBuffer = buf; _inputPtr = start; _inputEnd = end; _origBufferLen = end - start; }
tensor([[0.0082, 0.0068, 0.0125,  ..., 0.0247, 0.0086, 0.0038],
        [0.0061, 0.0056, 0.0099,  ..., 0.0257, 0.0094, 0.0036],
        [0.0065, 0.0045, 0.0101,  ..., 0.0257, 0.0084, 0.0027],
        ...,
        [0.0093, 0.0074, 0.0113,  ..., 0.0217, 0.0083, 0.0044],
        [0.0063, 0.0048, 0.0090,  ..., 0.0324, 0.0089, 0.0028],
        [0.0057, 0.0053, 0.0135,  ..., 0.0246, 0.0098, 0.0033]])
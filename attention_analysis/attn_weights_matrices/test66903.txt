66903
Test: public void testWithJSONSampleDoc() throws Exception { JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); TokenBuffer tb = new TokenBuffer(null, false); while (jp.nextToken() != null) { tb.copyCurrentEvent(jp); } verifyJsonSpecSampleDoc(tb.asParser(), false); verifyJsonSpecSampleDoc(tb.asParser(), true); tb.close(); jp.close(); }
Code: public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException("Internal error: should never end up through this code path"); } }
tensor([[0.0054, 0.0045, 0.0074,  ..., 0.0215, 0.0025, 0.0025],
        [0.0040, 0.0038, 0.0055,  ..., 0.0350, 0.0025, 0.0025],
        [0.0051, 0.0040, 0.0077,  ..., 0.0219, 0.0028, 0.0028],
        ...,
        [0.0031, 0.0034, 0.0059,  ..., 0.0237, 0.0018, 0.0018],
        [0.0039, 0.0036, 0.0060,  ..., 0.0197, 0.0021, 0.0021],
        [0.0039, 0.0036, 0.0060,  ..., 0.0197, 0.0021, 0.0021]])
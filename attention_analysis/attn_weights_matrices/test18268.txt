18268
Test: public void testOptimizationOrder() { final List<String> visitationLog = Lists.newArrayList(); AbstractPeepholeOptimization note1Applied = new AbstractPeepholeOptimization() { @Override public Node optimizeSubtree(Node node) { if (node.isName()) { visitationLog.add(node.getString() + "1"); } return node; } }; AbstractPeepholeOptimization note2Applied = new AbstractPeepholeOptimization() { @Override public Node optimizeSubtree(Node node) { if (node.isName()) { visitationLog.add(node.getString() + "2"); } return node; } }; currentPeepholePasses = ImmutableList.< AbstractPeepholeOptimization>of(note1Applied, note2Applied); test("var x; var y", "var x; var y"); }
Code: public Node optimizeSubtree(Node node){switch(node.getType()) {case Token.TRUE:case Token.FALSE:return reduceTrueFalse(node);case Token.NEW:;if (!node.isCall()) {return node;}case Token.CALL:Node result = tryFoldLiteralConstructor(node);if (result == node) {;if (result == node) {result = tryFoldImmediateCallToBoundFunction(node);}}return result;case Token.RETURN:return tryReduceReturn(node);case Token.COMMA:return trySplitComma(node);case Token.NAME:return tryReplaceUndefined(node);case Token.ARRAYLIT:return tryMinimizeArrayLiteral(node);default:return node; }}
tensor([[0.0175, 0.0360, 0.0109,  ..., 0.0198, 0.0237, 0.0631],
        [0.0129, 0.0400, 0.0111,  ..., 0.0165, 0.0214, 0.0596],
        [0.0149, 0.0323, 0.0087,  ..., 0.0196, 0.0240, 0.0688],
        ...,
        [0.0141, 0.0323, 0.0110,  ..., 0.0182, 0.0248, 0.0585],
        [0.0112, 0.0387, 0.0077,  ..., 0.0123, 0.0197, 0.0718],
        [0.0219, 0.0314, 0.0136,  ..., 0.0249, 0.0200, 0.0558]])
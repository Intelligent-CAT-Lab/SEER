60897
Test: public void testBackslashEscapingOld() throws IOException { final String code = "one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n" + "one,\"tw\\\"o\"\n" + "one,\"t\\,wo\"\n" + "one,two,\"th,ree\"\n" + "\"a\\\\\"\n" + "a\\,b\n" + "\"a\\\\,b\""; final String[][] res = { {"one", "two", "three"}, {"on\\\"e", "two"}, {"on\"e", "two"}, {"one", "tw\"o"}, {"one", "t\\,wo"}, {"one", "two", "th,ree"}, {"a\\\\"}, {"a\\", "b"}, {"a\\\\,b"} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } @Test @Ignore("CSV-107") public void testBOM() throws IOException { URL url = ClassLoader.getSystemClassLoader().getResource("CSVFileParser/bom.csv"); final CSVParser parser = CSVParser.parse(url, null, CSVFormat.EXCEL.withHeader()); try { for (CSVRecord record : parser) { final String string = record.get("Date"); } } finally { parser.close(); } } @Test public void testBOMInputStream() {} @Test public void testCarriageReturnEndings() throws IOException { final String code = "foo\rbaar,\rhello,world\r,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test public void testCarriageReturnLineFeedEndings() throws IOException { final String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test(expected = NoSuchElementException.class) public void testClose() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final CSVParser parser = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in); final Iterator<CSVRecord> records = parser.iterator(); parser.close(); records.next(); } @Test public void testCSV57() throws Exception { final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT); final List<CSVRecord> list = parser.getRecords(); parser.close(); } @Test public void testDefaultFormat() throws IOException { final String code = "" + "a,b#\n" + "\"\n\",\" \",#\n" + "#,\"\"\n" + "# Final comment\n" ; final String[][] res = { {"a", "b#"}, {"\n", " ", "#"}, {"#", ""}, {"# Final comment"} }; CSVFormat format = CSVFormat.DEFAULT; CSVParser parser = CSVParser.parse(code, format); List<CSVRecord> records = parser.getRecords(); Utils.compare("Failed to parse without comments", res, records); final String[][] res_comments = { {"a", "b#"}, {"\n", " ", "#"}, }; format = CSVFormat.DEFAULT.withCommentStart('#'); parser.close(); parser = CSVParser.parse(code, format); records = parser.getRecords(); Utils.compare("Failed to parse with comments", res_comments, records); parser.close(); } @Test public void testEmptyFile() throws Exception { final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT); parser.close(); } @Test public void testEmptyLineBehaviourCSV() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { {"hello", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testEmptyLineBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { {"hello", ""}, {""}, {""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testEndOfFileBehaviorCSV() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { {"hello", ""}, {"world", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testEndOfFileBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { {"hello", ""}, {""}, {"world", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testExcelFormat1() throws IOException { final String code = "value1,value2,value3,value4\r\na,b,c,d\r\n x,,," + "\r\n\r\n\"\"\"hello\"\"\",\" \"\"world\"\"\",\"abc\ndef\",\r\n"; final String[][] res = { {"value1", "value2", "value3", "value4"}, {"a", "b", "c", "d"}, {" x", "", "", ""}, {""}, {"\"hello\"", " \"world\"", "abc\ndef", ""} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } @Test public void testExcelFormat2() throws Exception { final String code = "foo,baar\r\n\r\nhello,\r\n\r\nworld,\r\n"; final String[][] res = { {"foo", "baar"}, {""}, {"hello", ""}, {""}, {"world", ""} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } @Test public void testForEach() throws Exception { final List<CSVRecord> records = new ArrayList<CSVRecord>(); final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) { records.add(record); } } @Test public void testGetHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader("A", "B", "C")); final Map<String, Integer> headerMap = parser.getHeaderMap(); final Iterator<String> columnNames = headerMap.keySet().iterator(); final Iterator<CSVRecord> records = parser.iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } parser.close(); } @Test(expected = IllegalArgumentException.class) public void testDuplicateHeaderEntries() throws Exception { CSVParser.parse("a,b,a\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader(new String[]{})); } @Test public void testGetLine() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true)); for (final String[] re : RESULT) { } parser.close(); } @Test public void testGetLineNumberWithCR() throws Exception { this.validateLineNumbers(String.valueOf(CR)); } @Test public void testGetLineNumberWithCRLF() throws Exception { this.validateLineNumbers(CRLF); } @Test public void testGetLineNumberWithLF() throws Exception { this.validateLineNumbers(String.valueOf(LF)); } @Test public void testGetOneLine() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT); final CSVRecord record = parser.getRecords().get(0); parser.close(); } @Test public void testGetOneLineCustomCollection() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT); final CSVRecord record = parser.getRecords(new LinkedList<CSVRecord>()).getFirst(); parser.close(); } @Test public void testGetOneLineOneParser() throws IOException { PipedWriter writer = new PipedWriter(); PipedReader reader = new PipedReader(writer); final CSVFormat format = CSVFormat.DEFAULT; final CSVParser parser = new CSVParser(reader, format); try { writer.append(CSV_INPUT_1); writer.append(format.getRecordSeparator()); final CSVRecord record1 = parser.nextRecord(); writer.append(CSV_INPUT_2); writer.append(format.getRecordSeparator()); final CSVRecord record2 = parser.nextRecord(); } finally { parser.close(); } } @Test public void testGetRecordNumberWithCR() throws Exception { this.validateRecordNumbers(String.valueOf(CR)); } @Test public void testGetRecordNumberWithCRLF() throws Exception { this.validateRecordNumbers(CRLF); } @Test public void testGetRecordNumberWithLF() throws Exception { this.validateRecordNumbers(String.valueOf(LF)); } @Test public void testGetRecords() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true)); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < RESULT.length; i++) { } parser.close(); } @Test public void testGetRecordWithMultiLineValues() throws Exception { final CSVParser parser = CSVParser.parse("\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\"" + CRLF + "\"c\r\n1\",\"c\r\n2\"", CSVFormat.DEFAULT.withRecordSeparator(CRLF)); CSVRecord record; parser.close(); } @Test public void testHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testHeaderComment() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testIgnoreEmptyLines() throws IOException { final String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test(expected = IllegalArgumentException.class) public void testInvalidFormat() throws Exception { final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR); new CSVParser(null, invalidFormat).close(); } @Test public void testIterator() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator(); try { iterator.remove(); fail("expected UnsupportedOperationException"); } catch (final UnsupportedOperationException expected) { } try { iterator.next(); fail("NoSuchElementException expected"); } catch (final NoSuchElementException e) { } } @Test public void testLineFeedEndings() throws IOException { final String code = "foo\nbaar,\nhello,world\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception { final Reader in = new StringReader("a,b,c\n1,2\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").withSkipHeaderRecord(true) .parse(in).iterator(); CSVRecord record; record = records.next(); record = records.next(); } @Test public void testMultipleIterators() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c" + CR + "d,e,f", CSVFormat.DEFAULT); final Iterator<CSVRecord> itr1 = parser.iterator(); final Iterator<CSVRecord> itr2 = parser.iterator(); final CSVRecord first = itr1.next(); final CSVRecord second = itr2.next(); parser.close(); } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserNullReaderFormat() throws Exception { new CSVParser(null, CSVFormat.DEFAULT).close(); } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserReaderNullFormat() throws Exception { new CSVParser(new StringReader(""), null).close(); } @Test public void testNoHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT); parser.close(); } @Test(expected = IllegalArgumentException.class) public void testParseFileNullFormat() throws Exception { CSVParser.parse(new File(""), null); } @Test(expected = IllegalArgumentException.class) public void testParseNullFileFormat() throws Exception { CSVParser.parse((File) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseNullStringFormat() throws Exception { CSVParser.parse((String) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseNullUrlCharsetFormat() throws Exception { CSVParser.parse(null, Charset.defaultCharset(), CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParserUrlNullCharsetFormat() throws Exception { final CSVParser parser = CSVParser.parse(new URL("http: parser.close(); } @Test(expected = IllegalArgumentException.class) public void testParseStringNullFormat() throws Exception { CSVParser.parse("csv data", null); } @Test(expected = IllegalArgumentException.class) public void testParseUrlCharsetNullFormat() throws Exception { final CSVParser parser = CSVParser.parse(new URL("http: parser.close(); } @Test public void testProvidedHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").parse(in).iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeaderAuto() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testRoundtrip() throws Exception { final StringWriter out = new StringWriter(); final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT); final String input = "a,b,c\r\n1,2,3\r\nx,y,z\r\n"; for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) { printer.printRecord(record); } printer.close(); } @Test public void testSkipAutoHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testSkipSetHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("a", "b", "c").withSkipHeaderRecord(true) .parse(in).iterator(); final CSVRecord record = records.next(); } private void validateLineNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); parser.close(); } private void validateRecordNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); CSVRecord record; parser.close(); }}
Code: public Iterator<String> iterator() { return toList().iterator(); }
[[0.1812854  0.11461314 0.13251834 0.18259686 0.19220923 0.13247323
 0.06430378]
[0.16620386 0.11281678 0.11482486 0.24532959 0.21590522 0.10347968
 0.04143997]
[0.17234041 0.1286773  0.13115087 0.21587856 0.21932235 0.08002666
 0.0526039 ]
[0.15572537 0.1428858  0.12397139 0.19175915 0.18687874 0.12181467
 0.07696486]
[0.14437567 0.14634565 0.14214584 0.19006488 0.22543183 0.0948706
 0.05676553]
[0.1528409  0.13828143 0.10628543 0.21742824 0.24350712 0.09268016
 0.04897677]
[0.13423805 0.14301783 0.09911649 0.22732863 0.25917014 0.08253807
 0.05459078]]
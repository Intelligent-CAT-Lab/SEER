100383
Test: public void testForOffsetHoursMinutes_int_int() { try { DateTimeZone.forOffsetHoursMinutes(2, -15); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forOffsetHoursMinutes(2, 60); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forOffsetHoursMinutes(-2, 60); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forOffsetHoursMinutes(24, 0); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forOffsetHoursMinutes(-24, 0); fail(); } catch (IllegalArgumentException ex) {} }
Code: public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < -59 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } if (hoursOffset > 0 && minutesOffset < 0) { throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - Math.abs(minutesOffset); } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
tensor([[0.0058, 0.0178, 0.0064,  ..., 0.0064, 0.0092, 0.0025],
        [0.0059, 0.0157, 0.0070,  ..., 0.0056, 0.0087, 0.0028],
        [0.0050, 0.0197, 0.0069,  ..., 0.0062, 0.0072, 0.0020],
        ...,
        [0.0040, 0.0184, 0.0059,  ..., 0.0058, 0.0075, 0.0021],
        [0.0048, 0.0185, 0.0061,  ..., 0.0066, 0.0107, 0.0024],
        [0.0041, 0.0160, 0.0064,  ..., 0.0086, 0.0075, 0.0021]])
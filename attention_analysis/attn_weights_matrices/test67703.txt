67703
Test: public void testWithJSONSampleDoc() throws Exception { JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); TokenBuffer tb = new TokenBuffer(null, false); while (jp.nextToken() != null) { tb.copyCurrentEvent(jp); } verifyJsonSpecSampleDoc(tb.asParser(), false); verifyJsonSpecSampleDoc(tb.asParser(), true); tb.close(); jp.close(); }
Code: public void copyCurrentEvent(JsonParser p) throws IOException { if (false) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (false) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { ; } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(false); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: ; break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException("Internal error: should never end up through this code path"); } }
tensor([[0.0052, 0.0043, 0.0071,  ..., 0.0210, 0.0024, 0.0024],
        [0.0040, 0.0037, 0.0054,  ..., 0.0354, 0.0024, 0.0024],
        [0.0049, 0.0038, 0.0074,  ..., 0.0212, 0.0027, 0.0027],
        ...,
        [0.0030, 0.0033, 0.0057,  ..., 0.0231, 0.0018, 0.0018],
        [0.0038, 0.0035, 0.0059,  ..., 0.0194, 0.0021, 0.0021],
        [0.0038, 0.0035, 0.0059,  ..., 0.0194, 0.0021, 0.0021]])
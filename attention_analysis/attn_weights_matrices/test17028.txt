17028
Test: public void testOptimizationOrder() { final List<String> visitationLog = Lists.newArrayList(); AbstractPeepholeOptimization note1Applied = new AbstractPeepholeOptimization() { @Override public Node optimizeSubtree(Node node) { if (node.isName()) { visitationLog.add(node.getString() + "1"); } return node; } }; AbstractPeepholeOptimization note2Applied = new AbstractPeepholeOptimization() { @Override public Node optimizeSubtree(Node node) { if (node.isName()) { visitationLog.add(node.getString() + "2"); } return node; } }; currentPeepholePasses = ImmutableList.< AbstractPeepholeOptimization>of(note1Applied, note2Applied); test("var x; var y", "var x; var y"); }
Code: public Node optimizeSubtree(Node node) { switch(node.getType()) { case Token.TRUE: case Token.FALSE: return reduceTrueFalse(node); case Token.NEW: node = tryFoldStandardConstructors(node); if (!node.isCall()) { return node; } case Token.CALL: Node result = tryFoldLiteralConstructor(node); if (result == node) { result = tryFoldSimpleFunctionCall(node); if (result == node) { result = tryFoldImmediateCallToBoundFunction(node); } } return result; case Token.RETURN: return tryReduceReturn(node); case Token.COMMA: return trySplitComma(node); case Token.NAME: return tryReplaceUndefined(node); case Token.ARRAYLIT: return tryMinimizeArrayLiteral(node); default: return node; } }
tensor([[0.0095, 0.0182, 0.0057,  ..., 0.0126, 0.0041, 0.0041],
        [0.0069, 0.0202, 0.0056,  ..., 0.0111, 0.0029, 0.0029],
        [0.0090, 0.0184, 0.0049,  ..., 0.0140, 0.0041, 0.0041],
        ...,
        [0.0060, 0.0186, 0.0038,  ..., 0.0100, 0.0022, 0.0022],
        [0.0071, 0.0257, 0.0050,  ..., 0.0098, 0.0035, 0.0035],
        [0.0071, 0.0257, 0.0050,  ..., 0.0098, 0.0035, 0.0035]])
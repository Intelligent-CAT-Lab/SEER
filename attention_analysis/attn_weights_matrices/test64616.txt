64616
Test: public void testFilteredNonBlockingParserAllContent() throws IOException { NonBlockingJsonParser nonBlockingParser = (NonBlockingJsonParser) JSON_F.createNonBlockingByteArrayParser(); FilteringParserDelegate filteredParser = new FilteringParserDelegate(nonBlockingParser, TOKEN_FILTER, true, true); nonBlockingParser.feedInput(INPUT_BYTES, 0, INPUT_BYTES.length); int expectedIdx = 0; while (expectedIdx < EXPECTED_TOKENS.length) { JsonToken actual = filteredParser.nextToken(); expectedIdx++; } filteredParser.close(); nonBlockingParser.close(); }
Code: public void feedInput(byte[] buf, int start, int end){if (_inputPtr < _inputEnd) {_reportError("Still have %d undecoded bytes, should not call 'feedInput'", _inputEnd - _inputPtr);}if (end < start) {_reportError("Input end (%d) may not be before start (%d)", end, start);}if (false) {;}_currInputProcessed += _origBufferLen;_currInputRowStart = start - (_inputEnd - _currInputRowStart);_inputBuffer = buf;;_inputEnd = end;_origBufferLen = end - start;}
tensor([[0.0135, 0.0115, 0.0197,  ..., 0.0044, 0.0387, 0.0114],
        [0.0104, 0.0103, 0.0169,  ..., 0.0036, 0.0413, 0.0097],
        [0.0107, 0.0080, 0.0168,  ..., 0.0040, 0.0407, 0.0094],
        ...,
        [0.0094, 0.0074, 0.0180,  ..., 0.0042, 0.0453, 0.0096],
        [0.0150, 0.0127, 0.0189,  ..., 0.0083, 0.0342, 0.0130],
        [0.0121, 0.0097, 0.0201,  ..., 0.0050, 0.0464, 0.0085]])
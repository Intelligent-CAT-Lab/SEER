100988
Test: public void testParseInto_monthDay_feb29_newYork_endOfYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 12, 31, 23, 59, 59, 999, NEWYORK); }
Code: public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }
tensor([[0.0073, 0.0044, 0.0101,  ..., 0.0082, 0.0266, 0.0034],
        [0.0049, 0.0034, 0.0085,  ..., 0.0080, 0.0264, 0.0025],
        [0.0063, 0.0037, 0.0087,  ..., 0.0088, 0.0303, 0.0029],
        ...,
        [0.0048, 0.0027, 0.0092,  ..., 0.0068, 0.0312, 0.0028],
        [0.0056, 0.0029, 0.0073,  ..., 0.0071, 0.0303, 0.0019],
        [0.0053, 0.0040, 0.0100,  ..., 0.0118, 0.0200, 0.0030]])
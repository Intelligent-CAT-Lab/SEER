60696
Test: public void testBackslashEscapingOld() throws IOException { final String code = "one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n" + "one,\"tw\\\"o\"\n" + "one,\"t\\,wo\"\n" + "one,two,\"th,ree\"\n" + "\"a\\\\\"\n" + "a\\,b\n" + "\"a\\\\,b\""; final String[][] res = { { "one", "two", "three" }, { "on\\\"e", "two" }, { "on\"e", "two" }, { "one", "tw\"o" }, { "one", "t\\,wo" }, { "one", "two", "th,ree" }, { "a\\\\" }, { "a\\", "b" }, { "a\\\\,b" } }; try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } } @Test @Ignore("CSV-107") public void testBOM() throws IOException { final URL url = ClassLoader.getSystemClassLoader().getResource("CSVFileParser/bom.csv"); try (final CSVParser parser = CSVParser.parse(url, Charset.forName(UTF_8_NAME), CSVFormat.EXCEL.withHeader())) { for (final CSVRecord record : parser) { final String string = record.get("Date"); } } } @Test public void testBOMInputStream_ParserWithReader() {} @Test public void testBOMInputStream_parseWithReader() {} @Test public void testBOMInputStream_ParserWithInputStream() {} @Test public void testCarriageReturnEndings() throws IOException { final String code = "foo\rbaar,\rhello,world\r,kanu"; try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); } } @Test public void testCarriageReturnLineFeedEndings() throws IOException { final String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); } } @Test public void testFirstEndOfLineCrLf() throws IOException { final String data = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); } } @Test public void testFirstEndOfLineLf() throws IOException { final String data = "foo\nbaar,\nhello,world\n,kanu"; try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); } } @Test public void testFirstEndOfLineCr() throws IOException { final String data = "foo\rbaar,\rhello,world\r,kanu"; try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); } } @Test(expected = NoSuchElementException.class) public void testClose() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records; try (final CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) { records = parser.iterator(); } records.next(); } @Test public void testCSV57() throws Exception { try (final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT)) { final List<CSVRecord> list = parser.getRecords(); } } @Test public void testDefaultFormat() throws IOException { final String code = "" + "a,b#\n" + "\"\n\",\" \",#\n" + "#,\"\"\n" + "# Final comment\n" ; final String[][] res = { { "a", "b#" }, { "\n", " ", "#" }, { "#", "" }, { "# Final comment" } }; CSVFormat format = CSVFormat.DEFAULT; final String[][] res_comments = { { "a", "b#" }, { "\n", " ", "#" }, }; try (final CSVParser parser = CSVParser.parse(code, format)) { final List<CSVRecord> records = parser.getRecords(); Utils.compare("Failed to parse without comments", res, records); format = CSVFormat.DEFAULT.withCommentMarker('#'); } try (final CSVParser parser = CSVParser.parse(code, format)) { final List<CSVRecord> records = parser.getRecords(); Utils.compare("Failed to parse with comments", res_comments, records); } } @Test(expected = IllegalArgumentException.class) public void testDuplicateHeaders() throws Exception { CSVParser.parse("a,b,a\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader(new String[] {})); } @Test public void testEmptyFile() throws Exception { try (final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT)) { } } @Test public void testEmptyLineBehaviourCSV() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { { "hello", "" } }; for (final String code : codes) { try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } } } @Test public void testEmptyLineBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { { "hello", "" }, { "" }, { "" } }; for (final String code : codes) { try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) { final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } } } @Test public void testEndOfFileBehaviorCSV() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { { "hello", "" }, { "world", "" } }; for (final String code : codes) { try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } } } @Test public void testEndOfFileBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { { "hello", "" }, { "" }, { "world", "" } }; for (final String code : codes) { try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) { final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } } } @Test public void testExcelFormat1() throws IOException { final String code = "value1,value2,value3,value4\r\na,b,c,d\r\n x,,," + "\r\n\r\n\"\"\"hello\"\"\",\" \"\"world\"\"\",\"abc\ndef\",\r\n"; final String[][] res = { { "value1", "value2", "value3", "value4" }, { "a", "b", "c", "d" }, { " x", "", "", "" }, { "" }, { "\"hello\"", " \"world\"", "abc\ndef", "" } }; try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) { final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } } @Test public void testExcelFormat2() throws Exception { final String code = "foo,baar\r\n\r\nhello,\r\n\r\nworld,\r\n"; final String[][] res = { { "foo", "baar" }, { "" }, { "hello", "" }, { "" }, { "world", "" } }; try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) { final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } } @Test public void testExcelHeaderCountLessThanData() throws Exception { final String code = "A,B,C,,\r\na,b,c,d,e\r\n"; try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader())) { for (final CSVRecord record : parser.getRecords()) { } } } @Test public void testForEach() throws Exception { final List<CSVRecord> records = new ArrayList<>(); try (final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z")) { for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) { records.add(record); } } } @Test public void testGetHeaderMap() throws Exception { try (final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader("A", "B", "C"))) { final Map<String, Integer> headerMap = parser.getHeaderMap(); final Iterator<String> columnNames = headerMap.keySet().iterator(); final Iterator<CSVRecord> records = parser.iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } } @Test public void testGetLine() throws IOException { try (final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) { for (final String[] re : RESULT) { } } } @Test public void testGetLineNumberWithCR() throws Exception { this.validateLineNumbers(String.valueOf(CR)); } @Test public void testGetLineNumberWithCRLF() throws Exception { this.validateLineNumbers(CRLF); } @Test public void testGetLineNumberWithLF() throws Exception { this.validateLineNumbers(String.valueOf(LF)); } @Test public void testGetOneLine() throws IOException { try (final CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT)) { final CSVRecord record = parser.getRecords().get(0); } } @Test public void testGetOneLineOneParser() throws IOException { final CSVFormat format = CSVFormat.DEFAULT; try (final PipedWriter writer = new PipedWriter(); final CSVParser parser = new CSVParser(new PipedReader(writer), format)) { writer.append(CSV_INPUT_1); writer.append(format.getRecordSeparator()); final CSVRecord record1 = parser.nextRecord(); writer.append(CSV_INPUT_2); writer.append(format.getRecordSeparator()); final CSVRecord record2 = parser.nextRecord(); } } @Test public void testGetRecordNumberWithCR() throws Exception { this.validateRecordNumbers(String.valueOf(CR)); } @Test public void testGetRecordNumberWithCRLF() throws Exception { this.validateRecordNumbers(CRLF); } @Test public void testGetRecordNumberWithLF() throws Exception { this.validateRecordNumbers(String.valueOf(LF)); } @Test public void testGetRecordPositionWithCRLF() throws Exception { this.validateRecordPosition(CRLF); } @Test public void testGetRecordPositionWithLF() throws Exception { this.validateRecordPosition(String.valueOf(LF)); } @Test public void testGetRecords() throws IOException { try (final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) { final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < RESULT.length; i++) { } } } @Test public void testGetRecordWithMultiLineValues() throws Exception { try (final CSVParser parser = CSVParser.parse( "\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\"" + CRLF + "\"c\r\n1\",\"c\r\n2\"", CSVFormat.DEFAULT.withRecordSeparator(CRLF))) { CSVRecord record; } } @Test public void testHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testHeaderComment() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testHeaderMissing() throws Exception { final Reader in = new StringReader("a,,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testHeaderMissingWithNull() throws Exception { final Reader in = new StringReader("a,,c,,d\n1,2,3,4\nx,y,z,zz"); CSVFormat.DEFAULT.withHeader().withNullString("").withAllowMissingColumnNames().parse(in).iterator(); } @Test public void testHeadersMissing() throws Exception { final Reader in = new StringReader("a,,c,,d\n1,2,3,4\nx,y,z,zz"); CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in).iterator(); } @Test(expected = IllegalArgumentException.class) public void testHeadersMissingException() throws Exception { final Reader in = new StringReader("a,,c,,d\n1,2,3,4\nx,y,z,zz"); CSVFormat.DEFAULT.withHeader().parse(in).iterator(); } @Test public void testIgnoreCaseHeaderMapping() throws Exception { final Reader in = new StringReader("1,2,3"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("One", "TWO", "three").withIgnoreHeaderCase() .parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testIgnoreEmptyLines() throws IOException { final String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n"; try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); } } @Test(expected = IllegalArgumentException.class) public void testInvalidFormat() throws Exception { final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR); try (final CSVParser parser = new CSVParser(null, invalidFormat)) { } } @Test public void testIterator() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator(); try { iterator.remove(); fail("expected UnsupportedOperationException"); } catch (final UnsupportedOperationException expected) { } try { iterator.next(); fail("NoSuchElementException expected"); } catch (final NoSuchElementException e) { } } @Test public void testLineFeedEndings() throws IOException { final String code = "foo\nbaar,\nhello,world\n,kanu"; try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) { final List<CSVRecord> records = parser.getRecords(); } } @Test public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception { final Reader in = new StringReader("a,b,c\n1,2\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").withSkipHeaderRecord().parse(in) .iterator(); CSVRecord record; record = records.next(); record = records.next(); } @Test public void testMultipleIterators() throws Exception { try (final CSVParser parser = CSVParser.parse("a,b,c" + CR + "d,e,f", CSVFormat.DEFAULT)) { final Iterator<CSVRecord> itr1 = parser.iterator(); final Iterator<CSVRecord> itr2 = parser.iterator(); final CSVRecord first = itr1.next(); final CSVRecord second = itr2.next(); } } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserNullReaderFormat() throws Exception { try (final CSVParser parser = new CSVParser(null, CSVFormat.DEFAULT)) { } } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserReaderNullFormat() throws Exception { try (final CSVParser parser = new CSVParser(new StringReader(""), null)) { } } @Test public void testNoHeaderMap() throws Exception { try (final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT)) { } } @Test(expected = IllegalArgumentException.class) public void testParseFileNullFormat() throws Exception { CSVParser.parse(new File(""), Charset.defaultCharset(), null); } @Test(expected = IllegalArgumentException.class) public void testParseNullFileFormat() throws Exception { CSVParser.parse((File) null, Charset.defaultCharset(), CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseNullStringFormat() throws Exception { CSVParser.parse((String) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseNullUrlCharsetFormat() throws Exception { CSVParser.parse((File) null, Charset.defaultCharset(), CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParserUrlNullCharsetFormat() throws Exception { try (final CSVParser parser = CSVParser.parse(new URL("http: } } @Test(expected = IllegalArgumentException.class) public void testParseStringNullFormat() throws Exception { CSVParser.parse("csv data", null); } @Test(expected = IllegalArgumentException.class) public void testParseUrlCharsetNullFormat() throws Exception { try (final CSVParser parser = CSVParser.parse(new URL("http: } } @Test public void testProvidedHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").parse(in).iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeaderAuto() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testRoundtrip() throws Exception { final StringWriter out = new StringWriter(); try (final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT)) { final String input = "a,b,c\r\n1,2,3\r\nx,y,z\r\n"; for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) { printer.printRecord(record); } } } @Test public void testSkipAutoHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testSkipHeaderOverrideDuplicateHeaders() throws Exception { final Reader in = new StringReader("a,a,a\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("X", "Y", "Z").withSkipHeaderRecord().parse(in) .iterator(); final CSVRecord record = records.next(); } @Test public void testSkipSetAltHeaders() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("X", "Y", "Z").withSkipHeaderRecord().parse(in) .iterator(); final CSVRecord record = records.next(); } @Test public void testSkipSetHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("a", "b", "c").withSkipHeaderRecord().parse(in) .iterator(); final CSVRecord record = records.next(); } @Test @Ignore public void testStartWithEmptyLinesThenHeaders() throws Exception { final String[] codes = { "\r\n\r\n\r\nhello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { { "hello", "" }, { "" }, { "" } }; for (final String code : codes) { try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) { final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } } } @Test public void testTrailingDelimiter() throws Exception { final Reader in = new StringReader("a,a,a,\n\"1\",\"2\",\"3\",\nx,y,z,"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("X", "Y", "Z").withSkipHeaderRecord() .withTrailingDelimiter().parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testTrim() throws Exception { final Reader in = new StringReader("a,a,a\n\" 1 \",\" 2 \",\" 3 \"\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("X", "Y", "Z").withSkipHeaderRecord() .withTrim().parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testIteratorSequenceBreaking() throws IOException { final String fiveRows = "1\n2\n3\n4\n5\n"; CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows)); int recordNumber = 0; Iterator<CSVRecord> iter = parser.iterator(); recordNumber = 0; while (iter.hasNext()) { CSVRecord record = iter.next(); recordNumber++; if (recordNumber >= 2) { break; } } iter.hasNext(); while (iter.hasNext()) { CSVRecord record = iter.next(); recordNumber++; } parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows)); recordNumber = 0; for (CSVRecord record : parser) { recordNumber++; if (recordNumber >= 2) { break; } } for (CSVRecord record : parser) { recordNumber++; } parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows)); recordNumber = 0; for (CSVRecord record : parser) { recordNumber++; if (recordNumber >= 2) { break; } } parser.iterator().hasNext(); for (CSVRecord record : parser) { recordNumber++; } } private void validateLineNumbers(final String lineSeparator) throws IOException { try (final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) { } } private void validateRecordNumbers(final String lineSeparator) throws IOException { try (final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) { CSVRecord record; } } private void validateRecordPosition(final String lineSeparator) throws IOException { final String nl = lineSeparator; final String code = "a,b,c" + lineSeparator + "1,2,3" + lineSeparator + "'A" + nl + "A','B" + nl + "B',CC" + lineSeparator + "\u00c4,\u00d6,\u00dc" + lineSeparator + "EOF,EOF,EOF"; final CSVFormat format = CSVFormat.newFormat(',').withQuote('\'').withRecordSeparator(lineSeparator); CSVParser parser = CSVParser.parse(code, format); CSVRecord record; final long positionRecord3 = record.getCharacterPosition(); parser.close(); parser = new CSVParser(new StringReader(code.substring((int) positionRecord3)), format, positionRecord3, 3); parser.close(); }}
Code: public Iterator<CSVRecord> iterator() { return csvRecordIterator; }
[[0.11845476 0.20236246 0.10609203 0.16552065 0.13129963 0.22414304
 0.05212738]
[0.11886081 0.20615399 0.09613518 0.17421097 0.11679919 0.23644674
 0.05139316]
[0.09543014 0.22257982 0.10484302 0.19083947 0.1371927  0.20953318
 0.03958159]
[0.11079223 0.24270508 0.10391996 0.17967555 0.12730502 0.17249577
 0.06310635]
[0.08782303 0.20396264 0.11270989 0.16367167 0.12888242 0.25768906
 0.04526129]
[0.10201287 0.17902681 0.09632866 0.20712999 0.113167   0.25175604
 0.0505787 ]
[0.08687779 0.21699919 0.08085278 0.21191637 0.18646175 0.17074148
 0.04615059]]
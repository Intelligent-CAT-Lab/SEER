19466
Test: public void test07() throws Throwable { if (debug) System.out.format("%n%s%n", "RegressionTest0.test07"); com.google.javascript.jscomp.AbstractCompiler abstractCompiler0 = null; com.google.javascript.jscomp.FoldConstants foldConstants1 = new com.google.javascript.jscomp.FoldConstants(abstractCompiler0); com.google.javascript.jscomp.AbstractCompiler abstractCompiler2 = null; com.google.javascript.jscomp.VarCheck varCheck4 = new com.google.javascript.jscomp.VarCheck(abstractCompiler2, true); com.google.javascript.jscomp.AbstractCompiler abstractCompiler5 = null; com.google.javascript.jscomp.AbstractCompiler abstractCompiler6 = null; com.google.javascript.jscomp.VarCheck varCheck8 = new com.google.javascript.jscomp.VarCheck(abstractCompiler6, true); com.google.javascript.jscomp.NodeTraversal nodeTraversal9 = new com.google.javascript.jscomp.NodeTraversal(abstractCompiler5, (com.google.javascript.jscomp.NodeTraversal.Callback) varCheck8); boolean boolean10 = nodeTraversal9.inGlobalScope(); com.google.javascript.rhino.Node node12 = com.google.javascript.rhino.Node.newString(""); boolean boolean13 = com.google.javascript.jscomp.NodeUtil.isString(node12); boolean boolean14 = com.google.javascript.jscomp.NodeUtil.isNew(node12); com.google.javascript.rhino.Node node16 = com.google.javascript.rhino.Node.newString(""); boolean boolean17 = com.google.javascript.jscomp.NodeUtil.isString(node16); com.google.javascript.jscomp.CodePrinter.Builder builder18 = new com.google.javascript.jscomp.CodePrinter.Builder(node16); com.google.javascript.rhino.Node node20 = com.google.javascript.rhino.Node.newString(""); java.lang.String str21 = node16.checkTreeEquals(node20); com.google.javascript.jscomp.NodeUtil.setDebugInformation(node12, node16, "<No stack trace available>"); com.google.javascript.jscomp.GoogleCodingConvention googleCodingConvention24 = new com.google.javascript.jscomp.GoogleCodingConvention(); com.google.javascript.rhino.jstype.ObjectType objectType25 = null; com.google.javascript.rhino.jstype.ObjectType objectType26 = null; com.google.javascript.rhino.jstype.ObjectType objectType27 = null; com.google.javascript.rhino.jstype.FunctionType functionType28 = null; com.google.javascript.rhino.jstype.FunctionType functionType29 = null; googleCodingConvention24.applyDelegateRelationship(objectType25, objectType26, objectType27, functionType28, functionType29); com.google.javascript.rhino.Node node32 = com.google.javascript.rhino.Node.newString(""); boolean boolean33 = com.google.javascript.jscomp.NodeUtil.isString(node32); com.google.javascript.jscomp.CodePrinter.Builder builder34 = new com.google.javascript.jscomp.CodePrinter.Builder(node32); com.google.javascript.rhino.Node node36 = com.google.javascript.rhino.Node.newString(""); boolean boolean37 = com.google.javascript.jscomp.NodeUtil.isString(node36); boolean boolean38 = com.google.javascript.jscomp.NodeUtil.isNew(node36); java.lang.String str39 = googleCodingConvention24.extractClassNameIfRequire(node32, node36); varCheck4.visit(nodeTraversal9, node12, node32); com.google.javascript.rhino.Node node42 = com.google.javascript.rhino.Node.newString(""); boolean boolean43 = com.google.javascript.jscomp.NodeUtil.isString(node42); com.google.javascript.jscomp.CodePrinter.Builder builder44 = new com.google.javascript.jscomp.CodePrinter.Builder(node42); node42.setType((int) (short) 0); com.google.javascript.jscomp.AbstractCompiler abstractCompiler47 = null; com.google.javascript.jscomp.VarCheck varCheck49 = new com.google.javascript.jscomp.VarCheck(abstractCompiler47, true); com.google.javascript.jscomp.AbstractCompiler abstractCompiler50 = null; com.google.javascript.jscomp.AbstractCompiler abstractCompiler51 = null; com.google.javascript.jscomp.VarCheck varCheck53 = new com.google.javascript.jscomp.VarCheck(abstractCompiler51, true); com.google.javascript.jscomp.NodeTraversal nodeTraversal54 = new com.google.javascript.jscomp.NodeTraversal(abstractCompiler50, (com.google.javascript.jscomp.NodeTraversal.Callback) varCheck53); boolean boolean55 = nodeTraversal54.inGlobalScope(); com.google.javascript.rhino.Node node57 = com.google.javascript.rhino.Node.newString(""); boolean boolean58 = com.google.javascript.jscomp.NodeUtil.isString(node57); boolean boolean59 = com.google.javascript.jscomp.NodeUtil.isNew(node57); com.google.javascript.rhino.Node node61 = com.google.javascript.rhino.Node.newString(""); boolean boolean62 = com.google.javascript.jscomp.NodeUtil.isString(node61); com.google.javascript.jscomp.CodePrinter.Builder builder63 = new com.google.javascript.jscomp.CodePrinter.Builder(node61); com.google.javascript.rhino.Node node65 = com.google.javascript.rhino.Node.newString(""); java.lang.String str66 = node61.checkTreeEquals(node65); com.google.javascript.jscomp.NodeUtil.setDebugInformation(node57, node61, "<No stack trace available>"); com.google.javascript.jscomp.GoogleCodingConvention googleCodingConvention69 = new com.google.javascript.jscomp.GoogleCodingConvention(); com.google.javascript.rhino.jstype.ObjectType objectType70 = null; com.google.javascript.rhino.jstype.ObjectType objectType71 = null; com.google.javascript.rhino.jstype.ObjectType objectType72 = null; com.google.javascript.rhino.jstype.FunctionType functionType73 = null; com.google.javascript.rhino.jstype.FunctionType functionType74 = null; googleCodingConvention69.applyDelegateRelationship(objectType70, objectType71, objectType72, functionType73, functionType74); com.google.javascript.rhino.Node node77 = com.google.javascript.rhino.Node.newString(""); boolean boolean78 = com.google.javascript.jscomp.NodeUtil.isString(node77); com.google.javascript.jscomp.CodePrinter.Builder builder79 = new com.google.javascript.jscomp.CodePrinter.Builder(node77); com.google.javascript.rhino.Node node81 = com.google.javascript.rhino.Node.newString(""); boolean boolean82 = com.google.javascript.jscomp.NodeUtil.isString(node81); boolean boolean83 = com.google.javascript.jscomp.NodeUtil.isNew(node81); java.lang.String str84 = googleCodingConvention69.extractClassNameIfRequire(node77, node81); varCheck49.visit(nodeTraversal54, node57, node77); try { foldConstants1.tryFoldRegularExpressionConstructor(nodeTraversal9, node42, node57); } catch (java.lang.NullPointerException e) { } }
Code: public void visit(NodeTraversal t, Node n, Node parent) { int type = n.getType(); if (type == Token.BLOCK) { tryFoldBlock(t, n, parent); return; } Node left = n.getFirstChild(); if (left == null) { return; } if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) { String newValue = null; switch (left.getType()) { case Token.STRING: newValue = "string"; break; case Token.NUMBER: newValue = "number"; break; case Token.TRUE: case Token.FALSE: newValue = "boolean"; break; case Token.NULL: case Token.OBJECTLIT: case Token.ARRAYLIT: newValue = "object"; break; case Token.NAME: if ("undefined".equals(left.getString())) { newValue = "undefined"; } break; } if (newValue != null) { parent.replaceChild(n, Node.newString(newValue)); t.getCompiler().reportCodeChange(); } return; } if (type == Token.NEG || type == Token.BITNOT) { Preconditions.checkState(n.hasOneChild()); if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, n.removeFirstChild()); t.getCompiler().reportCodeChange(); return; } if (type == Token.NOT && tryMinimizeNot(t, n, parent)) { return; } if (!NodeUtil.isLiteralValue(left)) { return; } switch (type) { case Token.NOT: int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE; parent.replaceChild(n, new Node(result)); t.getCompiler().reportCodeChange(); break; case Token.NEG: try { if (left.getType() == Token.NAME) { if (left.getString().equals("Infinity")) { return; } else if (left.getString().equals("NaN")) { n.removeChild(left); parent.replaceChild(n, left); t.getCompiler().reportCodeChange(); return; } } double negNum = +left.getDouble(); parent.replaceChild(n, Node.newNumber(negNum)); t.getCompiler().reportCodeChange(); } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break; case Token.BITNOT: try { double val = left.getDouble(); if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { int intVal = (int) val; if (intVal == val) { parent.replaceChild(n, Node.newNumber(~intVal)); t.getCompiler().reportCodeChange(); } else { error(t, FRACTIONAL_BITWISE_OPERAND, left); } } else { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); } } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break; } return; } else if (type == Token.NEW) { if (Token.NAME == left.getType()) { String className = left.getString(); if ("RegExp".equals(className)) { tryFoldRegularExpressionConstructor(t, n, parent); } else if (left.getNext() == null) { if ("Array".equals(className)) { tryFoldLiteralConstructor( t, n, parent, className, Token.ARRAYLIT); } else if ("Object".equals(className)) { tryFoldLiteralConstructor( t, n, parent, className, Token.OBJECTLIT); } } } } if (type == Token.EXPR_RESULT) { tryMinimizeCondition(t, left, n); return; } if (type == Token.RETURN) { tryReduceReturn(t, n); return; } Node right = left.getNext(); if (right == null) { return; } if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) { if (NodeUtil.isImmutableValue(left)) { parent.replaceChild(n, new Node(Token.FALSE)); t.getCompiler().reportCodeChange(); return; } if (right.getType() == Token.NAME && "Object".equals(right.getString())) { parent.replaceChild(n, new Node(Token.TRUE)); t.getCompiler().reportCodeChange(); return; } } if (type == Token.IF || type == Token.HOOK) { tryMinimizeCondition(t, n.getFirstChild(), n); boolean changes = tryFoldHookIf(t, n, parent); if (type == Token.IF && !changes) { tryMinimizeIf(t, n, parent); } return; } if (type == Token.DO) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldDo(t, n, parent); return; } if (type == Token.WHILE) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldWhile(t, n, parent); return; } if (type == Token.FOR) { Node condition = NodeUtil.getConditionExpression(n); if (condition != null) { tryMinimizeCondition(t, condition, n); condition = NodeUtil.getConditionExpression(n); this.tryFoldForCondition(condition, n); } tryFoldFor(t, n, parent); return; } if (type == Token.AND || type == Token.OR) { tryFoldAndOr(t, n, left, right, parent); return; } if (type == Token.BITOR || type == Token.BITAND) { tryFoldBitAndOr(t, n, left, right, parent); return; } if (type == Token.LSH || type == Token.RSH || type == Token.URSH) { tryFoldShift(t, n, left, right, parent); return; } if (type == Token.GETPROP) { tryFoldGetProp(t, n, left, right, parent); return; } if (type == Token.CALL) { tryFoldStringJoin(t, n, left, right, parent); tryFoldStringIndexOf(t, n, left, right, parent); return; } if (type == Token.ASSIGN) { tryFoldAssign(t, n, left, right); } if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) { if (type == Token.ADD) tryFoldLeftChildAdd(t, n, left, right, parent); if (type == Token.LT || type == Token.GT) { tryFoldComparison(t, n, left, right, parent); } return; } if (type == Token.ADD) { ; return; } if (type == Token.SUB || type <= Token.MUL || type == Token.DIV) { tryFoldArithmetic(t, n, left, right, parent); return; } if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) { tryFoldComparison(t, n, left, right, parent); return; } if (type == Token.GETELEM) { tryFoldGetElem(t, n, left, right, parent); return; } }
tensor([[0.0011, 0.0009, 0.0005,  ..., 0.0010, 0.0005, 0.0005],
        [0.0008, 0.0007, 0.0003,  ..., 0.0009, 0.0005, 0.0005],
        [0.0008, 0.0006, 0.0004,  ..., 0.0008, 0.0002, 0.0002],
        ...,
        [0.0008, 0.0006, 0.0004,  ..., 0.0010, 0.0004, 0.0004],
        [0.0008, 0.0007, 0.0005,  ..., 0.0009, 0.0004, 0.0004],
        [0.0008, 0.0007, 0.0005,  ..., 0.0009, 0.0004, 0.0004]])
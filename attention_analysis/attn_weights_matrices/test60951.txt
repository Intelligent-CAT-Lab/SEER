60951
Test: public void testBackslashEscapingOld() throws IOException { final String code = "one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n" + "one,\"tw\\\"o\"\n" + "one,\"t\\,wo\"\n" + "one,two,\"th,ree\"\n" + "\"a\\\\\"\n" + "a\\,b\n" + "\"a\\\\,b\""; final String[][] res = { {"one", "two", "three"}, {"on\\\"e", "two"}, {"on\"e", "two"}, {"one", "tw\"o"}, {"one", "t\\,wo"}, {"one", "two", "th,ree"}, {"a\\\\"}, {"a\\", "b"}, {"a\\\\,b"} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } @Test @Ignore("CSV-107") public void testBOM() throws IOException { URL url = ClassLoader.getSystemClassLoader().getResource("CSVFileParser/bom.csv"); final CSVParser parser = CSVParser.parse(url, null, CSVFormat.EXCEL.withHeader()); try { for (CSVRecord record : parser) { final String string = record.get("Date"); } } finally { parser.close(); } } @Test public void testBOMInputStream() {} @Test public void testCarriageReturnEndings() throws IOException { final String code = "foo\rbaar,\rhello,world\r,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test public void testCarriageReturnLineFeedEndings() throws IOException { final String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test(expected = NoSuchElementException.class) public void testClose() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final CSVParser parser = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in); final Iterator<CSVRecord> records = parser.iterator(); parser.close(); records.next(); } @Test public void testCSV57() throws Exception { final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT); final List<CSVRecord> list = parser.getRecords(); parser.close(); } @Test public void testDefaultFormat() throws IOException { final String code = "" + "a,b#\n" + "\"\n\",\" \",#\n" + "#,\"\"\n" + "# Final comment\n" ; final String[][] res = { {"a", "b#"}, {"\n", " ", "#"}, {"#", ""}, {"# Final comment"} }; CSVFormat format = CSVFormat.DEFAULT; CSVParser parser = CSVParser.parse(code, format); List<CSVRecord> records = parser.getRecords(); Utils.compare("Failed to parse without comments", res, records); final String[][] res_comments = { {"a", "b#"}, {"\n", " ", "#"}, }; format = CSVFormat.DEFAULT.withCommentStart('#'); parser.close(); parser = CSVParser.parse(code, format); records = parser.getRecords(); Utils.compare("Failed to parse with comments", res_comments, records); parser.close(); } @Test public void testEmptyFile() throws Exception { final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT); parser.close(); } @Test public void testEmptyLineBehaviourCSV() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { {"hello", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testEmptyLineBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { {"hello", ""}, {""}, {""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testEndOfFileBehaviorCSV() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { {"hello", ""}, {"world", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testEndOfFileBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { {"hello", ""}, {""}, {"world", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } } @Test public void testExcelFormat1() throws IOException { final String code = "value1,value2,value3,value4\r\na,b,c,d\r\n x,,," + "\r\n\r\n\"\"\"hello\"\"\",\" \"\"world\"\"\",\"abc\ndef\",\r\n"; final String[][] res = { {"value1", "value2", "value3", "value4"}, {"a", "b", "c", "d"}, {" x", "", "", ""}, {""}, {"\"hello\"", " \"world\"", "abc\ndef", ""} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } @Test public void testExcelFormat2() throws Exception { final String code = "foo,baar\r\n\r\nhello,\r\n\r\nworld,\r\n"; final String[][] res = { {"foo", "baar"}, {""}, {"hello", ""}, {""}, {"world", ""} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } parser.close(); } @Test public void testForEach() throws Exception { final List<CSVRecord> records = new ArrayList<CSVRecord>(); final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) { records.add(record); } } @Test public void testGetHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader("A", "B", "C")); final Map<String, Integer> headerMap = parser.getHeaderMap(); final Iterator<String> columnNames = headerMap.keySet().iterator(); final Iterator<CSVRecord> records = parser.iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } parser.close(); } @Test(expected = IllegalArgumentException.class) public void testDuplicateHeaderEntries() throws Exception { CSVParser.parse("a,b,a\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader(new String[]{})); } @Test public void testGetLine() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true)); for (final String[] re : RESULT) { } parser.close(); } @Test public void testGetLineNumberWithCR() throws Exception { this.validateLineNumbers(String.valueOf(CR)); } @Test public void testGetLineNumberWithCRLF() throws Exception { this.validateLineNumbers(CRLF); } @Test public void testGetLineNumberWithLF() throws Exception { this.validateLineNumbers(String.valueOf(LF)); } @Test public void testGetOneLine() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT); final CSVRecord record = parser.getRecords().get(0); parser.close(); } @Test public void testGetOneLineCustomCollection() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT); final CSVRecord record = parser.getRecords(new LinkedList<CSVRecord>()).getFirst(); parser.close(); } @Test public void testGetOneLineOneParser() throws IOException { PipedWriter writer = new PipedWriter(); PipedReader reader = new PipedReader(writer); final CSVFormat format = CSVFormat.DEFAULT; final CSVParser parser = new CSVParser(reader, format); try { writer.append(CSV_INPUT_1); writer.append(format.getRecordSeparator()); final CSVRecord record1 = parser.nextRecord(); writer.append(CSV_INPUT_2); writer.append(format.getRecordSeparator()); final CSVRecord record2 = parser.nextRecord(); } finally { parser.close(); } } @Test public void testGetRecordNumberWithCR() throws Exception { this.validateRecordNumbers(String.valueOf(CR)); } @Test public void testGetRecordNumberWithCRLF() throws Exception { this.validateRecordNumbers(CRLF); } @Test public void testGetRecordNumberWithLF() throws Exception { this.validateRecordNumbers(String.valueOf(LF)); } @Test public void testGetRecords() throws IOException { final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true)); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < RESULT.length; i++) { } parser.close(); } @Test public void testGetRecordWithMultiLineValues() throws Exception { final CSVParser parser = CSVParser.parse("\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\"" + CRLF + "\"c\r\n1\",\"c\r\n2\"", CSVFormat.DEFAULT.withRecordSeparator(CRLF)); CSVRecord record; parser.close(); } @Test public void testHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testHeaderComment() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testIgnoreEmptyLines() throws IOException { final String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test(expected = IllegalArgumentException.class) public void testInvalidFormat() throws Exception { final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR); new CSVParser(null, invalidFormat).close(); } @Test public void testIterator() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator(); try { iterator.remove(); fail("expected UnsupportedOperationException"); } catch (final UnsupportedOperationException expected) { } try { iterator.next(); fail("NoSuchElementException expected"); } catch (final NoSuchElementException e) { } } @Test public void testLineFeedEndings() throws IOException { final String code = "foo\nbaar,\nhello,world\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); parser.close(); } @Test public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception { final Reader in = new StringReader("a,b,c\n1,2\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").withSkipHeaderRecord(true) .parse(in).iterator(); CSVRecord record; record = records.next(); record = records.next(); } @Test public void testMultipleIterators() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c" + CR + "d,e,f", CSVFormat.DEFAULT); final Iterator<CSVRecord> itr1 = parser.iterator(); final Iterator<CSVRecord> itr2 = parser.iterator(); final CSVRecord first = itr1.next(); final CSVRecord second = itr2.next(); parser.close(); } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserNullReaderFormat() throws Exception { new CSVParser(null, CSVFormat.DEFAULT).close(); } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserReaderNullFormat() throws Exception { new CSVParser(new StringReader(""), null).close(); } @Test public void testNoHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT); parser.close(); } @Test(expected = IllegalArgumentException.class) public void testParseFileNullFormat() throws Exception { CSVParser.parse(new File(""), null); } @Test(expected = IllegalArgumentException.class) public void testParseNullFileFormat() throws Exception { CSVParser.parse((File) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseNullStringFormat() throws Exception { CSVParser.parse((String) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseNullUrlCharsetFormat() throws Exception { CSVParser.parse(null, Charset.defaultCharset(), CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParserUrlNullCharsetFormat() throws Exception { final CSVParser parser = CSVParser.parse(new URL("http: parser.close(); } @Test(expected = IllegalArgumentException.class) public void testParseStringNullFormat() throws Exception { CSVParser.parse("csv data", null); } @Test(expected = IllegalArgumentException.class) public void testParseUrlCharsetNullFormat() throws Exception { final CSVParser parser = CSVParser.parse(new URL("http: parser.close(); } @Test public void testProvidedHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").parse(in).iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeaderAuto() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testRoundtrip() throws Exception { final StringWriter out = new StringWriter(); final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT); final String input = "a,b,c\r\n1,2,3\r\nx,y,z\r\n"; for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) { printer.printRecord(record); } printer.close(); } @Test public void testSkipAutoHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testSkipSetHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("a", "b", "c").withSkipHeaderRecord(true) .parse(in).iterator(); final CSVRecord record = records.next(); } private void validateLineNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); parser.close(); } private void validateRecordNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); CSVRecord record; parser.close(); }}
Code: public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException { Assertions.notNull(out, "out"); Assertions.notNull(format, "format"); this.out = out; this.format = format; this.format.validate(); }
tensor([[0.0389, 0.0565, 0.0480, 0.0391, 0.0312, 0.0156, 0.0627, 0.0925, 0.0200,
         0.0516, 0.0367, 0.0469, 0.0398, 0.0438, 0.0616, 0.0245, 0.0319, 0.0554,
         0.0245, 0.0487, 0.1134, 0.0165],
        [0.0374, 0.0510, 0.0556, 0.0480, 0.0307, 0.0171, 0.0592, 0.1053, 0.0255,
         0.0588, 0.0411, 0.0470, 0.0374, 0.0412, 0.0499, 0.0287, 0.0381, 0.0533,
         0.0287, 0.0407, 0.0867, 0.0184],
        [0.0332, 0.0548, 0.0465, 0.0431, 0.0300, 0.0138, 0.0591, 0.1058, 0.0228,
         0.0613, 0.0446, 0.0344, 0.0367, 0.0403, 0.0610, 0.0280, 0.0340, 0.0503,
         0.0280, 0.0378, 0.1195, 0.0149],
        [0.0378, 0.0589, 0.0579, 0.0392, 0.0291, 0.0164, 0.0587, 0.0842, 0.0247,
         0.0575, 0.0414, 0.0420, 0.0299, 0.0447, 0.0497, 0.0254, 0.0420, 0.0570,
         0.0254, 0.0380, 0.1257, 0.0145],
        [0.0380, 0.0600, 0.0482, 0.0408, 0.0244, 0.0120, 0.0545, 0.1086, 0.0216,
         0.0554, 0.0390, 0.0322, 0.0296, 0.0396, 0.0493, 0.0296, 0.0325, 0.0442,
         0.0296, 0.0300, 0.1695, 0.0114],
        [0.0317, 0.0514, 0.0494, 0.0429, 0.0270, 0.0119, 0.0661, 0.1195, 0.0192,
         0.0730, 0.0454, 0.0433, 0.0300, 0.0348, 0.0410, 0.0234, 0.0289, 0.0543,
         0.0234, 0.0303, 0.1408, 0.0122],
        [0.0275, 0.0551, 0.0376, 0.0357, 0.0240, 0.0108, 0.0724, 0.1232, 0.0156,
         0.0564, 0.0477, 0.0368, 0.0287, 0.0348, 0.0502, 0.0198, 0.0312, 0.0583,
         0.0198, 0.0249, 0.1802, 0.0092],
        [0.0287, 0.0522, 0.0528, 0.0506, 0.0228, 0.0124, 0.0641, 0.1496, 0.0165,
         0.0601, 0.0443, 0.0392, 0.0262, 0.0337, 0.0485, 0.0248, 0.0258, 0.0474,
         0.0248, 0.0328, 0.1303, 0.0123],
        [0.0328, 0.0490, 0.0415, 0.0453, 0.0269, 0.0129, 0.0636, 0.1285, 0.0166,
         0.0503, 0.0417, 0.0384, 0.0390, 0.0415, 0.0523, 0.0251, 0.0316, 0.0523,
         0.0251, 0.0310, 0.1433, 0.0113],
        [0.0406, 0.0568, 0.0573, 0.0411, 0.0396, 0.0211, 0.0621, 0.0732, 0.0262,
         0.0586, 0.0473, 0.0391, 0.0361, 0.0390, 0.0490, 0.0335, 0.0323, 0.0523,
         0.0335, 0.0426, 0.0970, 0.0217],
        [0.0367, 0.0605, 0.0487, 0.0444, 0.0421, 0.0190, 0.0531, 0.0920, 0.0243,
         0.0702, 0.0379, 0.0394, 0.0393, 0.0368, 0.0572, 0.0269, 0.0303, 0.0532,
         0.0269, 0.0379, 0.1085, 0.0145],
        [0.0327, 0.0594, 0.0408, 0.0416, 0.0246, 0.0104, 0.0617, 0.1407, 0.0213,
         0.0492, 0.0451, 0.0360, 0.0313, 0.0290, 0.0513, 0.0230, 0.0317, 0.0449,
         0.0230, 0.0305, 0.1628, 0.0091],
        [0.0343, 0.0600, 0.0454, 0.0424, 0.0352, 0.0140, 0.0606, 0.1053, 0.0209,
         0.0528, 0.0422, 0.0397, 0.0327, 0.0446, 0.0544, 0.0289, 0.0309, 0.0534,
         0.0289, 0.0380, 0.1178, 0.0176],
        [0.0329, 0.0535, 0.0527, 0.0397, 0.0279, 0.0172, 0.0556, 0.1270, 0.0219,
         0.0570, 0.0336, 0.0428, 0.0342, 0.0455, 0.0554, 0.0353, 0.0306, 0.0534,
         0.0353, 0.0316, 0.0994, 0.0174],
        [0.0406, 0.0514, 0.0488, 0.0393, 0.0315, 0.0136, 0.0642, 0.1140, 0.0198,
         0.0611, 0.0494, 0.0422, 0.0357, 0.0355, 0.0473, 0.0247, 0.0364, 0.0412,
         0.0247, 0.0259, 0.1383, 0.0143],
        [0.0452, 0.0561, 0.0631, 0.0489, 0.0379, 0.0235, 0.0465, 0.0679, 0.0275,
         0.0470, 0.0441, 0.0389, 0.0441, 0.0371, 0.0555, 0.0363, 0.0351, 0.0564,
         0.0363, 0.0381, 0.0932, 0.0212],
        [0.0390, 0.0530, 0.0490, 0.0460, 0.0339, 0.0154, 0.0708, 0.1056, 0.0237,
         0.0469, 0.0406, 0.0395, 0.0326, 0.0432, 0.0574, 0.0238, 0.0297, 0.0446,
         0.0238, 0.0491, 0.1158, 0.0167],
        [0.0354, 0.0565, 0.0534, 0.0362, 0.0304, 0.0108, 0.0556, 0.1366, 0.0153,
         0.0468, 0.0377, 0.0383, 0.0340, 0.0444, 0.0554, 0.0352, 0.0340, 0.0517,
         0.0352, 0.0337, 0.1088, 0.0144],
        [0.0452, 0.0561, 0.0631, 0.0489, 0.0379, 0.0235, 0.0465, 0.0679, 0.0275,
         0.0470, 0.0441, 0.0389, 0.0441, 0.0371, 0.0555, 0.0363, 0.0351, 0.0564,
         0.0363, 0.0381, 0.0932, 0.0212],
        [0.0286, 0.0566, 0.0396, 0.0399, 0.0254, 0.0112, 0.0584, 0.1301, 0.0195,
         0.0657, 0.0381, 0.0365, 0.0264, 0.0440, 0.0539, 0.0278, 0.0328, 0.0548,
         0.0278, 0.0306, 0.1423, 0.0101],
        [0.0445, 0.0529, 0.0585, 0.0412, 0.0260, 0.0173, 0.0704, 0.1000, 0.0257,
         0.0602, 0.0406, 0.0470, 0.0365, 0.0266, 0.0535, 0.0244, 0.0272, 0.0503,
         0.0244, 0.0399, 0.1122, 0.0208],
        [0.0306, 0.0481, 0.0464, 0.0501, 0.0268, 0.0160, 0.0507, 0.1298, 0.0224,
         0.0677, 0.0380, 0.0521, 0.0340, 0.0487, 0.0539, 0.0265, 0.0295, 0.0486,
         0.0265, 0.0243, 0.1141, 0.0151]])
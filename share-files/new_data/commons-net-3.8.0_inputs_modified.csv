,method,test
0,"    public void setSoLinger(final boolean on, final int val) throws SocketException
    {
        _socket_.setSoLinger(on, val);
    }","  public void test0()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""\r\n"", false);
      // Undeclared exception!
      try { 
        fTPSClient0.setSoLinger(false, 3144);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test1()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setSendBufferSize((-112));
      InetAddress inetAddress0 = MockInetAddress.getByName(""Unknown parser type: "");
      // Undeclared exception!
      try { 
        pOP3Client0.connect(inetAddress0, (-112));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // negative send size
         //
         verifyException(""java.net.Socket"", e);
      }
  }"
2,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test2()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(false);
      byte[] byteArray0 = new byte[4];
      authenticatingIMAPClient0.setReceiveBufferSize((byte) (-96));
      InetAddress inetAddress0 = MockInetAddress.getByAddress("""", byteArray0);
      // Undeclared exception!
      try { 
        authenticatingIMAPClient0.connect(""9U6?qu|"", (-1060), inetAddress0, (-1060));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // invalid receive size
         //
         verifyException(""java.net.Socket"", e);
      }
  }"
3,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test3()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient(""TLS"", ""\r\n"");
          InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
          // Undeclared exception!
          try { 
            authenticatingSMTPClient0.connect(inetAddress0, 143, inetAddress0, 993);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:993\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.Socket.bind(Socket.java:660)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:251)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:236)
             // sun.reflect.GeneratedMethodAccessor297.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
4,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test4()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      // Undeclared exception!
      try { 
        authenticatingSMTPClient0.connect(inetAddress0, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
5,"    public boolean verifyRemote(final Socket socket)
    {
        final InetAddress host1;
        final InetAddress host2;

        host1 = socket.getInetAddress();
        host2 = getRemoteAddress();

        return host1.equals(host2);
    }","  public void test5()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      MockSocket mockSocket0 = new MockSocket();
      // Undeclared exception!
      try { 
        fTPSClient0.verifyRemote(mockSocket0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
6,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test6()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      MockPrintStream mockPrintStream0 = new MockPrintStream(""\r\n"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockPrintStream0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, false);
      nNTPClient0.removeProtocolCommandListener(printCommandListener0);
}"
7,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test7()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      MockPrintStream mockPrintStream0 = new MockPrintStream(""\r\n"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockPrintStream0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, false);
      nNTPClient0.removeProtocolCommandListener(printCommandListener0);
}"
8,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test8()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      MockPrintStream mockPrintStream0 = new MockPrintStream(""\r\n"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockPrintStream0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, false);
      nNTPClient0.removeProtocolCommandListener(printCommandListener0);
}"
9,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test9()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      nNTPClient0.setDefaultTimeout((-2997));
      int int0 = nNTPClient0.getDefaultTimeout();
}"
10,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test10()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
      authenticatingSMTPClient0.setConnectTimeout((-1398));
      int int0 = authenticatingSMTPClient0.getConnectTimeout();
}"
11,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test11()  throws Throwable  {
      EchoTCPClient echoTCPClient0 = new EchoTCPClient();
      InetAddress inetAddress0 = MockInetAddress.getByName(""\r\n"");
      // Undeclared exception!
      try { 
        echoTCPClient0.connect((InetAddress) null, (-983), inetAddress0, (-983));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-983
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
12,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test12()  throws Throwable  {
      RLoginClient rLoginClient0 = new RLoginClient();
      // Undeclared exception!
      try { 
        rLoginClient0.connect((InetAddress) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.net.Socket"", e);
      }
  }"
13,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test13()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient((String) null);
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      // Undeclared exception!
      try { 
        telnetClient0.connect(""eK?0FV:Xh!@4m^"", 72, inetAddress0, (-1740));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1740
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
14,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test14()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0.setReceiveBufferSize(0);
      // Undeclared exception!
      try { 
        nNTP0.connect("""", 182);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // invalid receive size
         //
         verifyException(""java.net.Socket"", e);
      }
  }"
15,"    public void addProtocolCommandListener(final ProtocolCommandListener listener) {
        getCommandSupport().addProtocolCommandListener(listener);
    }","  public void test15()  throws Throwable  {
      RLoginClient rLoginClient0 = new RLoginClient();
      CharArrayWriter charArrayWriter0 = new CharArrayWriter();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(charArrayWriter0, true);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, true, 'j');
      // Undeclared exception!
      try { 
        rLoginClient0.addProtocolCommandListener(printCommandListener0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
16,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test16()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.setServerSocketFactory((ServerSocketFactory) null);
}"
17,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test17()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.setServerSocketFactory((ServerSocketFactory) null);
}"
18,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test18()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.setServerSocketFactory((ServerSocketFactory) null);
}"
19,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test19()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      SSLContext sSLContext0 = SSLContext.getDefault();
      SSLSocketFactory sSLSocketFactory0 = sSLContext0.getSocketFactory();
      nNTP0.setSocketFactory(sSLSocketFactory0);
}"
20,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test20()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      SSLContext sSLContext0 = SSLContext.getDefault();
      SSLSocketFactory sSLSocketFactory0 = sSLContext0.getSocketFactory();
      nNTP0.setSocketFactory(sSLSocketFactory0);
}"
21,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test21()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      SSLContext sSLContext0 = SSLContext.getDefault();
      SSLSocketFactory sSLSocketFactory0 = sSLContext0.getSocketFactory();
      nNTP0.setSocketFactory(sSLSocketFactory0);
}"
22,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test22()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0.setSocketFactory((SocketFactory) null);
}"
23,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test23()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0.setSocketFactory((SocketFactory) null);
}"
24,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test24()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0.setSocketFactory((SocketFactory) null);
}"
25,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test25()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""");
      fTPSClient0.isConnected();
}"
26,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test26()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""");
      fTPSClient0.isConnected();
}"
27,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test27()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""");
      fTPSClient0.isConnected();
}"
28,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test28()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null, true);
      fTPSClient0.getCharset();
}"
29,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test29()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null, true);
      fTPSClient0.getCharset();
}"
30,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test30()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null, true);
      fTPSClient0.getCharset();
}"
31,"    public InetAddress getRemoteAddress()
    {
        return _socket_.getInetAddress();
    }","  public void test31()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(true);
      // Undeclared exception!
      try { 
        pOP3SClient0.getRemoteAddress();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
32,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test32()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
}"
33,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test33()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0.setDefaultPort(0);
}"
34,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test34()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      ServerSocketFactory serverSocketFactory0 = ServerSocketFactory.getDefault();
      pOP3Client0.setServerSocketFactory(serverSocketFactory0);
}"
35,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test35()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      ServerSocketFactory serverSocketFactory0 = ServerSocketFactory.getDefault();
      pOP3Client0.setServerSocketFactory(serverSocketFactory0);
}"
36,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test36()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      ServerSocketFactory serverSocketFactory0 = ServerSocketFactory.getDefault();
      pOP3Client0.setServerSocketFactory(serverSocketFactory0);
}"
37,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test37()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.disconnect();
}"
38,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test38()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.disconnect();
}"
39,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test39()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.disconnect();
}"
40,"    public boolean isConnected()
    {
        if (_socket_ == null) {
            return false;
        }

        return _socket_.isConnected();
    }","  public void test40()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
}"
41,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test41()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      boolean boolean0 = pOP3Client0.isAvailable();
}"
42,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test42()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      boolean boolean0 = pOP3Client0.isAvailable();
}"
43,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test43()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      boolean boolean0 = pOP3Client0.isAvailable();
}"
44,"    public boolean isAvailable(){
        if (isConnected()) {
            try
            {
                if (_socket_.getInetAddress() == null) {
                    return false;
                }
                if (_socket_.getPort() == 0) {
                    return false;
                }
                if (_socket_.getRemoteSocketAddress() == null) {
                    return false;
                }
                if (_socket_.isClosed()) {
                    return false;
                }
                /* these aren't exact checks (a Socket can be half-open),
                   but since we usually require two-way data transfer,
                   we check these here too: */
                if (_socket_.isInputShutdown()) {
                    return false;
                }
                if (_socket_.isOutputShutdown()) {
                    return false;
                }
                /* ignore the result, catch exceptions: */
                // No need to close
                _socket_.getInputStream();
                // No need to close
                _socket_.getOutputStream();
            }
            catch (final IOException ioex)
            {
                return false;
            }
            return true;
        }
        return false;
    }","  public void test44()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      boolean boolean0 = pOP3Client0.isAvailable();
}"
45,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test45()  throws Throwable  {
      ExtendedPOP3Client extendedPOP3Client0 = new ExtendedPOP3Client();
      extendedPOP3Client0.getCharsetName();
}"
46,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test46()  throws Throwable  {
      ExtendedPOP3Client extendedPOP3Client0 = new ExtendedPOP3Client();
      extendedPOP3Client0.getCharsetName();
}"
47,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test47()  throws Throwable  {
      ExtendedPOP3Client extendedPOP3Client0 = new ExtendedPOP3Client();
      extendedPOP3Client0.getCharsetName();
}"
48,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test48()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
      int int0 = authenticatingSMTPClient0.getConnectTimeout();
}"
49,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test49()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
      int int0 = authenticatingSMTPClient0.getConnectTimeout();
}"
50,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test50()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
      int int0 = authenticatingSMTPClient0.getConnectTimeout();
}"
51,"    public boolean getTcpNoDelay() throws SocketException
    {
        return _socket_.getTcpNoDelay();
    }","  public void test51()  throws Throwable  {
      RLoginClient rLoginClient0 = new RLoginClient();
      // Undeclared exception!
      try { 
        rLoginClient0.getTcpNoDelay();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
52,"    public int getSoLinger() throws SocketException
    {
        return _socket_.getSoLinger();
    }","  public void test52()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      // Undeclared exception!
      try { 
        fTPSClient0.getSoLinger();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
53,"    public boolean getKeepAlive() throws SocketException {
        return _socket_.getKeepAlive();
    }","  public void test53()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      // Undeclared exception!
      try { 
        iMAPSClient0.getKeepAlive();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
54,"    public int getRemotePort()
    {
        return _socket_.getPort();
    }","  public void test54()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      // Undeclared exception!
      try { 
        fTPSClient0.getRemotePort();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
55,"    public void setTcpNoDelay(final boolean on) throws SocketException
    {
        _socket_.setTcpNoDelay(on);
    }","  public void test55()  throws Throwable  {
      RLoginClient rLoginClient0 = new RLoginClient();
      // Undeclared exception!
      try { 
        rLoginClient0.setTcpNoDelay(false);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
56,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test56()  throws Throwable  {
      EchoTCPClient echoTCPClient0 = new EchoTCPClient();
      echoTCPClient0.setProxy((Proxy) null);
      InetAddress inetAddress0 = MockInetAddress.getByName(""\r\n"");
      try { 
        echoTCPClient0.connect(inetAddress0, 7, inetAddress0, 7);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@8657a306
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
57,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test57()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
          // Undeclared exception!
          try { 
            authenticatingSMTPClient0.connect(""F$1\""x)CM_%+k94/$"");
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:25\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // sun.reflect.GeneratedMethodAccessor295.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
58,"    public void connect(final InetAddress host, final int port)
    throws SocketException, IOException
    {
        _hostname_ = null;
        _connect(host, port, null, -1);
    }","  public void test58()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setSendBufferSize(0);
      InetAddress inetAddress0 = MockInetAddress.getByName(""\r\n"");
      // Undeclared exception!
      try { 
        pOP3Client0.connect(inetAddress0, 110);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // negative send size
         //
         verifyException(""java.net.Socket"", e);
      }
  }"
59,"    public int getSoTimeout() throws SocketException
    {
        return _socket_.getSoTimeout();
    }","  public void test59()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.getSoTimeout();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
60,"    public int getLocalPort()
    {
        return _socket_.getLocalPort();
    }","  public void test60()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient("""");
      // Undeclared exception!
      try { 
        authenticatingSMTPClient0.getLocalPort();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
61,"    public void removeProtocolCommandListener(final ProtocolCommandListener listener) {
        getCommandSupport().removeProtocolCommandListener(listener);
    }","  public void test61()  throws Throwable  {
      RLoginClient rLoginClient0 = new RLoginClient();
      // Undeclared exception!
      try { 
        rLoginClient0.removeProtocolCommandListener((ProtocolCommandListener) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
62,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test62()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      int int0 = nNTPClient0.getDefaultTimeout();
}"
63,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test63()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      int int0 = nNTPClient0.getDefaultTimeout();
}"
64,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test64()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      int int0 = nNTPClient0.getDefaultTimeout();
}"
65,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test65()  throws Throwable  {
      EchoTCPClient echoTCPClient0 = new EchoTCPClient();
      echoTCPClient0.getProxy();
}"
66,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test66()  throws Throwable  {
      EchoTCPClient echoTCPClient0 = new EchoTCPClient();
      echoTCPClient0.getProxy();
}"
67,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test67()  throws Throwable  {
      EchoTCPClient echoTCPClient0 = new EchoTCPClient();
      echoTCPClient0.getProxy();
}"
68,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test68()  throws Throwable  {
      EchoTCPClient echoTCPClient0 = new EchoTCPClient();
      echoTCPClient0.disconnect();
}"
69,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test69()  throws Throwable  {
      EchoTCPClient echoTCPClient0 = new EchoTCPClient();
      echoTCPClient0.disconnect();
}"
70,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test70()  throws Throwable  {
      EchoTCPClient echoTCPClient0 = new EchoTCPClient();
      echoTCPClient0.disconnect();
}"
71,"    public void setKeepAlive(final boolean keepAlive) throws SocketException {
        _socket_.setKeepAlive(keepAlive);
    }","  public void test71()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(true);
      // Undeclared exception!
      try { 
        authenticatingIMAPClient0.setKeepAlive(true);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
72,"    public InetAddress getLocalAddress()
    {
        return _socket_.getLocalAddress();
    }","  public void test72()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""");
      // Undeclared exception!
      try { 
        fTPSClient0.getLocalAddress();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
73,"    public void setSoTimeout(final int timeout) throws SocketException
    {
        _socket_.setSoTimeout(timeout);
    }","  public void test73()  throws Throwable  {
      RLoginClient rLoginClient0 = new RLoginClient();
      // Undeclared exception!
      try { 
        rLoginClient0.setSoTimeout(514);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
74,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test74()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
      int int0 = authenticatingSMTPClient0.getDefaultPort();
}"
75,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test75()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
      int int0 = authenticatingSMTPClient0.getDefaultPort();
}"
76,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test76()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
      int int0 = authenticatingSMTPClient0.getDefaultPort();
}"
77,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test77()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(true);
      authenticatingIMAPClient0.addProtocolCommandListener((ProtocolCommandListener) null);
}"
78,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test78()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(true);
      authenticatingIMAPClient0.addProtocolCommandListener((ProtocolCommandListener) null);
}"
79,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test79()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(true);
      authenticatingIMAPClient0.addProtocolCommandListener((ProtocolCommandListener) null);
}"
80,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test80()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      Charset charset0 = Charset.defaultCharset();
      nNTPClient0.setCharset(charset0);
}"
81,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test81()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      Charset charset0 = Charset.defaultCharset();
      nNTPClient0.setCharset(charset0);
}"
82,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test82()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      Charset charset0 = Charset.defaultCharset();
      nNTPClient0.setCharset(charset0);
}"
83,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test83()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(true);
      ServerSocketFactory serverSocketFactory0 = authenticatingIMAPClient0.getServerSocketFactory();
}"
84,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test84()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(true);
      ServerSocketFactory serverSocketFactory0 = authenticatingIMAPClient0.getServerSocketFactory();
}"
85,"    public int getConnectTimeout() {
        return connectTimeout;
    }","  public void test85()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(true);
      ServerSocketFactory serverSocketFactory0 = authenticatingIMAPClient0.getServerSocketFactory();
}"
86,"    public ServerSocketFactory getServerSocketFactory() {
        return _serverSocketFactory_;
    }","  public void test86()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(true);
      ServerSocketFactory serverSocketFactory0 = authenticatingIMAPClient0.getServerSocketFactory();
}"
87,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test0()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 0, ""#9jh8ac3[$"");
      boolean boolean0 = protocolCommandEvent0.isCommand();
}"
88,"    public boolean isCommand()
    {
        return isCommand;
    }","  public void test1()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 0, ""#9jh8ac3[$"");
      boolean boolean0 = protocolCommandEvent0.isCommand();
}"
89,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test2()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 1, """");
      int int0 = protocolCommandEvent0.getReplyCode();
}"
90,"    public boolean isCommand()
    {
        return isCommand;
    }","  public void test3()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 1, """");
      int int0 = protocolCommandEvent0.getReplyCode();
}"
91,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test4()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, (-1382), """");
      int int0 = protocolCommandEvent0.getReplyCode();
}"
92,"    public boolean isReply()
    {
        return !isCommand();
    }","  public void test5()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, (-1382), """");
      int int0 = protocolCommandEvent0.getReplyCode();
}"
93,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test6()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 740, (String) null);
      protocolCommandEvent0.getMessage();
}"
94,"    public boolean isReply()
    {
        return !isCommand();
    }","  public void test7()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 740, (String) null);
      protocolCommandEvent0.getMessage();
}"
95,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test8()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 0, ""#9jh8ac3[$"");
      protocolCommandEvent0.getMessage();
}"
96,"    public boolean isReply()
    {
        return !isCommand();
    }","  public void test9()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 0, ""#9jh8ac3[$"");
      protocolCommandEvent0.getMessage();
}"
97,"    public boolean isCommand()
    {
        return isCommand;
    }","  public void test10()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 0, ""#9jh8ac3[$"");
      protocolCommandEvent0.getCommand();
}"
98,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test11()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 0, ""#9jh8ac3[$"");
      protocolCommandEvent0.getCommand();
}"
99,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test12()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, ""FWg]@HN$#Gm&dG3B"", ""FWg]@HN$#Gm&dG3B"");
      protocolCommandEvent0.getCommand();
}"
100,"    public boolean isCommand()
    {
        return isCommand;
    }","  public void test13()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, ""FWg]@HN$#Gm&dG3B"", ""FWg]@HN$#Gm&dG3B"");
      protocolCommandEvent0.getCommand();
}"
101,"    public ProtocolCommandEvent(final Object source, final String command, final String message)
    {
        super(source);
        this.replyCode = 0;
        this.message = message;
        this.isCommand = true;
        this.command = command;
    }","  public void test14()  throws Throwable  {
      ProtocolCommandEvent protocolCommandEvent0 = null;
      try {
        protocolCommandEvent0 = new ProtocolCommandEvent((Object) null, """", """");
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // null source
         //
         verifyException(""java.util.EventObject"", e);
      }
  }"
102,"    public ProtocolCommandEvent(final Object source, final String command, final String message)
    {
        super(source);
        this.replyCode = 0;
        this.message = message;
        this.isCommand = true;
        this.command = command;
    }","  public void test15()  throws Throwable  {
      ProtocolCommandEvent protocolCommandEvent0 = null;
      try {
        protocolCommandEvent0 = new ProtocolCommandEvent((Object) null, 0, (String) null);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // null source
         //
         verifyException(""java.util.EventObject"", e);
      }
  }"
103,"    public boolean isReply()
    {
        return !isCommand();
    }","  public void test16()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      boolean boolean0 = protocolCommandEvent0.isReply();
}"
104,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test17()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      boolean boolean0 = protocolCommandEvent0.isReply();
}"
105,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test18()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      protocolCommandEvent0.getCommand();
}"
106,"    public boolean isReply()
    {
        return !isCommand();
    }","  public void test19()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      protocolCommandEvent0.getCommand();
}"
107,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test20()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      boolean boolean0 = protocolCommandEvent0.isCommand();
}"
108,"    public boolean isCommand()
    {
        return isCommand;
    }","  public void test21()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      boolean boolean0 = protocolCommandEvent0.isCommand();
}"
109,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test22()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      int int0 = protocolCommandEvent0.getReplyCode();
}"
110,"    public boolean isCommand()
    {
        return isCommand;
    }","  public void test23()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      int int0 = protocolCommandEvent0.getReplyCode();
}"
111,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test24()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      protocolCommandEvent0.getMessage();
}"
112,"    public boolean isCommand()
    {
        return isCommand;
    }","  public void test25()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, """", """");
      protocolCommandEvent0.getMessage();
}"
113,"    public boolean isReply()
    {
        return !isCommand();
    }","  public void test26()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 0, ""#9jh8ac3[$"");
      boolean boolean0 = protocolCommandEvent0.isReply();
}"
114,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test27()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, 0, ""#9jh8ac3[$"");
      boolean boolean0 = protocolCommandEvent0.isReply();
}"
115,"    public ServerSocket createServerSocket(final int port) throws IOException
    {
        return new ServerSocket(port);
    }","  public void test0()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      InetAddress inetAddress0 = MockInetAddress.getByName("":~%`&vzZrVS'A:n 1n"");
      ServerSocket serverSocket0 = defaultSocketFactory0.createServerSocket(0, 798, inetAddress0);
}"
116,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test1()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      InetAddress inetAddress1 = MockInetAddress.getByName("""");
      try { 
        defaultSocketFactory0.createSocket(inetAddress0, 0, inetAddress1, 1);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@3b7fa506
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
117,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test2()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      byte[] byteArray0 = new byte[4];
      InetAddress inetAddress0 = MockInetAddress.getByAddress(""J`%RAEBJ&c3c?]92r"", byteArray0);
      InetAddress inetAddress1 = MockInetAddress.getByAddress(byteArray0);
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createSocket(inetAddress0, (-1229), inetAddress1, (int) (byte)0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1229
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
118,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test3()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 3);
      NetworkHandling.openRemoteTcpServer(evoSuiteRemoteAddress0);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      Socket socket0 = defaultSocketFactory0.createSocket(inetAddress0, (int) (byte)3);
}"
119,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test4()  throws Throwable  {
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 867);
      NetworkHandling.openRemoteTcpServer(evoSuiteRemoteAddress0);
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      InetAddress inetAddress0 = MockInetAddress.getByName("",d/}8X`ky6SW|3C"");
      Socket socket0 = defaultSocketFactory0.createSocket(inetAddress0, 867, inetAddress0, 867);
}"
120,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test5()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 3);
      NetworkHandling.openRemoteTcpServer(evoSuiteRemoteAddress0);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      Socket socket0 = defaultSocketFactory0.createSocket(inetAddress0, (int) (byte)3);
}"
121,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test6()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 471);
      NetworkHandling.openRemoteTcpServer(evoSuiteRemoteAddress0);
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      Socket socket0 = defaultSocketFactory0.createSocket(""TLD-,Y>zEFze?ym@"", 471, inetAddress0, 0);
}"
122,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test7()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 471);
      NetworkHandling.openRemoteTcpServer(evoSuiteRemoteAddress0);
      Socket socket0 = defaultSocketFactory0.createSocket(""TLD-,Y>zEFze?ym@"", 471);
}"
123,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test8()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createSocket((InetAddress) null, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockSocket"", e);
      }
  }"
124,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test9()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createSocket(inetAddress0, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
125,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test10()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createSocket(""c~w<Z+E3;"", 1259, inetAddress0, (-6729));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-6729
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
126,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test11()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createSocket(""org.apache.commons.net.DefaultSocketFactory"", (-1));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
127,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test12()  throws Throwable  {
      Proxy.Type proxy_Type0 = Proxy.Type.HTTP;
      InetSocketAddress inetSocketAddress0 = MockInetSocketAddress.createUnresolved(""_O%?2Bc_BB2"", 0);
      Proxy proxy0 = new Proxy(proxy_Type0, inetSocketAddress0);
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createSocket();
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid Proxy
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockSocket"", e);
      }
  }"
128,"    public ServerSocket createServerSocket(final int port) throws IOException
    {
        return new ServerSocket(port);
    }","  public void test13()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createServerSocket((-1134), (-1134), inetAddress0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port value out of range: -1134
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockServerSocket"", e);
      }
  }"
129,"    public ServerSocket createServerSocket(final int port) throws IOException
    {
        return new ServerSocket(port);
    }","  public void test14()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createServerSocket((-3165), (-3165));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port value out of range: -3165
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockServerSocket"", e);
      }
  }"
130,"    public ServerSocket createServerSocket(final int port) throws IOException
    {
        return new ServerSocket(port);
    }","  public void test15()  throws Throwable  {
      Proxy.Type proxy_Type0 = Proxy.Type.HTTP;
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      MockInetSocketAddress mockInetSocketAddress0 = new MockInetSocketAddress(inetAddress0, 1468);
      Proxy proxy0 = new Proxy(proxy_Type0, mockInetSocketAddress0);
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      defaultSocketFactory0.createServerSocket(1468);
      try { 
        defaultSocketFactory0.createServerSocket(1468, (-1));
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Failed to open TCP port
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoSuiteSocket"", e);
      }
  }"
131,"    public ServerSocket createServerSocket(final int port) throws IOException
    {
        return new ServerSocket(port);
    }","  public void test16()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createServerSocket((-375));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port value out of range: -375
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockServerSocket"", e);
      }
  }"
132,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test17()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      // Undeclared exception!
      try { 
        defaultSocketFactory0.createSocket((InetAddress) null, 1070, (InetAddress) null, 1070);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockSocket"", e);
      }
  }"
133,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test18()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      try { 
        defaultSocketFactory0.createSocket(""TLD-,Y>zEFze?ym@"", 471, inetAddress0, 0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@25851b69
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
134,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test19()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      try { 
        defaultSocketFactory0.createSocket(inetAddress0, (int) (byte)3);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@3b7fa563
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
135,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test20()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      try { 
        defaultSocketFactory0.createSocket("""", 0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@164e3a9
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
136,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test21()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      try { 
        defaultSocketFactory0.createSocket(""7nP&7"", 0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@2584e260
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
137,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test22()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory(proxy0);
      Socket socket0 = defaultSocketFactory0.createSocket();
}"
138,"    public Socket createSocket() throws IOException
    {
        if (connProxy != null)
        {
            return new Socket(connProxy);
        }
        return new Socket();
    }","  public void test23()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      Socket socket0 = defaultSocketFactory0.createSocket();
}"
139,"    public ServerSocket createServerSocket(final int port) throws IOException
    {
        return new ServerSocket(port);
    }","  public void test24()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      defaultSocketFactory0.createServerSocket(12, 12, inetAddress0);
      try { 
        defaultSocketFactory0.createServerSocket(12);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Failed to open TCP port
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoSuiteSocket"", e);
      }
  }"
140,"    public ServerSocket createServerSocket(final int port) throws IOException
    {
        return new ServerSocket(port);
    }","  public void test25()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory();
      ServerSocket serverSocket0 = defaultSocketFactory0.createServerSocket(2015, 0);
}"
141,"    public ServerSocket createServerSocket(final int port) throws IOException
    {
        return new ServerSocket(port);
    }","  public void test26()  throws Throwable  {
      DefaultSocketFactory defaultSocketFactory0 = new DefaultSocketFactory((Proxy) null);
      defaultSocketFactory0.createServerSocket(829);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      try { 
        defaultSocketFactory0.createServerSocket(829, 829, inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Failed to open TCP port
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoSuiteSocket"", e);
      }
  }"
142,"    public MalformedServerReplyException()
    {
    }","  public void test0()  throws Throwable  {
      MalformedServerReplyException malformedServerReplyException0 = new MalformedServerReplyException("""");
  }"
143,"    public MalformedServerReplyException()
    {
    }","  public void test1()  throws Throwable  {
      MalformedServerReplyException malformedServerReplyException0 = new MalformedServerReplyException();
  }"
144,"    public void protocolCommandSent(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""> "");
        }
        if (nologin) {
            final String cmd = event.getCommand();
            if (""PASS"".equalsIgnoreCase(cmd) || ""USER"".equalsIgnoreCase(cmd)) {
                writer.print(cmd);
                writer.println("" *******""); // Don't bother with EOL marker for this!
            } else {
                final String IMAP_LOGIN = ""LOGIN"";
                if (IMAP_LOGIN.equalsIgnoreCase(cmd)) { // IMAP
                    String msg = event.getMessage();
                    msg=msg.substring(0, msg.indexOf(IMAP_LOGIN)+IMAP_LOGIN.length());
                    writer.print(msg);
                    writer.println("" *******""); // Don't bother with EOL marker for this!
                } else {
                    writer.print(getPrintableString(event.getMessage()));
                }
            }
        } else {
            writer.print(getPrintableString(event.getMessage()));
        }
        writer.flush();
    }","  public void test0()  throws Throwable  {
      URI uRI0 = MockURI.aFileURI;
      MockFile mockFile0 = new MockFile(uRI0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, false, 'e', false);
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(mockPrintStream0, 59, ""\r\n"");
      printCommandListener0.protocolCommandSent(protocolCommandEvent0);
}"
145,"    public PrintCommandListener(final PrintStream stream)
    {
        this(new PrintWriter(stream));
    }","  public void test1()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream(""SYSTEM"");
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, true, 'a');
  }"
146,"    public PrintCommandListener(final PrintStream stream)
    {
        this(new PrintWriter(stream));
    }","  public void test2()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream(""eL@Kt{$fBA0F"");
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, true);
  }"
147,"    public PrintCommandListener(final PrintStream stream)
    {
        this(new PrintWriter(stream));
    }","  public void test3()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream(""G~}@V8~q*f"");
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0);
  }"
148,"    public void protocolReplyReceived(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""< "");
        }
        writer.print(event.getMessage());
        writer.flush();
    }","  public void test4()  throws Throwable  {
      MockFile mockFile0 = new MockFile((File) null, ""org.apache.commons.io.filefilter.DelegateFileFilter"");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0);
      // Undeclared exception!
      try { 
        printCommandListener0.protocolReplyReceived((ProtocolCommandEvent) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.PrintCommandListener"", e);
      }
  }"
149,"    public void protocolCommandSent(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""> "");
        }
        if (nologin) {
            final String cmd = event.getCommand();
            if (""PASS"".equalsIgnoreCase(cmd) || ""USER"".equalsIgnoreCase(cmd)) {
                writer.print(cmd);
                writer.println("" *******""); // Don't bother with EOL marker for this!
            } else {
                final String IMAP_LOGIN = ""LOGIN"";
                if (IMAP_LOGIN.equalsIgnoreCase(cmd)) { // IMAP
                    String msg = event.getMessage();
                    msg=msg.substring(0, msg.indexOf(IMAP_LOGIN)+IMAP_LOGIN.length());
                    writer.print(msg);
                    writer.println("" *******""); // Don't bother with EOL marker for this!
                } else {
                    writer.print(getPrintableString(event.getMessage()));
                }
            }
        } else {
            writer.print(getPrintableString(event.getMessage()));
        }
        writer.flush();
    }","  public void test5()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""org.apache.commons.io.filefilter.AgeFileFilter"", ""org.apache.commons.io.filefilter.AgeFileFilter"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, true, 'G', true);
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(""< "", ""LOGIN"", """");
      // Undeclared exception!
      try { 
        printCommandListener0.protocolCommandSent(protocolCommandEvent0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
150,"    public PrintCommandListener(final PrintStream stream)
    {
        this(new PrintWriter(stream));
    }","  public void test6()  throws Throwable  {
      PrintCommandListener printCommandListener0 = null;
      try {
        printCommandListener0 = new PrintCommandListener((PrintStream) null, false, '-');
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Writer"", e);
      }
  }"
151,"    public PrintCommandListener(final PrintStream stream)
    {
        this(new PrintWriter(stream));
    }","  public void test7()  throws Throwable  {
      PrintCommandListener printCommandListener0 = null;
      try {
        printCommandListener0 = new PrintCommandListener((PrintStream) null, false);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Writer"", e);
      }
  }"
152,"    public PrintCommandListener(final PrintStream stream)
    {
        this(new PrintWriter(stream));
    }","  public void test8()  throws Throwable  {
      PrintCommandListener printCommandListener0 = null;
      try {
        printCommandListener0 = new PrintCommandListener((PrintStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Writer"", e);
      }
  }"
153,"    public PrintCommandListener(final PrintStream stream)
    {
        this(new PrintWriter(stream));
    }","  public void test9()  throws Throwable  {
      File file0 = MockFile.createTempFile(""login"", ""login"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(file0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, true, '(');
  }"
154,"    public void protocolReplyReceived(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""< "");
        }
        writer.print(event.getMessage());
        writer.flush();
    }","  public void test10()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""org.apache.commons.io.filefilter.AgeFileFilter"", ""org.apache.commons.io.filefilter.AgeFileFilter"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, true, 'G', true);
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(printCommandListener0, 'G', ""< "");
      printCommandListener0.protocolReplyReceived(protocolCommandEvent0);
}"
155,"    public void protocolCommandSent(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""> "");
        }
        if (nologin) {
            final String cmd = event.getCommand();
            if (""PASS"".equalsIgnoreCase(cmd) || ""USER"".equalsIgnoreCase(cmd)) {
                writer.print(cmd);
                writer.println("" *******""); // Don't bother with EOL marker for this!
            } else {
                final String IMAP_LOGIN = ""LOGIN"";
                if (IMAP_LOGIN.equalsIgnoreCase(cmd)) { // IMAP
                    String msg = event.getMessage();
                    msg=msg.substring(0, msg.indexOf(IMAP_LOGIN)+IMAP_LOGIN.length());
                    writer.print(msg);
                    writer.println("" *******""); // Don't bother with EOL marker for this!
                } else {
                    writer.print(getPrintableString(event.getMessage()));
                }
            }
        } else {
            writer.print(getPrintableString(event.getMessage()));
        }
        writer.flush();
    }","  public void test11()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""org.apache.commons.io.filefilter.AgeFileFilter"", ""org.apache.commons.io.filefilter.AgeFileFilter"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, true, 'G', true);
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(printCommandListener0, 'G', ""< "");
      printCommandListener0.protocolCommandSent(protocolCommandEvent0);
}"
156,"    public void protocolCommandSent(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""> "");
        }
        if (nologin) {
            final String cmd = event.getCommand();
            if (""PASS"".equalsIgnoreCase(cmd) || ""USER"".equalsIgnoreCase(cmd)) {
                writer.print(cmd);
                writer.println("" *******""); // Don't bother with EOL marker for this!
            } else {
                final String IMAP_LOGIN = ""LOGIN"";
                if (IMAP_LOGIN.equalsIgnoreCase(cmd)) { // IMAP
                    String msg = event.getMessage();
                    msg=msg.substring(0, msg.indexOf(IMAP_LOGIN)+IMAP_LOGIN.length());
                    writer.print(msg);
                    writer.println("" *******""); // Don't bother with EOL marker for this!
                } else {
                    writer.print(getPrintableString(event.getMessage()));
                }
            }
        } else {
            writer.print(getPrintableString(event.getMessage()));
        }
        writer.flush();
    }","  public void test12()  throws Throwable  {
      PrintCommandListener printCommandListener0 = new PrintCommandListener((PrintWriter) null, true);
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, ""nTll"", ""nTll"");
      // Undeclared exception!
      try { 
        printCommandListener0.protocolCommandSent(protocolCommandEvent0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.PrintCommandListener"", e);
      }
  }"
157,"    public void protocolCommandSent(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""> "");
        }
        if (nologin) {
            final String cmd = event.getCommand();
            if (""PASS"".equalsIgnoreCase(cmd) || ""USER"".equalsIgnoreCase(cmd)) {
                writer.print(cmd);
                writer.println("" *******""); // Don't bother with EOL marker for this!
            } else {
                final String IMAP_LOGIN = ""LOGIN"";
                if (IMAP_LOGIN.equalsIgnoreCase(cmd)) { // IMAP
                    String msg = event.getMessage();
                    msg=msg.substring(0, msg.indexOf(IMAP_LOGIN)+IMAP_LOGIN.length());
                    writer.print(msg);
                    writer.println("" *******""); // Don't bother with EOL marker for this!
                } else {
                    writer.print(getPrintableString(event.getMessage()));
                }
            }
        } else {
            writer.print(getPrintableString(event.getMessage()));
        }
        writer.flush();
    }","  public void test13()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""org.apache.commons.io.filefilter.AgeFile7ilter"", ""org.apache.commons.io.filefilter.AgeFile7ilter"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, true, 'G', true);
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(""org.apache.commons.io.filefilter.AgeFile7ilter"", ""USER"", ""org.apache.commons.io.filefilter.AgeFile7ilter"");
      printCommandListener0.protocolCommandSent(protocolCommandEvent0);
}"
158,"    public void protocolCommandSent(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""> "");
        }
        if (nologin) {
            final String cmd = event.getCommand();
            if (""PASS"".equalsIgnoreCase(cmd) || ""USER"".equalsIgnoreCase(cmd)) {
                writer.print(cmd);
                writer.println("" *******""); // Don't bother with EOL marker for this!
            } else {
                final String IMAP_LOGIN = ""LOGIN"";
                if (IMAP_LOGIN.equalsIgnoreCase(cmd)) { // IMAP
                    String msg = event.getMessage();
                    msg=msg.substring(0, msg.indexOf(IMAP_LOGIN)+IMAP_LOGIN.length());
                    writer.print(msg);
                    writer.println("" *******""); // Don't bother with EOL marker for this!
                } else {
                    writer.print(getPrintableString(event.getMessage()));
                }
            }
        } else {
            writer.print(getPrintableString(event.getMessage()));
        }
        writer.flush();
    }","  public void test14()  throws Throwable  {
      URI uRI0 = MockURI.aFileURI;
      MockFile mockFile0 = new MockFile(uRI0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, false, 'b', false);
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(mockPrintStream0, (-3414), ""];p\r\n"");
      printCommandListener0.protocolCommandSent(protocolCommandEvent0);
}"
159,"    public void protocolCommandSent(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""> "");
        }
        if (nologin) {
            final String cmd = event.getCommand();
            if (""PASS"".equalsIgnoreCase(cmd) || ""USER"".equalsIgnoreCase(cmd)) {
                writer.print(cmd);
                writer.println("" *******""); // Don't bother with EOL marker for this!
            } else {
                final String IMAP_LOGIN = ""LOGIN"";
                if (IMAP_LOGIN.equalsIgnoreCase(cmd)) { // IMAP
                    String msg = event.getMessage();
                    msg=msg.substring(0, msg.indexOf(IMAP_LOGIN)+IMAP_LOGIN.length());
                    writer.print(msg);
                    writer.println("" *******""); // Don't bother with EOL marker for this!
                } else {
                    writer.print(getPrintableString(event.getMessage()));
                }
            }
        } else {
            writer.print(getPrintableString(event.getMessage()));
        }
        writer.flush();
    }","  public void test15()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""LOGIN"", ""The array of prefixes must not be null"");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, true, '4');
      Object object0 = new Object();
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(object0, ""LOGIN"", ""The array of prefixes must not be null"");
      printCommandListener0.protocolCommandSent(protocolCommandEvent0);
}"
160,"    public void protocolCommandSent(final ProtocolCommandEvent event)
    {
        if (directionMarker) {
            writer.print(""> "");
        }
        if (nologin) {
            final String cmd = event.getCommand();
            if (""PASS"".equalsIgnoreCase(cmd) || ""USER"".equalsIgnoreCase(cmd)) {
                writer.print(cmd);
                writer.println("" *******""); // Don't bother with EOL marker for this!
            } else {
                final String IMAP_LOGIN = ""LOGIN"";
                if (IMAP_LOGIN.equalsIgnoreCase(cmd)) { // IMAP
                    String msg = event.getMessage();
                    msg=msg.substring(0, msg.indexOf(IMAP_LOGIN)+IMAP_LOGIN.length());
                    writer.print(msg);
                    writer.println("" *******""); // Don't bother with EOL marker for this!
                } else {
                    writer.print(getPrintableString(event.getMessage()));
                }
            }
        } else {
            writer.print(getPrintableString(event.getMessage()));
        }
        writer.flush();
    }","  public void test16()  throws Throwable  {
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream(pipedInputStream0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, true);
      ProtocolCommandEvent protocolCommandEvent0 = new ProtocolCommandEvent(mockPrintStream0, ""PASS"", ""PASS"");
      printCommandListener0.protocolCommandSent(protocolCommandEvent0);
}"
161,"    public PrintCommandListener(final PrintStream stream)
    {
        this(new PrintWriter(stream));
    }","  public void test17()  throws Throwable  {
      PrintCommandListener printCommandListener0 = null;
      try {
        printCommandListener0 = new PrintCommandListener((PrintStream) null, true, '&', true);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Writer"", e);
      }
  }"
162,"    public int getListenerCount()
    {
        return listeners.getListenerCount();
    }","  public void test0()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport(object0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(""/<GfwB"");
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, true, 't');
      protocolCommandSupport0.addProtocolCommandListener(printCommandListener0);
      int int0 = protocolCommandSupport0.getListenerCount();
}"
163,"    public void fireReplyReceived(final int replyCode, final String message)
    {
        final ProtocolCommandEvent event;
        event = new ProtocolCommandEvent(source, replyCode, message);

        for (final EventListener listener : listeners)
        {
            ((ProtocolCommandListener)listener).protocolReplyReceived(event);
        }
    }","  public void test1()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport(object0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener((PrintWriter) null, true, '2');
      protocolCommandSupport0.addProtocolCommandListener(printCommandListener0);
      // Undeclared exception!
      try { 
        protocolCommandSupport0.fireReplyReceived(1716, """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.PrintCommandListener"", e);
      }
  }"
164,"    public void fireReplyReceived(final int replyCode, final String message)
    {
        final ProtocolCommandEvent event;
        event = new ProtocolCommandEvent(source, replyCode, message);

        for (final EventListener listener : listeners)
        {
            ((ProtocolCommandListener)listener).protocolReplyReceived(event);
        }
    }","  public void test2()  throws Throwable  {
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport((Object) null);
      // Undeclared exception!
      try { 
        protocolCommandSupport0.fireReplyReceived((-1578), """");
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // null source
         //
         verifyException(""java.util.EventObject"", e);
      }
  }"
165,"    public void fireCommandSent(final String command, final String message)
    {
        final ProtocolCommandEvent event;

        event = new ProtocolCommandEvent(source, command, message);

        for (final EventListener listener : listeners)
        {
           ((ProtocolCommandListener)listener).protocolCommandSent(event);
        }
    }","  public void test3()  throws Throwable  {
      VetoableChangeListener vetoableChangeListener0 = mock(VetoableChangeListener.class, new ViolatedAssumptionAnswer());
      VetoableChangeListenerProxy vetoableChangeListenerProxy0 = new VetoableChangeListenerProxy((String) null, vetoableChangeListener0);
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport(vetoableChangeListenerProxy0);
      protocolCommandSupport0.addProtocolCommandListener((ProtocolCommandListener) null);
      // Undeclared exception!
      try { 
        protocolCommandSupport0.fireCommandSent(""Invalid IOCase name: "", """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ProtocolCommandSupport"", e);
      }
  }"
166,"    public void fireCommandSent(final String command, final String message)
    {
        final ProtocolCommandEvent event;

        event = new ProtocolCommandEvent(source, command, message);

        for (final EventListener listener : listeners)
        {
           ((ProtocolCommandListener)listener).protocolCommandSent(event);
        }
    }","  public void test4()  throws Throwable  {
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport((Object) null);
      // Undeclared exception!
      try { 
        protocolCommandSupport0.fireCommandSent("":y{O5aRgo"", ""The wildcard list must not be null"");
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // null source
         //
         verifyException(""java.util.EventObject"", e);
      }
  }"
167,"    public void fireReplyReceived(final int replyCode, final String message)
    {
        final ProtocolCommandEvent event;
        event = new ProtocolCommandEvent(source, replyCode, message);

        for (final EventListener listener : listeners)
        {
            ((ProtocolCommandListener)listener).protocolReplyReceived(event);
        }
    }","  public void test5()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport(object0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(""/<GfwB"");
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, true, 't');
      protocolCommandSupport0.addProtocolCommandListener(printCommandListener0);
      protocolCommandSupport0.fireReplyReceived('t', ""/<GfwB"");
  }"
168,"    public void fireCommandSent(final String command, final String message)
    {
        final ProtocolCommandEvent event;

        event = new ProtocolCommandEvent(source, command, message);

        for (final EventListener listener : listeners)
        {
           ((ProtocolCommandListener)listener).protocolCommandSent(event);
        }
    }","  public void test6()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport(object0);
      protocolCommandSupport0.fireCommandSent(""/<GfwB"", ""/<GfwB"");
  }"
169,"    public void removeProtocolCommandListener(final ProtocolCommandListener listener)
    {
        listeners.removeListener(listener);
    }","  public void test7()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport(object0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(""/<GfwB"");
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, true, 't');
      protocolCommandSupport0.removeProtocolCommandListener(printCommandListener0);
  }"
170,"    public void fireCommandSent(final String command, final String message)
    {
        final ProtocolCommandEvent event;

        event = new ProtocolCommandEvent(source, command, message);

        for (final EventListener listener : listeners)
        {
           ((ProtocolCommandListener)listener).protocolCommandSent(event);
        }
    }","  public void test8()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport(object0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(""/<GfwB"");
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0, true, 't');
      protocolCommandSupport0.addProtocolCommandListener(printCommandListener0);
      protocolCommandSupport0.fireCommandSent(""/<GfwB"", ""/<GfwB"");
  }"
171,"    public int getListenerCount()
    {
        return listeners.getListenerCount();
    }","  public void test9()  throws Throwable  {
      Object object0 = new Object();
      ProtocolCommandSupport protocolCommandSupport0 = new ProtocolCommandSupport(object0);
      int int0 = protocolCommandSupport0.getListenerCount();
}"
172,"    public DatagramSocket createDatagramSocket() throws SocketException
    {
        return new DatagramSocket();
    }","  public void test0()  throws Throwable  {
      DefaultDatagramSocketFactory defaultDatagramSocketFactory0 = new DefaultDatagramSocketFactory();
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      // Undeclared exception!
      try { 
        defaultDatagramSocketFactory0.createDatagramSocket((-2502), inetAddress0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-2502
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
173,"    public DatagramSocket createDatagramSocket() throws SocketException
    {
        return new DatagramSocket();
    }","  public void test1()  throws Throwable  {
      DefaultDatagramSocketFactory defaultDatagramSocketFactory0 = new DefaultDatagramSocketFactory();
      // Undeclared exception!
      try { 
        defaultDatagramSocketFactory0.createDatagramSocket((-2231));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-2231
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
174,"    public DatagramSocket createDatagramSocket() throws SocketException
    {
        return new DatagramSocket();
    }","  public void test2()  throws Throwable  {
      DefaultDatagramSocketFactory defaultDatagramSocketFactory0 = new DefaultDatagramSocketFactory();
      DatagramSocket datagramSocket0 = defaultDatagramSocketFactory0.createDatagramSocket(1648);
}"
175,"    public DatagramSocket createDatagramSocket() throws SocketException
    {
        return new DatagramSocket();
    }","  public void test3()  throws Throwable  {
      DefaultDatagramSocketFactory defaultDatagramSocketFactory0 = new DefaultDatagramSocketFactory();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      DatagramSocket datagramSocket0 = defaultDatagramSocketFactory0.createDatagramSocket(1648, inetAddress0);
}"
176,"    public DatagramSocket createDatagramSocket() throws SocketException
    {
        return new DatagramSocket();
    }","  public void test4()  throws Throwable  {
      DefaultDatagramSocketFactory defaultDatagramSocketFactory0 = new DefaultDatagramSocketFactory();
      DatagramSocket datagramSocket0 = defaultDatagramSocketFactory0.createDatagramSocket();
}"
177,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test0()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      DefaultDatagramSocketFactory defaultDatagramSocketFactory0 = new DefaultDatagramSocketFactory();
      discardUDPClient0.setDatagramSocketFactory(defaultDatagramSocketFactory0);
      discardUDPClient0.setDatagramSocketFactory((DatagramSocketFactory) null);
}"
178,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test1()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      DefaultDatagramSocketFactory defaultDatagramSocketFactory0 = new DefaultDatagramSocketFactory();
      discardUDPClient0.setDatagramSocketFactory(defaultDatagramSocketFactory0);
      discardUDPClient0.setDatagramSocketFactory((DatagramSocketFactory) null);
}"
179,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test2()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
}"
180,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test3()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      charGenUDPClient0.open(19, inetAddress0);
      charGenUDPClient0.setSoTimeout(15);
}"
181,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test4()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
}"
182,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test5()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.open(5);
      boolean boolean0 = tFTPClient0.isOpen();
}"
183,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test6()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
}"
184,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test7()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      charGenUDPClient0.open(3443);
      charGenUDPClient0.getSoTimeout();
}"
185,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test8()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
}"
186,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test9()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.open(9);
      int int0 = echoUDPClient0.getLocalPort();
}"
187,"    public int getLocalPort()
    {
        return _socket_.getLocalPort();
    }","  public void test10()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.open(9);
      int int0 = echoUDPClient0.getLocalPort();
}"
188,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test11()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.setDefaultTimeout((-1));
      int int0 = echoUDPClient0.getDefaultTimeout();
}"
189,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test12()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.setCharset((Charset) null);
      echoUDPClient0.getCharset();
}"
190,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test13()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.setCharset((Charset) null);
      echoUDPClient0.getCharset();
}"
191,"    public void open() throws SocketException
    {
        _socket_ = _socketFactory_.createDatagramSocket();
        _socket_.setSoTimeout(_timeout_);
        _isOpen_ = true;
    }","  public void test14()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        timeUDPClient0.open((-1891), inetAddress0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1891
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
192,"    public InetAddress getLocalAddress()
    {
        return _socket_.getLocalAddress();
    }","  public void test15()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      // Undeclared exception!
      try { 
        discardUDPClient0.getLocalAddress();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.DatagramSocketClient"", e);
      }
  }"
193,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test16()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      boolean boolean0 = echoUDPClient0.isOpen();
}"
194,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test17()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      boolean boolean0 = echoUDPClient0.isOpen();
}"
195,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test18()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.open(9);
}"
196,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test19()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.open(9);
      echoUDPClient0.close();
}"
197,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test20()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.close();
}"
198,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test21()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.close();
}"
199,"    public int getLocalPort()
    {
        return _socket_.getLocalPort();
    }","  public void test22()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      // Undeclared exception!
      try { 
        echoUDPClient0.getLocalPort();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.DatagramSocketClient"", e);
      }
  }"
200,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test23()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      int int0 = tFTPClient0.getDefaultTimeout();
}"
201,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test24()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      int int0 = tFTPClient0.getDefaultTimeout();
}"
202,"    public int getSoTimeout() throws SocketException
    {
        return _socket_.getSoTimeout();
    }","  public void test25()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      // Undeclared exception!
      try { 
        charGenUDPClient0.getSoTimeout();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.DatagramSocketClient"", e);
      }
  }"
203,"    public String getCharsetName() {
        return charset.name();
    }","  public void test26()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      discardUDPClient0.setCharset((Charset) null);
      // Undeclared exception!
      try { 
        discardUDPClient0.getCharsetName();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.DatagramSocketClient"", e);
      }
  }"
204,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test27()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      int int0 = echoUDPClient0.getDefaultTimeout();
}"
205,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test28()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      int int0 = echoUDPClient0.getDefaultTimeout();
}"
206,"    public InetAddress getLocalAddress()
    {
        return _socket_.getLocalAddress();
    }","  public void test29()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.open(9);
      InetAddress inetAddress0 = echoUDPClient0.getLocalAddress();
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      try { 
        nTPUDPClient0.getTime(inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
207,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test30()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
}"
208,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test31()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      discardUDPClient0.open();
}"
209,"    public boolean isOpen()
    {
        return _isOpen_;
    }","  public void test32()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      discardUDPClient0.getCharsetName();
}"
210,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test33()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      discardUDPClient0.getCharsetName();
}"
211,"    public void open() throws SocketException
    {
        _socket_ = _socketFactory_.createDatagramSocket();
        _socket_.setSoTimeout(_timeout_);
        _isOpen_ = true;
    }","  public void test34()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      // Undeclared exception!
      try { 
        echoUDPClient0.open((-1357));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1357
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
212,"    public void setSoTimeout(final int timeout) throws SocketException
    {
        _socket_.setSoTimeout(timeout);
    }","  public void test35()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      // Undeclared exception!
      try { 
        charGenUDPClient0.setSoTimeout(15);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.DatagramSocketClient"", e);
      }
  }"
213,"    public InputStream getInputStream(final boolean longOutput, final String username)
    throws IOException
    {
        return getInputStream(longOutput, username, null);
    }","  public void test0()  throws Throwable  {
      FingerClient fingerClient0 = new FingerClient();
      // Undeclared exception!
      try { 
        fingerClient0.getInputStream(true, (String) null, (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.BufferedOutputStream"", e);
      }
  }"
214,"    public InputStream getInputStream(final boolean longOutput, final String username)
    throws IOException
    {
        return getInputStream(longOutput, username, null);
    }","  public void test1()  throws Throwable  {
      FingerClient fingerClient0 = new FingerClient();
      // Undeclared exception!
      try { 
        fingerClient0.getInputStream(true, ""org.apache.commons.net.finger.FingerClient"", ""org.apache.commons.net.finger.FingerClient"");
        fail(""Expecting exception: UnsupportedCharsetException"");
      } catch(UnsupportedCharsetException e) {
         //
         // org.apache.commons.net.finger.FingerClient
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
215,"    public InputStream getInputStream(final boolean longOutput, final String username)
    throws IOException
    {
        return getInputStream(longOutput, username, null);
    }","  public void test2()  throws Throwable  {
      FingerClient fingerClient0 = new FingerClient();
      // Undeclared exception!
      try { 
        fingerClient0.getInputStream(false, """", ""'_!@)_<_"");
        fail(""Expecting exception: IllegalCharsetNameException"");
      } catch(IllegalCharsetNameException e) {
         //
         // '_!@)_<_
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
216,"    public InputStream getInputStream(final boolean longOutput, final String username)
    throws IOException
    {
        return getInputStream(longOutput, username, null);
    }","  public void test3()  throws Throwable  {
      FingerClient fingerClient0 = new FingerClient();
      // Undeclared exception!
      try { 
        fingerClient0.getInputStream(false, (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
217,"    public String query(final boolean longOutput, final String username) throws IOException
    {
        int read;
        final StringBuilder result = new StringBuilder(buffer.length);

        try (final BufferedReader input = new BufferedReader(
                new InputStreamReader(getInputStream(longOutput, username), getCharset()))) {
            while (true) {
                read = input.read(buffer, 0, buffer.length);
                if (read <= 0) {
                    break;
                }
                result.append(buffer, 0, read);
            }
        }

        return result.toString();
    }","  public void test4()  throws Throwable  {
      FingerClient fingerClient0 = new FingerClient();
      // Undeclared exception!
      try { 
        fingerClient0.query(true, ""/W "");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
218,"    public InputStream getInputStream(final boolean longOutput, final String username)
    throws IOException
    {
        return getInputStream(longOutput, username, null);
    }","  public void test5()  throws Throwable  {
      FingerClient fingerClient0 = new FingerClient();
      // Undeclared exception!
      try { 
        fingerClient0.getInputStream(false);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
219,"    public String query(final boolean longOutput, final String username) throws IOException
    {
        int read;
        final StringBuilder result = new StringBuilder(buffer.length);

        try (final BufferedReader input = new BufferedReader(
                new InputStreamReader(getInputStream(longOutput, username), getCharset()))) {
            while (true) {
                read = input.read(buffer, 0, buffer.length);
                if (read <= 0) {
                    break;
                }
                result.append(buffer, 0, read);
            }
        }

        return result.toString();
    }","  public void test6()  throws Throwable  {
      FingerClient fingerClient0 = new FingerClient();
      // Undeclared exception!
      try { 
        fingerClient0.query(false);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
220,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test0()  throws Throwable  {
      CharGenTCPClient charGenTCPClient0 = new CharGenTCPClient();
      charGenTCPClient0.getInputStream();
}"
221,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test0()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getByName(""org.apache.commons.net.chargen.CharGenUDPClient"");
      charGenUDPClient0.open(0);
      charGenUDPClient0.send(inetAddress0, 0);
}"
222,"    public byte[] receive() throws IOException
    {
        final int length;
        final byte[] result;

        _socket_.receive(receivePacket);

        result = new byte[length = receivePacket.getLength()];
        System.arraycopy(receiveData, 0, result, 0, length);

        return result;
    }","  public void test1()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      charGenUDPClient0.open();
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      byte[] byteArray0 = new byte[3];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, byteArray0);
      byte[] byteArray1 = charGenUDPClient0.receive();
}"
223,"    public byte[] receive() throws IOException
    {
        final int length;
        final byte[] result;

        _socket_.receive(receivePacket);

        result = new byte[length = receivePacket.getLength()];
        System.arraycopy(receiveData, 0, result, 0, length);

        return result;
    }","  public void test2()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      charGenUDPClient0.open();
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      byte[] byteArray0 = new byte[0];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, byteArray0);
      byte[] byteArray1 = charGenUDPClient0.receive();
}"
224,"    public void send(final InetAddress host, final int port) throws IOException
    {
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test3()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      // Undeclared exception!
      try { 
        charGenUDPClient0.send((InetAddress) null, 727);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.chargen.CharGenUDPClient"", e);
      }
  }"
225,"    public void send(final InetAddress host, final int port) throws IOException
    {
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test4()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        charGenUDPClient0.send(inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.chargen.CharGenUDPClient"", e);
      }
  }"
226,"    public byte[] receive() throws IOException
    {
        final int length;
        final byte[] result;

        _socket_.receive(receivePacket);

        result = new byte[length = receivePacket.getLength()];
        System.arraycopy(receiveData, 0, result, 0, length);

        return result;
    }","  public void test5()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      charGenUDPClient0.open(0);
      try { 
        charGenUDPClient0.receive();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
227,"    public void send(final InetAddress host, final int port) throws IOException
    {
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test6()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        charGenUDPClient0.send(inetAddress0, (-383));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-383
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
228,"    public void send(final InetAddress host, final int port) throws IOException
    {
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test7()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      charGenUDPClient0.open();
      InetAddress inetAddress0 = charGenUDPClient0.getLocalAddress();
      charGenUDPClient0.send(inetAddress0);
}"
229,"    public byte[] receive() throws IOException
    {
        final int length;
        final byte[] result;

        _socket_.receive(receivePacket);

        result = new byte[length = receivePacket.getLength()];
        System.arraycopy(receiveData, 0, result, 0, length);

        return result;
    }","  public void test8()  throws Throwable  {
      CharGenUDPClient charGenUDPClient0 = new CharGenUDPClient();
      // Undeclared exception!
      try { 
        charGenUDPClient0.receive();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.chargen.CharGenUDPClient"", e);
      }
  }"
230,"    public int getListenerCount()
    {
        return listeners.size();
    }","  public void test0()  throws Throwable  {
      ListenerList listenerList0 = new ListenerList();
      int int0 = listenerList0.getListenerCount();
}"
231,"    public int getListenerCount()
    {
        return listeners.size();
    }","  public void test1()  throws Throwable  {
      ListenerList listenerList0 = new ListenerList();
      DefaultEditorKit.InsertBreakAction defaultEditorKit_InsertBreakAction0 = new DefaultEditorKit.InsertBreakAction();
      listenerList0.removeListener(defaultEditorKit_InsertBreakAction0);
}"
232,"    public int getListenerCount()
    {
        return listeners.size();
    }","  public void test2()  throws Throwable  {
      ListenerList listenerList0 = new ListenerList();
      Action action0 = TransferHandler.getCopyAction();
      listenerList0.addListener(action0);
      int int0 = listenerList0.getListenerCount();
}"
233,"    public Iterator<EventListener> iterator() {
            return listeners.iterator();
    }","  public void test3()  throws Throwable  {
      ListenerList listenerList0 = new ListenerList();
      Iterator<EventListener> iterator0 = listenerList0.iterator();
}"
234,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        KeyManagerUtils.createClientKeyManager((KeyStore) null, ""%ABmGHIYo("", "",C"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.util.KeyManagerUtils$ClientKeyStore"", e);
      }
  }"
235,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        KeyManagerUtils.createClientKeyManager((String) null, (File) null, ""The filters must not be null"", ""[%?"", ""[%?"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
236,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        KeyManagerUtils.createClientKeyManager((File) null, ""Gutq"", ""Gutq"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
      }
  }"
237,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test3()  throws Throwable  {
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""U"");
      FileSystemHandling.appendStringToFile(evoSuiteFile0, ""SENSITIVE"");
      MockFile mockFile0 = new MockFile(""U"");
      try { 
        KeyManagerUtils.createClientKeyManager((File) mockFile0, ""U"", ""org.apache.commons.io.filefilter.AndFileFilter"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
      }
  }"
238,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test4()  throws Throwable  {
      MockFile mockFile0 = new MockFile((File) null, """");
      mockFile0.createNewFile();
      mockFile0.delete();
      try { 
        KeyManagerUtils.createClientKeyManager((File) mockFile0, """", """");
        fail(""Expecting exception: EOFException"");
      } catch(EOFException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.DataInputStream"", e);
      }
  }"
239,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test5()  throws Throwable  {
      URI uRI0 = MockURI.aFileURI;
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""/tmp/foo.bar"");
      FileSystemHandling.appendStringToFile(evoSuiteFile0, ""]{Y(+O7+_mKW2"");
      MockFile mockFile0 = new MockFile(uRI0);
      try { 
        KeyManagerUtils.createClientKeyManager((File) mockFile0, """");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
      }
  }"
240,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test6()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""org.apache.commons.net.util.KeyManagerUtils$X509KeyManager"");
      try { 
        KeyManagerUtils.createClientKeyManager((File) mockFile0, ""org.apache.commons.net.util.KeyManagerUtils$X509KeyManager"");
        fail(""Expecting exception: FileNotFoundException"");
      } catch(FileNotFoundException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
      }
  }"
241,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test7()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""Bpx\""MRK~k1sph"");
      File file0 = MockFile.createTempFile(""Bpx\""MRK~k1sph"", ""Bpx\""MRK~k1sph"", (File) mockFile0);
      try { 
        KeyManagerUtils.createClientKeyManager(file0, ""Bpx\""MRK~k1sph"");
        fail(""Expecting exception: EOFException"");
      } catch(EOFException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.DataInputStream"", e);
      }
  }"
242,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test8()  throws Throwable  {
      File file0 = MockFile.createTempFile(""]X_6L"", ""]X_6L"");
      try { 
        KeyManagerUtils.createClientKeyManager(""]X_6L"", file0, ""]X_6L"", ""Sensitive"", (String) null);
        fail(""Expecting exception: KeyStoreException"");
      } catch(KeyStoreException e) {
         //
         // ]X_6L not found
         //
         verifyException(""java.security.KeyStore"", e);
      }
  }"
243,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test9()  throws Throwable  {
      // Undeclared exception!
      try { 
        KeyManagerUtils.createClientKeyManager((KeyStore) null, (String) null, (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.util.KeyManagerUtils"", e);
      }
  }"
244,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test10()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""U"");
      try { 
        KeyManagerUtils.createClientKeyManager((File) mockFile0, ""U"", ""org.apache.commons.io.filefilter.AndFileFilter"");
        fail(""Expecting exception: FileNotFoundException"");
      } catch(FileNotFoundException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
      }
  }"
245,"    public static KeyManager createClientKeyManager(final KeyStore ks, final String keyAlias, final String keyPass)
        throws GeneralSecurityException
    {
        final ClientKeyStore cks = new ClientKeyStore(ks, keyAlias != null ? keyAlias : findAlias(ks), keyPass);
        return new X509KeyManager(cks);
    }","  public void test11()  throws Throwable  {
      // Undeclared exception!
      try { 
        KeyManagerUtils.createClientKeyManager((File) null, ""Ym=i+A@a(on8"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
      }
  }"
246,"    public static X509TrustManager getDefaultTrustManager(final KeyStore keyStore) throws GeneralSecurityException {
        final String defaultAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        final TrustManagerFactory instance = TrustManagerFactory.getInstance(defaultAlgorithm);
        instance.init(keyStore);
        return (X509TrustManager) instance.getTrustManagers()[0];
    }","  public void test0()  throws Throwable  {
      X509TrustManager x509TrustManager0 = TrustManagerUtils.getDefaultTrustManager((KeyStore) null);
}"
247,"    public static X509TrustManager getValidateServerCertificateTrustManager(){
        return CHECK_SERVER_VALIDITY;
    }","  public void test1()  throws Throwable  {
      X509TrustManager x509TrustManager0 = TrustManagerUtils.getValidateServerCertificateTrustManager();
}"
248,"    public static X509TrustManager getAcceptAllTrustManager(){
        return ACCEPT_ALL;
    }","  public void test2()  throws Throwable  {
      X509TrustManager x509TrustManager0 = TrustManagerUtils.getAcceptAllTrustManager();
}"
249,,"  public void test3()  throws Throwable  {
      TrustManagerUtils trustManagerUtils0 = new TrustManagerUtils();
  }"
250,"    public static Charset toCharset(final String charsetName) {
        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);
    }","  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        Charsets.toCharset((String) null, """");
        fail(""Expecting exception: IllegalCharsetNameException"");
      } catch(IllegalCharsetNameException e) {
         //
         // 
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
251,"    public static Charset toCharset(final String charsetName) {
        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);
    }","  public void test1()  throws Throwable  {
      Charset charset0 = Charsets.toCharset(""L4"", """");
}"
252,"    public static Charset toCharset(final String charsetName) {
        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        Charsets.toCharset(""org.apache.commons.net.util.Charsets"", (String) null);
        fail(""Expecting exception: UnsupportedCharsetException"");
      } catch(UnsupportedCharsetException e) {
         //
         // org.apache.commons.net.util.Charsets
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
253,"    public static Charset toCharset(final String charsetName) {
        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);
    }","  public void test3()  throws Throwable  {
      // Undeclared exception!
      try { 
        Charsets.toCharset(""Kl6"");
        fail(""Expecting exception: UnsupportedCharsetException"");
      } catch(UnsupportedCharsetException e) {
         //
         // Kl6
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
254,"    public static Charset toCharset(final String charsetName) {
        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);
    }","  public void test4()  throws Throwable  {
      // Undeclared exception!
      try { 
        Charsets.toCharset((String) null, (String) null);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Null charset name
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
255,"    public static Charset toCharset(final String charsetName) {
        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);
    }","  public void test5()  throws Throwable  {
      Charset charset0 = Charsets.toCharset((String) null);
}"
256,"    public static Charset toCharset(final String charsetName) {
        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);
    }","  public void test6()  throws Throwable  {
      // Undeclared exception!
      try { 
        Charsets.toCharset(""?ATy-93y\u00018_1"");
        fail(""Expecting exception: IllegalCharsetNameException"");
      } catch(IllegalCharsetNameException e) {
         //
         // ?ATy-93y\u00018_1
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
257,,"  public void test7()  throws Throwable  {
      Charsets charsets0 = new Charsets();
  }"
258,"    public static SSLContext createSSLContext(final String protocol, final KeyManager keyManager, final TrustManager trustManager)
            throws IOException {
        return createSSLContext(protocol,
                keyManager == null ? null : new KeyManager[] { keyManager },
                trustManager == null ? null : new TrustManager[] { trustManager });
    }","  public void test0()  throws Throwable  {
      KeyManager[] keyManagerArray0 = new KeyManager[3];
      TrustManager[] trustManagerArray0 = new TrustManager[2];
      // Undeclared exception!
      try { 
        SSLContextUtils.createSSLContext((String) null, keyManagerArray0, trustManagerArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.security.Provider$ServiceKey"", e);
      }
  }"
259,"    public static SSLContext createSSLContext(final String protocol, final KeyManager keyManager, final TrustManager trustManager)
            throws IOException {
        return createSSLContext(protocol,
                keyManager == null ? null : new KeyManager[] { keyManager },
                trustManager == null ? null : new TrustManager[] { trustManager });
    }","  public void test1()  throws Throwable  {
      ExtendedAliasKeyManager extendedAliasKeyManager0 = new ExtendedAliasKeyManager((KeyManager) null, (String) null);
      // Undeclared exception!
      try { 
        SSLContextUtils.createSSLContext((String) null, (KeyManager) extendedAliasKeyManager0, (TrustManager) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.security.Provider$ServiceKey"", e);
      }
  }"
260,"    public static SSLContext createSSLContext(final String protocol, final KeyManager keyManager, final TrustManager trustManager)
            throws IOException {
        return createSSLContext(protocol,
                keyManager == null ? null : new KeyManager[] { keyManager },
                trustManager == null ? null : new TrustManager[] { trustManager });
    }","  public void test2()  throws Throwable  {
      KeyManager[] keyManagerArray0 = new KeyManager[0];
      TrustManager[] trustManagerArray0 = new TrustManager[1];
      try { 
        SSLContextUtils.createSSLContext(""ZQs>OL:+Z"", keyManagerArray0, trustManagerArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not initialize SSL context
         //
         verifyException(""org.apache.commons.net.util.SSLContextUtils"", e);
      }
  }"
261,"    public static SSLContext createSSLContext(final String protocol, final KeyManager keyManager, final TrustManager trustManager)
            throws IOException {
        return createSSLContext(protocol,
                keyManager == null ? null : new KeyManager[] { keyManager },
                trustManager == null ? null : new TrustManager[] { trustManager });
    }","  public void test3()  throws Throwable  {
      TrustManager trustManager0 = mock(TrustManager.class, new ViolatedAssumptionAnswer());
      try { 
        SSLContextUtils.createSSLContext(""iLy!o{v ~J.Rh-"", (KeyManager) null, trustManager0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not initialize SSL context
         //
         verifyException(""org.apache.commons.net.util.SSLContextUtils"", e);
      }
  }"
262,"    public SubnetUtils(final String cidrNotation) {
      final Matcher matcher = cidrPattern.matcher(cidrNotation);

      if (matcher.matches()) {
          this.address = matchAddress(matcher);

          /* Create a binary netmask from the number of bits specification /x */

          final int trailingZeroes = NBITS - rangeCheck(Integer.parseInt(matcher.group(5)), 0, NBITS);
          /*
           * An IPv4 netmask consists of 32 bits, a contiguous sequence
           * of the specified number of ones followed by all zeros.
           * So, it can be obtained by shifting an unsigned integer (32 bits) to the left by
           * the number of trailing zeros which is (32 - the # bits specification).
           * Note that there is no unsigned left shift operator, so we have to use
           * a long to ensure that the left-most bit is shifted out correctly.
           */
          this.netmask = (int) (0x0FFFFFFFFL << trailingZeroes );

          /* Calculate base network address */
          this.network = address & netmask;

          /* Calculate broadcast address */
          this.broadcast = network | ~netmask;
      } else {
          throw new IllegalArgumentException(String.format(PARSE_FAIL, cidrNotation));
      }
    }","  public void test0()  throws Throwable  {
      SubnetUtils subnetUtils0 = null;
      try {
        subnetUtils0 = new SubnetUtils((String) null, ""qUhzi?"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
263,"    public SubnetUtils(final String cidrNotation) {
      final Matcher matcher = cidrPattern.matcher(cidrNotation);

      if (matcher.matches()) {
          this.address = matchAddress(matcher);

          /* Create a binary netmask from the number of bits specification /x */

          final int trailingZeroes = NBITS - rangeCheck(Integer.parseInt(matcher.group(5)), 0, NBITS);
          /*
           * An IPv4 netmask consists of 32 bits, a contiguous sequence
           * of the specified number of ones followed by all zeros.
           * So, it can be obtained by shifting an unsigned integer (32 bits) to the left by
           * the number of trailing zeros which is (32 - the # bits specification).
           * Note that there is no unsigned left shift operator, so we have to use
           * a long to ensure that the left-most bit is shifted out correctly.
           */
          this.netmask = (int) (0x0FFFFFFFFL << trailingZeroes );

          /* Calculate base network address */
          this.network = address & netmask;

          /* Calculate broadcast address */
          this.broadcast = network | ~netmask;
      } else {
          throw new IllegalArgumentException(String.format(PARSE_FAIL, cidrNotation));
      }
    }","  public void test1()  throws Throwable  {
      SubnetUtils subnetUtils0 = null;
      try {
        subnetUtils0 = new SubnetUtils((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
264,"    public SubnetUtils(final String cidrNotation) {
      final Matcher matcher = cidrPattern.matcher(cidrNotation);

      if (matcher.matches()) {
          this.address = matchAddress(matcher);

          /* Create a binary netmask from the number of bits specification /x */

          final int trailingZeroes = NBITS - rangeCheck(Integer.parseInt(matcher.group(5)), 0, NBITS);
          /*
           * An IPv4 netmask consists of 32 bits, a contiguous sequence
           * of the specified number of ones followed by all zeros.
           * So, it can be obtained by shifting an unsigned integer (32 bits) to the left by
           * the number of trailing zeros which is (32 - the # bits specification).
           * Note that there is no unsigned left shift operator, so we have to use
           * a long to ensure that the left-most bit is shifted out correctly.
           */
          this.netmask = (int) (0x0FFFFFFFFL << trailingZeroes );

          /* Calculate base network address */
          this.network = address & netmask;

          /* Calculate broadcast address */
          this.broadcast = network | ~netmask;
      } else {
          throw new IllegalArgumentException(String.format(PARSE_FAIL, cidrNotation));
      }
    }","  public void test2()  throws Throwable  {
      SubnetUtils subnetUtils0 = null;
      try {
        subnetUtils0 = new SubnetUtils("""", ""RBG OdbCzP@3O@3"");
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Could not parse []
         //
         verifyException(""org.apache.commons.net.util.SubnetUtils"", e);
      }
  }"
265,"    public SubnetUtils(final String cidrNotation) {
      final Matcher matcher = cidrPattern.matcher(cidrNotation);

      if (matcher.matches()) {
          this.address = matchAddress(matcher);

          /* Create a binary netmask from the number of bits specification /x */

          final int trailingZeroes = NBITS - rangeCheck(Integer.parseInt(matcher.group(5)), 0, NBITS);
          /*
           * An IPv4 netmask consists of 32 bits, a contiguous sequence
           * of the specified number of ones followed by all zeros.
           * So, it can be obtained by shifting an unsigned integer (32 bits) to the left by
           * the number of trailing zeros which is (32 - the # bits specification).
           * Note that there is no unsigned left shift operator, so we have to use
           * a long to ensure that the left-most bit is shifted out correctly.
           */
          this.netmask = (int) (0x0FFFFFFFFL << trailingZeroes );

          /* Calculate base network address */
          this.network = address & netmask;

          /* Calculate broadcast address */
          this.broadcast = network | ~netmask;
      } else {
          throw new IllegalArgumentException(String.format(PARSE_FAIL, cidrNotation));
      }
    }","  public void test3()  throws Throwable  {
      SubnetUtils subnetUtils0 = null;
      try {
        subnetUtils0 = new SubnetUtils("""");
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Could not parse []
         //
         verifyException(""org.apache.commons.net.util.SubnetUtils"", e);
      }
  }"
266,"    public static boolean enableEndpointNameVerification(final SSLSocket socket) {
        try {
            final Class<?> cls = Class.forName(""javax.net.ssl.SSLParameters"");
            final Method setEndpointIdentificationAlgorithm = cls
                .getDeclaredMethod(""setEndpointIdentificationAlgorithm"", String.class);
            final Method getSSLParameters = SSLSocket.class.getDeclaredMethod(""getSSLParameters"");
            final Method setSSLParameters = SSLSocket.class.getDeclaredMethod(""setSSLParameters"", cls);
            if (setEndpointIdentificationAlgorithm != null && getSSLParameters != null && setSSLParameters != null) {
                final Object sslParams = getSSLParameters.invoke(socket);
                if (sslParams != null) {
                    setEndpointIdentificationAlgorithm.invoke(sslParams, ""HTTPS"");
                    setSSLParameters.invoke(socket, sslParams);
                    return true;
                }
            }
        } catch (final SecurityException | ClassNotFoundException | NoSuchMethodException | IllegalArgumentException |
            IllegalAccessException | InvocationTargetException e) { // Ignored
        }
        return false;
    }","  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        SSLSocketUtils.enableEndpointNameVerification((SSLSocket) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
267,"    public static boolean enableEndpointNameVerification(final SSLSocket socket) {
        try {
            final Class<?> cls = Class.forName(""javax.net.ssl.SSLParameters"");
            final Method setEndpointIdentificationAlgorithm = cls
                .getDeclaredMethod(""setEndpointIdentificationAlgorithm"", String.class);
            final Method getSSLParameters = SSLSocket.class.getDeclaredMethod(""getSSLParameters"");
            final Method setSSLParameters = SSLSocket.class.getDeclaredMethod(""setSSLParameters"", cls);
            if (setEndpointIdentificationAlgorithm != null && getSSLParameters != null && setSSLParameters != null) {
                final Object sslParams = getSSLParameters.invoke(socket);
                if (sslParams != null) {
                    setEndpointIdentificationAlgorithm.invoke(sslParams, ""HTTPS"");
                    setSSLParameters.invoke(socket, sslParams);
                    return true;
                }
            }
        } catch (final SecurityException | ClassNotFoundException | NoSuchMethodException | IllegalArgumentException |
            IllegalAccessException | InvocationTargetException e) { // Ignored
        }
        return false;
    }","  public void test1()  throws Throwable  {
      SSLSocket sSLSocket0 = mock(SSLSocket.class, new ViolatedAssumptionAnswer());
      doReturn((SSLParameters) null).when(sSLSocket0).getSSLParameters();
      boolean boolean0 = SSLSocketUtils.enableEndpointNameVerification(sSLSocket0);
}"
268,"    public static boolean enableEndpointNameVerification(final SSLSocket socket) {
        try {
            final Class<?> cls = Class.forName(""javax.net.ssl.SSLParameters"");
            final Method setEndpointIdentificationAlgorithm = cls
                .getDeclaredMethod(""setEndpointIdentificationAlgorithm"", String.class);
            final Method getSSLParameters = SSLSocket.class.getDeclaredMethod(""getSSLParameters"");
            final Method setSSLParameters = SSLSocket.class.getDeclaredMethod(""setSSLParameters"", cls);
            if (setEndpointIdentificationAlgorithm != null && getSSLParameters != null && setSSLParameters != null) {
                final Object sslParams = getSSLParameters.invoke(socket);
                if (sslParams != null) {
                    setEndpointIdentificationAlgorithm.invoke(sslParams, ""HTTPS"");
                    setSSLParameters.invoke(socket, sslParams);
                    return true;
                }
            }
        } catch (final SecurityException | ClassNotFoundException | NoSuchMethodException | IllegalArgumentException |
            IllegalAccessException | InvocationTargetException e) { // Ignored
        }
        return false;
    }","  public void test2()  throws Throwable  {
      SSLParameters sSLParameters0 = mock(SSLParameters.class, new ViolatedAssumptionAnswer());
      SSLSocket sSLSocket0 = mock(SSLSocket.class, new ViolatedAssumptionAnswer());
      doReturn(sSLParameters0).when(sSLSocket0).getSSLParameters();
      boolean boolean0 = SSLSocketUtils.enableEndpointNameVerification(sSLSocket0);
}"
269,"    public String encodeToString(final byte[] pArray) {
        return newStringUtf8(encode(pArray));
    }","  public void test0()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      Base64 base64_0 = new Base64(6, byteArray0, true);
      String string0 = base64_0.encodeToString(byteArray0);
}"
270,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test1()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      Base64 base64_0 = new Base64(6, byteArray0, true);
      String string0 = base64_0.encodeToString(byteArray0);
}"
271,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test2()  throws Throwable  {
      Base64 base64_0 = new Base64(false);
      byte[] byteArray0 = new byte[4];
      base64_0.decode(byteArray0, (-1229), (int) (byte)0);
}"
272,"    public static byte[] encodeBase64Chunked(final byte[] binaryData) {
        return encodeBase64(binaryData, true);
    }","  public void test3()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-40);
      byte[] byteArray1 = Base64.encodeBase64Chunked(byteArray0);
}"
273,"    public static byte[] encodeBase64Chunked(final byte[] binaryData) {
        return encodeBase64(binaryData, true);
    }","  public void test4()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-40);
      byte[] byteArray1 = Base64.encodeBase64Chunked(byteArray0);
}"
274,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test5()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      Base64 base64_0 = new Base64(0, byteArray0, true);
      base64_0.encode(byteArray0, 0, 0);
}"
275,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test6()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = Base64.decodeBase64(""h@!m&2AFUJA{"");
      base64_0.setInitialBuffer(byteArray0, 0, 0);
}"
276,"    void setInitialBuffer(final byte[] out, final int outPos, final int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }","  public void test7()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = Base64.decodeBase64(""h@!m&2AFUJA{"");
      base64_0.setInitialBuffer(byteArray0, 0, 0);
}"
277,"    void setInitialBuffer(final byte[] out, final int outPos, final int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }","  public void test8()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = Base64.decodeBase64(""h@!m&2AFUJA{"");
      base64_0.setInitialBuffer(byteArray0, 0, 0);
}"
278,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test9()  throws Throwable  {
      byte[] byteArray0 = new byte[6];
      Base64 base64_0 = new Base64();
      base64_0.encode(byteArray0, (int) (byte) (-75), (-879));
      int int0 = base64_0.readResults(byteArray0, 0, 168);
}"
279,"    static byte[] toIntegerBytes(final BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        final byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        final byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }","  public void test10()  throws Throwable  {
      BigInteger bigInteger0 = BigInteger.ONE;
      byte[] byteArray0 = Base64.toIntegerBytes(bigInteger0);
}"
280,"    static byte[] toIntegerBytes(final BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        final byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        final byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }","  public void test11()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      BigInteger bigInteger0 = Base64.decodeInteger(byteArray0);
      byte[] byteArray1 = Base64.toIntegerBytes(bigInteger0);
}"
281,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test12()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[2];
      byte[] byteArray1 = base64_0.encode(byteArray0);
      int int0 = base64_0.readResults(byteArray1, (byte)41, (byte)41);
}"
282,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test13()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[2];
      byte[] byteArray1 = base64_0.encode(byteArray0);
      int int0 = base64_0.readResults(byteArray1, (byte)41, (byte)41);
}"
283,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test14()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[2];
      byte[] byteArray1 = base64_0.encode(byteArray0);
      int int0 = base64_0.readResults(byteArray1, (byte)41, (byte)41);
}"
284,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test15()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      Base64 base64_0 = new Base64(0, byteArray0, true);
      base64_0.getLineSeparator();
}"
285,"    int getLineLength() {
        return lineLength;
    }","  public void test16()  throws Throwable  {
      Base64 base64_0 = new Base64();
      int int0 = base64_0.getLineLength();
}"
286,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test17()  throws Throwable  {
      Base64 base64_0 = new Base64();
      int int0 = base64_0.getLineLength();
}"
287,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test18()  throws Throwable  {
      Base64 base64_0 = new Base64((-3035));
      byte[] byteArray0 = new byte[0];
      base64_0.encodeToString(byteArray0);
}"
288,"    public static String encodeBase64URLSafeString(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, false, true));
    }","  public void test19()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      String string0 = Base64.encodeBase64URLSafeString(byteArray0);
}"
289,"    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {
        return encodeBase64(binaryData, false, true);
    }","  public void test20()  throws Throwable  {
      byte[] byteArray0 = Base64.encodeBase64URLSafe((byte[]) null);
}"
290,"    public static String encodeBase64StringUnChunked(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, false));
    }","  public void test21()  throws Throwable  {
      byte[] byteArray0 = Base64.decodeBase64(""]"");
      String string0 = Base64.encodeBase64StringUnChunked(byteArray0);
}"
291,"    public static String encodeBase64String(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, true));
    }","  public void test22()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      byte[] byteArray1 = Base64.decodeBase64(byteArray0);
      String string0 = Base64.encodeBase64String(byteArray1, true);
}"
292,"    public static String encodeBase64String(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, true));
    }","  public void test23()  throws Throwable  {
      byte[] byteArray0 = new byte[2];
      String string0 = Base64.encodeBase64String(byteArray0);
}"
293,"    public static byte[] encodeBase64Chunked(final byte[] binaryData) {
        return encodeBase64(binaryData, true);
    }","  public void test24()  throws Throwable  {
      byte[] byteArray0 = Base64.encodeBase64Chunked((byte[]) null);
}"
294,"    public static byte[] encodeBase64Chunked(final byte[] binaryData) {
        return encodeBase64(binaryData, true);
    }","  public void test25()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      byte[] byteArray1 = Base64.encodeBase64Chunked(byteArray0);
}"
295,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test26()  throws Throwable  {
      byte[] byteArray0 = Base64.encodeBase64((byte[]) null, true, false);
}"
296,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test27()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0, false, false);
}"
297,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test28()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0, false, false);
}"
298,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test29()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0, true);
}"
299,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test30()  throws Throwable  {
      byte[] byteArray0 = Base64.encodeBase64((byte[]) null);
}"
300,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test31()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0);
}"
301,"    public static BigInteger decodeInteger(final byte[] pArray) {
        return new BigInteger(1, decodeBase64(pArray));
    }","  public void test32()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[2] = (byte) (-39);
      Base64 base64_0 = new Base64(0);
      byte[] byteArray1 = base64_0.encode(byteArray0);
      BigInteger bigInteger0 = Base64.decodeInteger(byteArray1);
}"
302,"    public static BigInteger decodeInteger(final byte[] pArray) {
        return new BigInteger(1, decodeBase64(pArray));
    }","  public void test33()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[2] = (byte) (-39);
      Base64 base64_0 = new Base64(0);
      byte[] byteArray1 = base64_0.encode(byteArray0);
      BigInteger bigInteger0 = Base64.decodeInteger(byteArray1);
}"
303,"    public static BigInteger decodeInteger(final byte[] pArray) {
        return new BigInteger(1, decodeBase64(pArray));
    }","  public void test34()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)81;
      byte[] byteArray1 = Base64.encodeBase64(byteArray0);
      BigInteger bigInteger0 = Base64.decodeInteger(byteArray1);
}"
304,"    public static BigInteger decodeInteger(final byte[] pArray) {
        return new BigInteger(1, decodeBase64(pArray));
    }","  public void test35()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)81;
      byte[] byteArray1 = Base64.encodeBase64(byteArray0);
      BigInteger bigInteger0 = Base64.decodeInteger(byteArray1);
}"
305,"    static byte[] toIntegerBytes(final BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        final byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        final byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }","  public void test36()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[2] = (byte)103;
      byteArray0[4] = (byte)50;
      BigInteger bigInteger0 = Base64.decodeInteger(byteArray0);
      byte[] byteArray1 = Base64.toIntegerBytes(bigInteger0);
}"
306,"    public static byte[] decodeBase64(final String base64String) {
        return new Base64().decode(base64String);
    }","  public void test37()  throws Throwable  {
      byte[] byteArray0 = Base64.decodeBase64((byte[]) null);
}"
307,"    public static byte[] decodeBase64(final String base64String) {
        return new Base64().decode(base64String);
    }","  public void test38()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      byte[] byteArray1 = Base64.encodeBase64URLSafe(byteArray0);
      byte[] byteArray2 = Base64.decodeBase64(byteArray1);
}"
308,"    public static byte[] decodeBase64(final String base64String) {
        return new Base64().decode(base64String);
    }","  public void test39()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      byte[] byteArray1 = Base64.encodeBase64URLSafe(byteArray0);
      byte[] byteArray2 = Base64.decodeBase64(byteArray1);
}"
309,"    public static byte[] decodeBase64(final String base64String) {
        return new Base64().decode(base64String);
    }","  public void test40()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      byte[] byteArray1 = Base64.encodeBase64URLSafe(byteArray0);
      byte[] byteArray2 = Base64.decodeBase64(byteArray1);
}"
310,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test41()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[4];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0);
      byte[] byteArray2 = base64_0.decode(byteArray1);
}"
311,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test42()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[4];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0);
      byte[] byteArray2 = base64_0.decode(byteArray1);
}"
312,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test43()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[4];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0);
      byte[] byteArray2 = base64_0.decode(byteArray1);
}"
313,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test44()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[4];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0);
      byte[] byteArray2 = base64_0.decode(byteArray1);
}"
314,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test45()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[4];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0);
      byte[] byteArray2 = base64_0.decode(byteArray1);
}"
315,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test46()  throws Throwable  {
      Base64 base64_0 = new Base64();
      base64_0.decode("""");
}"
316,"    static byte[] toIntegerBytes(final BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        final byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        final byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }","  public void test47()  throws Throwable  {
      // Undeclared exception!
      try { 
        Base64.toIntegerBytes((BigInteger) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
317,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test48()  throws Throwable  {
      Base64 base64_0 = new Base64(false);
      byte[] byteArray0 = new byte[8];
      base64_0.encode(byteArray0);
      // Undeclared exception!
      try { 
        base64_0.readResults((byte[]) null, 1540, (-1));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
318,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test49()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      Base64 base64_0 = new Base64();
      base64_0.encodeToString(byteArray0);
      // Undeclared exception!
      try { 
        base64_0.readResults(byteArray0, 2267, (byte) (-78));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
      }
  }"
319,"    public static boolean isArrayByteBase64(final byte[] arrayOctet) {
        for (final byte element : arrayOctet) {
            if (!isBase64(element) && !isWhiteSpace(element)) {
                return false;
            }
        }
        return true;
    }","  public void test50()  throws Throwable  {
      // Undeclared exception!
      try { 
        Base64.isArrayByteBase64((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
320,"    public static String encodeBase64URLSafeString(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, false, true));
    }","  public void test51()  throws Throwable  {
      // Undeclared exception!
      try { 
        Base64.encodeBase64URLSafeString((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
321,"    public static String encodeBase64StringUnChunked(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, false));
    }","  public void test52()  throws Throwable  {
      // Undeclared exception!
      try { 
        Base64.encodeBase64StringUnChunked((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
322,"    public static String encodeBase64String(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, true));
    }","  public void test53()  throws Throwable  {
      // Undeclared exception!
      try { 
        Base64.encodeBase64String((byte[]) null, true);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
323,"    public static String encodeBase64String(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, true));
    }","  public void test54()  throws Throwable  {
      // Undeclared exception!
      try { 
        Base64.encodeBase64String((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
324,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test55()  throws Throwable  {
      Base64 base64_0 = new Base64(383);
      // Undeclared exception!
      try { 
        base64_0.encode((byte[]) null, 383, 81);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
325,"    public static BigInteger decodeInteger(final byte[] pArray) {
        return new BigInteger(1, decodeBase64(pArray));
    }","  public void test56()  throws Throwable  {
      // Undeclared exception!
      try { 
        Base64.decodeInteger((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
326,"    public static byte[] decodeBase64(final String base64String) {
        return new Base64().decode(base64String);
    }","  public void test57()  throws Throwable  {
      // Undeclared exception!
      try { 
        Base64.decodeBase64((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
327,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test58()  throws Throwable  {
      Base64 base64_0 = new Base64();
      // Undeclared exception!
      try { 
        base64_0.decode((byte[]) null, 1, 1297);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
328,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test59()  throws Throwable  {
      Base64 base64_0 = new Base64(4);
      // Undeclared exception!
      try { 
        base64_0.decode((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
329,"    public Base64() {
        this(false);
    }","  public void test60()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      byteArray0[1] = (byte)81;
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64((-1), byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [\u0000Q\u0000\u0000\u0000\u0000\u0000\u0000]
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
330,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test61()  throws Throwable  {
      Base64 base64_0 = new Base64(true);
      byte[] byteArray0 = new byte[1];
      byte[] byteArray1 = base64_0.encode(byteArray0);
}"
331,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test62()  throws Throwable  {
      Base64 base64_0 = new Base64(true);
      byte[] byteArray0 = new byte[1];
      byte[] byteArray1 = base64_0.encode(byteArray0);
}"
332,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test63()  throws Throwable  {
      Base64 base64_0 = new Base64(0, (byte[]) null);
      base64_0.encode((byte[]) null);
}"
333,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test64()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0, true, true, 73);
}"
334,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test65()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0, true, true, 73);
}"
335,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test66()  throws Throwable  {
      Base64 base64_0 = new Base64(4);
      byte[] byteArray0 = base64_0.getLineSeparator();
      byte[] byteArray1 = Base64.encodeBase64(byteArray0, false, false, 4);
}"
336,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test67()  throws Throwable  {
      byte[] byteArray0 = new byte[2];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, false, false, (int) (byte) (-43));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Input array too big, the output array would be bigger (4) than the specified maxium size of -43
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
337,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test68()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      byte[] byteArray1 = Base64.decodeBase64(byteArray0);
      byte[] byteArray2 = Base64.encodeBase64(byteArray1, true, false, (-2059));
}"
338,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test69()  throws Throwable  {
      byte[] byteArray0 = Base64.encodeBase64((byte[]) null, false, true, 14);
}"
339,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test70()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[0];
      byte[] byteArray1 = base64_0.decode(byteArray0);
}"
340,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test71()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[0];
      byte[] byteArray1 = base64_0.decode(byteArray0);
}"
341,"    public static boolean isBase64(final byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }","  public void test72()  throws Throwable  {
      boolean boolean0 = Base64.isBase64((byte)61);
}"
342,"    public static boolean isBase64(final byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }","  public void test73()  throws Throwable  {
      boolean boolean0 = Base64.isBase64((byte)123);
}"
343,"    public static boolean isBase64(final byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }","  public void test74()  throws Throwable  {
      boolean boolean0 = Base64.isBase64((byte)105);
}"
344,"    public static boolean isBase64(final byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }","  public void test75()  throws Throwable  {
      boolean boolean0 = Base64.isBase64((byte)0);
}"
345,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test76()  throws Throwable  {
      byte[] byteArray0 = new byte[14];
      Base64 base64_0 = new Base64();
      base64_0.encode(byteArray0, (int) (byte)0, (int) (byte)1);
      base64_0.decode(byteArray0, (int) (byte)0, (-2161));
}"
346,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test77()  throws Throwable  {
      Base64 base64_0 = new Base64(493);
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)101;
      // Undeclared exception!
      try { 
        base64_0.decode(byteArray0, 0, 1551);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 4
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
347,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test78()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)124;
      Base64 base64_0 = new Base64((-41), byteArray0);
      // Undeclared exception!
      try { 
        base64_0.decode(byteArray0, 0, 766);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
348,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test79()  throws Throwable  {
      Base64 base64_0 = new Base64(493);
      byte[] byteArray0 = new byte[4];
      byteArray0[1] = (byte) (-41);
      // Undeclared exception!
      try { 
        base64_0.decode(byteArray0, 0, 1551);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 4
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
349,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test80()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      byteArray0[2] = (byte)61;
      Base64 base64_0 = new Base64();
      base64_0.decode(byteArray0, (int) (byte)0, (int) (byte)61);
}"
350,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test81()  throws Throwable  {
      Base64 base64_0 = new Base64(false);
      byte[] byteArray0 = new byte[1];
      base64_0.setInitialBuffer(byteArray0, 1, (short)1);
      // Undeclared exception!
      try { 
        base64_0.decode(byteArray0, (int) (byte)58, (int) (byte)58);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 58
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
351,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test82()  throws Throwable  {
      Base64 base64_0 = new Base64(6);
      byte[] byteArray0 = new byte[3];
      base64_0.encode(byteArray0, 58, (-1196));
      base64_0.decode(byteArray0, (int) (byte)0, 3);
}"
352,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test83()  throws Throwable  {
      byte[] byteArray0 = new byte[36];
      Base64 base64_0 = new Base64(8, byteArray0, false);
      base64_0.encode(byteArray0, (int) (byte)0, 8);
      base64_0.decode(byteArray0, (int) (byte)0, (-1171));
}"
353,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test84()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      Base64 base64_0 = new Base64(0, byteArray0, false);
      // Undeclared exception!
      try { 
        base64_0.encode(byteArray0, (int) (byte)0, 459);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
354,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test85()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[8];
      byteArray0[7] = (byte) (-104);
      // Undeclared exception!
      try { 
        base64_0.encode(byteArray0, (int) (byte)1, (int) (byte)115);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
355,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test86()  throws Throwable  {
      byte[] byteArray0 = new byte[11];
      Base64 base64_0 = new Base64(true);
      base64_0.encode(byteArray0, (int) (byte)0, (int) (byte)8);
      base64_0.encode(byteArray0, (int) (byte) (-78), (int) (byte) (-78));
}"
356,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test87()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      Base64 base64_0 = new Base64();
      base64_0.encode(byteArray0, (int) (byte)1, (int) (byte)1);
      base64_0.encode(byteArray0, (int) (byte)0, (int) (byte) (-78));
}"
357,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test88()  throws Throwable  {
      byte[] byteArray0 = new byte[36];
      Base64 base64_0 = new Base64();
      base64_0.encode(byteArray0, (int) (byte)0, 23);
      base64_0.encode(byteArray0, (int) (byte)0, (-108));
}"
358,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test89()  throws Throwable  {
      byte[] byteArray0 = new byte[36];
      Base64 base64_0 = new Base64();
      byte[] byteArray1 = new byte[0];
      base64_0.setInitialBuffer(byteArray1, 3884, (byte)0);
      // Undeclared exception!
      try { 
        base64_0.encode(byteArray0, (int) (byte)0, (-108));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
359,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test90()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      Base64 base64_0 = new Base64(0, byteArray0, true);
      boolean boolean0 = base64_0.isUrlSafe();
}"
360,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test91()  throws Throwable  {
      Base64 base64_0 = new Base64();
      boolean boolean0 = base64_0.isUrlSafe();
}"
361,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test92()  throws Throwable  {
      byte[] byteArray0 = new byte[21];
      Base64 base64_0 = new Base64(0, byteArray0, false);
      byte[] byteArray1 = Base64.encodeBase64URLSafe(byteArray0);
      // Undeclared exception!
      try { 
        base64_0.decode(byteArray1, 0, 459);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 28
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
362,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test93()  throws Throwable  {
      Base64 base64_0 = new Base64(75, (byte[]) null, true);
}"
363,"    public static byte[] encodeInteger(final BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }","  public void test94()  throws Throwable  {
      BigInteger bigInteger0 = BigInteger.TEN;
      byte[] byteArray0 = Base64.encodeInteger(bigInteger0);
}"
364,"    public static byte[] encodeInteger(final BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }","  public void test95()  throws Throwable  {
      BigInteger bigInteger0 = BigInteger.TEN;
      byte[] byteArray0 = Base64.encodeInteger(bigInteger0);
}"
365,"    public static byte[] encodeInteger(final BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }","  public void test96()  throws Throwable  {
      // Undeclared exception!
      try { 
        Base64.encodeInteger((BigInteger) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // encodeInteger called with null parameter
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
366,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test97()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[0];
      base64_0.encode(byteArray0);
}"
367,"    public String encodeToString(final byte[] pArray) {
        return newStringUtf8(encode(pArray));
    }","  public void test98()  throws Throwable  {
      Base64 base64_0 = new Base64(0);
      // Undeclared exception!
      try { 
        base64_0.encodeToString((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
368,"    public static boolean isArrayByteBase64(final byte[] arrayOctet) {
        for (final byte element : arrayOctet) {
            if (!isBase64(element) && !isWhiteSpace(element)) {
                return false;
            }
        }
        return true;
    }","  public void test99()  throws Throwable  {
      byte[] byteArray0 = new byte[6];
      byteArray0[0] = (byte)32;
      boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
}"
369,"    public static boolean isArrayByteBase64(final byte[] arrayOctet) {
        for (final byte element : arrayOctet) {
            if (!isBase64(element) && !isWhiteSpace(element)) {
                return false;
            }
        }
        return true;
    }","  public void test100()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)9;
      boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
}"
370,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test101()  throws Throwable  {
      byte[] byteArray0 = Base64.encodeBase64((byte[]) null, false);
}"
371,"    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {
        return encodeBase64(binaryData, false, true);
    }","  public void test102()  throws Throwable  {
      byte[] byteArray0 = Base64.decodeBase64("""");
      byte[] byteArray1 = Base64.encodeBase64URLSafe(byteArray0);
}"
372,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test103()  throws Throwable  {
      Base64 base64_0 = new Base64(false);
      base64_0.decode((byte[]) null);
}"
373,"    public static boolean isBase64(final byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }","  public void test104()  throws Throwable  {
      boolean boolean0 = Base64.isBase64((byte) (-92));
}"
374,"    public static boolean isArrayByteBase64(final byte[] arrayOctet) {
        for (final byte element : arrayOctet) {
            if (!isBase64(element) && !isWhiteSpace(element)) {
                return false;
            }
        }
        return true;
    }","  public void test105()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      Base64 base64_0 = new Base64();
      byte[] byteArray1 = base64_0.encode(byteArray0);
      boolean boolean0 = Base64.isArrayByteBase64(byteArray1);
}"
375,"    public static boolean isArrayByteBase64(final byte[] arrayOctet) {
        for (final byte element : arrayOctet) {
            if (!isBase64(element) && !isWhiteSpace(element)) {
                return false;
            }
        }
        return true;
    }","  public void test106()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      Base64 base64_0 = new Base64();
      byte[] byteArray1 = base64_0.encode(byteArray0);
      boolean boolean0 = Base64.isArrayByteBase64(byteArray1);
}"
376,"    void decode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            final byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            }
            if (b >= 0 && b < DECODE_TABLE.length) {
                final int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
                default:
                    break;  // other values ignored
            }
        }
    }","  public void test107()  throws Throwable  {
      Base64 base64_0 = new Base64(false);
      byte[] byteArray0 = base64_0.decode(""*GKrcDvL1Mf0Vj|VT/"");
}"
377,"    public static byte[] decodeBase64(final String base64String) {
        return new Base64().decode(base64String);
    }","  public void test108()  throws Throwable  {
      byte[] byteArray0 = Base64.decodeBase64(""AAAAAAAAAAEAAAA=\r\n"");
}"
378,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test109()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      BigInteger bigInteger0 = BigInteger.ZERO;
      byte[] byteArray1 = Base64.encodeInteger(bigInteger0);
      Base64 base64_0 = new Base64(true);
      base64_0.setInitialBuffer(byteArray1, (byte)6, 0);
      // Undeclared exception!
      try { 
        base64_0.encode(byteArray0, (-1), 2);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
379,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test110()  throws Throwable  {
      byte[] byteArray0 = new byte[11];
      Base64 base64_0 = new Base64(true);
      base64_0.encode(byteArray0, (int) (byte)0, (int) (byte)1);
      base64_0.encode(byteArray0, (int) (byte) (-109), (int) (byte) (-109));
}"
380,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test111()  throws Throwable  {
      Base64 base64_0 = new Base64(true);
      byte[] byteArray0 = new byte[9];
      byte[] byteArray1 = base64_0.encode(byteArray0);
      base64_0.encode(byteArray0, (int) (byte)3, 1366);
}"
381,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test112()  throws Throwable  {
      Base64 base64_0 = new Base64(true);
      byte[] byteArray0 = new byte[9];
      base64_0.setInitialBuffer(byteArray0, (byte)89, 1346);
}"
382,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test113()  throws Throwable  {
      Base64 base64_0 = new Base64(14, (byte[]) null);
      base64_0.setInitialBuffer((byte[]) null, 685, (-1));
}"
383,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test114()  throws Throwable  {
      Base64 base64_0 = new Base64(false);
      byte[] byteArray0 = new byte[8];
      byte[] byteArray1 = base64_0.encode(byteArray0);
      int int0 = base64_0.readResults(byteArray1, 0, (-476));
}"
384,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test115()  throws Throwable  {
      Base64 base64_0 = new Base64(false);
      byte[] byteArray0 = new byte[8];
      byte[] byteArray1 = base64_0.encode(byteArray0);
      int int0 = base64_0.readResults(byteArray1, 0, (-476));
}"
385,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test116()  throws Throwable  {
      Base64 base64_0 = new Base64(false);
      byte[] byteArray0 = new byte[8];
      byte[] byteArray1 = base64_0.encode(byteArray0);
      int int0 = base64_0.readResults(byteArray1, 0, (-476));
      int int1 = base64_0.readResults((byte[]) null, 1540, (-1));
}"
386,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test117()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[2];
      int int0 = base64_0.readResults(byteArray0, 1, (byte)1);
}"
387,"    int readResults(final byte[] b, final int bPos, final int bAvail) {
        if (buffer != null) {
            final int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }","  public void test118()  throws Throwable  {
      Base64 base64_0 = new Base64();
      byte[] byteArray0 = new byte[2];
      int int0 = base64_0.readResults(byteArray0, 1, (byte)1);
}"
388,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test119()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      Base64 base64_0 = new Base64((-234), byteArray0, true);
      base64_0.encode(byteArray0, (-2549), (-2549));
}"
389,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test120()  throws Throwable  {
      Base64 base64_0 = new Base64();
      int int0 = base64_0.avail();
}"
390,"    int avail() {
        return buffer != null ? pos - readPos : 0;
    }","  public void test121()  throws Throwable  {
      Base64 base64_0 = new Base64();
      int int0 = base64_0.avail();
}"
391,"    void encode(final byte[] in, int inPos, final int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
                default:
                    break;  // other values ignored
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","  public void test122()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      Base64 base64_0 = new Base64();
      byte[] byteArray1 = base64_0.encode(byteArray0);
}"
392,"    boolean hasData() {
        return this.buffer != null;
    }","  public void test123()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      Base64 base64_0 = new Base64();
      byte[] byteArray1 = base64_0.encode(byteArray0);
      boolean boolean0 = base64_0.hasData();
}"
393,"    boolean hasData() {
        return this.buffer != null;
    }","  public void test124()  throws Throwable  {
      Base64 base64_0 = new Base64();
      boolean boolean0 = base64_0.hasData();
}"
394,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test125()  throws Throwable  {
      Base64 base64_0 = new Base64();
      boolean boolean0 = base64_0.hasData();
}"
395,"    public Base64() {
        this(false);
    }","  public void test126()  throws Throwable  {
      byte[] byteArray0 = Base64.decodeBase64(""X2*fK4"");
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64((-3998), byteArray0, false);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [_g\uFFFD]
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
396,"    public String encodeToString(final byte[] pArray) {
        return newStringUtf8(encode(pArray));
    }","  public void test127()  throws Throwable  {
      Base64 base64_0 = new Base64(6);
      byte[] byteArray0 = new byte[3];
      String string0 = base64_0.encodeToString(byteArray0);
}"
397,"    int avail() {
        return buffer != null ? pos - readPos : 0;
    }","  public void test128()  throws Throwable  {
      Base64 base64_0 = new Base64(6);
      byte[] byteArray0 = new byte[3];
      String string0 = base64_0.encodeToString(byteArray0);
      int int0 = base64_0.avail();
}"
398,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test129()  throws Throwable  {
      Base64 base64_0 = new Base64(6);
      byte[] byteArray0 = new byte[3];
      String string0 = base64_0.encodeToString(byteArray0);
      int int0 = base64_0.avail();
}"
399,"    public static String encodeBase64String(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, true));
    }","  public void test130()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      String string0 = Base64.encodeBase64String(byteArray0, true);
}"
400,"    public static String encodeBase64String(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, true));
    }","  public void test131()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      byte[] byteArray1 = Base64.encodeBase64(byteArray0, true, true);
      String string0 = Base64.encodeBase64String(byteArray1);
}"
401,"    int getLineLength() {
        return lineLength;
    }","  public void test132()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      Base64 base64_0 = new Base64((-234), byteArray0, true);
      int int0 = base64_0.getLineLength();
}"
402,"    public boolean isUrlSafe() {
        return this.encodeTable == URL_SAFE_ENCODE_TABLE;
    }","  public void test133()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      Base64 base64_0 = new Base64((-234), byteArray0, true);
      int int0 = base64_0.getLineLength();
}"
403,"    public static String encodeBase64StringUnChunked(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, false));
    }","  public void test134()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      String string0 = Base64.encodeBase64StringUnChunked(byteArray0);
}"
404,"    public static String encodeBase64URLSafeString(final byte[] binaryData) {
        return newStringUtf8(encodeBase64(binaryData, false, true));
    }","  public void test135()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      String string0 = Base64.encodeBase64URLSafeString(byteArray0);
}"
405,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test136()  throws Throwable  {
      byte[] byteArray0 = Base64.decodeBase64(""5upLi"");
      byte[] byteArray1 = Base64.encodeBase64(byteArray0, false);
}"
406,"    public static byte[] encodeBase64(final byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test137()  throws Throwable  {
      byte[] byteArray0 = Base64.decodeBase64(""5upLi"");
      byte[] byteArray1 = Base64.encodeBase64(byteArray0, false);
}"
407,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test0()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.write(""xZ ]'=T[l-!TW+q"");
}"
408,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test1()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter(1271);
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.close();
      char[] charArray0 = new char[4];
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write(charArray0, 1, 1271);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
409,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test2()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write((char[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
410,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test3()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      char[] charArray0 = new char[5];
      dotTerminatedMessageWriter0.close();
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write(charArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
411,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test4()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write((String) null, 0, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
412,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test5()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.close();
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write(""xZ ]'=T[l-!TW+q"", 0, 1);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
413,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test6()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write(""G3Fr4%p!h.~2lYrC"", 0, 69);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 16
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
414,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test7()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
415,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test8()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter(0);
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.close();
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write(""eO7H6UuX,l~"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
416,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test9()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.close();
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write((-1548));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
417,"    public void flush() throws IOException
    {
        synchronized (lock)
        {
            output.flush();
        }
    }","  public void test10()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.close();
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.flush();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
418,"    public void close() throws IOException
    {
        synchronized (lock)
        {
            if (output == null) {
                return ;
            }

            if (state == LAST_WAS_CR_STATE) {
                output.write('\n');
            } else if (state != LAST_WAS_NL_STATE) {
                output.write(""\r\n"");
            }

            output.write("".\r\n"");

            output.flush();
            output = null;
        }
    }","  public void test11()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter(0);
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      DotTerminatedMessageWriter dotTerminatedMessageWriter1 = new DotTerminatedMessageWriter(dotTerminatedMessageWriter0);
      dotTerminatedMessageWriter0.close();
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter1.close();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
419,"    public DotTerminatedMessageWriter(final Writer output)
    {
        super(output);
        this.output = output;
        this.state = NOTHING_SPECIAL_STATE;
    }","  public void test12()  throws Throwable  {
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = null;
      try {
        dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter((Writer) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Writer"", e);
      }
  }"
420,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test13()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      char[] charArray0 = new char[1];
      dotTerminatedMessageWriter0.write(charArray0, 1327, (-1));
}"
421,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test14()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      char[] charArray0 = new char[1];
      // Undeclared exception!
      try { 
        dotTerminatedMessageWriter0.write(charArray0, 1327, 2042);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1327
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageWriter"", e);
      }
  }"
422,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test15()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter(0);
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      DotTerminatedMessageWriter dotTerminatedMessageWriter1 = new DotTerminatedMessageWriter(dotTerminatedMessageWriter0);
      dotTerminatedMessageWriter1.close();
      dotTerminatedMessageWriter0.write(46);
}"
423,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test16()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.write(13);
      dotTerminatedMessageWriter0.write(10);
}"
424,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test17()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.write(46);
}"
425,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test18()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      char[] charArray0 = new char[8];
      dotTerminatedMessageWriter0.write(charArray0);
}"
426,"    public void flush() throws IOException
    {
        synchronized (lock)
        {
            output.flush();
        }
    }","  public void test19()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter(0);
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.flush();
  }"
427,"    public void close() throws IOException
    {
        synchronized (lock)
        {
            if (output == null) {
                return ;
            }

            if (state == LAST_WAS_CR_STATE) {
                output.write('\n');
            } else if (state != LAST_WAS_NL_STATE) {
                output.write(""\r\n"");
            }

            output.write("".\r\n"");

            output.flush();
            output = null;
        }
    }","  public void test20()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.write(13);
      dotTerminatedMessageWriter0.close();
}"
428,"    public void close() throws IOException
    {
        synchronized (lock)
        {
            if (output == null) {
                return ;
            }

            if (state == LAST_WAS_CR_STATE) {
                output.write('\n');
            } else if (state != LAST_WAS_NL_STATE) {
                output.write(""\r\n"");
            }

            output.write("".\r\n"");

            output.flush();
            output = null;
        }
    }","  public void test21()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter(0);
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.close();
      dotTerminatedMessageWriter0.close();
}"
429,"    public void close() throws IOException
    {
        synchronized (lock)
        {
            if (output == null) {
                return ;
            }

            if (state == LAST_WAS_CR_STATE) {
                output.write('\n');
            } else if (state != LAST_WAS_NL_STATE) {
                output.write(""\r\n"");
            }

            output.write("".\r\n"");

            output.flush();
            output = null;
        }
    }","  public void test22()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.write(10);
      dotTerminatedMessageWriter0.close();
}"
430,"    public void write(final int ch) throws IOException
    {
        synchronized (lock)
        {
            switch (ch)
            {
            case '\r':
                state = LAST_WAS_CR_STATE;
                output.write('\r');
                return ;
            case '\n':
                if (state != LAST_WAS_CR_STATE) {
                    output.write('\r');
                }
                output.write('\n');
                state = LAST_WAS_NL_STATE;
                return ;
            case '.':
                // Double the dot at the beginning of a line
                if (state == LAST_WAS_NL_STATE) {
                    output.write('.');
                }
                //$FALL-THROUGH$
            default:
                state = NOTHING_SPECIAL_STATE;
                output.write(ch);
            }
        }
    }","  public void test23()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      DotTerminatedMessageWriter dotTerminatedMessageWriter0 = new DotTerminatedMessageWriter(stringWriter0);
      dotTerminatedMessageWriter0.write(""org.apache.o.mons.netT}o.DotTerminatedMessageWitir"", 2, 2);
}"
431,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test0()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 0L, (-2506), (-2506));
      long long0 = copyStreamEvent0.getTotalBytesTransferred();
}"
432,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test1()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 0L, (-2506), (-2506));
      long long0 = copyStreamEvent0.getTotalBytesTransferred();
}"
433,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test2()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 0L, (-2506), (-2506));
      long long0 = copyStreamEvent0.getTotalBytesTransferred();
}"
434,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test3()  throws Throwable  {
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(""org.apache.commons.net.io.CopyStreamEvent"", (-1L), (-3064), (-1L));
      long long0 = copyStreamEvent0.getTotalBytesTransferred();
}"
435,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test4()  throws Throwable  {
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(""org.apache.commons.net.io.CopyStreamEvent"", (-1L), (-3064), (-1L));
      long long0 = copyStreamEvent0.getTotalBytesTransferred();
}"
436,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test5()  throws Throwable  {
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(""org.apache.commons.net.io.CopyStreamEvent"", (-1L), (-3064), (-1L));
      long long0 = copyStreamEvent0.getTotalBytesTransferred();
}"
437,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test6()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1L, (-1), 0L);
      long long0 = copyStreamEvent0.getStreamSize();
}"
438,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test7()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1L, (-1), 0L);
      long long0 = copyStreamEvent0.getStreamSize();
}"
439,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test8()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1L, (-1), 0L);
      long long0 = copyStreamEvent0.getStreamSize();
}"
440,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test9()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 0L, (-2506), (-2506));
      long long0 = copyStreamEvent0.getStreamSize();
}"
441,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test10()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 0L, (-2506), (-2506));
      long long0 = copyStreamEvent0.getStreamSize();
}"
442,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test11()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 0L, (-2506), (-2506));
      long long0 = copyStreamEvent0.getStreamSize();
}"
443,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test12()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 0L, 0, 0);
      int int0 = copyStreamEvent0.getBytesTransferred();
}"
444,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test13()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 0L, 0, 0);
      int int0 = copyStreamEvent0.getBytesTransferred();
}"
445,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test14()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 0L, 0, 0);
      int int0 = copyStreamEvent0.getBytesTransferred();
}"
446,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test15()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, (-1099L), (-421), (-1099L));
      int int0 = copyStreamEvent0.getBytesTransferred();
}"
447,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test16()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, (-1099L), (-421), (-1099L));
      int int0 = copyStreamEvent0.getBytesTransferred();
}"
448,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test17()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, (-1099L), (-421), (-1099L));
      int int0 = copyStreamEvent0.getBytesTransferred();
}"
449,"    public CopyStreamEvent(final Object source, final long totalBytesTransferred,
                           final int bytesTransferred, final long streamSize)
    {
        super(source);
        this.bytesTransferred = bytesTransferred;
        this.totalBytesTransferred = totalBytesTransferred;
        this.streamSize = streamSize;
    }","  public void test18()  throws Throwable  {
      CopyStreamEvent copyStreamEvent0 = null;
      try {
        copyStreamEvent0 = new CopyStreamEvent((Object) null, 971L, 1, 2828L);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // null source
         //
         verifyException(""java.util.EventObject"", e);
      }
  }"
450,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test19()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      int int0 = copyStreamEvent0.getBytesTransferred();
}"
451,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test20()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      int int0 = copyStreamEvent0.getBytesTransferred();
}"
452,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test21()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      int int0 = copyStreamEvent0.getBytesTransferred();
}"
453,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test22()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      copyStreamEvent0.toString();
}"
454,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test23()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      copyStreamEvent0.toString();
}"
455,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test24()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      copyStreamEvent0.toString();
}"
456,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test25()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      long long0 = copyStreamEvent0.getStreamSize();
}"
457,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test26()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      long long0 = copyStreamEvent0.getStreamSize();
}"
458,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test27()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      long long0 = copyStreamEvent0.getStreamSize();
}"
459,"    public long getStreamSize()
    {
        return streamSize;
    }","  public void test28()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      long long0 = copyStreamEvent0.getTotalBytesTransferred();
}"
460,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test29()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      long long0 = copyStreamEvent0.getTotalBytesTransferred();
}"
461,"    public int getBytesTransferred()
    {
        return bytesTransferred;
    }","  public void test30()  throws Throwable  {
      Object object0 = new Object();
      CopyStreamEvent copyStreamEvent0 = new CopyStreamEvent(object0, 1605L, 3282, 1605L);
      long long0 = copyStreamEvent0.getTotalBytesTransferred();
}"
462,"    public String readLine() throws IOException {
        final StringBuilder sb = new StringBuilder();
        int intch;
        boolean prevWasCR = false;
        synchronized(lock) { // make thread-safe (hopefully!)
            while((intch = read()) != -1)
            {
                if (prevWasCR && intch == LF) {
                    return sb.substring(0, sb.length()-1);
                }
                if (intch == CR) {
                    prevWasCR = true;
                } else {
                    prevWasCR = false;
                }
                sb.append((char) intch);
            }
        }
        final String string = sb.toString();
        if (string.isEmpty()) { // immediate EOF
            return null;
        }
        return string;
    }","  public void test0()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""3!?19({2*"");
      CRLFLineReader cRLFLineReader0 = new CRLFLineReader(stringReader0);
      stringReader0.close();
      try { 
        cRLFLineReader0.readLine();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.StringReader"", e);
      }
  }"
463,"    public String readLine() throws IOException {
        final StringBuilder sb = new StringBuilder();
        int intch;
        boolean prevWasCR = false;
        synchronized(lock) { // make thread-safe (hopefully!)
            while((intch = read()) != -1)
            {
                if (prevWasCR && intch == LF) {
                    return sb.substring(0, sb.length()-1);
                }
                if (intch == CR) {
                    prevWasCR = true;
                } else {
                    prevWasCR = false;
                }
                sb.append((char) intch);
            }
        }
        final String string = sb.toString();
        if (string.isEmpty()) { // immediate EOF
            return null;
        }
        return string;
    }","  public void test1()  throws Throwable  {
      StringReader stringReader0 = new StringReader("" "");
      CRLFLineReader cRLFLineReader0 = new CRLFLineReader(stringReader0);
      cRLFLineReader0.readLine();
      String string0 = cRLFLineReader0.readLine();
}"
464,"    public CRLFLineReader(final Reader reader)
    {
        super(reader);
    }","  public void test2()  throws Throwable  {
      CRLFLineReader cRLFLineReader0 = null;
      try {
        cRLFLineReader0 = new CRLFLineReader((Reader) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Reader"", e);
      }
  }"
465,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test0()  throws Throwable  {
      PipedWriter pipedWriter0 = new PipedWriter();
      int int0 = 4038;
      PipedReader pipedReader0 = new PipedReader(pipedWriter0, 4038);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(pipedWriter0);
      Locale locale0 = null;
      Object[] objectArray0 = new Object[7];
      objectArray0[1] = (Object) ""Tir^|j_\"""";
      objectArray0[2] = (Object) pipedWriter0;
      objectArray0[3] = (Object) pipedReader0;
      objectArray0[4] = (Object) null;
      Object object0 = new Object();
      objectArray0[6] = object0;
      PrintWriter printWriter0 = mockPrintWriter0.printf((Locale) null, ""Tir^|j_\"""", objectArray0);
      printWriter0.println(2089L);
      // Undeclared exception!
      Util.copyReader((Reader) pipedReader0, (Writer) mockPrintWriter0, 4038);
  }"
466,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test1()  throws Throwable  {
      PipedWriter pipedWriter0 = new PipedWriter();
      PipedReader pipedReader0 = new PipedReader(pipedWriter0, 4038);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(pipedWriter0);
      String string0 = ""Tir^|j_\"""";
      Object[] objectArray0 = new Object[7];
      objectArray0[0] = (Object) null;
      objectArray0[1] = (Object) ""Tir^|j_\"""";
      objectArray0[2] = (Object) pipedWriter0;
      objectArray0[3] = (Object) pipedReader0;
      objectArray0[4] = (Object) null;
      objectArray0[5] = (Object) mockPrintWriter0;
      Object object0 = new Object();
      objectArray0[6] = object0;
      PrintWriter printWriter0 = mockPrintWriter0.printf((Locale) null, ""Tir^|j_\"""", objectArray0);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      // Undeclared exception!
      Util.copyReader((Reader) pipedReader0, (Writer) printWriter0);
  }"
467,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test2()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      byteArray0[0] = (byte)21;
      byteArray0[1] = (byte)0;
      byteArray0[2] = (byte) (-125);
      byteArray0[3] = (byte)53;
      byteArray0[4] = (byte) (-78);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0);
      Enumeration<PushbackInputStream> enumeration0 = (Enumeration<PushbackInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(true, false).when(enumeration0).hasMoreElements();
      doReturn(pushbackInputStream0).when(enumeration0).nextElement();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      int int0 = 0;
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      PrintStream printStream0 = mockPrintStream0.append('t');
      Util.copyStream((InputStream) sequenceInputStream0, (OutputStream) printStream0, 0);
      PushbackInputStream pushbackInputStream1 = null;
      try {
        pushbackInputStream1 = new PushbackInputStream(sequenceInputStream0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // size <= 0
         //
         verifyException(""java.io.PushbackInputStream"", e);
      }
  }"
468,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test3()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      char[] charArray0 = new char[8];
      charArray0[0] = '%';
      charArray0[1] = 'I';
      charArray0[2] = 'W';
      charArray0[3] = '\""';
      charArray0[4] = '/';
      charArray0[5] = '[';
      charArray0[6] = 'g';
      charArray0[7] = '!';
      stringWriter0.write(charArray0);
      CopyStreamAdapter copyStreamAdapter1 = new CopyStreamAdapter();
      copyStreamAdapter0.addCopyStreamListener(copyStreamAdapter1);
      File file0 = MockFile.createTempFile(""A4p^-N*l=r"", ""The magic number cannot be null"");
      MockFileReader mockFileReader0 = new MockFileReader(file0);
      Util.copyReader((Reader) mockFileReader0, (Writer) stringWriter0, 1566);
  }"
469,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test4()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte)0;
      byteArray0[2] = (byte)0;
      byteArray0[3] = (byte)101;
      byteArray0[4] = (byte) (-92);
      byteArray0[5] = (byte) (-7);
      byte byte0 = (byte) (-26);
      byteArray0[6] = (byte) (-26);
      byteArray0[7] = (byte)63;
      byteArray0[8] = (byte) (-13);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) (-7), (byte)63);
      MockPrintStream mockPrintStream0 = new MockPrintStream(""oOYj?7Ssk%~%b1"");
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      // Undeclared exception!
      try { 
        Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) mockPrintStream0, 2, 0L, (CopyStreamListener) copyStreamAdapter0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ByteArrayInputStream"", e);
      }
  }"
470,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test5()  throws Throwable  {
      MockSocket mockSocket0 = new MockSocket();
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)1;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      byteArrayInputStream0.reset();
      MockPrintStream mockPrintStream0 = new MockPrintStream(""IOException caught while copying."");
      Locale locale0 = Locale.SIMPLIFIED_CHINESE;
      Object[] objectArray0 = new Object[5];
      Object object0 = new Object();
      objectArray0[0] = object0;
      Object object1 = new Object();
      objectArray0[1] = object1;
      objectArray0[2] = (Object) locale0;
      Object object2 = new Object();
      objectArray0[3] = object2;
      objectArray0[4] = (Object) byteArrayInputStream0;
      PrintStream printStream0 = mockPrintStream0.printf(locale0, """", objectArray0);
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) printStream0, (int) (byte)1, (long) (-3576), (CopyStreamListener) copyStreamAdapter0, true);
  }"
471,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test6()  throws Throwable  {
      PipedWriter pipedWriter0 = new PipedWriter();
      PipedReader pipedReader0 = new PipedReader(pipedWriter0, 4038);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(pipedWriter0);
      Object[] objectArray0 = new Object[7];
      objectArray0[0] = (Object) null;
      objectArray0[1] = (Object) ""Tir^|j_\"""";
      objectArray0[2] = (Object) pipedWriter0;
      objectArray0[3] = (Object) pipedReader0;
      objectArray0[4] = (Object) null;
      objectArray0[5] = (Object) mockPrintWriter0;
      Object object0 = new Object();
      objectArray0[6] = object0;
      PrintWriter printWriter0 = mockPrintWriter0.printf((Locale) null, ""Tir^|j_\"""", objectArray0);
      printWriter0.println();
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      Util.closeQuietly((Closeable) printWriter0);
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)125;
      byteArray0[1] = (byte)45;
      byteArray0[2] = (byte)1;
      byteArray0[3] = (byte)18;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      MockFile mockFile0 = new MockFile(""HU ayeg#qyNQdR`0|"");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(mockPrintStream0);
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) objectOutputStream0);
      Util.copyReader((Reader) pipedReader0, (Writer) printWriter0, 4038, (long) 4038, (CopyStreamListener) copyStreamAdapter0);
  }"
472,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test7()  throws Throwable  {
      int int0 = 274;
      PipedReader pipedReader0 = new PipedReader(274);
      CharArrayWriter charArrayWriter0 = new CharArrayWriter(274);
      char[] charArray0 = new char[2];
      charArray0[0] = 'T';
      charArray0[1] = 'R';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      charBuffer0.duplicate();
      int int1 = 45;
      try { 
        Util.copyReader((Reader) pipedReader0, (Writer) charArrayWriter0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // IOException caught while copying.
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
473,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test8()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""z_02n3(Q"", ""KO4V48Vi}gInMdN9"");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0, false);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      // Undeclared exception!
      try { 
        Util.copyStream((InputStream) null, (OutputStream) mockFileOutputStream0, 854, (long) 854, (CopyStreamListener) copyStreamAdapter0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
474,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test9()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte) (-34);
      byteArray0[2] = (byte)27;
      byteArray0[3] = (byte)0;
      byteArray0[4] = (byte)82;
      byteArray0[5] = (byte) (-61);
      byteArray0[6] = (byte)92;
      byteArray0[7] = (byte) (-97);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      try { 
        Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) pipedOutputStream0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // IOException caught while copying.
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
475,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test10()  throws Throwable  {
      Util.closeQuietly((Closeable) null);
      int int0 = 1929;
      PipedReader pipedReader0 = new PipedReader(1929);
      String string0 = ""[=?G9:OK^+zu"";
      MockFileWriter mockFileWriter0 = new MockFileWriter(""[=?G9:OK^+zu"", false);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      try { 
        Util.copyReader((Reader) pipedReader0, (Writer) mockFileWriter0, 1929, 482L, (CopyStreamListener) copyStreamAdapter0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // IOException caught while copying.
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
476,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test11()  throws Throwable  {
      MockFile mockFile0 = new MockFile("""", "".iJr-T3V6op @fU"");
      File file0 = MockFile.createTempFile(""Nb&q\""*mxl<S!Z-"", (String) null, (File) mockFile0);
      MockFile mockFile1 = new MockFile(file0, """");
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(mockFile1);
      DataInputStream dataInputStream0 = new DataInputStream(mockFileInputStream0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile1);
      int int0 = 0;
      Util.copyStream((InputStream) dataInputStream0, (OutputStream) mockPrintStream0, 0);
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      MockSocket mockSocket0 = null;
      try {
        mockSocket0 = new MockSocket("""", 0, inetAddress0, 0);
        fail(""Expecting exception: IOException"");
      } catch(Throwable e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@4047aa24
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
477,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test12()  throws Throwable  {
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      MockFile mockFile0 = new MockFile(""The strings must not be null"", ""The strings must not be null"");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0, true);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      try { 
        Util.copyStream((InputStream) pipedInputStream0, (OutputStream) mockFileOutputStream0, 2156, (-426L), (CopyStreamListener) copyStreamAdapter0, true);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // IOException caught while copying.
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
478,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test13()  throws Throwable  {
      char[] charArray0 = new char[2];
      charArray0[0] = '*';
      charArray0[1] = '?';
      int int0 = 0;
      CharArrayReader charArrayReader0 = new CharArrayReader(charArray0, 0, 0);
      LineNumberReader lineNumberReader0 = new LineNumberReader(charArrayReader0);
      BufferedReader bufferedReader0 = new BufferedReader(lineNumberReader0);
      File file0 = MockFile.createTempFile(""H`M,?z>3+X6t="", ""wM&`m=6)?A.Y#m#5}"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(file0);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      Util.copyReader((Reader) bufferedReader0, (Writer) mockPrintWriter0, 0, (long) 0, (CopyStreamListener) copyStreamAdapter0);
      Util.copyReader((Reader) lineNumberReader0, (Writer) mockPrintWriter0);
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.File"", e);
      }
  }"
479,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test14()  throws Throwable  {
      String string0 = """";
      StringReader stringReader0 = new StringReader("""");
      Util.copyReader((Reader) stringReader0, (Writer) null);
      ObjectInputStream objectInputStream0 = null;
      try {
        objectInputStream0 = new ObjectInputStream((InputStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ObjectInputStream$PeekInputStream"", e);
      }
  }"
480,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test15()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0, false);
      PrintStream printStream0 = mockPrintStream0.append('}');
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(printStream0);
      // Undeclared exception!
      try { 
        Util.copyStream((InputStream) null, (OutputStream) objectOutputStream0, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
481,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test16()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte)0;
      byteArray0[2] = (byte)0;
      byteArray0[3] = (byte)101;
      byteArray0[4] = (byte) (-92);
      byteArray0[5] = (byte)0;
      byteArray0[6] = (byte) (-26);
      byteArray0[7] = (byte)63;
      byteArray0[8] = (byte) (-13);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)0, (byte)63);
      MockPrintStream mockPrintStream0 = new MockPrintStream(""oOYj?7Ssk%~%b1"");
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) mockPrintStream0, 2, 0L, (CopyStreamListener) copyStreamAdapter0);
  }"
482,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test17()  throws Throwable  {
      CharArrayWriter charArrayWriter0 = new CharArrayWriter();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(charArrayWriter0, false);
      PrintWriter printWriter0 = mockPrintWriter0.append('?');
      Util.closeQuietly((Closeable) printWriter0);
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      MockFile mockFile0 = new MockFile((File) null, ""v6.[6VlkQeB"");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      PrintStream printStream0 = mockPrintStream0.append((CharSequence) ""v6.[6VlkQeB"");
      Util.copyStream((InputStream) sequenceInputStream0, (OutputStream) printStream0);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      Util.copyStream((InputStream) sequenceInputStream0, (OutputStream) printStream0, (-477), (-3431L), (CopyStreamListener) copyStreamAdapter0);
      int int0 = 1786;
      PipedInputStream pipedInputStream0 = new PipedInputStream(1786);
      // Undeclared exception!
      try { 
        Charset.forName(""v6.[6VlkQeB"");
        fail(""Expecting exception: IllegalCharsetNameException"");
      } catch(IllegalCharsetNameException e) {
         //
         // v6.[6VlkQeB
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
483,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test18()  throws Throwable  {
      String string0 = ""e.va[JeHHgqf"";
      MockPrintStream mockPrintStream0 = new MockPrintStream(""e.va[JeHHgqf"");
      Charset charset0 = Charset.defaultCharset();
      OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(mockPrintStream0, charset0);
      // Undeclared exception!
      try { 
        Util.copyReader((Reader) null, (Writer) outputStreamWriter0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
484,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test19()  throws Throwable  {
      InputStream inputStream0 = null;
      OutputStream outputStream0 = null;
      int int0 = (-1);
      CopyStreamListener copyStreamListener0 = null;
      // Undeclared exception!
      try { 
        Util.copyStream((InputStream) null, (OutputStream) null, (-1), (long) (-1), (CopyStreamListener) null, false);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
485,"    public static void closeQuietly(final Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (final IOException e) {
                // Ignored
            }
        }
    }","  public void test20()  throws Throwable  {
      Socket socket0 = null;
      Util.closeQuietly((Socket) null);
      InputStream inputStream0 = null;
      ObjectInputStream objectInputStream0 = null;
      try {
        objectInputStream0 = new ObjectInputStream((InputStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ObjectInputStream$PeekInputStream"", e);
      }
  }"
486,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test21()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)0;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)0, (byte)0);
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) byteArrayOutputStream0, (int) (byte)0, 0L, (CopyStreamListener) copyStreamAdapter0, true);
  }"
487,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test22()  throws Throwable  {
      InputStream inputStream0 = null;
      OutputStream outputStream0 = null;
      int int0 = (-1);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      // Undeclared exception!
      try { 
        Util.copyStream((InputStream) null, (OutputStream) null, (-1), (long) (-1), (CopyStreamListener) copyStreamAdapter0, true);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
488,"    public static void closeQuietly(final Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (final IOException e) {
                // Ignored
            }
        }
    }","  public void test23()  throws Throwable  {
      MockSocket mockSocket0 = new MockSocket();
      Util.closeQuietly((Socket) mockSocket0);
      PipedReader pipedReader0 = new PipedReader();
      PipedWriter pipedWriter0 = new PipedWriter(pipedReader0);
      PipedReader pipedReader1 = null;
      try {
        pipedReader1 = new PipedReader(pipedWriter0, (-3576));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Pipe size <= 0
         //
         verifyException(""java.io.PipedReader"", e);
      }
  }"
489,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test24()  throws Throwable  {
      PipedWriter pipedWriter0 = new PipedWriter();
      PipedReader pipedReader0 = new PipedReader(pipedWriter0, 4038);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(pipedWriter0);
      Object[] objectArray0 = new Object[7];
      objectArray0[0] = (Object) null;
      objectArray0[1] = (Object) ""Tir^|j_\"""";
      objectArray0[2] = (Object) pipedWriter0;
      objectArray0[3] = (Object) pipedReader0;
      objectArray0[4] = (Object) null;
      objectArray0[5] = (Object) mockPrintWriter0;
      Object object0 = new Object();
      objectArray0[6] = object0;
      PrintWriter printWriter0 = mockPrintWriter0.printf((Locale) null, ""Tir^|j_\"""", objectArray0);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      // Undeclared exception!
      Util.copyReader((Reader) pipedReader0, (Writer) printWriter0, 4038, (long) 4038, (CopyStreamListener) copyStreamAdapter0);
  }"
490,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test25()  throws Throwable  {
      String string0 = ""IV#%G"";
      StringReader stringReader0 = new StringReader(""IV#%G"");
      // Undeclared exception!
      try { 
        Util.copyReader((Reader) stringReader0, (Writer) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
491,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test26()  throws Throwable  {
      Reader reader0 = null;
      Writer writer0 = null;
      int int0 = (-1609);
      // Undeclared exception!
      try { 
        Util.copyReader((Reader) null, (Writer) null, (-1609));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
492,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test27()  throws Throwable  {
      PipedInputStream pipedInputStream0 = new PipedInputStream(6);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(pipedInputStream0);
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(byteArrayOutputStream0, 2);
      MockPrintStream mockPrintStream0 = new MockPrintStream(bufferedOutputStream0, false);
      Object[] objectArray0 = new Object[6];
      objectArray0[0] = (Object) byteArrayOutputStream0;
      objectArray0[1] = (Object) mockPrintStream0;
      objectArray0[2] = (Object) pushbackInputStream0;
      objectArray0[3] = (Object) ""IOException caught while copying."";
      objectArray0[4] = (Object) ""IOException caught while copying."";
      objectArray0[5] = (Object) null;
      PrintStream printStream0 = mockPrintStream0.printf((Locale) null, ""IOException caught while copying."", objectArray0);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      try { 
        Util.copyStream((InputStream) pushbackInputStream0, (OutputStream) printStream0, 6, (long) 2, (CopyStreamListener) copyStreamAdapter0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // IOException caught while copying.
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
493,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test28()  throws Throwable  {
      OutputStream outputStream0 = null;
      // Undeclared exception!
      try { 
        Util.copyStream((InputStream) null, (OutputStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
494,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test29()  throws Throwable  {
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream((InputStream) null);
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      FilterOutputStream filterOutputStream0 = new FilterOutputStream(mockPrintStream0);
      try { 
        Util.copyStream((InputStream) pushbackInputStream0, (OutputStream) filterOutputStream0, 1024);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // IOException caught while copying.
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
495,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test30()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""The magic number must contain at least one byte"");
      mockFile0.setReadable(true);
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0, true);
      mockFileOutputStream0.getChannel();
      Util.closeQuietly((Closeable) mockFileOutputStream0);
      PipedReader pipedReader0 = new PipedReader(1146);
      Writer writer0 = null;
      try { 
        Util.copyReader((Reader) pipedReader0, (Writer) null, 1146);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // IOException caught while copying.
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
496,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test31()  throws Throwable  {
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      // Undeclared exception!
      try { 
        Util.copyReader((Reader) null, (Writer) null, (-1734), (-2419L), (CopyStreamListener) copyStreamAdapter0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
497,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test32()  throws Throwable  {
      PipedReader pipedReader0 = new PipedReader(2780);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      try { 
        Util.copyReader((Reader) pipedReader0, (Writer) null, 2780, (-1152L), (CopyStreamListener) copyStreamAdapter0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // IOException caught while copying.
         //
         verifyException(""org.apache.commons.net.io.Util"", e);
      }
  }"
498,,"  public void test33()  throws Throwable  {
      ObjectOutputStream objectOutputStream0 = null;
      try {
        objectOutputStream0 = new ObjectOutputStream((OutputStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ObjectOutputStream$BlockDataOutputStream"", e);
      }
  }"
499,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test34()  throws Throwable  {
      MockSocket mockSocket0 = new MockSocket();
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)1;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      byteArrayInputStream0.reset();
      MockPrintStream mockPrintStream0 = new MockPrintStream(""IOException caught while copying."");
      Locale locale0 = Locale.SIMPLIFIED_CHINESE;
      Object[] objectArray0 = new Object[5];
      Object object0 = new Object();
      objectArray0[0] = object0;
      Object object1 = new Object();
      objectArray0[1] = object1;
      objectArray0[2] = (Object) locale0;
      Object object2 = new Object();
      objectArray0[3] = object2;
      objectArray0[4] = (Object) byteArrayInputStream0;
      PrintStream printStream0 = mockPrintStream0.printf(locale0, """", objectArray0);
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) printStream0, (int) (byte)1, (long) (-3576), (CopyStreamListener) copyStreamAdapter0, false);
  }"
500,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test35()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte) (-34);
      byteArray0[2] = (byte)27;
      byteArray0[3] = (byte)0;
      byteArray0[4] = (byte)0;
      FileSystemHandling.shouldAllThrowIOExceptions();
      byteArray0[5] = (byte) (-61);
      byteArray0[6] = (byte)92;
      byteArray0[7] = (byte) (-97);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      byteArrayInputStream0.read(byteArray0);
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) pipedOutputStream0);
      char[] charArray0 = new char[3];
      charArray0[0] = 'B';
      charArray0[1] = 'E';
      charArray0[2] = 'e';
      CharArrayReader charArrayReader0 = new CharArrayReader(charArray0);
      charArrayReader0.markSupported();
      URI uRI0 = MockURI.aFileURI;
      MockFile mockFile0 = new MockFile(uRI0);
      Util.closeQuietly((Socket) null);
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) pipedOutputStream0);
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) pipedOutputStream0, (int) (byte) (-34));
      MockPrintWriter mockPrintWriter0 = null;
      try {
        mockPrintWriter0 = new MockPrintWriter(mockFile0, ""IOException caught while copying."");
        fail(""Expecting exception: UnsupportedEncodingException"");
      } catch(Throwable e) {
         //
         // IOException caught while copying.
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockPrintWriter"", e);
      }
  }"
501,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test36()  throws Throwable  {
      PipedWriter pipedWriter0 = new PipedWriter();
      int int0 = 4028;
      PipedReader pipedReader0 = new PipedReader(pipedWriter0, 4028);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(pipedWriter0);
      Locale locale0 = null;
      Object[] objectArray0 = new Object[7];
      objectArray0[1] = (Object) ""Ti^|j_\"""";
      objectArray0[2] = (Object) pipedWriter0;
      objectArray0[3] = (Object) pipedReader0;
      objectArray0[4] = (Object) null;
      Object object0 = new Object();
      objectArray0[6] = object0;
      PrintWriter printWriter0 = mockPrintWriter0.printf((Locale) null, ""Ti^|j_\"""", objectArray0);
      printWriter0.println(2089L);
      // Undeclared exception!
      Util.copyReader((Reader) pipedReader0, (Writer) mockPrintWriter0, 4028);
  }"
502,,"  public void test37()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      byte byte0 = (byte) (-102);
      byteArray0[1] = (byte) (-102);
      int int0 = 0;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, (-7));
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream("""");
        fail(""Expecting exception: FileNotFoundException"");
      } catch(Throwable e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileOutputStream"", e);
      }
  }"
503,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test38()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      CharBuffer charBuffer0 = CharBuffer.allocate(1024);
      charBuffer0.subSequence(1024, 1024);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      char[] charArray0 = new char[8];
      charArray0[0] = '%';
      charArray0[1] = 'I';
      charArray0[2] = 'W';
      charArray0[3] = '\""';
      charArray0[4] = '/';
      charArray0[5] = '[';
      charArray0[6] = 'g';
      charArray0[7] = '!';
      stringWriter0.write(charArray0);
      CopyStreamAdapter copyStreamAdapter1 = new CopyStreamAdapter();
      copyStreamAdapter0.addCopyStreamListener(copyStreamAdapter1);
      File file0 = MockFile.createTempFile(""A4p^-N*l=r"", ""The magic number cannot be null"");
      MockFileReader mockFileReader0 = new MockFileReader(file0);
      long long0 = Util.copyReader((Reader) mockFileReader0, (Writer) stringWriter0, 1566);
}"
504,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test39()  throws Throwable  {
      char[] charArray0 = new char[2];
      charArray0[0] = '*';
      charArray0[1] = '?';
      int int0 = 0;
      CharArrayReader charArrayReader0 = new CharArrayReader(charArray0, 0, 0);
      LineNumberReader lineNumberReader0 = new LineNumberReader(charArrayReader0);
      BufferedReader bufferedReader0 = new BufferedReader(lineNumberReader0);
      File file0 = MockFile.createTempFile(""H`M,?z>3+X6t="", ""wM&`m=6)?A.Y#m#5}"");
      file0.toURL();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(file0);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      Util.copyReader((Reader) bufferedReader0, (Writer) mockPrintWriter0, 0, (long) 0, (CopyStreamListener) copyStreamAdapter0);
      Util.copyReader((Reader) lineNumberReader0, (Writer) mockPrintWriter0);
      MockFileInputStream mockFileInputStream0 = null;
      try {
        mockFileInputStream0 = new MockFileInputStream(""wM&`m=6)?A.Y#m#5}"");
        fail(""Expecting exception: FileNotFoundException"");
      } catch(Throwable e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
      }
  }"
505,"    public static void closeQuietly(final Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (final IOException e) {
                // Ignored
            }
        }
    }","  public void test40()  throws Throwable  {
      Socket socket0 = null;
      Util.closeQuietly((Socket) null);
      PipedWriter pipedWriter0 = new PipedWriter();
      pipedWriter0.close();
      int int0 = 91;
      Util.closeQuietly((Closeable) null);
      PipedInputStream pipedInputStream0 = new PipedInputStream(91);
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream(pipedInputStream0);
      PipedInputStream pipedInputStream1 = null;
      try {
        pipedInputStream1 = new PipedInputStream(pipedOutputStream0, 91);
        fail(""Expecting exception: IOException"");
      } catch(Throwable e) {
         //
         // Already connected
         //
         verifyException(""java.io.PipedOutputStream"", e);
      }
  }"
506,"    public static long copyReader(final Reader source, final Writer dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener)
    throws CopyStreamException
    {
        int numChars;
        long total = 0;
        final char[] buffer = new char[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numChars = source.read(buffer)) != -1)
            {
                // Technically, some read(char[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.
                if (numChars == 0)
                {
                    final int singleChar = source.read();
                    if (singleChar < 0) {
                        break;
                    }
                    dest.write(singleChar);
                    dest.flush();
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numChars);
                dest.flush();
                total += numChars;
                if (listener != null) {
                    listener.bytesTransferred(total, numChars, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test41()  throws Throwable  {
      PipedWriter pipedWriter0 = new PipedWriter();
      PipedReader pipedReader0 = new PipedReader(pipedWriter0, 4038);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(pipedWriter0);
      Object[] objectArray0 = new Object[7];
      objectArray0[0] = (Object) null;
      objectArray0[1] = (Object) ""Tir^|j_\"""";
      objectArray0[2] = (Object) pipedWriter0;
      objectArray0[3] = (Object) pipedReader0;
      objectArray0[4] = (Object) null;
      objectArray0[5] = (Object) mockPrintWriter0;
      Object object0 = new Object();
      objectArray0[6] = object0;
      PrintWriter printWriter0 = mockPrintWriter0.printf((Locale) null, ""Tir^|j_\"""", objectArray0);
      printWriter0.printf(""Tir^|j_\"""", objectArray0);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      Util.closeQuietly((Closeable) mockPrintWriter0);
      long long0 = Util.copyReader((Reader) pipedReader0, (Writer) printWriter0, 4038, (long) 4038, (CopyStreamListener) copyStreamAdapter0);
}"
507,"    public static void closeQuietly(final Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (final IOException e) {
                // Ignored
            }
        }
    }","  public void test42()  throws Throwable  {
      PipedWriter pipedWriter0 = new PipedWriter();
      int int0 = 4038;
      PipedReader pipedReader0 = new PipedReader(pipedWriter0, 4038);
      pipedWriter0.write("""");
      Object[] objectArray0 = new Object[7];
      objectArray0[0] = (Object) null;
      objectArray0[1] = (Object) ""Tir^|j_\"""";
      objectArray0[2] = (Object) pipedWriter0;
      objectArray0[3] = (Object) pipedReader0;
      objectArray0[4] = (Object) null;
      Object object0 = new Object();
      objectArray0[6] = object0;
      MockSocket mockSocket0 = new MockSocket();
      Util.closeQuietly((Socket) mockSocket0);
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      Util.closeQuietly((Closeable) pipedWriter0);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream((InputStream) null, 4038);
      Util.copyReader((Reader) pipedReader0, (Writer) pipedWriter0);
      Util.closeQuietly((Closeable) mockSocket0);
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream("""");
        fail(""Expecting exception: FileNotFoundException"");
      } catch(Throwable e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileOutputStream"", e);
      }
  }"
508,"    public static long copyStream(final InputStream source, final OutputStream dest,
                                        final int bufferSize, final long streamSize,
                                        final CopyStreamListener listener,
                                        final boolean flush)
    throws CopyStreamException
    {
        int numBytes;
        long total = 0;
        final byte[] buffer = new byte[bufferSize > 0 ? bufferSize : DEFAULT_COPY_BUFFER_SIZE];

        try
        {
            while ((numBytes = source.read(buffer)) != -1)
            {
                // Technically, some read(byte[]) methods may return 0 and we cannot
                // accept that as an indication of EOF.

                if (numBytes == 0)
                {
                    final int singleByte = source.read();
                    if (singleByte < 0) {
                        break;
                    }
                    dest.write(singleByte);
                    if(flush) {
                        dest.flush();
                    }
                    ++total;
                    if (listener != null) {
                        listener.bytesTransferred(total, 1, streamSize);
                    }
                    continue;
                }

                dest.write(buffer, 0, numBytes);
                if(flush) {
                    dest.flush();
                }
                total += numBytes;
                if (listener != null) {
                    listener.bytesTransferred(total, numBytes, streamSize);
                }
            }
        }
        catch (final IOException e)
        {
            throw new CopyStreamException(""IOException caught while copying."",
                                          total, e);
        }

        return total;
    }","  public void test43()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)0;
      byte byte0 = (byte)0;
      byteArray0[1] = (byte)0;
      byteArray0[2] = (byte)0;
      byteArray0[3] = (byte)101;
      byteArray0[4] = (byte) (-92);
      byteArray0[5] = (byte)0;
      byteArray0[6] = (byte) (-26);
      byteArray0[7] = (byte)63;
      byteArray0[8] = (byte) (-13);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)0, (byte)63);
      String string0 = ""oOYj?7Ssk%~%b1"";
      MockPrintStream mockPrintStream0 = new MockPrintStream(""oOYj?7Ssk%~%b1"");
      CopyStreamAdapter copyStreamAdapter0 = new CopyStreamAdapter();
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) mockPrintStream0, 2, 0L, (CopyStreamListener) copyStreamAdapter0);
      Util.copyStream((InputStream) byteArrayInputStream0, (OutputStream) mockPrintStream0, (int) (byte)0, (-382L), (CopyStreamListener) copyStreamAdapter0);
      File file0 = MockFile.createTempFile(""oOYj?7Ssk%~%b1"", ""oOYj?7Ssk%~%b1"");
      try { 
        MockFile.createTempFile(""oOYj?7Ssk%~%b1"", ""oOYj?7Ssk%~%b1"", file0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.vfs.VirtualFileSystem"", e);
      }
  }"
509,"    public void close() throws IOException
    {
        super.close();
        socket.close();
    }","  public void test0()  throws Throwable  {
      SocketInputStream socketInputStream0 = new SocketInputStream((Socket) null, (InputStream) null);
      // Undeclared exception!
      try { 
        socketInputStream0.close();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.FilterInputStream"", e);
      }
  }"
510,"    public void close() throws IOException
    {
        super.close();
        socket.close();
    }","  public void test1()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      MockSocket mockSocket0 = new MockSocket(proxy0);
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      SocketInputStream socketInputStream0 = new SocketInputStream(mockSocket0, mockFileInputStream0);
      socketInputStream0.close();
  }"
511,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test0()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.net.io.DotTerminatedMessageReader"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[7];
      int int0 = dotTerminatedMessageReader0.read(charArray0, 2, 2);
}"
512,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test1()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.net.io.DotTerminatedMessageReader"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[7];
      int int0 = dotTerminatedMessageReader0.read(charArray0, 2, 2);
}"
513,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test2()  throws Throwable  {
      StringReader stringReader0 = new StringReader("". 1lN"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      int int0 = dotTerminatedMessageReader0.read();
}"
514,"    public String readLine() throws IOException {
        final StringBuilder sb = new StringBuilder();
        int intch;
        synchronized(lock) { // make thread-safe (hopefully!)
            while((intch = read()) != -1)
            {
                if (intch == LF && atBeginning) {
                    return sb.substring(0, sb.length()-1);
                }
                sb.append((char) intch);
            }
        }
        final String string = sb.toString();
        if (string.isEmpty()) { // immediate EOF
            return null;
        }
        // Should not happen - EOF without CRLF
        //new Throwable(string).printStackTrace();
        return string;
    }","  public void test3()  throws Throwable  {
      StringReader stringReader0 = new StringReader("" "");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      String string0 = dotTerminatedMessageReader0.readLine();
}"
515,"    public String readLine() throws IOException {
        final StringBuilder sb = new StringBuilder();
        int intch;
        synchronized(lock) { // make thread-safe (hopefully!)
            while((intch = read()) != -1)
            {
                if (intch == LF && atBeginning) {
                    return sb.substring(0, sb.length()-1);
                }
                sb.append((char) intch);
            }
        }
        final String string = sb.toString();
        if (string.isEmpty()) { // immediate EOF
            return null;
        }
        // Should not happen - EOF without CRLF
        //new Throwable(string).printStackTrace();
        return string;
    }","  public void test4()  throws Throwable  {
      StringReader stringReader0 = new StringReader("" "");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      String string0 = dotTerminatedMessageReader0.readLine();
}"
516,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test5()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[0];
      int int0 = dotTerminatedMessageReader0.read(charArray0);
}"
517,"    public String readLine() throws IOException {
        final StringBuilder sb = new StringBuilder();
        int intch;
        synchronized(lock) { // make thread-safe (hopefully!)
            while((intch = read()) != -1)
            {
                if (intch == LF && atBeginning) {
                    return sb.substring(0, sb.length()-1);
                }
                sb.append((char) intch);
            }
        }
        final String string = sb.toString();
        if (string.isEmpty()) { // immediate EOF
            return null;
        }
        // Should not happen - EOF without CRLF
        //new Throwable(string).printStackTrace();
        return string;
    }","  public void test6()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      stringReader0.close();
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      try { 
        dotTerminatedMessageReader0.readLine();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.StringReader"", e);
      }
  }"
518,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test7()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""a\"">U9EH2A{[Tpd,"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      // Undeclared exception!
      try { 
        dotTerminatedMessageReader0.read((char[]) null, 1, 602);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageReader"", e);
      }
  }"
519,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test8()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""@h6HA("");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[0];
      // Undeclared exception!
      try { 
        dotTerminatedMessageReader0.read(charArray0, (-1), 69);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageReader"", e);
      }
  }"
520,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test9()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""D"");
      stringReader0.close();
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[9];
      try { 
        dotTerminatedMessageReader0.read(charArray0, 0, 2438);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.StringReader"", e);
      }
  }"
521,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test10()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""8'"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      // Undeclared exception!
      try { 
        dotTerminatedMessageReader0.read((char[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.DotTerminatedMessageReader"", e);
      }
  }"
522,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test11()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[2];
      stringReader0.close();
      try { 
        dotTerminatedMessageReader0.read(charArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.StringReader"", e);
      }
  }"
523,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test12()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.net.io.DotTerminatedMessageReader"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      stringReader0.close();
      try { 
        dotTerminatedMessageReader0.read();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.StringReader"", e);
      }
  }"
524,"    public void close() throws IOException
    {
        synchronized (lock)
        {
            if (!eof)
            {
                while (read() != -1)
                {
                    // read to EOF
                }
            }
            eof = true;
            atBeginning = false;
        }
    }","  public void test13()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      stringReader0.close();
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      try { 
        dotTerminatedMessageReader0.close();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.StringReader"", e);
      }
  }"
525,"    public DotTerminatedMessageReader(final Reader reader)
    {
        super(reader);
        // Assumes input is at start of message
        atBeginning = true;
        eof = false;
    }","  public void test14()  throws Throwable  {
      DotTerminatedMessageReader dotTerminatedMessageReader0 = null;
      try {
        dotTerminatedMessageReader0 = new DotTerminatedMessageReader((Reader) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Reader"", e);
      }
  }"
526,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test15()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.net.io.DotTerminatedMessageReader"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[7];
      int int0 = dotTerminatedMessageReader0.read(charArray0, 0, 2);
}"
527,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test16()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.net.io.DotTerminatedMessageReader"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[7];
      int int0 = dotTerminatedMessageReader0.read(charArray0, 0, 2);
}"
528,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test17()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[1];
      int int0 = dotTerminatedMessageReader0.read(charArray0, 2192, 2192);
}"
529,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test18()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""."");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      int int0 = dotTerminatedMessageReader0.read();
}"
530,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test19()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""8'"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      int int0 = dotTerminatedMessageReader0.read();
}"
531,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test20()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""8'"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      int int0 = dotTerminatedMessageReader0.read();
      int int1 = dotTerminatedMessageReader0.read();
}"
532,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test21()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      int int0 = dotTerminatedMessageReader0.read();
}"
533,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test22()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      dotTerminatedMessageReader0.close();
      int int0 = dotTerminatedMessageReader0.read();
}"
534,"    public void close() throws IOException
    {
        synchronized (lock)
        {
            if (!eof)
            {
                while (read() != -1)
                {
                    // read to EOF
                }
            }
            eof = true;
            atBeginning = false;
        }
    }","  public void test23()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""ERu7q vg+/ZrJkgB}09"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      dotTerminatedMessageReader0.close();
      dotTerminatedMessageReader0.close();
  }"
535,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test24()  throws Throwable  {
      StringReader stringReader0 = new StringReader("".Th[;OK/S{\""e1O"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      CharBuffer charBuffer0 = CharBuffer.allocate(2007);
      int int0 = dotTerminatedMessageReader0.read(charBuffer0);
}"
536,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test25()  throws Throwable  {
      StringReader stringReader0 = new StringReader("".Th[;OK/S{\""e1O"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      CharBuffer charBuffer0 = CharBuffer.allocate(2007);
      int int0 = dotTerminatedMessageReader0.read(charBuffer0);
}"
537,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test26()  throws Throwable  {
      StringReader stringReader0 = new StringReader("".Th[k;AOSo\""eO"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[6];
      int int0 = dotTerminatedMessageReader0.read(charArray0);
}"
538,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test27()  throws Throwable  {
      StringReader stringReader0 = new StringReader("".Th[k;AOSo\""eO"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[6];
      int int0 = dotTerminatedMessageReader0.read(charArray0);
}"
539,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test28()  throws Throwable  {
      StringReader stringReader0 = new StringReader("" "");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[5];
      int int0 = dotTerminatedMessageReader0.read(charArray0, (int) '\u0000', 0);
}"
540,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test29()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""..+V\"""");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      int int0 = dotTerminatedMessageReader0.read();
}"
541,"    public String readLine() throws IOException {
        final StringBuilder sb = new StringBuilder();
        int intch;
        synchronized(lock) { // make thread-safe (hopefully!)
            while((intch = read()) != -1)
            {
                if (intch == LF && atBeginning) {
                    return sb.substring(0, sb.length()-1);
                }
                sb.append((char) intch);
            }
        }
        final String string = sb.toString();
        if (string.isEmpty()) { // immediate EOF
            return null;
        }
        // Should not happen - EOF without CRLF
        //new Throwable(string).printStackTrace();
        return string;
    }","  public void test30()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""ERu7q vg+/ZrJkgB}09"");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      dotTerminatedMessageReader0.close();
      String string0 = dotTerminatedMessageReader0.readLine();
}"
542,"    public int read() throws IOException {
        synchronized (lock) {
            if (eof) {
                return -1; // Don't allow read past EOF
            }
            int chint = super.read();
            if (chint == -1) { // True EOF
                eof = true;
                return -1;
            }
            if (atBeginning) {
                atBeginning = false;
                if (chint == DOT) { // Have DOT
                    mark(2); // need to check for CR LF or DOT
                    chint = super.read();
                    if (chint == -1) { // Should not happen
                        // new Throwable(""Trailing DOT"").printStackTrace();
                        eof = true;
                        return DOT; // return the trailing DOT
                    }
                    if (chint == DOT) { // Have DOT DOT
                        // no need to reset as we want to lose the first DOT
                        return chint; // i.e. DOT
                    }
                    if (chint == CR) { // Have DOT CR
                        chint = super.read();
                        if (chint == -1) { // Still only DOT CR - should not happen
                            //new Throwable(""Trailing DOT CR"").printStackTrace();
                            reset(); // So CR is picked up next time
                            return DOT; // return the trailing DOT
                        }
                        if (chint == LF) { // DOT CR LF
                            atBeginning = true;
                            eof = true;
                            // Do we need to clear the mark somehow?
                            return -1;
                        }
                    }
                    // Should not happen - lone DOT at beginning
                    //new Throwable(""Lone DOT followed by ""+(char)chint).printStackTrace();
                    reset();
                    return DOT;
                } // have DOT
            } // atBeginning

            // Handle CRLF in normal flow
            if (seenCR) {
                seenCR = false;
                if (chint == LF) {
                    atBeginning = true;
                }
            }
            if (chint == CR) {
                seenCR = true;
            }
            return chint;
        }
    }","  public void test31()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      DotTerminatedMessageReader dotTerminatedMessageReader0 = new DotTerminatedMessageReader(stringReader0);
      char[] charArray0 = new char[2];
      int int0 = dotTerminatedMessageReader0.read(charArray0);
}"
543,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test0()  throws Throwable  {
      MockIOException mockIOException0 = new MockIOException();
      CopyStreamException copyStreamException0 = new CopyStreamException(""org.apache.commons.net.io.CopyStreamException"", 0L, mockIOException0);
      long long0 = copyStreamException0.getTotalBytesTransferred();
}"
544,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test1()  throws Throwable  {
      MockIOException mockIOException0 = new MockIOException();
      CopyStreamException copyStreamException0 = new CopyStreamException((String) null, (-994L), mockIOException0);
      long long0 = copyStreamException0.getTotalBytesTransferred();
}"
545,"    public IOException getIOException()
    {
        return (IOException) getCause(); // cast is OK because it was initialized with an IOException
    }","  public void test2()  throws Throwable  {
      MockIOException mockIOException0 = new MockIOException();
      CopyStreamException copyStreamException0 = new CopyStreamException("""", 1625L, mockIOException0);
      IOException iOException0 = copyStreamException0.getIOException();
}"
546,"    public long getTotalBytesTransferred()
    {
        return totalBytesTransferred;
    }","  public void test3()  throws Throwable  {
      CopyStreamException copyStreamException0 = new CopyStreamException(""F+hJC=6Lz"", 979L, (IOException) null);
      long long0 = copyStreamException0.getTotalBytesTransferred();
}"
547,"    public IOException getIOException()
    {
        return (IOException) getCause(); // cast is OK because it was initialized with an IOException
    }","  public void test4()  throws Throwable  {
      CopyStreamException copyStreamException0 = new CopyStreamException(""F+hJC=6Lz"", 979L, (IOException) null);
      IOException iOException0 = copyStreamException0.getIOException();
}"
548,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test0()  throws Throwable  {
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      BufferedInputStream bufferedInputStream0 = new BufferedInputStream(mockFileInputStream0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(bufferedInputStream0);
      byte[] byteArray0 = new byte[0];
      int int0 = toNetASCIIInputStream0.read(byteArray0);
}"
549,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test1()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      int int0 = toNetASCIIInputStream0.read();
}"
550,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test2()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 45, (-1011));
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      int int0 = toNetASCIIInputStream0.available();
}"
551,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test3()  throws Throwable  {
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream((InputStream) null);
      byte[] byteArray0 = new byte[7];
      // Undeclared exception!
      try { 
        toNetASCIIInputStream0.read(byteArray0, (int) (byte)1, (int) (byte)115);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.ToNetASCIIInputStream"", e);
      }
  }"
552,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test4()  throws Throwable  {
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(pipedInputStream0);
      byte[] byteArray0 = new byte[2];
      try { 
        toNetASCIIInputStream0.read(byteArray0, 0, (int) (byte)14);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedInputStream"", e);
      }
  }"
553,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test5()  throws Throwable  {
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream((InputStream) null);
      byte[] byteArray0 = new byte[1];
      // Undeclared exception!
      try { 
        toNetASCIIInputStream0.read(byteArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.ToNetASCIIInputStream"", e);
      }
  }"
554,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test6()  throws Throwable  {
      PipedInputStream pipedInputStream0 = new PipedInputStream(344);
      BufferedInputStream bufferedInputStream0 = new BufferedInputStream(pipedInputStream0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(bufferedInputStream0);
      byte[] byteArray0 = new byte[4];
      try { 
        toNetASCIIInputStream0.read(byteArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedInputStream"", e);
      }
  }"
555,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test7()  throws Throwable  {
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream((InputStream) null);
      // Undeclared exception!
      try { 
        toNetASCIIInputStream0.read();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.ToNetASCIIInputStream"", e);
      }
  }"
556,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test8()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) (-23), (byte)2);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      // Undeclared exception!
      try { 
        toNetASCIIInputStream0.read();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
557,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test9()  throws Throwable  {
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(pipedInputStream0);
      try { 
        toNetASCIIInputStream0.read();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedInputStream"", e);
      }
  }"
558,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test10()  throws Throwable  {
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream((InputStream) null);
      // Undeclared exception!
      try { 
        toNetASCIIInputStream0.available();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.ToNetASCIIInputStream"", e);
      }
  }"
559,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test11()  throws Throwable  {
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(mockFileInputStream0);
      try { 
        toNetASCIIInputStream0.available();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
      }
  }"
560,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test12()  throws Throwable  {
      File file0 = MockFile.createTempFile(""|J6FRxa z ,8a"", ""|J6FRxa z ,8a"");
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(mockFileInputStream0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(pushbackInputStream0);
      int int0 = toNetASCIIInputStream0.available();
}"
561,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test13()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)10;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      int int0 = toNetASCIIInputStream0.read();
}"
562,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test14()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)10;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      int int0 = toNetASCIIInputStream0.read();
      int int1 = toNetASCIIInputStream0.available();
}"
563,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test15()  throws Throwable  {
      byte[] byteArray0 = new byte[15];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      int int0 = toNetASCIIInputStream0.read(byteArray0, (int) (byte)6, (int) (byte)6);
}"
564,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test16()  throws Throwable  {
      byte[] byteArray0 = new byte[15];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      int int0 = toNetASCIIInputStream0.read(byteArray0, (int) (byte)6, (int) (byte)6);
}"
565,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test17()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      toNetASCIIInputStream0.read(byteArray0);
      int int0 = toNetASCIIInputStream0.read(byteArray0, (int) (byte)13, 1028);
}"
566,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test18()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      toNetASCIIInputStream0.read(byteArray0);
      int int0 = toNetASCIIInputStream0.read(byteArray0, (int) (byte)13, 1028);
}"
567,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test19()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      // Undeclared exception!
      try { 
        toNetASCIIInputStream0.read(byteArray0, (int) (byte)13, 1028);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 13
         //
         verifyException(""org.apache.commons.net.io.ToNetASCIIInputStream"", e);
      }
  }"
568,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test20()  throws Throwable  {
      File file0 = MockFile.createTempFile(""|J6FRxa z ,8a"", ""|J6FRxa z ,8a"");
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(mockFileInputStream0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(pushbackInputStream0);
      toNetASCIIInputStream0.read();
      byte[] byteArray0 = new byte[4];
      int int0 = toNetASCIIInputStream0.read(byteArray0, Integer.MAX_VALUE, 3811);
}"
569,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test21()  throws Throwable  {
      File file0 = MockFile.createTempFile(""|J6FRxa z ,8a"", ""|J6FRxa z ,8a"");
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(mockFileInputStream0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(pushbackInputStream0);
      toNetASCIIInputStream0.read();
      byte[] byteArray0 = new byte[4];
      int int0 = toNetASCIIInputStream0.read(byteArray0, Integer.MAX_VALUE, 3811);
}"
570,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test22()  throws Throwable  {
      byte[] byteArray0 = new byte[19];
      byteArray0[0] = (byte)13;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, (byte)93);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      int int0 = toNetASCIIInputStream0.read();
}"
571,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test23()  throws Throwable  {
      byte[] byteArray0 = new byte[19];
      byteArray0[0] = (byte)13;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, (byte)93);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      int int0 = toNetASCIIInputStream0.read();
}"
572,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test24()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)10;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      toNetASCIIInputStream0.read();
      int int0 = toNetASCIIInputStream0.read();
}"
573,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test25()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)10;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      toNetASCIIInputStream0.read();
      int int0 = toNetASCIIInputStream0.read();
}"
574,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test26()  throws Throwable  {
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream((InputStream) null);
      byte[] byteArray0 = new byte[4];
      int int0 = toNetASCIIInputStream0.read(byteArray0, (int) (byte) (-6), 0);
}"
575,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test27()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)10;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      toNetASCIIInputStream0.read(byteArray0);
      int int0 = toNetASCIIInputStream0.read();
}"
576,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test28()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)10;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      toNetASCIIInputStream0.read(byteArray0);
      int int0 = toNetASCIIInputStream0.read();
}"
577,"    public boolean markSupported()
    {
        return false;
    }","  public void test29()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      boolean boolean0 = toNetASCIIInputStream0.markSupported();
}"
578,"    public int available() throws IOException
    {
        final int result;

        result = in.available();

        if (status == LAST_WAS_NL) {
            return result + 1;
        }

        return result;
    }","  public void test30()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      toNetASCIIInputStream0.read(byteArray0);
      int int0 = toNetASCIIInputStream0.read(byteArray0);
}"
579,"    public int read() throws IOException
    {
        final int ch;

        if (status == LAST_WAS_NL)
        {
            status = NOTHING_SPECIAL;
            return '\n';
        }

        ch = in.read();

        switch (ch)
        {
        case '\r':
            status = LAST_WAS_CR;
            return '\r';
        case '\n':
            if (status != LAST_WAS_CR)
            {
                status = LAST_WAS_NL;
                return '\r';
            }
            //$FALL-THROUGH$
        default:
            status = NOTHING_SPECIAL;
            return ch;
        }
        // statement not reached
        //return ch;
    }","  public void test31()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ToNetASCIIInputStream toNetASCIIInputStream0 = new ToNetASCIIInputStream(byteArrayInputStream0);
      toNetASCIIInputStream0.read(byteArray0);
      int int0 = toNetASCIIInputStream0.read(byteArray0);
}"
580,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test0()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(byteArrayOutputStream0);
      byte[] byteArray0 = new byte[1];
      toNetASCIIOutputStream0.write(byteArray0, (int) (byte) (-27), (int) (byte) (-27));
}"
581,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test1()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("">"");
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(mockFileOutputStream0);
      byte[] byteArray0 = new byte[0];
      // Undeclared exception!
      try { 
        toNetASCIIOutputStream0.write(byteArray0, 91, 91);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 91
         //
         verifyException(""org.apache.commons.net.io.ToNetASCIIOutputStream"", e);
      }
  }"
582,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test2()  throws Throwable  {
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream((OutputStream) null);
      byte[] byteArray0 = new byte[6];
      // Undeclared exception!
      try { 
        toNetASCIIOutputStream0.write(byteArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.ToNetASCIIOutputStream"", e);
      }
  }"
583,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test3()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(pipedOutputStream0);
      byte[] byteArray0 = new byte[7];
      try { 
        toNetASCIIOutputStream0.write(byteArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedOutputStream"", e);
      }
  }"
584,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test4()  throws Throwable  {
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream((OutputStream) null);
      // Undeclared exception!
      try { 
        toNetASCIIOutputStream0.write((-21));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.ToNetASCIIOutputStream"", e);
      }
  }"
585,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test5()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(pipedOutputStream0);
      try { 
        toNetASCIIOutputStream0.write((-2345));
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedOutputStream"", e);
      }
  }"
586,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test6()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(byteArrayOutputStream0);
      // Undeclared exception!
      try { 
        toNetASCIIOutputStream0.write((byte[]) null, 0, 1);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.ToNetASCIIOutputStream"", e);
      }
  }"
587,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test7()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream(""DXE#k&t]G"");
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(mockPrintStream0);
      byte[] byteArray0 = new byte[6];
      toNetASCIIOutputStream0.write(byteArray0, (int) (byte)0, (int) (byte)0);
}"
588,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test8()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream(""DXE#k&t]G"");
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(mockPrintStream0);
      toNetASCIIOutputStream0.write(5);
  }"
589,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test9()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream(""$VALUES"");
      DataOutputStream dataOutputStream0 = new DataOutputStream(mockPrintStream0);
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(dataOutputStream0);
      toNetASCIIOutputStream0.write(13);
      toNetASCIIOutputStream0.write(10);
  }"
590,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test10()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""d47p,h,3//.m"", """");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(mockPrintStream0);
      byte[] byteArray0 = new byte[9];
      byteArray0[8] = (byte)13;
      toNetASCIIOutputStream0.write(byteArray0);
}"
591,"    public synchronized void write(final int ch)
    throws IOException
    {
        switch (ch)
        {
        case '\r':
            lastWasCR = true;
            out.write('\r');
            return ;
        case '\n':
            if (!lastWasCR) {
                out.write('\r');
            }
            //$FALL-THROUGH$
        default:
            lastWasCR = false;
            out.write(ch);
        }
    }","  public void test11()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream(""$VALUES"");
      DataOutputStream dataOutputStream0 = new DataOutputStream(mockPrintStream0);
      ToNetASCIIOutputStream toNetASCIIOutputStream0 = new ToNetASCIIOutputStream(dataOutputStream0);
      toNetASCIIOutputStream0.write(10);
  }"
592,"    public void write(final byte buffer[], final int offset, final int length) throws IOException
    {
        out.write(buffer, offset, length);
    }","  public void test0()  throws Throwable  {
      Proxy.Type proxy_Type0 = Proxy.Type.SOCKS;
      MockInetSocketAddress mockInetSocketAddress0 = new MockInetSocketAddress(63);
      Proxy proxy0 = new Proxy(proxy_Type0, mockInetSocketAddress0);
      MockSocket mockSocket0 = new MockSocket(proxy0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(""d|e^>X<I)\""op=O!N%%'"");
      SocketOutputStream socketOutputStream0 = new SocketOutputStream(mockSocket0, mockPrintStream0);
      socketOutputStream0.close();
      byte[] byteArray0 = new byte[2];
      socketOutputStream0.write(byteArray0, (-597), 63);
}"
593,"    public void write(final byte buffer[], final int offset, final int length) throws IOException
    {
        out.write(buffer, offset, length);
    }","  public void test1()  throws Throwable  {
      MockSocket mockSocket0 = new MockSocket();
      SocketOutputStream socketOutputStream0 = new SocketOutputStream(mockSocket0, (OutputStream) null);
      byte[] byteArray0 = new byte[9];
      // Undeclared exception!
      try { 
        socketOutputStream0.write(byteArray0, (-1661), (int) (byte)31);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.io.SocketOutputStream"", e);
      }
  }"
594,"    public void write(final byte buffer[], final int offset, final int length) throws IOException
    {
        out.write(buffer, offset, length);
    }","  public void test2()  throws Throwable  {
      MockSocket mockSocket0 = new MockSocket();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(63);
      SocketOutputStream socketOutputStream0 = new SocketOutputStream(mockSocket0, byteArrayOutputStream0);
      byte[] byteArray0 = new byte[3];
      // Undeclared exception!
      try { 
        socketOutputStream0.write(byteArray0, (-616), (-616));
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ByteArrayOutputStream"", e);
      }
  }"
595,"    public void write(final byte buffer[], final int offset, final int length) throws IOException
    {
        out.write(buffer, offset, length);
    }","  public void test3()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      MockSocket mockSocket0 = new MockSocket(proxy0);
      File file0 = MockFile.createTempFile(""n5MiRy!"", """");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(file0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0, true);
      SocketOutputStream socketOutputStream0 = new SocketOutputStream(mockSocket0, mockPrintStream0);
      byte[] byteArray0 = new byte[9];
      // Undeclared exception!
      try { 
        socketOutputStream0.write(byteArray0, (-1883), 348);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1883
         //
         verifyException(""org.evosuite.runtime.vfs.VFile"", e);
      }
  }"
596,"    public void close() throws IOException
    {
        super.close();
        socket.close();
    }","  public void test4()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      MockSocket mockSocket0 = new MockSocket(proxy0);
      SocketOutputStream socketOutputStream0 = new SocketOutputStream(mockSocket0, (OutputStream) null);
      // Undeclared exception!
      try { 
        socketOutputStream0.close();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.FilterOutputStream"", e);
      }
  }"
597,"    public void write(final byte buffer[], final int offset, final int length) throws IOException
    {
        out.write(buffer, offset, length);
    }","  public void test5()  throws Throwable  {
      Proxy proxy0 = Proxy.NO_PROXY;
      MockSocket mockSocket0 = new MockSocket(proxy0);
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""org.apache.commons.io.filefilter.AbstractFileFilter"");
      SocketOutputStream socketOutputStream0 = new SocketOutputStream(mockSocket0, mockFileOutputStream0);
      byte[] byteArray0 = new byte[8];
      try { 
        socketOutputStream0.write(byteArray0, 0, (-1));
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Error in writing to file
         //
         verifyException(""org.evosuite.runtime.mock.java.io.NativeMockedIO"", e);
      }
  }"
598,"    public String toString() {
        return super.toString() + "" RRQ "" + getFilename() + "" "" + TFTP.getModeName(getMode());
    }","  public void test0()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 0, """", 0);
      String string0 = tFTPReadRequestPacket0.toString();
}"
599,"    public TFTPReadRequestPacket(final InetAddress destination, final int port,
                                 final String fileName, final int mode)
    {
        super(destination, port, TFTPPacket.READ_REQUEST, fileName, mode);
    }","  public void test1()  throws Throwable  {
      byte[] byteArray0 = new byte[2];
      MockInetSocketAddress mockInetSocketAddress0 = new MockInetSocketAddress(1);
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)2, mockInetSocketAddress0);
      TFTPReadRequestPacket tFTPReadRequestPacket0 = null;
      try {
        tFTPReadRequestPacket0 = new TFTPReadRequestPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Throwable e) {
         //
         // TFTP operator code does not match type.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
600,"    public TFTPReadRequestPacket(final InetAddress destination, final int port,
                                 final String fileName, final int mode)
    {
        super(destination, port, TFTPPacket.READ_REQUEST, fileName, mode);
    }","  public void test2()  throws Throwable  {
      TFTPReadRequestPacket tFTPReadRequestPacket0 = null;
      try {
        tFTPReadRequestPacket0 = new TFTPReadRequestPacket((DatagramPacket) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
601,"    public TFTPReadRequestPacket(final InetAddress destination, final int port,
                                 final String fileName, final int mode)
    {
        super(destination, port, TFTPPacket.READ_REQUEST, fileName, mode);
    }","  public void test3()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      MockInetSocketAddress mockInetSocketAddress0 = new MockInetSocketAddress((byte)0);
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0, 0, mockInetSocketAddress0);
      TFTPReadRequestPacket tFTPReadRequestPacket0 = null;
      try {
        tFTPReadRequestPacket0 = new TFTPReadRequestPacket(datagramPacket0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
602,"    public TFTPReadRequestPacket(final InetAddress destination, final int port,
                                 final String fileName, final int mode)
    {
        super(destination, port, TFTPPacket.READ_REQUEST, fileName, mode);
    }","  public void test4()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 8, """", 1);
      DatagramPacket datagramPacket0 = tFTPReadRequestPacket0.newDatagram();
      TFTPPacket tFTPPacket0 = TFTPPacket.newTFTPPacket(datagramPacket0);
}"
603,"    public String toString() {
        return super.toString() + "" RRQ "" + getFilename() + "" "" + TFTP.getModeName(getMode());
    }","  public void test5()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 255, ""%X:TshiR$t"", 255);
      // Undeclared exception!
      try { 
        tFTPReadRequestPacket0.toString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 255
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
604,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test0()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 0, 1712, ""+mf/7*do1,x>K^^&"");
      tFTPErrorPacket0.type = 0;
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      byte[] byteArray0 = new byte[5];
      // Undeclared exception!
      try { 
        tFTPErrorPacket0.newDatagram(datagramPacket0, byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
      }
  }"
605,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test1()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 0, 0, """");
      byte[] byteArray0 = new byte[7];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, 2);
      tFTPErrorPacket0.newDatagram(datagramPacket0, byteArray0);
}"
606,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test2()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 0, 0, """");
      byte[] byteArray0 = new byte[7];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, 2);
      tFTPErrorPacket0.newDatagram(datagramPacket0, byteArray0);
}"
607,"    public int getError()
    {
        return error;
    }","  public void test3()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 0, 1959, ""G>i"");
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
}"
608,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test4()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 0, 1959, ""G>i"");
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
}"
609,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test5()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 0, 1959, ""G>i"");
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
}"
610,"    public int getError()
    {
        return error;
    }","  public void test6()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 47, 0, (String) null);
      tFTPErrorPacket0.getMessage();
}"
611,"    public int getError()
    {
        return error;
    }","  public void test7()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), ""u-)"");
      tFTPErrorPacket0.getMessage();
}"
612,"    public int getError()
    {
        return error;
    }","  public void test8()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 0, 0, ""I-;Q$3w(xEpc?"");
      int int0 = tFTPErrorPacket0.getError();
}"
613,"    public int getError()
    {
        return error;
    }","  public void test9()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 1929, 1929, ""u-)"");
      int int0 = tFTPErrorPacket0.getError();
}"
614,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test10()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1), (-1), "" "");
      // Undeclared exception!
      try { 
        tFTPErrorPacket0.newDatagram((DatagramPacket) null, (byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPErrorPacket"", e);
      }
  }"
615,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test11()  throws Throwable  {
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket((InetAddress) null, (-38), (-38), """");
      byte[] byteArray0 = new byte[7];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, 5);
      // Undeclared exception!
      try { 
        tFTPErrorPacket0.newDatagram(datagramPacket0, byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-38
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
616,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test12()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), ""Bad file name and mode format."");
      tFTPErrorPacket0.port = 270;
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      byte[] byteArray0 = new byte[8];
      // Undeclared exception!
      try { 
        tFTPErrorPacket0.newDatagram(datagramPacket0, byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
      }
  }"
617,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test13()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-158), (-158), (String) null);
      // Undeclared exception!
      try { 
        tFTPErrorPacket0.newDatagram();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPErrorPacket"", e);
      }
  }"
618,"    public TFTPErrorPacket(final InetAddress destination, final int port,
                           final int error, final String message)
    {
        super(TFTPPacket.ERROR, destination, port);

        this.error = error;
        this.message = message;
    }","  public void test14()  throws Throwable  {
      TFTPErrorPacket tFTPErrorPacket0 = null;
      try {
        tFTPErrorPacket0 = new TFTPErrorPacket((DatagramPacket) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPErrorPacket"", e);
      }
  }"
619,"    public TFTPErrorPacket(final InetAddress destination, final int port,
                           final int error, final String message)
    {
        super(TFTPPacket.ERROR, destination, port);

        this.error = error;
        this.message = message;
    }","  public void test15()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0);
      TFTPErrorPacket tFTPErrorPacket0 = null;
      try {
        tFTPErrorPacket0 = new TFTPErrorPacket(datagramPacket0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.tftp.TFTPErrorPacket"", e);
      }
  }"
620,"    public TFTPErrorPacket(final InetAddress destination, final int port,
                           final int error, final String message)
    {
        super(TFTPPacket.ERROR, destination, port);

        this.error = error;
        this.message = message;
    }","  public void test16()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), ""u-)"");
      tFTPErrorPacket0.port = 270;
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      byte[] byteArray0 = new byte[9];
      DatagramPacket datagramPacket1 = tFTPErrorPacket0.newDatagram(datagramPacket0, byteArray0);
      TFTPErrorPacket tFTPErrorPacket1 = new TFTPErrorPacket(datagramPacket1);
}"
621,"    public int getError()
    {
        return error;
    }","  public void test17()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), ""u-)"");
      tFTPErrorPacket0.port = 270;
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      byte[] byteArray0 = new byte[9];
      DatagramPacket datagramPacket1 = tFTPErrorPacket0.newDatagram(datagramPacket0, byteArray0);
      TFTPErrorPacket tFTPErrorPacket1 = new TFTPErrorPacket(datagramPacket1);
}"
622,"    public TFTPErrorPacket(final InetAddress destination, final int port,
                           final int error, final String message)
    {
        super(TFTPPacket.ERROR, destination, port);

        this.error = error;
        this.message = message;
    }","  public void test18()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), ""u-)"");
      tFTPErrorPacket0.port = 270;
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      TFTPErrorPacket tFTPErrorPacket1 = new TFTPErrorPacket(datagramPacket0);
}"
623,"    public String getMessage()
    {
        return message;
    }","  public void test19()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), ""u-)"");
      tFTPErrorPacket0.port = 270;
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      TFTPErrorPacket tFTPErrorPacket1 = new TFTPErrorPacket(datagramPacket0);
}"
624,"    public int getError()
    {
        return error;
    }","  public void test20()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), ""u-)"");
      tFTPErrorPacket0.port = 270;
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      TFTPErrorPacket tFTPErrorPacket1 = new TFTPErrorPacket(datagramPacket0);
}"
625,"    public TFTPErrorPacket(final InetAddress destination, final int port,
                           final int error, final String message)
    {
        super(TFTPPacket.ERROR, destination, port);

        this.error = error;
        this.message = message;
    }","  public void test21()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), ""u-)"");
      tFTPErrorPacket0.port = 270;
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      TFTPErrorPacket tFTPErrorPacket1 = new TFTPErrorPacket(datagramPacket0);
}"
626,"    public TFTPErrorPacket(final InetAddress destination, final int port,
                           final int error, final String message)
    {
        super(TFTPPacket.ERROR, destination, port);

        this.error = error;
        this.message = message;
    }","  public void test22()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      byteArray0[1] = (byte)5;
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)5, (byte)0);
      TFTPErrorPacket tFTPErrorPacket0 = null;
      try {
        tFTPErrorPacket0 = new TFTPErrorPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Throwable e) {
         //
         // Bad error packet. No message.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPErrorPacket"", e);
      }
  }"
627,"    public TFTPErrorPacket(final InetAddress destination, final int port,
                           final int error, final String message)
    {
        super(TFTPPacket.ERROR, destination, port);

        this.error = error;
        this.message = message;
    }","  public void test23()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      InetAddress inetAddress0 = MockInetAddress.getByAddress(byteArray0);
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0, inetAddress0, (byte)0);
      TFTPErrorPacket tFTPErrorPacket0 = null;
      try {
        tFTPErrorPacket0 = new TFTPErrorPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Throwable e) {
         //
         // TFTP operator code does not match type.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPErrorPacket"", e);
      }
  }"
628,"    public String toString() {
        return super.toString() + "" ERR "" + error + "" "" + message;
    }","  public void test24()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), """");
      String string0 = tFTPErrorPacket0.toString();
}"
629,"    public int getError()
    {
        return error;
    }","  public void test25()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), """");
      int int0 = tFTPErrorPacket0.getError();
}"
630,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int length;

        length = message.length();

        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((error & 0xffff) >> 8);
        data[3] = (byte)(error & 0xff);

        System.arraycopy(message.getBytes(), 0, data, 4, length);

        data[length + 4] = 0;

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test26()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), """");
      // Undeclared exception!
      try { 
        tFTPErrorPacket0.newDatagram();
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-1348
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
631,"    public int getError()
    {
        return error;
    }","  public void test27()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-1348), (-26), """");
      tFTPErrorPacket0.getMessage();
}"
632,"    public String toString() {
        return super.toString() + "" WRQ "" + getFilename() + "" "" + TFTP.getModeName(getMode());
    }","  public void test0()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""N"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, (-57), ""N"", (-57));
      // Undeclared exception!
      try { 
        tFTPWriteRequestPacket0.toString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -57
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
633,"    public TFTPWriteRequestPacket(final InetAddress destination, final int port,
                                  final String fileName, final int mode)
    {
        super(destination, port, TFTPPacket.WRITE_REQUEST, fileName, mode);
    }","  public void test1()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, 0);
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = null;
      try {
        tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Throwable e) {
         //
         // TFTP operator code does not match type.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
634,"    public TFTPWriteRequestPacket(final InetAddress destination, final int port,
                                  final String fileName, final int mode)
    {
        super(destination, port, TFTPPacket.WRITE_REQUEST, fileName, mode);
    }","  public void test2()  throws Throwable  {
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = null;
      try {
        tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket((DatagramPacket) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
635,"    public TFTPWriteRequestPacket(final InetAddress destination, final int port,
                                  final String fileName, final int mode)
    {
        super(destination, port, TFTPPacket.WRITE_REQUEST, fileName, mode);
    }","  public void test3()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      MockInetSocketAddress mockInetSocketAddress0 = new MockInetSocketAddress(124);
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0, (byte)0, mockInetSocketAddress0);
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = null;
      try {
        tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(datagramPacket0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
636,"    public TFTPWriteRequestPacket(final InetAddress destination, final int port,
                                  final String fileName, final int mode)
    {
        super(destination, port, TFTPPacket.WRITE_REQUEST, fileName, mode);
    }","  public void test4()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, ""+"", 0);
      DatagramPacket datagramPacket0 = tFTPWriteRequestPacket0.newDatagram();
      TFTPPacket tFTPPacket0 = TFTPPacket.newTFTPPacket(datagramPacket0);
}"
637,"    public String toString() {
        return super.toString() + "" WRQ "" + getFilename() + "" "" + TFTP.getModeName(getMode());
    }","  public void test5()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, ""+"", 0);
      String string0 = tFTPWriteRequestPacket0.toString();
}"
638,"    public final int getPort()
    {
        return port;
    }","  public void test0()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName("" WRQ "");
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      InetAddress inetAddress1 = MockInetAddress.getLocalHost();
      tFTPDataPacket0.setAddress(inetAddress1);
}"
639,"    public final int getType()
    {
        return type;
    }","  public void test1()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName("" WRQ "");
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      InetAddress inetAddress1 = MockInetAddress.getLocalHost();
      tFTPDataPacket0.setAddress(inetAddress1);
}"
640,"    public String toString() {
        return address + "" "" + port + "" "" + type;
    }","  public void test2()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 1561, 1561, (String) null);
      String string0 = tFTPErrorPacket0.toString();
}"
641,"    public final int getPort()
    {
        return port;
    }","  public void test3()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-505), (-505), ""N'!MH^FF&D;(29"");
}"
642,"    public final int getPort()
    {
        return port;
    }","  public void test4()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-505), (-505), ""N'!MH^FF&D;(29"");
      tFTPErrorPacket0.setPort(0);
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      TFTPPacket.newTFTPPacket(datagramPacket0);
}"
643,"    public final int getPort()
    {
        return port;
    }","  public void test5()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      tFTPDataPacket0.newDatagram();
}"
644,"    public final int getType()
    {
        return type;
    }","  public void test6()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      tFTPDataPacket0.newDatagram();
}"
645,"    public final int getPort()
    {
        return port;
    }","  public void test7()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 8, 5, """");
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
}"
646,"    public final int getType()
    {
        return type;
    }","  public void test8()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 8, 5, """");
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
}"
647,"    public final int getType()
    {
        return type;
    }","  public void test9()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-505), (-505), ""N'!MH^FF&D;(29"");
}"
648,"    public final int getPort()
    {
        return port;
    }","  public void test10()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-505), (-505), ""N'!MH^FF&D;(29"");
      tFTPErrorPacket0.type = 0;
      tFTPErrorPacket0.getType();
}"
649,"    public final int getType()
    {
        return type;
    }","  public void test11()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 5, byteArray0);
}"
650,"    public final int getPort()
    {
        return port;
    }","  public void test12()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 5, byteArray0);
      tFTPDataPacket0.type = (-2018);
      tFTPDataPacket0.getType();
}"
651,"    public final int getPort()
    {
        return port;
    }","  public void test13()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-505), (-505), ""N'!MH^FF&D;(29"");
}"
652,"    public final int getPort()
    {
        return port;
    }","  public void test14()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-505), (-505), ""N'!MH^FF&D;(29"");
      tFTPErrorPacket0.setPort(0);
      int int0 = tFTPErrorPacket0.getPort();
}"
653,"    public final int getPort()
    {
        return port;
    }","  public void test15()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-3177), (-3177), (byte[]) null, (-3177), (-2537));
      int int0 = tFTPDataPacket0.getPort();
}"
654,"    public final int getType()
    {
        return type;
    }","  public void test16()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-3177), (-3177), (byte[]) null, (-3177), (-2537));
      int int0 = tFTPDataPacket0.getPort();
}"
655,"    public final int getType()
    {
        return type;
    }","  public void test17()  throws Throwable  {
      byte[] byteArray0 = new byte[6];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket((InetAddress) null, 2, 2, byteArray0, 2667, (byte)105);
      tFTPDataPacket0.getAddress();
}"
656,"    public final int getPort()
    {
        return port;
    }","  public void test18()  throws Throwable  {
      byte[] byteArray0 = new byte[6];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket((InetAddress) null, 2, 2, byteArray0, 2667, (byte)105);
      tFTPDataPacket0.getAddress();
}"
657,"    public final int getPort()
    {
        return port;
    }","  public void test19()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-17);
      InetAddress inetAddress0 = MockInetAddress.getByAddress(""*o)#"", byteArray0);
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 516, (String) null, (byte)68);
      InetAddress inetAddress1 = tFTPWriteRequestPacket0.getAddress();
}"
658,"    public final int getType()
    {
        return type;
    }","  public void test20()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-17);
      InetAddress inetAddress0 = MockInetAddress.getByAddress(""*o)#"", byteArray0);
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 516, (String) null, (byte)68);
      InetAddress inetAddress1 = tFTPWriteRequestPacket0.getAddress();
}"
659,"    public final InetAddress getAddress()
    {
        return address;
    }","  public void test21()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-17);
      InetAddress inetAddress0 = MockInetAddress.getByAddress(""*o)#"", byteArray0);
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 516, (String) null, (byte)68);
      InetAddress inetAddress1 = tFTPWriteRequestPacket0.getAddress();
}"
660,"    public final int getType()
    {
        return type;
    }","  public void test22()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 0, ""Bad packet.  Invalid TFTP operator code."", 0);
      InetAddress inetAddress1 = tFTPReadRequestPacket0.getAddress();
}"
661,"    public final int getPort()
    {
        return port;
    }","  public void test23()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 0, ""Bad packet.  Invalid TFTP operator code."", 0);
      InetAddress inetAddress1 = tFTPReadRequestPacket0.getAddress();
}"
662,"    public final InetAddress getAddress()
    {
        return address;
    }","  public void test24()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 0, ""Bad packet.  Invalid TFTP operator code."", 0);
      InetAddress inetAddress1 = tFTPReadRequestPacket0.getAddress();
}"
663,"    public String toString() {
        return address + "" "" + port + "" "" + type;
    }","  public void test25()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName("" RRQ "");
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 17, """", 5);
      // Undeclared exception!
      try { 
        tFTPReadRequestPacket0.toString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 5
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
664,"    public static final TFTPPacket newTFTPPacket(final DatagramPacket datagram)
    throws TFTPPacketException
    {
        final byte[] data;
        TFTPPacket packet = null;

        if (datagram.getLength() < MIN_PACKET_SIZE) {
            throw new TFTPPacketException(
                ""Bad packet. Datagram data length is too short."");
        }

        data = datagram.getData();

        switch (data[1])
        {
        case READ_REQUEST:
            packet = new TFTPReadRequestPacket(datagram);
            break;
        case WRITE_REQUEST:
            packet = new TFTPWriteRequestPacket(datagram);
            break;
        case DATA:
            packet = new TFTPDataPacket(datagram);
            break;
        case ACKNOWLEDGEMENT:
            packet = new TFTPAckPacket(datagram);
            break;
        case ERROR:
            packet = new TFTPErrorPacket(datagram);
            break;
        default:
            throw new TFTPPacketException(
                ""Bad packet.  Invalid TFTP operator code."");
        }

        return packet;
    }","  public void test26()  throws Throwable  {
      // Undeclared exception!
      try { 
        TFTPPacket.newTFTPPacket((DatagramPacket) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPPacket"", e);
      }
  }"
665,"    abstract DatagramPacket newDatagram(DatagramPacket datagram, byte[] data);

    /**
     * Creates a UDP datagram containing all the TFTP packet
     * data in the proper format.
     * This is an abstract method, exposed to the programmer in case he
     * wants to implement his own TFTP client instead of using
     * the {@link org.apache.commons.net.tftp.TFTPClient}","  public void test27()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 1561, 1561, (String) null);
      // Undeclared exception!
      try { 
        tFTPErrorPacket0.newDatagram();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPErrorPacket"", e);
      }
  }"
666,"    abstract DatagramPacket newDatagram(DatagramPacket datagram, byte[] data);

    /**
     * Creates a UDP datagram containing all the TFTP packet
     * data in the proper format.
     * This is an abstract method, exposed to the programmer in case he
     * wants to implement his own TFTP client instead of using
     * the {@link org.apache.commons.net.tftp.TFTPClient}","  public void test28()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      InetAddress inetAddress0 = MockInetAddress.getByAddress(byteArray0);
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (byte)5, (-598), byteArray0, 5, (-1829));
      // Undeclared exception!
      try { 
        tFTPDataPacket0.newDatagram();
        fail(""Expecting exception: NegativeArraySizeException"");
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPDataPacket"", e);
      }
  }"
667,"    abstract DatagramPacket newDatagram(DatagramPacket datagram, byte[] data);

    /**
     * Creates a UDP datagram containing all the TFTP packet
     * data in the proper format.
     * This is an abstract method, exposed to the programmer in case he
     * wants to implement his own TFTP client instead of using
     * the {@link org.apache.commons.net.tftp.TFTPClient}","  public void test29()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-791), 4, byteArray0);
      // Undeclared exception!
      try { 
        tFTPDataPacket0.newDatagram();
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-791
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
668,"    abstract DatagramPacket newDatagram(DatagramPacket datagram, byte[] data);

    /**
     * Creates a UDP datagram containing all the TFTP packet
     * data in the proper format.
     * This is an abstract method, exposed to the programmer in case he
     * wants to implement his own TFTP client instead of using
     * the {@link org.apache.commons.net.tftp.TFTPClient}","  public void test30()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      InetAddress inetAddress0 = MockInetAddress.getByAddress(""mh"", byteArray0);
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, (byte) (-51), ""mh"", 656);
      // Undeclared exception!
      try { 
        tFTPWriteRequestPacket0.newDatagram();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 656
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
669,"    public final int getType()
    {
        return type;
    }","  public void test31()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 8, 5, """");
      int int0 = tFTPErrorPacket0.getType();
}"
670,"    public final int getPort()
    {
        return port;
    }","  public void test32()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 8, 5, """");
      int int0 = tFTPErrorPacket0.getType();
}"
671,"    public static final TFTPPacket newTFTPPacket(final DatagramPacket datagram)
    throws TFTPPacketException
    {
        final byte[] data;
        TFTPPacket packet = null;

        if (datagram.getLength() < MIN_PACKET_SIZE) {
            throw new TFTPPacketException(
                ""Bad packet. Datagram data length is too short."");
        }

        data = datagram.getData();

        switch (data[1])
        {
        case READ_REQUEST:
            packet = new TFTPReadRequestPacket(datagram);
            break;
        case WRITE_REQUEST:
            packet = new TFTPWriteRequestPacket(datagram);
            break;
        case DATA:
            packet = new TFTPDataPacket(datagram);
            break;
        case ACKNOWLEDGEMENT:
            packet = new TFTPAckPacket(datagram);
            break;
        case ERROR:
            packet = new TFTPErrorPacket(datagram);
            break;
        default:
            throw new TFTPPacketException(
                ""Bad packet.  Invalid TFTP operator code."");
        }

        return packet;
    }","  public void test33()  throws Throwable  {
      byte[] byteArray0 = new byte[17];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)9);
      try { 
        TFTPPacket.newTFTPPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Bad packet.  Invalid TFTP operator code.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPPacket"", e);
      }
  }"
672,"    public final int getPort()
    {
        return port;
    }","  public void test34()  throws Throwable  {
      byte[] byteArray0 = new byte[6];
      byteArray0[1] = (byte)4;
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)4);
      TFTPPacket tFTPPacket0 = TFTPPacket.newTFTPPacket(datagramPacket0);
}"
673,"    public static final TFTPPacket newTFTPPacket(final DatagramPacket datagram)
    throws TFTPPacketException
    {
        final byte[] data;
        TFTPPacket packet = null;

        if (datagram.getLength() < MIN_PACKET_SIZE) {
            throw new TFTPPacketException(
                ""Bad packet. Datagram data length is too short."");
        }

        data = datagram.getData();

        switch (data[1])
        {
        case READ_REQUEST:
            packet = new TFTPReadRequestPacket(datagram);
            break;
        case WRITE_REQUEST:
            packet = new TFTPWriteRequestPacket(datagram);
            break;
        case DATA:
            packet = new TFTPDataPacket(datagram);
            break;
        case ACKNOWLEDGEMENT:
            packet = new TFTPAckPacket(datagram);
            break;
        case ERROR:
            packet = new TFTPErrorPacket(datagram);
            break;
        default:
            throw new TFTPPacketException(
                ""Bad packet.  Invalid TFTP operator code."");
        }

        return packet;
    }","  public void test35()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0);
      InetAddress inetAddress0 = MockInetAddress.getByName(""4kf"");
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 446, 446, byteArray0, 446, 0);
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray0);
      TFTPPacket.newTFTPPacket(datagramPacket0);
}"
674,"    public final int getPort()
    {
        return port;
    }","  public void test36()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0);
      InetAddress inetAddress0 = MockInetAddress.getByName(""4kf"");
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 446, 446, byteArray0, 446, 0);
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray0);
      TFTPPacket.newTFTPPacket(datagramPacket0);
}"
675,"    public static final TFTPPacket newTFTPPacket(final DatagramPacket datagram)
    throws TFTPPacketException
    {
        final byte[] data;
        TFTPPacket packet = null;

        if (datagram.getLength() < MIN_PACKET_SIZE) {
            throw new TFTPPacketException(
                ""Bad packet. Datagram data length is too short."");
        }

        data = datagram.getData();

        switch (data[1])
        {
        case READ_REQUEST:
            packet = new TFTPReadRequestPacket(datagram);
            break;
        case WRITE_REQUEST:
            packet = new TFTPWriteRequestPacket(datagram);
            break;
        case DATA:
            packet = new TFTPDataPacket(datagram);
            break;
        case ACKNOWLEDGEMENT:
            packet = new TFTPAckPacket(datagram);
            break;
        case ERROR:
            packet = new TFTPErrorPacket(datagram);
            break;
        default:
            throw new TFTPPacketException(
                ""Bad packet.  Invalid TFTP operator code."");
        }

        return packet;
    }","  public void test37()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, (-505), (-505), """");
      tFTPErrorPacket0.setPort(5);
      DatagramPacket datagramPacket0 = tFTPErrorPacket0.newDatagram();
      byte[] byteArray0 = new byte[7];
      byteArray0[1] = (byte)2;
      datagramPacket0.setData(byteArray0);
      try { 
        TFTPPacket.newTFTPPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Unrecognized TFTP transfer mode: 
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
676,"    public static final TFTPPacket newTFTPPacket(final DatagramPacket datagram)
    throws TFTPPacketException
    {
        final byte[] data;
        TFTPPacket packet = null;

        if (datagram.getLength() < MIN_PACKET_SIZE) {
            throw new TFTPPacketException(
                ""Bad packet. Datagram data length is too short."");
        }

        data = datagram.getData();

        switch (data[1])
        {
        case READ_REQUEST:
            packet = new TFTPReadRequestPacket(datagram);
            break;
        case WRITE_REQUEST:
            packet = new TFTPWriteRequestPacket(datagram);
            break;
        case DATA:
            packet = new TFTPDataPacket(datagram);
            break;
        case ACKNOWLEDGEMENT:
            packet = new TFTPAckPacket(datagram);
            break;
        case ERROR:
            packet = new TFTPErrorPacket(datagram);
            break;
        default:
            throw new TFTPPacketException(
                ""Bad packet.  Invalid TFTP operator code."");
        }

        return packet;
    }","  public void test38()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[1] = (byte)1;
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)1);
      datagramPacket0.setData(byteArray0);
      try { 
        TFTPPacket.newTFTPPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Unrecognized TFTP transfer mode: 
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
677,"    public static final TFTPPacket newTFTPPacket(final DatagramPacket datagram)
    throws TFTPPacketException
    {
        final byte[] data;
        TFTPPacket packet = null;

        if (datagram.getLength() < MIN_PACKET_SIZE) {
            throw new TFTPPacketException(
                ""Bad packet. Datagram data length is too short."");
        }

        data = datagram.getData();

        switch (data[1])
        {
        case READ_REQUEST:
            packet = new TFTPReadRequestPacket(datagram);
            break;
        case WRITE_REQUEST:
            packet = new TFTPWriteRequestPacket(datagram);
            break;
        case DATA:
            packet = new TFTPDataPacket(datagram);
            break;
        case ACKNOWLEDGEMENT:
            packet = new TFTPAckPacket(datagram);
            break;
        case ERROR:
            packet = new TFTPErrorPacket(datagram);
            break;
        default:
            throw new TFTPPacketException(
                ""Bad packet.  Invalid TFTP operator code."");
        }

        return packet;
    }","  public void test39()  throws Throwable  {
      byte[] byteArray0 = new byte[23];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0);
      try { 
        TFTPPacket.newTFTPPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Bad packet. Datagram data length is too short.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPPacket"", e);
      }
  }"
678,"    public final int getType()
    {
        return type;
    }","  public void test40()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 39, 39, ""CBlD"");
      InetAddress inetAddress1 = tFTPErrorPacket0.getAddress();
}"
679,"    public final int getPort()
    {
        return port;
    }","  public void test41()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 39, 39, ""CBlD"");
      InetAddress inetAddress1 = tFTPErrorPacket0.getAddress();
}"
680,"    public final InetAddress getAddress()
    {
        return address;
    }","  public void test42()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 39, 39, ""CBlD"");
      InetAddress inetAddress1 = tFTPErrorPacket0.getAddress();
}"
681,"    public final int getType()
    {
        return type;
    }","  public void test43()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 39, 39, ""CBlD"");
      int int0 = tFTPErrorPacket0.getPort();
}"
682,"    public final int getPort()
    {
        return port;
    }","  public void test44()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket(inetAddress0, 39, 39, ""CBlD"");
      int int0 = tFTPErrorPacket0.getPort();
}"
683,"    public int getDataOffset()
    {
        return offset;
    }","  public void test0()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 1, byteArray0);
      String string0 = tFTPDataPacket0.toString();
}"
684,"    public String toString() {
        return super.toString() + "" DATA "" + blockNumber + "" "" + length;
    }","  public void test1()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 1, byteArray0);
      String string0 = tFTPDataPacket0.toString();
}"
685,"    public int getDataOffset()
    {
        return offset;
    }","  public void test2()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[6];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 255, 255, byteArray0);
      tFTPDataPacket0.setData(byteArray0, 392, 512);
}"
686,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test3()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[6];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 255, 255, byteArray0);
}"
687,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test4()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[6];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 255, 255, byteArray0);
      tFTPDataPacket0.setBlockNumber(0);
}"
688,"    public int getDataOffset()
    {
        return offset;
    }","  public void test5()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName((String) null);
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      tFTPDataPacket0.type = (int) (byte) (-52);
}"
689,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test6()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName((String) null);
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      tFTPDataPacket0.type = (int) (byte) (-52);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
}"
690,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test7()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName((String) null);
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      tFTPDataPacket0.type = (int) (byte) (-52);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
}"
691,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test8()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName((String) null);
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      tFTPDataPacket0.type = (int) (byte) (-52);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
}"
692,"    public int getDataLength()
    {
        return length;
    }","  public void test9()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName((String) null);
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      tFTPDataPacket0.type = (int) (byte) (-52);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
}"
693,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test10()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[8];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 1029, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      TFTPDataPacket tFTPDataPacket1 = (TFTPDataPacket)TFTPPacket.newTFTPPacket(datagramPacket0);
      // Undeclared exception!
      try { 
        tFTPDataPacket1.newDatagram(datagramPacket0, byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
      }
  }"
694,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test11()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName((String) null);
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      tFTPDataPacket0.type = (int) (byte) (-52);
      // Undeclared exception!
      try { 
        tFTPDataPacket0.newDatagram(datagramPacket0, byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // illegal length
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
695,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test12()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[8];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 1029, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      tFTPDataPacket0.setData(byteArray0, 0, (byte)0);
      tFTPDataPacket0.setPort(1043);
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray0);
}"
696,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test13()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[8];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 1029, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      tFTPDataPacket0.setData(byteArray0, 0, (byte)0);
      tFTPDataPacket0.setPort(1043);
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray0);
}"
697,"    public int getDataOffset()
    {
        return offset;
    }","  public void test14()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[2];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 1, 1, byteArray0);
}"
698,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test15()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[2];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 1, 1, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
}"
699,"    public int getDataLength()
    {
        return length;
    }","  public void test16()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[2];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 1, 1, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
}"
700,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test17()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[2];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 1, 1, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
}"
701,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test18()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[2];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 1, 1, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
}"
702,"    public int getDataOffset()
    {
        return offset;
    }","  public void test19()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[2];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-4843), 114, byteArray0);
      tFTPDataPacket0.setData(byteArray0, 114, (-622));
      int int0 = tFTPDataPacket0.getDataOffset();
}"
703,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test20()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[7];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-410), (-410), byteArray0, (byte) (-1), (byte) (-99));
      int int0 = tFTPDataPacket0.getDataOffset();
}"
704,"    public int getDataOffset()
    {
        return offset;
    }","  public void test21()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[7];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-410), (-410), byteArray0, (byte) (-1), (byte) (-99));
      int int0 = tFTPDataPacket0.getDataOffset();
}"
705,"    public int getDataLength()
    {
        return length;
    }","  public void test22()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[7];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-410), (-410), byteArray0, (byte) (-1), (byte) (-99));
      int int0 = tFTPDataPacket0.getDataOffset();
}"
706,"    public int getDataOffset()
    {
        return offset;
    }","  public void test23()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[9];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-3254), (-3254), byteArray0, (byte)0, (byte)0);
      int int0 = tFTPDataPacket0.getDataLength();
}"
707,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test24()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[9];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-3254), (-3254), byteArray0, (byte)0, (byte)0);
      int int0 = tFTPDataPacket0.getDataLength();
}"
708,"    public int getDataLength()
    {
        return length;
    }","  public void test25()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[9];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-3254), (-3254), byteArray0, (byte)0, (byte)0);
      int int0 = tFTPDataPacket0.getDataLength();
}"
709,"    public int getDataLength()
    {
        return length;
    }","  public void test26()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[2];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-4843), 114, byteArray0);
      tFTPDataPacket0.setData(byteArray0, 114, (-622));
      int int0 = tFTPDataPacket0.getDataLength();
}"
710,"    public int getDataLength()
    {
        return length;
    }","  public void test27()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-4), 0, (byte[]) null, 1420, (-4));
      tFTPDataPacket0.getData();
}"
711,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test28()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-4), 0, (byte[]) null, 1420, (-4));
      tFTPDataPacket0.getData();
}"
712,"    public int getDataOffset()
    {
        return offset;
    }","  public void test29()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-4), 0, (byte[]) null, 1420, (-4));
      tFTPDataPacket0.getData();
}"
713,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test30()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1123), 0, byteArray0, 0, 99);
      tFTPDataPacket0.getData();
}"
714,"    public int getDataLength()
    {
        return length;
    }","  public void test31()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1123), 0, byteArray0, 0, 99);
      tFTPDataPacket0.getData();
}"
715,"    public int getDataOffset()
    {
        return offset;
    }","  public void test32()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1123), 0, byteArray0, 0, 99);
      tFTPDataPacket0.getData();
}"
716,"    public int getDataLength()
    {
        return length;
    }","  public void test33()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[469];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      int int0 = tFTPDataPacket0.getBlockNumber();
}"
717,"    public int getDataOffset()
    {
        return offset;
    }","  public void test34()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[469];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      int int0 = tFTPDataPacket0.getBlockNumber();
}"
718,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test35()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[469];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      int int0 = tFTPDataPacket0.getBlockNumber();
}"
719,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test36()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-2792), (-2792), byteArray0);
      int int0 = tFTPDataPacket0.getBlockNumber();
}"
720,"    public int getDataOffset()
    {
        return offset;
    }","  public void test37()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-2792), (-2792), byteArray0);
      int int0 = tFTPDataPacket0.getBlockNumber();
}"
721,"    public int getDataLength()
    {
        return length;
    }","  public void test38()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-2792), (-2792), byteArray0);
      int int0 = tFTPDataPacket0.getBlockNumber();
}"
722,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test39()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket((InetAddress) null, 777, 1910, byteArray0, 777, (byte)115);
      // Undeclared exception!
      try { 
        tFTPDataPacket0.newDatagram((DatagramPacket) null, byteArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPDataPacket"", e);
      }
  }"
723,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test40()  throws Throwable  {
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket((InetAddress) null, 2564, 3552, (byte[]) null, 3552, 3552);
      // Undeclared exception!
      try { 
        tFTPDataPacket0.newDatagram();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
724,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test41()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      tFTPDataPacket0.setData(byteArray0, 0, (-420));
      // Undeclared exception!
      try { 
        tFTPDataPacket0.newDatagram();
        fail(""Expecting exception: NegativeArraySizeException"");
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPDataPacket"", e);
      }
  }"
725,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test42()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[8];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-372), 1, byteArray0);
      // Undeclared exception!
      try { 
        tFTPDataPacket0.newDatagram();
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-372
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
726,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test43()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1123), 0, byteArray0, 0, 99);
      // Undeclared exception!
      try { 
        tFTPDataPacket0.newDatagram();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
      }
  }"
727,"    public TFTPDataPacket(final InetAddress destination, final int port, final int blockNumber,
                          final byte[] data, final int offset, final int length)
    {
        super(TFTPPacket.DATA, destination, port);

        this.blockNumber = blockNumber;
        this.data = data;
        this.offset = offset;

        if (length > MAX_DATA_LENGTH) {
            this.length = MAX_DATA_LENGTH;
        } else {
            this.length = length;
        }
    }","  public void test44()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPDataPacket tFTPDataPacket0 = null;
      try {
        tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1666), (-1666), (byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPDataPacket"", e);
      }
  }"
728,"    public TFTPDataPacket(final InetAddress destination, final int port, final int blockNumber,
                          final byte[] data, final int offset, final int length)
    {
        super(TFTPPacket.DATA, destination, port);

        this.blockNumber = blockNumber;
        this.data = data;
        this.offset = offset;

        if (length > MAX_DATA_LENGTH) {
            this.length = MAX_DATA_LENGTH;
        } else {
            this.length = length;
        }
    }","  public void test45()  throws Throwable  {
      TFTPDataPacket tFTPDataPacket0 = null;
      try {
        tFTPDataPacket0 = new TFTPDataPacket((DatagramPacket) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPDataPacket"", e);
      }
  }"
729,"    public TFTPDataPacket(final InetAddress destination, final int port, final int blockNumber,
                          final byte[] data, final int offset, final int length)
    {
        super(TFTPPacket.DATA, destination, port);

        this.blockNumber = blockNumber;
        this.data = data;
        this.offset = offset;

        if (length > MAX_DATA_LENGTH) {
            this.length = MAX_DATA_LENGTH;
        } else {
            this.length = length;
        }
    }","  public void test46()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, 0, 0);
      TFTPDataPacket tFTPDataPacket0 = null;
      try {
        tFTPDataPacket0 = new TFTPDataPacket(datagramPacket0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.tftp.TFTPDataPacket"", e);
      }
  }"
730,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test47()  throws Throwable  {
      byte[] byteArray0 = new byte[21];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket((InetAddress) null, 1685, 1685, byteArray0, 1685, 1685);
      tFTPDataPacket0.setData(byteArray0, 1685, 1685);
}"
731,"    public int getDataOffset()
    {
        return offset;
    }","  public void test48()  throws Throwable  {
      byte[] byteArray0 = new byte[21];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket((InetAddress) null, 1685, 1685, byteArray0, 1685, 1685);
      tFTPDataPacket0.setData(byteArray0, 1685, 1685);
}"
732,"    public int getDataLength()
    {
        return length;
    }","  public void test49()  throws Throwable  {
      byte[] byteArray0 = new byte[21];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket((InetAddress) null, 1685, 1685, byteArray0, 1685, 1685);
      tFTPDataPacket0.setData(byteArray0, 1685, 1685);
}"
733,"    public int getDataOffset()
    {
        return offset;
    }","  public void test50()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[519];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      TFTPDataPacket tFTPDataPacket1 = new TFTPDataPacket(datagramPacket0);
      byte[] byteArray1 = tFTPDataPacket1.getData();
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray1);
}"
734,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test51()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[519];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      TFTPDataPacket tFTPDataPacket1 = new TFTPDataPacket(datagramPacket0);
      byte[] byteArray1 = tFTPDataPacket1.getData();
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray1);
}"
735,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test52()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[519];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      TFTPDataPacket tFTPDataPacket1 = new TFTPDataPacket(datagramPacket0);
      byte[] byteArray1 = tFTPDataPacket1.getData();
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray1);
}"
736,"    public int getDataOffset()
    {
        return offset;
    }","  public void test53()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[519];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      TFTPDataPacket tFTPDataPacket1 = new TFTPDataPacket(datagramPacket0);
      byte[] byteArray1 = tFTPDataPacket1.getData();
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray1);
}"
737,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test54()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[519];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      TFTPDataPacket tFTPDataPacket1 = new TFTPDataPacket(datagramPacket0);
      byte[] byteArray1 = tFTPDataPacket1.getData();
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray1);
}"
738,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        // Doublecheck we're not the same
        if (data != this.data) {
            System.arraycopy(this.data, offset, data, 4, length);
        }

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(length + 4);

        return datagram;
    }","  public void test55()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[519];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      DatagramPacket datagramPacket0 = tFTPDataPacket0.newDatagram();
      TFTPDataPacket tFTPDataPacket1 = new TFTPDataPacket(datagramPacket0);
      byte[] byteArray1 = tFTPDataPacket1.getData();
      tFTPDataPacket0.newDatagram(datagramPacket0, byteArray1);
}"
739,"    public TFTPDataPacket(final InetAddress destination, final int port, final int blockNumber,
                          final byte[] data, final int offset, final int length)
    {
        super(TFTPPacket.DATA, destination, port);

        this.blockNumber = blockNumber;
        this.data = data;
        this.offset = offset;

        if (length > MAX_DATA_LENGTH) {
            this.length = MAX_DATA_LENGTH;
        } else {
            this.length = length;
        }
    }","  public void test56()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0);
      TFTPDataPacket tFTPDataPacket0 = null;
      try {
        tFTPDataPacket0 = new TFTPDataPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Throwable e) {
         //
         // TFTP operator code does not match type.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPDataPacket"", e);
      }
  }"
740,"    public int getDataLength()
    {
        return length;
    }","  public void test57()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName((String) null);
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      int int0 = tFTPDataPacket0.getDataLength();
}"
741,"    public int getDataOffset()
    {
        return offset;
    }","  public void test58()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName((String) null);
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      int int0 = tFTPDataPacket0.getDataLength();
}"
742,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test59()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName((String) null);
      byte[] byteArray0 = new byte[4];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      int int0 = tFTPDataPacket0.getDataLength();
}"
743,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test60()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[519];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
}"
744,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test61()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[519];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 0, byteArray0);
      tFTPDataPacket0.setBlockNumber(5);
}"
745,"    public int getDataLength()
    {
        return length;
    }","  public void test62()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1123), 0, byteArray0, 0, 99);
      int int0 = tFTPDataPacket0.getDataOffset();
}"
746,"    public int getDataOffset()
    {
        return offset;
    }","  public void test63()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1123), 0, byteArray0, 0, 99);
      int int0 = tFTPDataPacket0.getDataOffset();
}"
747,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test64()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1123), 0, byteArray0, 0, 99);
      int int0 = tFTPDataPacket0.getDataOffset();
}"
748,"    public int getDataOffset()
    {
        return offset;
    }","  public void test65()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1123), 0, byteArray0, 0, 99);
      String string0 = tFTPDataPacket0.toString();
}"
749,"    public String toString() {
        return super.toString() + "" DATA "" + blockNumber + "" "" + length;
    }","  public void test66()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[0];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-1123), 0, byteArray0, 0, 99);
      String string0 = tFTPDataPacket0.toString();
}"
750,"    public int getDataOffset()
    {
        return offset;
    }","  public void test67()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 3, byteArray0, (byte)2, 1);
      int int0 = tFTPDataPacket0.getBlockNumber();
}"
751,"    public int getDataLength()
    {
        return length;
    }","  public void test68()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 3, byteArray0, (byte)2, 1);
      int int0 = tFTPDataPacket0.getBlockNumber();
}"
752,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test69()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[3];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, 3, byteArray0, (byte)2, 1);
      int int0 = tFTPDataPacket0.getBlockNumber();
}"
753,"    public final int getMode()
    {
        return mode;
    }","  public void test0()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""a:IwtuM4"");
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, (-2387), ""a:IwtuM4"", (-2387));
      tFTPReadRequestPacket0.port = 2027;
      int int0 = tFTPReadRequestPacket0.getMode();
}"
754,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test1()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 5, ""GxNoOv2nGbdUDa"", 0);
      tFTPWriteRequestPacket0.type = 5000;
      DatagramPacket datagramPacket0 = tFTPWriteRequestPacket0.newDatagram();
}"
755,"    public final int getMode()
    {
        return mode;
    }","  public void test2()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 5, ""GxNoOv2nGbdUDa"", 0);
      tFTPWriteRequestPacket0.type = 5000;
      DatagramPacket datagramPacket0 = tFTPWriteRequestPacket0.newDatagram();
}"
756,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test3()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 5, ""GxNoOv2nGbdUDa"", 0);
      tFTPWriteRequestPacket0.type = 5000;
      DatagramPacket datagramPacket0 = tFTPWriteRequestPacket0.newDatagram();
}"
757,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test4()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""?-[hl}[IMxT"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, "">"", 0);
      tFTPWriteRequestPacket0.port = 115;
      byte[] byteArray0 = new byte[15];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0, inetAddress0, (byte)0);
      tFTPWriteRequestPacket0.newDatagram(datagramPacket0, byteArray0);
}"
758,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test5()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""?-[hl}[IMxT"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, "">"", 0);
      tFTPWriteRequestPacket0.port = 115;
      byte[] byteArray0 = new byte[15];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0, inetAddress0, (byte)0);
      tFTPWriteRequestPacket0.newDatagram(datagramPacket0, byteArray0);
}"
759,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test6()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""?-[hl}[IMxT"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, "">"", 0);
      tFTPWriteRequestPacket0.port = 115;
      DatagramPacket datagramPacket0 = tFTPWriteRequestPacket0.newDatagram();
}"
760,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test7()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""?-[hl}[IMxT"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, "">"", 0);
      tFTPWriteRequestPacket0.port = 115;
      DatagramPacket datagramPacket0 = tFTPWriteRequestPacket0.newDatagram();
}"
761,"    public final int getMode()
    {
        return mode;
    }","  public void test8()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, """", 0);
      int int0 = tFTPWriteRequestPacket0.getMode();
}"
762,"    public final int getMode()
    {
        return mode;
    }","  public void test9()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""2]J,k[_3>{}f="");
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 1, ""2]J,k[_3>{}f="", 1);
      int int0 = tFTPReadRequestPacket0.getMode();
}"
763,"    public final int getMode()
    {
        return mode;
    }","  public void test10()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 538, (String) null, 0);
      tFTPWriteRequestPacket0.getFilename();
}"
764,"    public final int getMode()
    {
        return mode;
    }","  public void test11()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, """", 0);
      tFTPWriteRequestPacket0.getFilename();
}"
765,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test12()  throws Throwable  {
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket((InetAddress) null, 512, (String) null, 115);
      byte[] byteArray0 = new byte[4];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)1);
      // Undeclared exception!
      try { 
        tFTPWriteRequestPacket0.newDatagram(datagramPacket0, byteArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
766,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test13()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""?-[hl}[IMxT"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, "">"", 0);
      byte[] byteArray0 = new byte[15];
      DatagramPacket datagramPacket0 = tFTPWriteRequestPacket0.newDatagram();
      tFTPWriteRequestPacket0.setPort((-564));
      // Undeclared exception!
      try { 
        tFTPWriteRequestPacket0.newDatagram(datagramPacket0, byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-564
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
767,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test14()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 0, ""!Cm\""A"", 0);
      byte[] byteArray0 = new byte[7];
      // Undeclared exception!
      try { 
        tFTPReadRequestPacket0.newDatagram((DatagramPacket) null, byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 7
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
768,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test15()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 538, (String) null, 0);
      // Undeclared exception!
      try { 
        tFTPWriteRequestPacket0.newDatagram();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
769,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test16()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, (-20), ""GxNoOv2nZbdUDa"", 0);
      // Undeclared exception!
      try { 
        tFTPWriteRequestPacket0.newDatagram();
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-20
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
770,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test17()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""a:IwtuM4"");
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, (-2387), ""a:IwtuM4"", (-2387));
      // Undeclared exception!
      try { 
        tFTPReadRequestPacket0.newDatagram();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -2387
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
771,"    public final int getMode()
    {
        return mode;
    }","  public void test18()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""a:IwtuM4"");
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, (-2387), ""a:IwtuM4"", (-2387));
      tFTPReadRequestPacket0.getFilename();
}"
772,,"  public void test19()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      byteArray0[1] = (byte)1;
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)1);
      datagramPacket0.setData(byteArray0);
      TFTPReadRequestPacket tFTPReadRequestPacket0 = null;
      try {
        tFTPReadRequestPacket0 = new TFTPReadRequestPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Throwable e) {
         //
         // Unrecognized TFTP transfer mode: 
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
773,,"  public void test20()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      byteArray0[1] = (byte)1;
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)1);
      TFTPReadRequestPacket tFTPReadRequestPacket0 = null;
      try {
        tFTPReadRequestPacket0 = new TFTPReadRequestPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Throwable e) {
         //
         // Bad file name and mode format.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
774,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test21()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""Q"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, ""Q"", 0);
      DatagramPacket datagramPacket0 = tFTPWriteRequestPacket0.newDatagram();
      TFTPReadRequestPacket tFTPReadRequestPacket0 = null;
      try {
        tFTPReadRequestPacket0 = new TFTPReadRequestPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Throwable e) {
         //
         // TFTP operator code does not match type.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
775,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test22()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""?-[hl}[IMxT"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, "">"", 0);
      byte[] byteArray0 = new byte[15];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0, inetAddress0, 118);
      DatagramPacket datagramPacket1 = tFTPWriteRequestPacket0.newDatagram(datagramPacket0, byteArray0);
      TFTPWriteRequestPacket tFTPWriteRequestPacket1 = (TFTPWriteRequestPacket)TFTPPacket.newTFTPPacket(datagramPacket1);
}"
776,"    public final String getFilename()
    {
        return fileName;
    }","  public void test23()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""?-[hl}[IMxT"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, "">"", 0);
      byte[] byteArray0 = new byte[15];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0, inetAddress0, 118);
      DatagramPacket datagramPacket1 = tFTPWriteRequestPacket0.newDatagram(datagramPacket0, byteArray0);
      TFTPWriteRequestPacket tFTPWriteRequestPacket1 = (TFTPWriteRequestPacket)TFTPPacket.newTFTPPacket(datagramPacket1);
}"
777,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test24()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""?-[hl}[IMxT"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, """", 0);
      byte[] byteArray0 = new byte[15];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0, inetAddress0, 116);
      tFTPWriteRequestPacket0.newDatagram(datagramPacket0, byteArray0);
}"
778,"    final DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        final int fileLength;
        final int modeLength;

        fileLength = fileName.length();
        modeLength = modeBytes[mode].length;

        data[0] = 0;
        data[1] = (byte)type;
        System.arraycopy(fileName.getBytes(), 0, data, 2, fileLength);
        data[fileLength + 2] = 0;
        System.arraycopy(modeBytes[mode], 0, data, fileLength + 3,
                         modeLength);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(fileLength + modeLength + 3);

        return datagram;
    }","  public void test25()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""?-[hl}[IMxT"");
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 0, """", 0);
      byte[] byteArray0 = new byte[15];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, (byte)0, inetAddress0, 116);
      tFTPWriteRequestPacket0.newDatagram(datagramPacket0, byteArray0);
}"
779,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test0()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      TFTPErrorPacket tFTPErrorPacket0 = new TFTPErrorPacket((InetAddress) null, 5000, 0, """");
      tFTP0.trace("""", tFTPErrorPacket0);
}"
780,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test1()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      tFTP0.open(0, inetAddress0);
      byte[] byteArray0 = new byte[5];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 1, 5000, byteArray0, 0, (byte)0);
      tFTP0.send(tFTPDataPacket0);
}"
781,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test2()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      tFTP0.beginBufferedOps();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      tFTP0.open(0, inetAddress0);
      byte[] byteArray0 = new byte[5];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 1, 5000, byteArray0, 0, (byte)0);
      tFTP0.bufferedSend(tFTPDataPacket0);
}"
782,"    public final void send(final TFTPPacket packet) throws IOException
    {
        trace("">"", packet);
        _socket_.send(packet.newDatagram());
    }","  public void test3()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      InetAddress inetAddress0 = MockInetAddress.getByName(""}knU:I?pF` Heu"");
      byte[] byteArray0 = new byte[6];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 0, (-92), byteArray0, 0, (-1297));
      // Undeclared exception!
      try { 
        tFTP0.send(tFTPDataPacket0);
        fail(""Expecting exception: NegativeArraySizeException"");
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPDataPacket"", e);
      }
  }"
783,"    public final void send(final TFTPPacket packet) throws IOException
    {
        trace("">"", packet);
        _socket_.send(packet.newDatagram());
    }","  public void test4()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      byte[] byteArray0 = new byte[2];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, (-3349), 1309, byteArray0, 0, 1);
      // Undeclared exception!
      try { 
        tFTP0.send(tFTPDataPacket0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-3349
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
784,"    public final void send(final TFTPPacket packet) throws IOException
    {
        trace("">"", packet);
        _socket_.send(packet.newDatagram());
    }","  public void test5()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      byte[] byteArray0 = new byte[2];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 1, 5000, byteArray0, 5000, (byte)1);
      // Undeclared exception!
      try { 
        tFTP0.send(tFTPDataPacket0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
      }
  }"
785,"    public final TFTPPacket receive() throws IOException, InterruptedIOException,
                SocketException, TFTPPacketException
    {
        final DatagramPacket packet;

        packet = new DatagramPacket(new byte[PACKET_SIZE], PACKET_SIZE);

        _socket_.receive(packet);

        final TFTPPacket newTFTPPacket = TFTPPacket.newTFTPPacket(packet);
        trace(""<"", newTFTPPacket);
        return newTFTPPacket;
    }","  public void test6()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""Bad error packet. No message."", 512);
      byte[] byteArray0 = new byte[5];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      TFTP tFTP0 = new TFTP();
      tFTP0.open();
      try { 
        tFTP0.receive();
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Bad packet.  Invalid TFTP operator code.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPPacket"", e);
      }
  }"
786,"    public final TFTPPacket receive() throws IOException, InterruptedIOException,
                SocketException, TFTPPacketException
    {
        final DatagramPacket packet;

        packet = new DatagramPacket(new byte[PACKET_SIZE], PACKET_SIZE);

        _socket_.receive(packet);

        final TFTPPacket newTFTPPacket = TFTPPacket.newTFTPPacket(packet);
        trace(""<"", newTFTPPacket);
        return newTFTPPacket;
    }","  public void test7()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      tFTP0.open();
      try { 
        tFTP0.receive();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
787,"    public static final String getModeName(final int mode)
    {
        return TFTPRequestPacket.modeStrings[mode];
    }","  public void test8()  throws Throwable  {
      // Undeclared exception!
      try { 
        TFTP.getModeName(7);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 7
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
788,"    public final void discardPackets() throws IOException
    {
        final int to;
        final DatagramPacket datagram;

        datagram = new DatagramPacket(new byte[PACKET_SIZE], PACKET_SIZE);

        to = getSoTimeout();
        setSoTimeout(1);

        try
        {
            while (true) {
                _socket_.receive(datagram);
            }
        }
        catch (final SocketException | InterruptedIOException e)
        {
            // Do nothing.  We timed out so we hope we're caught up.
        }

        setSoTimeout(to);
    }","  public void test9()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      tFTP0.open(0, inetAddress0);
      try { 
        tFTP0.discardPackets();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
789,"    public final void bufferedSend(final TFTPPacket packet) throws IOException
    {
        trace("">"", packet);
        _socket_.send(packet.newDatagram(sendDatagram, sendBuffer));
    }","  public void test10()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      TFTPReadRequestPacket tFTPReadRequestPacket0 = new TFTPReadRequestPacket(inetAddress0, 1, ""<"", 1457);
      // Undeclared exception!
      try { 
        tFTP0.bufferedSend(tFTPReadRequestPacket0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1457
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
790,"    public final TFTPPacket bufferedReceive() throws IOException,
                InterruptedIOException, SocketException, TFTPPacketException
    {
        receiveDatagram.setData(receiveBuffer);
        receiveDatagram.setLength(receiveBuffer.length);
        _socket_.receive(receiveDatagram);

        final TFTPPacket newTFTPPacket = TFTPPacket.newTFTPPacket(receiveDatagram);
        trace(""<"", newTFTPPacket);
        return newTFTPPacket;
    }","  public void test11()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      tFTP0.beginBufferedOps();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      tFTP0.open(0, inetAddress0);
      byte[] byteArray0 = new byte[5];
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""127.0.0.1"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 1);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      try { 
        tFTP0.bufferedReceive();
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Bad packet.  Invalid TFTP operator code.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPPacket"", e);
      }
  }"
791,"    public final TFTPPacket receive() throws IOException, InterruptedIOException,
                SocketException, TFTPPacketException
    {
        final DatagramPacket packet;

        packet = new DatagramPacket(new byte[PACKET_SIZE], PACKET_SIZE);

        _socket_.receive(packet);

        final TFTPPacket newTFTPPacket = TFTPPacket.newTFTPPacket(packet);
        trace(""<"", newTFTPPacket);
        return newTFTPPacket;
    }","  public void test12()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      // Undeclared exception!
      try { 
        tFTP0.receive();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
792,"    public static final String getModeName(final int mode)
    {
        return TFTPRequestPacket.modeStrings[mode];
    }","  public void test13()  throws Throwable  {
      String string0 = TFTP.getModeName(0);
}"
793,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test14()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      tFTP0.endBufferedOps();
}"
794,"    public final void discardPackets() throws IOException
    {
        final int to;
        final DatagramPacket datagram;

        datagram = new DatagramPacket(new byte[PACKET_SIZE], PACKET_SIZE);

        to = getSoTimeout();
        setSoTimeout(1);

        try
        {
            while (true) {
                _socket_.receive(datagram);
            }
        }
        catch (final SocketException | InterruptedIOException e)
        {
            // Do nothing.  We timed out so we hope we're caught up.
        }

        setSoTimeout(to);
    }","  public void test15()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      // Undeclared exception!
      try { 
        tFTP0.discardPackets();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.DatagramSocketClient"", e);
      }
  }"
795,"    public final void send(final TFTPPacket packet) throws IOException
    {
        trace("">"", packet);
        _socket_.send(packet.newDatagram());
    }","  public void test16()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[13];
      TFTPDataPacket tFTPDataPacket0 = new TFTPDataPacket(inetAddress0, 1, 5000, byteArray0, 0, (byte)0);
      // Undeclared exception!
      try { 
        tFTP0.send(tFTPDataPacket0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
796,"    public final void bufferedSend(final TFTPPacket packet) throws IOException
    {
        trace("">"", packet);
        _socket_.send(packet.newDatagram(sendDatagram, sendBuffer));
    }","  public void test17()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPWriteRequestPacket tFTPWriteRequestPacket0 = new TFTPWriteRequestPacket(inetAddress0, 460, (String) null, (-1257));
      // Undeclared exception!
      try { 
        tFTP0.bufferedSend(tFTPWriteRequestPacket0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
797,"    public final TFTPPacket bufferedReceive() throws IOException,
                InterruptedIOException, SocketException, TFTPPacketException
    {
        receiveDatagram.setData(receiveBuffer);
        receiveDatagram.setLength(receiveBuffer.length);
        _socket_.receive(receiveDatagram);

        final TFTPPacket newTFTPPacket = TFTPPacket.newTFTPPacket(receiveDatagram);
        trace(""<"", newTFTPPacket);
        return newTFTPPacket;
    }","  public void test18()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      tFTP0.beginBufferedOps();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      tFTP0.open(0, inetAddress0);
      try { 
        tFTP0.bufferedReceive();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
798,"    public final TFTPPacket bufferedReceive() throws IOException,
                InterruptedIOException, SocketException, TFTPPacketException
    {
        receiveDatagram.setData(receiveBuffer);
        receiveDatagram.setLength(receiveBuffer.length);
        _socket_.receive(receiveDatagram);

        final TFTPPacket newTFTPPacket = TFTPPacket.newTFTPPacket(receiveDatagram);
        trace(""<"", newTFTPPacket);
        return newTFTPPacket;
    }","  public void test19()  throws Throwable  {
      TFTP tFTP0 = new TFTP();
      // Undeclared exception!
      try { 
        tFTP0.bufferedReceive();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
799,"    public TFTPPacketException()
    {
    }","  public void test0()  throws Throwable  {
      TFTPPacketException tFTPPacketException0 = new TFTPPacketException(""org.evosuite.runtime.mock.java.lang.MockThrowable"");
  }"
800,"    public TFTPPacketException()
    {
    }","  public void test1()  throws Throwable  {
      TFTPPacketException tFTPPacketException0 = new TFTPPacketException();
  }"
801,"    public int getMaxTimeouts()
    {
        return maxTimeouts;
    }","  public void test0()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.setMaxTimeouts(65535);
      int int0 = tFTPClient0.getMaxTimeouts();
}"
802,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test1()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.open();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[7];
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, byteArray0);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 5, (byte)105);
      try { 
        tFTPClient0.sendFile(""rd#v-4"", (int) (byte)0, (InputStream) byteArrayInputStream0, inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Bad packet: Bad packet.  Invalid TFTP operator code.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPClient"", e);
      }
  }"
803,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test2()  throws Throwable  {
      byte[] byteArray0 = new byte[6];
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""127.0.0.1"", 69);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.open();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""Connection timed out."", false);
      try { 
        tFTPClient0.receiveFile(""org.apache.commons.net.DatagramSocketClient"", 0, (OutputStream) mockFileOutputStream0, """");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Bad packet: Bad packet.  Invalid TFTP operator code.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPClient"", e);
      }
  }"
804,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test3()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile((String) null, 5, (InputStream) mockFileInputStream0, inetAddress0, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
805,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test4()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.open();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 5, (byte)105);
      try { 
        tFTPClient0.sendFile("""", (int) (byte)0, (InputStream) byteArrayInputStream0, inetAddress0, (int) (byte)105);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
806,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test5()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      byte[] byteArray0 = new byte[0];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, (-2628));
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile("""", (-478), (InputStream) byteArrayInputStream0, inetAddress0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -478
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
807,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test6()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 255, (-754));
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile(""File write failed."", 0, (InputStream) byteArrayInputStream0, ""N]\""jE`j-o)|~$rYs,"", (-2111));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-2111
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
808,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test7()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(mockFileInputStream0, 5);
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile(""6%bC%"", (-292), (InputStream) pushbackInputStream0, (String) null, (-292));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -292
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
809,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test8()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.open();
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 5, (byte)105);
      try { 
        tFTPClient0.sendFile(""Qv\""w-u8dC"", (int) (byte)0, (InputStream) byteArrayInputStream0, ""Qv\""w-u8dC"", 4);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
810,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test9()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile("""", 0, (InputStream) byteArrayInputStream0, """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
811,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test10()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      PipedInputStream pipedInputStream0 = new PipedInputStream(1);
      byte[] byteArray0 = new byte[22];
      tFTPClient0.open();
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(pipedInputStream0, byteArrayInputStream0);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(sequenceInputStream0);
      try { 
        tFTPClient0.sendFile("""", 0, (InputStream) pushbackInputStream0, ""rd#v-4"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
812,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test11()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile(""ckqqrMyuGI{{"", (-3536), (OutputStream) null, inetAddress0, (-3536));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -3536
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
813,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test12()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      tFTPClient0.open();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      try { 
        tFTPClient0.receiveFile(""Unexpected host or port."", 1, (OutputStream) byteArrayOutputStream0, inetAddress0, 1);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
814,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test13()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      MockPrintStream mockPrintStream0 = new MockPrintStream(""System"");
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile("""", (-129), (OutputStream) mockPrintStream0, inetAddress0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -129
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
815,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test14()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      InetAddress inetAddress0 = MockInetAddress.getByName(""Error code "");
      tFTPClient0.open(6);
      try { 
        tFTPClient0.receiveFile(""Error code "", 0, (OutputStream) null, inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
816,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test15()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile((String) null, 0, (OutputStream) byteArrayOutputStream0, ""*}ozMtI3skH+47%-"", 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
817,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test16()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(5000);
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile("""", 0, (OutputStream) byteArrayOutputStream0, (String) null, (-1966));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-1966
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
818,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test17()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.open();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""sH70-y-H-R)#B6S|O"", true);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0, true);
      try { 
        tFTPClient0.receiveFile("""", (int) (byte)0, (OutputStream) mockPrintStream0, ""sH70-y-H-R)#B6S|O"", (int) (byte)0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
819,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test18()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile(""Bad packet: "", 982, (OutputStream) pipedOutputStream0, ""Bad packet: "");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 982
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
820,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test19()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      byte[] byteArray0 = new byte[8];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile(""}*kRa~Er0W-'`99b"", 1191, (InputStream) sequenceInputStream0, inetAddress0, (-64));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1191
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
821,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test20()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      InetAddress inetAddress0 = MockInetAddress.getByName(""7w-*QrB'C}P7K yZJ"");
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile(""7w-*QrB'C}P7K yZJ"", (int) (byte)0, (InputStream) null, inetAddress0, (-3031));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-3031
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
822,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test21()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
      InetAddress inetAddress0 = MockInetAddress.getByName("";"");
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile(""fF4r4) E"", 0, (OutputStream) byteArrayOutputStream0, inetAddress0, (-550));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-550
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
823,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test22()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile(""Unexpected host or port."", 1, (OutputStream) byteArrayOutputStream0, inetAddress0, 1);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
824,"    public int getMaxTimeouts()
    {
        return maxTimeouts;
    }","  public void test23()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
}"
825,"    public int getMaxTimeouts()
    {
        return maxTimeouts;
    }","  public void test24()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.setMaxTimeouts((byte)0);
}"
826,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test25()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile(""Bad packet.  Invalid TFTP operator code."", 1, (InputStream) pipedInputStream0, ""Bad packet.  Invalid TFTP operator code."", 3231);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
827,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test26()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""org.apache.commons.net.tftp.TFTPClient"");
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile(""org.apache.commons.net.tftp.TFTPClient"", 1, (OutputStream) mockFileOutputStream0, ""org.apache.commons.net.tftp.TFTPClient"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
828,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test27()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile(""$/VAb{ES"", 5, (InputStream) null, ""$/VAb{ES"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 5
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
829,"    public void sendFile(final String fileName, final int mode, InputStream input,
                         InetAddress host, final int port) throws IOException
    {
        int block = 0;
        int hostPort = 0;
        boolean justStarted = true;
        boolean lastAckWait = false;

        totalBytesSent = 0L;

        if (mode == TFTP.ASCII_MODE) {
            input = new ToNetASCIIInputStream(input);
        }

        TFTPPacket sent = new TFTPWriteRequestPacket(host, port, fileName, mode);
        final TFTPDataPacket data = new TFTPDataPacket(host, port, 0, sendBuffer, 4, 0);

        beginBufferedOps();

        try {
            do { // until eof
                // first time: block is 0, lastBlock is 0, send a request packet.
                // subsequent: block is integer starting at 1, send data packet.
                bufferedSend(sent);
                boolean wantReply = true;
                int timeouts = 0;
                do {
                    try {
                        final TFTPPacket received = bufferedReceive();
                        final InetAddress recdAddress = received.getAddress();
                        final int recdPort = received.getPort();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            data.setPort(hostPort);
                            if (!host.equals(recdAddress)) {
                                host = recdAddress;
                                data.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {

                            switch (received.getType()) {
                            case TFTPPacket.ERROR:
                                final TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.ACKNOWLEDGEMENT:

                                final int lastBlock = ((TFTPAckPacket)received).getBlockNumber();

                                if (lastBlock == block) {
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the ack we want
                                } else {
                                    discardPackets();
                                }
                                break;
                            default:
                                throw new IOException(""Received unexpected packet type."");
                            }
                        } else { // wrong host or TID; send error
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                                        recdPort,
                                                        TFTPErrorPacket.UNKNOWN_TID,
                                                        ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                    // retry until a good ack
                } while(wantReply);

                if (lastAckWait) {
                    break; // we were waiting for this; now all done
                }

                int dataLength = TFTPPacket.SEGMENT_SIZE;
                int offset = 4;
                int totalThisPacket = 0;
                int bytesRead = 0;
                while (dataLength > 0 &&
                        (bytesRead = input.read(sendBuffer, offset, dataLength)) > 0) {
                    offset += bytesRead;
                    dataLength -= bytesRead;
                    totalThisPacket += bytesRead;
                }
                if( totalThisPacket < TFTPPacket.SEGMENT_SIZE ) {
                    /* this will be our last packet -- send, wait for ack, stop */
                    lastAckWait = true;
                }
                data.setBlockNumber(block);
                data.setData(sendBuffer, 4, totalThisPacket);
                sent = data;
                totalBytesSent += totalThisPacket;
            } while (true); // loops until after lastAckWait is set
        } finally {
            endBufferedOps();
        }
    }","  public void test28()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 5, (byte)105);
      // Undeclared exception!
      try { 
        tFTPClient0.sendFile(""rd#v-4"", (int) (byte)0, (InputStream) byteArrayInputStream0, inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
830,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test29()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile(""K:\""PA&zv>us1[+G4(PE"", 3591, (OutputStream) byteArrayOutputStream0, "" RRQ "", 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 3591
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
831,"    public int getMaxTimeouts()
    {
        return maxTimeouts;
    }","  public void test30()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.getTotalBytesSent();
}"
832,"    public int receiveFile(final String fileName, final int mode, OutputStream output,
                           InetAddress host, final int port) throws IOException
    {
        int bytesRead = 0;
        int lastBlock = 0;
        int block = 1;
        int hostPort = 0;
        int dataLength = 0;

        totalBytesReceived = 0;

        if (mode == TFTP.ASCII_MODE) {
            output = new FromNetASCIIOutputStream(output);
        }

        TFTPPacket sent = new TFTPReadRequestPacket(host, port, fileName, mode);
        final TFTPAckPacket ack = new TFTPAckPacket(host, port, 0);

        beginBufferedOps();

        boolean justStarted = true;
        try {
            do { // while more data to fetch
                bufferedSend(sent); // start the fetch/send an ack
                boolean wantReply = true;
                int timeouts = 0;
                do { // until successful response
                    try {
                        final TFTPPacket received = bufferedReceive();
                        // The first time we receive we get the port number and
                        // answering host address (for hosts with multiple IPs)
                        final int recdPort = received.getPort();
                        final InetAddress recdAddress = received.getAddress();
                        if (justStarted) {
                            justStarted = false;
                            if (recdPort == port) { // must not use the control port here
                                final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress,
                                        recdPort, TFTPErrorPacket.UNKNOWN_TID,
                                        ""INCORRECT SOURCE PORT"");
                                bufferedSend(error);
                                throw new IOException(""Incorrect source port (""+recdPort+"") in request reply."");
                            }
                            hostPort = recdPort;
                            ack.setPort(hostPort);
                            if(!host.equals(recdAddress))
                            {
                                host = recdAddress;
                                ack.setAddress(host);
                                sent.setAddress(host);
                            }
                        }
                        // Comply with RFC 783 indication that an error acknowledgment
                        // should be sent to originator if unexpected TID or host.
                        if (host.equals(recdAddress) && recdPort == hostPort) {
                            switch (received.getType()) {

                            case TFTPPacket.ERROR:
                                TFTPErrorPacket error = (TFTPErrorPacket)received;
                                throw new IOException(""Error code "" + error.getError() +
                                                      "" received: "" + error.getMessage());
                            case TFTPPacket.DATA:
                                final TFTPDataPacket data = (TFTPDataPacket)received;
                                dataLength = data.getDataLength();
                                lastBlock = data.getBlockNumber();

                                if (lastBlock == block) { // is the next block number?
                                    try {
                                        output.write(data.getData(), data.getDataOffset(), dataLength);
                                    } catch (final IOException e) {
                                        error = new TFTPErrorPacket(host, hostPort,
                                                                    TFTPErrorPacket.OUT_OF_SPACE,
                                                                    ""File write failed."");
                                        bufferedSend(error);
                                        throw e;
                                    }
                                    ++block;
                                    if (block > 65535) {
                                        // wrap the block number
                                        block = 0;
                                    }
                                    wantReply = false; // got the next block, drop out to ack it
                                } else { // unexpected block number
                                    discardPackets();
                                    if (lastBlock == (block == 0 ? 65535 : block - 1)) {
                                        wantReply = false; // Resend last acknowledgemen
                                    }
                                }
                                break;

                            default:
                                throw new IOException(""Received unexpected packet type ("" + received.getType() + "")"");
                            }
                        } else { // incorrect host or TID
                            final TFTPErrorPacket error = new TFTPErrorPacket(recdAddress, recdPort,
                                    TFTPErrorPacket.UNKNOWN_TID,
                                    ""Unexpected host or port."");
                            bufferedSend(error);
                        }
                    } catch (final SocketException | InterruptedIOException e) {
                        if (++timeouts >= maxTimeouts) {
                            throw new IOException(""Connection timed out."");
                        }
                    } catch (final TFTPPacketException e) {
                        throw new IOException(""Bad packet: "" + e.getMessage());
                    }
                } while(wantReply); // waiting for response

                ack.setBlockNumber(lastBlock);
                sent = ack;
                bytesRead += dataLength;
                totalBytesReceived += dataLength;
            } while (dataLength == TFTPPacket.SEGMENT_SIZE); // not eof
            bufferedSend(sent); // send the final ack
        } finally {
            endBufferedOps();
        }
        return bytesRead;
    }","  public void test31()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      InetAddress inetAddress0 = MockInetAddress.getByName("") in request reply."");
      // Undeclared exception!
      try { 
        tFTPClient0.receiveFile("") in request reply."", 0, (OutputStream) null, inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTP"", e);
      }
  }"
833,"    public int getMaxTimeouts()
    {
        return maxTimeouts;
    }","  public void test32()  throws Throwable  {
      TFTPClient tFTPClient0 = new TFTPClient();
      tFTPClient0.getTotalBytesReceived();
}"
834,"    public String toString() {
        return super.toString() + "" ACK "" + blockNumber;
    }","  public void test0()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      InetAddress inetAddress0 = MockInetAddress.getByAddress("""", byteArray0);
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 0, 1363);
      String string0 = tFTPAckPacket0.toString();
}"
835,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test1()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""+:"");
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 115, 115);
      tFTPAckPacket0.type = 65535;
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
}"
836,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test2()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""+:"");
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 115, 115);
      tFTPAckPacket0.type = 65535;
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
}"
837,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test3()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""+:"");
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 115, 115);
      tFTPAckPacket0.type = 65535;
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
}"
838,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test4()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""+:"");
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 115, 115);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      tFTPAckPacket0.type = 65535;
      byte[] byteArray0 = new byte[2];
      // Undeclared exception!
      try { 
        tFTPAckPacket0.newDatagram(datagramPacket0, byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2
         //
         verifyException(""org.apache.commons.net.tftp.TFTPAckPacket"", e);
      }
  }"
839,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test5()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 946, 946);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      byte[] byteArray0 = new byte[5];
      tFTPAckPacket0.newDatagram(datagramPacket0, byteArray0);
}"
840,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test6()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 946, 946);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      byte[] byteArray0 = new byte[5];
      tFTPAckPacket0.newDatagram(datagramPacket0, byteArray0);
}"
841,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test7()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 946, 946);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      byte[] byteArray0 = new byte[5];
      tFTPAckPacket0.newDatagram(datagramPacket0, byteArray0);
}"
842,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test8()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 0, 0);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      byte[] byteArray0 = new byte[9];
      tFTPAckPacket0.newDatagram(datagramPacket0, byteArray0);
}"
843,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test9()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 0, 0);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      byte[] byteArray0 = new byte[9];
      tFTPAckPacket0.newDatagram(datagramPacket0, byteArray0);
}"
844,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test10()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 0, 0);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      byte[] byteArray0 = new byte[9];
      tFTPAckPacket0.newDatagram(datagramPacket0, byteArray0);
}"
845,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test11()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""Bad packet.  Invalid TFTP operator code."");
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 0, 0);
      int int0 = tFTPAckPacket0.getBlockNumber();
}"
846,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test12()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 0, 0);
      byte[] byteArray0 = new byte[7];
      // Undeclared exception!
      try { 
        tFTPAckPacket0.newDatagram((DatagramPacket) null, byteArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPAckPacket"", e);
      }
  }"
847,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test13()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      InetAddress inetAddress0 = MockInetAddress.getByAddress("""", byteArray0);
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 0, 1363);
      tFTPAckPacket0.port = (int) (byte)0;
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, 3, 0, inetAddress0, (byte)1);
      tFTPAckPacket0.port = (int) (byte) (-80);
      // Undeclared exception!
      try { 
        tFTPAckPacket0.newDatagram(datagramPacket0, byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-80
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
848,"    DatagramPacket newDatagram(final DatagramPacket datagram, final byte[] data)
    {
        data[0] = 0;
        data[1] = (byte)type;
        data[2] = (byte)((blockNumber & 0xffff) >> 8);
        data[3] = (byte)(blockNumber & 0xff);

        datagram.setAddress(address);
        datagram.setPort(port);
        datagram.setData(data);
        datagram.setLength(4);

        return datagram;
    }","  public void test14()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, (-932), 5444);
      // Undeclared exception!
      try { 
        tFTPAckPacket0.newDatagram();
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-932
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
849,"    public TFTPAckPacket(final InetAddress destination, final int port, final int blockNumber)
    {
        super(TFTPPacket.ACKNOWLEDGEMENT, destination, port);
        this.blockNumber = blockNumber;
    }","  public void test15()  throws Throwable  {
      TFTPAckPacket tFTPAckPacket0 = null;
      try {
        tFTPAckPacket0 = new TFTPAckPacket((DatagramPacket) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPAckPacket"", e);
      }
  }"
850,"    public TFTPAckPacket(final InetAddress destination, final int port, final int blockNumber)
    {
        super(TFTPPacket.ACKNOWLEDGEMENT, destination, port);
        this.blockNumber = blockNumber;
    }","  public void test16()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, 0);
      TFTPAckPacket tFTPAckPacket0 = null;
      try {
        tFTPAckPacket0 = new TFTPAckPacket(datagramPacket0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.tftp.TFTPAckPacket"", e);
      }
  }"
851,"    public TFTPAckPacket(final InetAddress destination, final int port, final int blockNumber)
    {
        super(TFTPPacket.ACKNOWLEDGEMENT, destination, port);
        this.blockNumber = blockNumber;
    }","  public void test17()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      DatagramPacket datagramPacket0 = new DatagramPacket(byteArray0, 0, 0);
      TFTPAckPacket tFTPAckPacket0 = null;
      try {
        tFTPAckPacket0 = new TFTPAckPacket(datagramPacket0);
        fail(""Expecting exception: Exception"");
      } catch(Throwable e) {
         //
         // TFTP operator code does not match type.
         //
         verifyException(""org.apache.commons.net.tftp.TFTPAckPacket"", e);
      }
  }"
852,"    public TFTPAckPacket(final InetAddress destination, final int port, final int blockNumber)
    {
        super(TFTPPacket.ACKNOWLEDGEMENT, destination, port);
        this.blockNumber = blockNumber;
    }","  public void test18()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 55, 55);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      TFTPAckPacket tFTPAckPacket1 = new TFTPAckPacket(datagramPacket0);
}"
853,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test19()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 55, 55);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      TFTPAckPacket tFTPAckPacket1 = new TFTPAckPacket(datagramPacket0);
}"
854,"    public TFTPAckPacket(final InetAddress destination, final int port, final int blockNumber)
    {
        super(TFTPPacket.ACKNOWLEDGEMENT, destination, port);
        this.blockNumber = blockNumber;
    }","  public void test20()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 55, 55);
      DatagramPacket datagramPacket0 = tFTPAckPacket0.newDatagram();
      TFTPAckPacket tFTPAckPacket1 = new TFTPAckPacket(datagramPacket0);
}"
855,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test21()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 65535, 65535);
      int int0 = tFTPAckPacket0.getBlockNumber();
}"
856,"    public int getBlockNumber()
    {
        return blockNumber;
    }","  public void test22()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      TFTPAckPacket tFTPAckPacket0 = new TFTPAckPacket(inetAddress0, 65535, 65535);
      tFTPAckPacket0.setBlockNumber((-1));
      int int0 = tFTPAckPacket0.getBlockNumber();
}"
857,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test0()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      timeStamp0.hashCode();
}"
858,"    protected static long toNtpTime(final long millis)
    {
        final boolean useBase1 = millis < msb0baseTime;    // time < Feb-2036
        final long baseTimeMillis;
        if (useBase1) {
            baseTimeMillis = millis - msb1baseTime; // dates <= Feb-2036
        } else {
            // if base0 needed for dates >= Feb-2036
            baseTimeMillis = millis - msb0baseTime;
        }

        long seconds = baseTimeMillis / 1000;
        final long fraction = ((baseTimeMillis % 1000) * 0x100000000L) / 1000;

        if (useBase1) {
            seconds |= 0x80000000L; // set high-order bit if msb1baseTime 1900 used
        }

        return seconds << 32 | fraction;
    }","  public void test1()  throws Throwable  {
      long long0 = TimeStamp.toNtpTime((-8959209424988982477L));
}"
859,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test2()  throws Throwable  {
      long long0 = TimeStamp.getTime(2085978496000L);
}"
860,"    protected static long toNtpTime(final long millis)
    {
        final boolean useBase1 = millis < msb0baseTime;    // time < Feb-2036
        final long baseTimeMillis;
        if (useBase1) {
            baseTimeMillis = millis - msb1baseTime; // dates <= Feb-2036
        } else {
            // if base0 needed for dates >= Feb-2036
            baseTimeMillis = millis - msb0baseTime;
        }

        long seconds = baseTimeMillis / 1000;
        final long fraction = ((baseTimeMillis % 1000) * 0x100000000L) / 1000;

        if (useBase1) {
            seconds |= 0x80000000L; // set high-order bit if msb1baseTime 1900 used
        }

        return seconds << 32 | fraction;
    }","  public void test3()  throws Throwable  {
      long long0 = TimeStamp.toNtpTime(2085978496000L);
}"
861,"    protected static long toNtpTime(final long millis)
    {
        final boolean useBase1 = millis < msb0baseTime;    // time < Feb-2036
        final long baseTimeMillis;
        if (useBase1) {
            baseTimeMillis = millis - msb1baseTime; // dates <= Feb-2036
        } else {
            // if base0 needed for dates >= Feb-2036
            baseTimeMillis = millis - msb0baseTime;
        }

        long seconds = baseTimeMillis / 1000;
        final long fraction = ((baseTimeMillis % 1000) * 0x100000000L) / 1000;

        if (useBase1) {
            seconds |= 0x80000000L; // set high-order bit if msb1baseTime 1900 used
        }

        return seconds << 32 | fraction;
    }","  public void test4()  throws Throwable  {
      long long0 = TimeStamp.toNtpTime(2085978496839L);
}"
862,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test5()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString("""");
      TimeStamp timeStamp1 = TimeStamp.getNtpTime(0L);
      boolean boolean0 = timeStamp1.equals(timeStamp0);
}"
863,"    public boolean equals(final Object obj)
    {
        if (obj instanceof TimeStamp) {
            return ntpTime == ((TimeStamp) obj).ntpValue();
        }
        return false;
    }","  public void test6()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString("""");
      TimeStamp timeStamp1 = TimeStamp.getNtpTime(0L);
      boolean boolean0 = timeStamp1.equals(timeStamp0);
}"
864,"    public boolean equals(final Object obj)
    {
        if (obj instanceof TimeStamp) {
            return ntpTime == ((TimeStamp) obj).ntpValue();
        }
        return false;
    }","  public void test7()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString("""");
      TimeStamp timeStamp1 = TimeStamp.getNtpTime(0L);
      boolean boolean0 = timeStamp1.equals(timeStamp0);
}"
865,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test8()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""83aa7e80.00000000"");
}"
866,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test9()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""83aa7e7d.a872b020"");
}"
867,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test10()  throws Throwable  {
      TimeStamp timeStamp0 = new TimeStamp(0L);
      long long0 = timeStamp0.ntpValue();
}"
868,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test11()  throws Throwable  {
      TimeStamp timeStamp0 = new TimeStamp(2645L);
      long long0 = timeStamp0.ntpValue();
}"
869,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test12()  throws Throwable  {
      long long0 = TimeStamp.getTime((-8959209420479266816L));
}"
870,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test13()  throws Throwable  {
      long long0 = TimeStamp.getTime((-8959209420530806424L));
}"
871,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test14()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getNtpTime(0L);
      long long0 = timeStamp0.getTime();
}"
872,"    public long getFraction()
    {
        return ntpTime & 0xffffffffL;
    }","  public void test15()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getNtpTime((-1874L));
      long long0 = timeStamp0.getTime();
}"
873,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test16()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getNtpTime((-1874L));
      long long0 = timeStamp0.getTime();
}"
874,"    public long getSeconds()
    {
        return (ntpTime >>> 32) & 0xffffffffL;
    }","  public void test17()  throws Throwable  {
      TimeStamp timeStamp0 = new TimeStamp(0L);
      long long0 = timeStamp0.getSeconds();
}"
875,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test18()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getNtpTime(2085978496839L);
}"
876,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test19()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getNtpTime(2085978496000L);
}"
877,"    public long getFraction()
    {
        return ntpTime & 0xffffffffL;
    }","  public void test20()  throws Throwable  {
      MockDate mockDate0 = new MockDate((-1), 63, (-1053), (-1), 24, 1126);
      TimeStamp timeStamp0 = new TimeStamp(mockDate0);
      long long0 = timeStamp0.getFraction();
}"
878,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test21()  throws Throwable  {
      MockDate mockDate0 = new MockDate((-1), 63, (-1053), (-1), 24, 1126);
      TimeStamp timeStamp0 = new TimeStamp(mockDate0);
      long long0 = timeStamp0.getFraction();
}"
879,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test22()  throws Throwable  {
      System.setCurrentTimeMillis(2085978820196L);
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
}"
880,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test23()  throws Throwable  {
      System.setCurrentTimeMillis((-5559L));
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
}"
881,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test24()  throws Throwable  {
      System.setCurrentTimeMillis(2085978496000L);
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
}"
882,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test25()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
}"
883,"    protected static long decodeNtpHexString(final String hexString)
            throws NumberFormatException
    {
        if (hexString == null) {
            throw new NumberFormatException(""null"");
        }
        final int ind = hexString.indexOf('.');
        if (ind == -1) {
            if (hexString.isEmpty()) {
                return 0;
            }
            return Long.parseLong(hexString, 16) << 32; // no decimal
        }

        return Long.parseLong(hexString.substring(0, ind), 16) << 32 |
                Long.parseLong(hexString.substring(ind + 1), 16);
    }","  public void test26()  throws Throwable  {
      long long0 = TimeStamp.decodeNtpHexString("""");
}"
884,"    protected static long decodeNtpHexString(final String hexString)
            throws NumberFormatException
    {
        if (hexString == null) {
            throw new NumberFormatException(""null"");
        }
        final int ind = hexString.indexOf('.');
        if (ind == -1) {
            if (hexString.isEmpty()) {
                return 0;
            }
            return Long.parseLong(hexString, 16) << 32; // no decimal
        }

        return Long.parseLong(hexString.substring(0, ind), 16) << 32 |
                Long.parseLong(hexString.substring(ind + 1), 16);
    }","  public void test27()  throws Throwable  {
      long long0 = TimeStamp.decodeNtpHexString(""+F"");
}"
885,"    protected static long decodeNtpHexString(final String hexString)
            throws NumberFormatException
    {
        if (hexString == null) {
            throw new NumberFormatException(""null"");
        }
        final int ind = hexString.indexOf('.');
        if (ind == -1) {
            if (hexString.isEmpty()) {
                return 0;
            }
            return Long.parseLong(hexString, 16) << 32; // no decimal
        }

        return Long.parseLong(hexString.substring(0, ind), 16) << 32 |
                Long.parseLong(hexString.substring(ind + 1), 16);
    }","  public void test28()  throws Throwable  {
      long long0 = TimeStamp.decodeNtpHexString(""d6a8f941.51eb851e"");
}"
886,"    protected static long decodeNtpHexString(final String hexString)
            throws NumberFormatException
    {
        if (hexString == null) {
            throw new NumberFormatException(""null"");
        }
        final int ind = hexString.indexOf('.');
        if (ind == -1) {
            if (hexString.isEmpty()) {
                return 0;
            }
            return Long.parseLong(hexString, 16) << 32; // no decimal
        }

        return Long.parseLong(hexString.substring(0, ind), 16) << 32 |
                Long.parseLong(hexString.substring(ind + 1), 16);
    }","  public void test29()  throws Throwable  {
      try { 
        TimeStamp.decodeNtpHexString(""null"");
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // For input string: \""null\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
887,"    public TimeStamp(final long ntpTime)
    {
        this.ntpTime = ntpTime;
    }","  public void test30()  throws Throwable  {
      TimeStamp timeStamp0 = null;
      try {
        timeStamp0 = new TimeStamp(""91\"""");
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // For input string: \""91\""\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
888,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test31()  throws Throwable  {
      long long0 = TimeStamp.getTime((-567L));
}"
889,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test32()  throws Throwable  {
      TimeStamp timeStamp0 = new TimeStamp(2645L);
      Date date0 = timeStamp0.getDate();
}"
890,"    public String toString()
    {
        return toString(ntpTime);
    }","  public void test33()  throws Throwable  {
      TimeStamp timeStamp0 = new TimeStamp(2645L);
      Date date0 = timeStamp0.getDate();
}"
891,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test34()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      long long0 = timeStamp0.ntpValue();
}"
892,"    public int compareTo(final TimeStamp anotherTimeStamp)
    {
        final long thisVal = this.ntpTime;
        final long anotherVal = anotherTimeStamp.ntpTime;
        return (thisVal < anotherVal ? -1 : (thisVal == anotherVal ? 0 : 1));
    }","  public void test35()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      TimeStamp timeStamp1 = TimeStamp.getNtpTime(0L);
      int int0 = timeStamp0.compareTo(timeStamp1);
}"
893,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test36()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      TimeStamp timeStamp1 = TimeStamp.getNtpTime(0L);
      int int0 = timeStamp0.compareTo(timeStamp1);
}"
894,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test37()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      TimeStamp timeStamp1 = TimeStamp.getNtpTime(0L);
      int int0 = timeStamp0.compareTo(timeStamp1);
}"
895,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test38()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      MockDate mockDate0 = new MockDate(1266, 1266, 1266, 1266, 1266, 1266);
      TimeStamp timeStamp1 = new TimeStamp(mockDate0);
      int int0 = timeStamp0.compareTo(timeStamp1);
}"
896,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test39()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      MockDate mockDate0 = new MockDate(1266, 1266, 1266, 1266, 1266, 1266);
      TimeStamp timeStamp1 = new TimeStamp(mockDate0);
      int int0 = timeStamp0.compareTo(timeStamp1);
}"
897,"    public int compareTo(final TimeStamp anotherTimeStamp)
    {
        final long thisVal = this.ntpTime;
        final long anotherVal = anotherTimeStamp.ntpTime;
        return (thisVal < anotherVal ? -1 : (thisVal == anotherVal ? 0 : 1));
    }","  public void test40()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      MockDate mockDate0 = new MockDate(1266, 1266, 1266, 1266, 1266, 1266);
      TimeStamp timeStamp1 = new TimeStamp(mockDate0);
      int int0 = timeStamp0.compareTo(timeStamp1);
}"
898,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test41()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      int int0 = timeStamp0.compareTo(timeStamp0);
}"
899,"    public int compareTo(final TimeStamp anotherTimeStamp)
    {
        final long thisVal = this.ntpTime;
        final long anotherVal = anotherTimeStamp.ntpTime;
        return (thisVal < anotherVal ? -1 : (thisVal == anotherVal ? 0 : 1));
    }","  public void test42()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      int int0 = timeStamp0.compareTo(timeStamp0);
}"
900,"    public String toUTCString()
    {
        if (utcFormatter == null) {
            utcFormatter = new SimpleDateFormat(NTP_DATE_FORMAT + "" 'UTC'"",
                    Locale.US);
            utcFormatter.setTimeZone(TimeZone.getTimeZone(""UTC""));
        }
        final Date ntpDate = getDate();
        return utcFormatter.format(ntpDate);
    }","  public void test43()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      timeStamp0.toUTCString();
      String string0 = timeStamp0.toUTCString();
}"
901,"    public boolean equals(final Object obj)
    {
        if (obj instanceof TimeStamp) {
            return ntpTime == ((TimeStamp) obj).ntpValue();
        }
        return false;
    }","  public void test44()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""00000000.00000cb1"");
      boolean boolean0 = timeStamp0.equals(""00000000.00000cb1"");
}"
902,"    public long getFraction()
    {
        return ntpTime & 0xffffffffL;
    }","  public void test45()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""00000000.00000cb1"");
      boolean boolean0 = timeStamp0.equals(""00000000.00000cb1"");
}"
903,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test46()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""7"");
      TimeStamp timeStamp1 = TimeStamp.getCurrentTime();
      boolean boolean0 = timeStamp0.equals(timeStamp1);
}"
904,"    public boolean equals(final Object obj)
    {
        if (obj instanceof TimeStamp) {
            return ntpTime == ((TimeStamp) obj).ntpValue();
        }
        return false;
    }","  public void test47()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""7"");
      TimeStamp timeStamp1 = TimeStamp.getCurrentTime();
      boolean boolean0 = timeStamp0.equals(timeStamp1);
}"
905,"    public boolean equals(final Object obj)
    {
        if (obj instanceof TimeStamp) {
            return ntpTime == ((TimeStamp) obj).ntpValue();
        }
        return false;
    }","  public void test48()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""7"");
      TimeStamp timeStamp1 = TimeStamp.getCurrentTime();
      boolean boolean0 = timeStamp0.equals(timeStamp1);
}"
906,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test49()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""7"");
      TimeStamp timeStamp1 = TimeStamp.getCurrentTime();
      boolean boolean0 = timeStamp0.equals(timeStamp1);
}"
907,"    public static TimeStamp parseNtpString(final String s)
            throws NumberFormatException
    {
        return new TimeStamp(decodeNtpHexString(s));
    }","  public void test50()  throws Throwable  {
      try { 
        TimeStamp.parseNtpString((String) null);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // null
         //
         verifyException(""org.apache.commons.net.ntp.TimeStamp"", e);
      }
  }"
908,"    public int compareTo(final TimeStamp anotherTimeStamp)
    {
        final long thisVal = this.ntpTime;
        final long anotherVal = anotherTimeStamp.ntpTime;
        return (thisVal < anotherVal ? -1 : (thisVal == anotherVal ? 0 : 1));
    }","  public void test51()  throws Throwable  {
      TimeStamp timeStamp0 = new TimeStamp((Date) null);
      // Undeclared exception!
      try { 
        timeStamp0.compareTo((TimeStamp) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ntp.TimeStamp"", e);
      }
  }"
909,"    public long getTime()
    {
        return getTime(ntpTime);
    }","  public void test52()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""00000000.00000cb1"");
      long long0 = timeStamp0.getTime();
}"
910,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test53()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""00000000.00000cb1"");
      long long0 = timeStamp0.getTime();
}"
911,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test54()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      long long0 = timeStamp0.getSeconds();
}"
912,"    public long getSeconds()
    {
        return (ntpTime >>> 32) & 0xffffffffL;
    }","  public void test55()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      long long0 = timeStamp0.getSeconds();
}"
913,"    public String toString()
    {
        return toString(ntpTime);
    }","  public void test56()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.parseNtpString(""00000000.00000cb1"");
      String string0 = timeStamp0.toString();
}"
914,"    public long getFraction()
    {
        return ntpTime & 0xffffffffL;
    }","  public void test57()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      long long0 = timeStamp0.getFraction();
}"
915,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test58()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      long long0 = timeStamp0.getFraction();
}"
916,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test59()  throws Throwable  {
      TimeStamp timeStamp0 = new TimeStamp("""");
      boolean boolean0 = timeStamp0.equals(timeStamp0);
}"
917,"    public boolean equals(final Object obj)
    {
        if (obj instanceof TimeStamp) {
            return ntpTime == ((TimeStamp) obj).ntpValue();
        }
        return false;
    }","  public void test60()  throws Throwable  {
      TimeStamp timeStamp0 = new TimeStamp("""");
      boolean boolean0 = timeStamp0.equals(timeStamp0);
}"
918,"    public String toString()
    {
        return toString(ntpTime);
    }","  public void test61()  throws Throwable  {
      String string0 = TimeStamp.toString((-1L));
}"
919,"    public long ntpValue()
    {
        return ntpTime;
    }","  public void test62()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      timeStamp0.toDateString();
      String string0 = timeStamp0.toDateString();
}"
920,"    public String toDateString()
    {
        if (simpleFormatter == null) {
            simpleFormatter = new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);
            simpleFormatter.setTimeZone(TimeZone.getDefault());
        }
        final Date ntpDate = getDate();
        return simpleFormatter.format(ntpDate);
    }","  public void test63()  throws Throwable  {
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      timeStamp0.toDateString();
      String string0 = timeStamp0.toDateString();
}"
921,"     public static String getHostAddress(final int address)
     {
          return ((address >>> 24) & 0xFF) + ""."" +
                 ((address >>> 16) & 0xFF) + ""."" +
                 ((address >>>  8) & 0xFF) + ""."" +
                 ((address >>>  0) & 0xFF);
     }","  public void test0()  throws Throwable  {
      String string0 = NtpUtils.getHostAddress((-79));
}"
922,"    public static String getModeName(final int mode)
    {
        switch (mode) {
            case NtpV3Packet.MODE_RESERVED:
                return ""Reserved"";
            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
                return ""Symmetric Active"";
            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
                return ""Symmetric Passive"";
            case NtpV3Packet.MODE_CLIENT:
                return ""Client"";
            case NtpV3Packet.MODE_SERVER:
                return ""Server"";
            case NtpV3Packet.MODE_BROADCAST:
                return ""Broadcast"";
            case NtpV3Packet.MODE_CONTROL_MESSAGE:
                return ""Control"";
            case NtpV3Packet.MODE_PRIVATE:
                return ""Private"";
            default:
                return ""Unknown"";
        }
    }","  public void test1()  throws Throwable  {
      String string0 = NtpUtils.getModeName((-1629));
}"
923,"    public static String getModeName(final int mode)
    {
        switch (mode) {
            case NtpV3Packet.MODE_RESERVED:
                return ""Reserved"";
            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
                return ""Symmetric Active"";
            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
                return ""Symmetric Passive"";
            case NtpV3Packet.MODE_CLIENT:
                return ""Client"";
            case NtpV3Packet.MODE_SERVER:
                return ""Server"";
            case NtpV3Packet.MODE_BROADCAST:
                return ""Broadcast"";
            case NtpV3Packet.MODE_CONTROL_MESSAGE:
                return ""Control"";
            case NtpV3Packet.MODE_PRIVATE:
                return ""Private"";
            default:
                return ""Unknown"";
        }
    }","  public void test2()  throws Throwable  {
      String string0 = NtpUtils.getModeName(7);
}"
924,"    public static String getModeName(final int mode)
    {
        switch (mode) {
            case NtpV3Packet.MODE_RESERVED:
                return ""Reserved"";
            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
                return ""Symmetric Active"";
            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
                return ""Symmetric Passive"";
            case NtpV3Packet.MODE_CLIENT:
                return ""Client"";
            case NtpV3Packet.MODE_SERVER:
                return ""Server"";
            case NtpV3Packet.MODE_BROADCAST:
                return ""Broadcast"";
            case NtpV3Packet.MODE_CONTROL_MESSAGE:
                return ""Control"";
            case NtpV3Packet.MODE_PRIVATE:
                return ""Private"";
            default:
                return ""Unknown"";
        }
    }","  public void test3()  throws Throwable  {
      String string0 = NtpUtils.getModeName(6);
}"
925,"    public static String getModeName(final int mode)
    {
        switch (mode) {
            case NtpV3Packet.MODE_RESERVED:
                return ""Reserved"";
            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
                return ""Symmetric Active"";
            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
                return ""Symmetric Passive"";
            case NtpV3Packet.MODE_CLIENT:
                return ""Client"";
            case NtpV3Packet.MODE_SERVER:
                return ""Server"";
            case NtpV3Packet.MODE_BROADCAST:
                return ""Broadcast"";
            case NtpV3Packet.MODE_CONTROL_MESSAGE:
                return ""Control"";
            case NtpV3Packet.MODE_PRIVATE:
                return ""Private"";
            default:
                return ""Unknown"";
        }
    }","  public void test4()  throws Throwable  {
      String string0 = NtpUtils.getModeName(5);
}"
926,"    public static String getModeName(final int mode)
    {
        switch (mode) {
            case NtpV3Packet.MODE_RESERVED:
                return ""Reserved"";
            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
                return ""Symmetric Active"";
            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
                return ""Symmetric Passive"";
            case NtpV3Packet.MODE_CLIENT:
                return ""Client"";
            case NtpV3Packet.MODE_SERVER:
                return ""Server"";
            case NtpV3Packet.MODE_BROADCAST:
                return ""Broadcast"";
            case NtpV3Packet.MODE_CONTROL_MESSAGE:
                return ""Control"";
            case NtpV3Packet.MODE_PRIVATE:
                return ""Private"";
            default:
                return ""Unknown"";
        }
    }","  public void test5()  throws Throwable  {
      String string0 = NtpUtils.getModeName(4);
}"
927,"    public static String getModeName(final int mode)
    {
        switch (mode) {
            case NtpV3Packet.MODE_RESERVED:
                return ""Reserved"";
            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
                return ""Symmetric Active"";
            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
                return ""Symmetric Passive"";
            case NtpV3Packet.MODE_CLIENT:
                return ""Client"";
            case NtpV3Packet.MODE_SERVER:
                return ""Server"";
            case NtpV3Packet.MODE_BROADCAST:
                return ""Broadcast"";
            case NtpV3Packet.MODE_CONTROL_MESSAGE:
                return ""Control"";
            case NtpV3Packet.MODE_PRIVATE:
                return ""Private"";
            default:
                return ""Unknown"";
        }
    }","  public void test6()  throws Throwable  {
      String string0 = NtpUtils.getModeName(3);
}"
928,"    public static String getModeName(final int mode)
    {
        switch (mode) {
            case NtpV3Packet.MODE_RESERVED:
                return ""Reserved"";
            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
                return ""Symmetric Active"";
            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
                return ""Symmetric Passive"";
            case NtpV3Packet.MODE_CLIENT:
                return ""Client"";
            case NtpV3Packet.MODE_SERVER:
                return ""Server"";
            case NtpV3Packet.MODE_BROADCAST:
                return ""Broadcast"";
            case NtpV3Packet.MODE_CONTROL_MESSAGE:
                return ""Control"";
            case NtpV3Packet.MODE_PRIVATE:
                return ""Private"";
            default:
                return ""Unknown"";
        }
    }","  public void test7()  throws Throwable  {
      String string0 = NtpUtils.getModeName(2);
}"
929,"    public static String getModeName(final int mode)
    {
        switch (mode) {
            case NtpV3Packet.MODE_RESERVED:
                return ""Reserved"";
            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
                return ""Symmetric Active"";
            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
                return ""Symmetric Passive"";
            case NtpV3Packet.MODE_CLIENT:
                return ""Client"";
            case NtpV3Packet.MODE_SERVER:
                return ""Server"";
            case NtpV3Packet.MODE_BROADCAST:
                return ""Broadcast"";
            case NtpV3Packet.MODE_CONTROL_MESSAGE:
                return ""Control"";
            case NtpV3Packet.MODE_PRIVATE:
                return ""Private"";
            default:
                return ""Unknown"";
        }
    }","  public void test8()  throws Throwable  {
      String string0 = NtpUtils.getModeName(1);
}"
930,"    public static String getModeName(final int mode)
    {
        switch (mode) {
            case NtpV3Packet.MODE_RESERVED:
                return ""Reserved"";
            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
                return ""Symmetric Active"";
            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
                return ""Symmetric Passive"";
            case NtpV3Packet.MODE_CLIENT:
                return ""Client"";
            case NtpV3Packet.MODE_SERVER:
                return ""Server"";
            case NtpV3Packet.MODE_BROADCAST:
                return ""Broadcast"";
            case NtpV3Packet.MODE_CONTROL_MESSAGE:
                return ""Control"";
            case NtpV3Packet.MODE_PRIVATE:
                return ""Private"";
            default:
                return ""Unknown"";
        }
    }","  public void test9()  throws Throwable  {
      String string0 = NtpUtils.getModeName(0);
}"
931,"    public static String getReferenceClock(final NtpV3Packet message) {
        if (message == null) {
            return """";
        }
        final int refId = message.getReferenceId();
        if (refId == 0) {
            return """";
        }
        final StringBuilder buf = new StringBuilder(4);
        // start at highest-order byte (0x4c434c00 -> LCL)
        for (int shiftBits = 24; shiftBits >= 0; shiftBits -= 8)
        {
            final char c = (char) ((refId >>> shiftBits) & 0xff);
            if (c == 0) { // 0-terminated ASCII string
                break;
            }
            if (!Character.isLetterOrDigit(c)) {
                return """";
            }
            buf.append(c);
        }
        return buf.toString();
    }","  public void test10()  throws Throwable  {
      String string0 = NtpUtils.getReferenceClock((NtpV3Packet) null);
}"
932,"    public static String getReferenceClock(final NtpV3Packet message) {
        if (message == null) {
            return """";
        }
        final int refId = message.getReferenceId();
        if (refId == 0) {
            return """";
        }
        final StringBuilder buf = new StringBuilder(4);
        // start at highest-order byte (0x4c434c00 -> LCL)
        for (int shiftBits = 24; shiftBits >= 0; shiftBits -= 8)
        {
            final char c = (char) ((refId >>> shiftBits) & 0xff);
            if (c == 0) { // 0-terminated ASCII string
                break;
            }
            if (!Character.isLetterOrDigit(c)) {
                return """";
            }
            buf.append(c);
        }
        return buf.toString();
    }","  public void test11()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      String string0 = NtpUtils.getReferenceClock(ntpV3Impl0);
}"
933,"     public static String getRefAddress(final NtpV3Packet packet)
     {
         final int address = (packet == null) ? 0 : packet.getReferenceId();
         return getHostAddress(address);
     }","  public void test12()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      String string0 = NtpUtils.getRefAddress(ntpV3Impl0);
}"
934,,"  public void test13()  throws Throwable  {
      NtpUtils ntpUtils0 = new NtpUtils();
  }"
935,"     public static String getRefAddress(final NtpV3Packet packet)
     {
         final int address = (packet == null) ? 0 : packet.getReferenceId();
         return getHostAddress(address);
     }","  public void test14()  throws Throwable  {
      String string0 = NtpUtils.getRefAddress((NtpV3Packet) null);
}"
936,"    public int getVersion()
    {
        return version;
    }","  public void test0()  throws Throwable  {
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
}"
937,"    public int getVersion()
    {
        return version;
    }","  public void test1()  throws Throwable  {
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      nTPUDPClient0.setVersion(0);
      int int0 = nTPUDPClient0.getVersion();
}"
938,"    public int getVersion()
    {
        return version;
    }","  public void test2()  throws Throwable  {
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      nTPUDPClient0.setVersion((-2144));
      int int0 = nTPUDPClient0.getVersion();
}"
939,"    public int getVersion()
    {
        return version;
    }","  public void test3()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""org.apache.commons.net.ntp.NTPUDPClient"", 123);
      byte[] byteArray0 = new byte[7];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      System.setCurrentTimeMillis(0);
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      nTPUDPClient0.getTime(inetAddress0, 0);
}"
940,"    public int getVersion()
    {
        return version;
    }","  public void test4()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 123);
      byte[] byteArray0 = new byte[8];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      TimeInfo timeInfo0 = nTPUDPClient0.getTime(inetAddress0, (int) (byte)24);
}"
941,"    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
    {
        // if not connected then open to next available UDP port
        if (!isOpen())
        {
            open();
        }

        final NtpV3Packet message = new NtpV3Impl();
        message.setMode(NtpV3Packet.MODE_CLIENT);
        message.setVersion(version);
        final DatagramPacket sendPacket = message.getDatagramPacket();
        sendPacket.setAddress(host);
        sendPacket.setPort(port);

        final NtpV3Packet recMessage = new NtpV3Impl();
        final DatagramPacket receivePacket = recMessage.getDatagramPacket();

        /*
         * Must minimize the time between getting the current time,
         * timestamping the packet, and sending it out which
         * introduces an error in the delay time.
         * No extraneous logging and initializations here !!!
         */
        final TimeStamp now = TimeStamp.getCurrentTime();

        // Note that if you do not set the transmit time field then originating time
        // in server response is all 0's which is ""Thu Feb 07 01:28:16 EST 2036"".
        message.setTransmitTime(now);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        final long returnTimeMillis = System.currentTimeMillis();
        // create TimeInfo message container but don't pre-compute the details yet
        return new TimeInfo(recMessage, returnTimeMillis, false);
    }","  public void test5()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 123);
      byte[] byteArray0 = new byte[8];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      TimeInfo timeInfo0 = nTPUDPClient0.getTime(inetAddress0, (int) (byte)24);
}"
942,"    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
    {
        // if not connected then open to next available UDP port
        if (!isOpen())
        {
            open();
        }

        final NtpV3Packet message = new NtpV3Impl();
        message.setMode(NtpV3Packet.MODE_CLIENT);
        message.setVersion(version);
        final DatagramPacket sendPacket = message.getDatagramPacket();
        sendPacket.setAddress(host);
        sendPacket.setPort(port);

        final NtpV3Packet recMessage = new NtpV3Impl();
        final DatagramPacket receivePacket = recMessage.getDatagramPacket();

        /*
         * Must minimize the time between getting the current time,
         * timestamping the packet, and sending it out which
         * introduces an error in the delay time.
         * No extraneous logging and initializations here !!!
         */
        final TimeStamp now = TimeStamp.getCurrentTime();

        // Note that if you do not set the transmit time field then originating time
        // in server response is all 0's which is ""Thu Feb 07 01:28:16 EST 2036"".
        message.setTransmitTime(now);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        final long returnTimeMillis = System.currentTimeMillis();
        // create TimeInfo message container but don't pre-compute the details yet
        return new TimeInfo(recMessage, returnTimeMillis, false);
    }","  public void test6()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 123);
      byte[] byteArray0 = new byte[8];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      System.setCurrentTimeMillis((-638L));
      TimeInfo timeInfo0 = nTPUDPClient0.getTime(inetAddress0, 0);
}"
943,"    public int getVersion()
    {
        return version;
    }","  public void test7()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 123);
      byte[] byteArray0 = new byte[8];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      System.setCurrentTimeMillis((-638L));
      TimeInfo timeInfo0 = nTPUDPClient0.getTime(inetAddress0, 0);
}"
944,"    public int getVersion()
    {
        return version;
    }","  public void test8()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 123);
      byte[] byteArray0 = new byte[8];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      System.setCurrentTimeMillis(0L);
      nTPUDPClient0.getTime(inetAddress0);
}"
945,"    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
    {
        // if not connected then open to next available UDP port
        if (!isOpen())
        {
            open();
        }

        final NtpV3Packet message = new NtpV3Impl();
        message.setMode(NtpV3Packet.MODE_CLIENT);
        message.setVersion(version);
        final DatagramPacket sendPacket = message.getDatagramPacket();
        sendPacket.setAddress(host);
        sendPacket.setPort(port);

        final NtpV3Packet recMessage = new NtpV3Impl();
        final DatagramPacket receivePacket = recMessage.getDatagramPacket();

        /*
         * Must minimize the time between getting the current time,
         * timestamping the packet, and sending it out which
         * introduces an error in the delay time.
         * No extraneous logging and initializations here !!!
         */
        final TimeStamp now = TimeStamp.getCurrentTime();

        // Note that if you do not set the transmit time field then originating time
        // in server response is all 0's which is ""Thu Feb 07 01:28:16 EST 2036"".
        message.setTransmitTime(now);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        final long returnTimeMillis = System.currentTimeMillis();
        // create TimeInfo message container but don't pre-compute the details yet
        return new TimeInfo(recMessage, returnTimeMillis, false);
    }","  public void test9()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 123);
      byte[] byteArray0 = new byte[8];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      System.setCurrentTimeMillis((-638L));
      TimeInfo timeInfo0 = nTPUDPClient0.getTime(inetAddress0);
}"
946,"    public int getVersion()
    {
        return version;
    }","  public void test10()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 123);
      byte[] byteArray0 = new byte[8];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      System.setCurrentTimeMillis((-638L));
      TimeInfo timeInfo0 = nTPUDPClient0.getTime(inetAddress0);
}"
947,"    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
    {
        // if not connected then open to next available UDP port
        if (!isOpen())
        {
            open();
        }

        final NtpV3Packet message = new NtpV3Impl();
        message.setMode(NtpV3Packet.MODE_CLIENT);
        message.setVersion(version);
        final DatagramPacket sendPacket = message.getDatagramPacket();
        sendPacket.setAddress(host);
        sendPacket.setPort(port);

        final NtpV3Packet recMessage = new NtpV3Impl();
        final DatagramPacket receivePacket = recMessage.getDatagramPacket();

        /*
         * Must minimize the time between getting the current time,
         * timestamping the packet, and sending it out which
         * introduces an error in the delay time.
         * No extraneous logging and initializations here !!!
         */
        final TimeStamp now = TimeStamp.getCurrentTime();

        // Note that if you do not set the transmit time field then originating time
        // in server response is all 0's which is ""Thu Feb 07 01:28:16 EST 2036"".
        message.setTransmitTime(now);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        final long returnTimeMillis = System.currentTimeMillis();
        // create TimeInfo message container but don't pre-compute the details yet
        return new TimeInfo(recMessage, returnTimeMillis, false);
    }","  public void test11()  throws Throwable  {
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      // Undeclared exception!
      try { 
        nTPUDPClient0.getTime(inetAddress0, (-1426));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-1426
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
948,"    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
    {
        // if not connected then open to next available UDP port
        if (!isOpen())
        {
            open();
        }

        final NtpV3Packet message = new NtpV3Impl();
        message.setMode(NtpV3Packet.MODE_CLIENT);
        message.setVersion(version);
        final DatagramPacket sendPacket = message.getDatagramPacket();
        sendPacket.setAddress(host);
        sendPacket.setPort(port);

        final NtpV3Packet recMessage = new NtpV3Impl();
        final DatagramPacket receivePacket = recMessage.getDatagramPacket();

        /*
         * Must minimize the time between getting the current time,
         * timestamping the packet, and sending it out which
         * introduces an error in the delay time.
         * No extraneous logging and initializations here !!!
         */
        final TimeStamp now = TimeStamp.getCurrentTime();

        // Note that if you do not set the transmit time field then originating time
        // in server response is all 0's which is ""Thu Feb 07 01:28:16 EST 2036"".
        message.setTransmitTime(now);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        final long returnTimeMillis = System.currentTimeMillis();
        // create TimeInfo message container but don't pre-compute the details yet
        return new TimeInfo(recMessage, returnTimeMillis, false);
    }","  public void test12()  throws Throwable  {
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      // Undeclared exception!
      try { 
        nTPUDPClient0.getTime((InetAddress) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // null buffer || null address
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
949,"    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
    {
        // if not connected then open to next available UDP port
        if (!isOpen())
        {
            open();
        }

        final NtpV3Packet message = new NtpV3Impl();
        message.setMode(NtpV3Packet.MODE_CLIENT);
        message.setVersion(version);
        final DatagramPacket sendPacket = message.getDatagramPacket();
        sendPacket.setAddress(host);
        sendPacket.setPort(port);

        final NtpV3Packet recMessage = new NtpV3Impl();
        final DatagramPacket receivePacket = recMessage.getDatagramPacket();

        /*
         * Must minimize the time between getting the current time,
         * timestamping the packet, and sending it out which
         * introduces an error in the delay time.
         * No extraneous logging and initializations here !!!
         */
        final TimeStamp now = TimeStamp.getCurrentTime();

        // Note that if you do not set the transmit time field then originating time
        // in server response is all 0's which is ""Thu Feb 07 01:28:16 EST 2036"".
        message.setTransmitTime(now);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        final long returnTimeMillis = System.currentTimeMillis();
        // create TimeInfo message container but don't pre-compute the details yet
        return new TimeInfo(recMessage, returnTimeMillis, false);
    }","  public void test13()  throws Throwable  {
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      // Undeclared exception!
      try { 
        nTPUDPClient0.getTime((InetAddress) null, 1328);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // null buffer || null address
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
950,"    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
    {
        // if not connected then open to next available UDP port
        if (!isOpen())
        {
            open();
        }

        final NtpV3Packet message = new NtpV3Impl();
        message.setMode(NtpV3Packet.MODE_CLIENT);
        message.setVersion(version);
        final DatagramPacket sendPacket = message.getDatagramPacket();
        sendPacket.setAddress(host);
        sendPacket.setPort(port);

        final NtpV3Packet recMessage = new NtpV3Impl();
        final DatagramPacket receivePacket = recMessage.getDatagramPacket();

        /*
         * Must minimize the time between getting the current time,
         * timestamping the packet, and sending it out which
         * introduces an error in the delay time.
         * No extraneous logging and initializations here !!!
         */
        final TimeStamp now = TimeStamp.getCurrentTime();

        // Note that if you do not set the transmit time field then originating time
        // in server response is all 0's which is ""Thu Feb 07 01:28:16 EST 2036"".
        message.setTransmitTime(now);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        final long returnTimeMillis = System.currentTimeMillis();
        // create TimeInfo message container but don't pre-compute the details yet
        return new TimeInfo(recMessage, returnTimeMillis, false);
    }","  public void test14()  throws Throwable  {
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      nTPUDPClient0.open(0, inetAddress0);
      try { 
        nTPUDPClient0.getTime(inetAddress0, 0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
951,"    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
    {
        // if not connected then open to next available UDP port
        if (!isOpen())
        {
            open();
        }

        final NtpV3Packet message = new NtpV3Impl();
        message.setMode(NtpV3Packet.MODE_CLIENT);
        message.setVersion(version);
        final DatagramPacket sendPacket = message.getDatagramPacket();
        sendPacket.setAddress(host);
        sendPacket.setPort(port);

        final NtpV3Packet recMessage = new NtpV3Impl();
        final DatagramPacket receivePacket = recMessage.getDatagramPacket();

        /*
         * Must minimize the time between getting the current time,
         * timestamping the packet, and sending it out which
         * introduces an error in the delay time.
         * No extraneous logging and initializations here !!!
         */
        final TimeStamp now = TimeStamp.getCurrentTime();

        // Note that if you do not set the transmit time field then originating time
        // in server response is all 0's which is ""Thu Feb 07 01:28:16 EST 2036"".
        message.setTransmitTime(now);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        final long returnTimeMillis = System.currentTimeMillis();
        // create TimeInfo message container but don't pre-compute the details yet
        return new TimeInfo(recMessage, returnTimeMillis, false);
    }","  public void test15()  throws Throwable  {
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 123);
      byte[] byteArray0 = new byte[28];
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      nTPUDPClient0.getTime(inetAddress0);
      try { 
        nTPUDPClient0.getTime(inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
952,"    public int getVersion()
    {
        return version;
    }","  public void test16()  throws Throwable  {
      NTPUDPClient nTPUDPClient0 = new NTPUDPClient();
      int int0 = nTPUDPClient0.getVersion();
}"
953,"    public List<String> getComments()
    {
        return comments;
    }","  public void test0()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 3841L);
      List<String> list0 = timeInfo0.getComments();
}"
954,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test1()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 3841L);
      List<String> list0 = timeInfo0.getComments();
      TimeInfo timeInfo1 = new TimeInfo(ntpV3Impl0, 0L, list0, false);
      boolean boolean0 = timeInfo0.equals(timeInfo1);
}"
955,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test2()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 3841L);
      List<String> list0 = timeInfo0.getComments();
      TimeInfo timeInfo1 = new TimeInfo(ntpV3Impl0, 0L, list0, false);
      boolean boolean0 = timeInfo0.equals(timeInfo1);
}"
956,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test3()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 3841L);
      List<String> list0 = timeInfo0.getComments();
      TimeInfo timeInfo1 = new TimeInfo(ntpV3Impl0, 0L, list0, false);
      boolean boolean0 = timeInfo0.equals(timeInfo1);
}"
957,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test4()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 3841L);
      List<String> list0 = timeInfo0.getComments();
      TimeInfo timeInfo1 = new TimeInfo(ntpV3Impl0, 0L, list0, false);
      boolean boolean0 = timeInfo0.equals(timeInfo1);
}"
958,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test5()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 0L, linkedList0);
      timeInfo0.getReturnTime();
}"
959,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test6()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-2715L), linkedList0, true);
      long long0 = timeInfo0.getReturnTime();
}"
960,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test7()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-2715L), linkedList0, true);
      long long0 = timeInfo0.getReturnTime();
}"
961,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test8()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
      Locale locale0 = Locale.CHINA;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0);
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 1896L, list0, false);
      List<String> list1 = timeInfo0.getComments();
}"
962,"    public List<String> getComments()
    {
        return comments;
    }","  public void test9()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
      Locale locale0 = Locale.CHINA;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0);
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 1896L, list0, false);
      List<String> list1 = timeInfo0.getComments();
}"
963,"    public InetAddress getAddress() {
        final DatagramPacket pkt = message.getDatagramPacket();
        return pkt == null ? null : pkt.getAddress();
    }","  public void test10()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 0L, linkedList0);
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      MockInetSocketAddress mockInetSocketAddress0 = new MockInetSocketAddress((InetAddress) null, 427);
      datagramPacket0.setSocketAddress(mockInetSocketAddress0);
      timeInfo0.getAddress();
}"
964,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test11()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 110L);
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      SocketAddress socketAddress0 = datagramPacket0.getSocketAddress();
      datagramPacket0.setSocketAddress(socketAddress0);
      InetAddress inetAddress0 = timeInfo0.getAddress();
}"
965,"    public InetAddress getAddress() {
        final DatagramPacket pkt = message.getDatagramPacket();
        return pkt == null ? null : pkt.getAddress();
    }","  public void test12()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 110L);
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      SocketAddress socketAddress0 = datagramPacket0.getSocketAddress();
      datagramPacket0.setSocketAddress(socketAddress0);
      InetAddress inetAddress0 = timeInfo0.getAddress();
}"
966,"    public InetAddress getAddress() {
        final DatagramPacket pkt = message.getDatagramPacket();
        return pkt == null ? null : pkt.getAddress();
    }","  public void test13()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      datagramPacket0.setAddress(inetAddress0);
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-1103L), false);
      InetAddress inetAddress1 = timeInfo0.getAddress();
}"
967,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test14()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      datagramPacket0.setAddress(inetAddress0);
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-1103L), false);
      InetAddress inetAddress1 = timeInfo0.getAddress();
}"
968,"    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis) {
        this(message, returnTimeMillis, null, true);
    }","  public void test15()  throws Throwable  {
      TimeInfo timeInfo0 = null;
      try {
        timeInfo0 = new TimeInfo((NtpV3Packet) null, (-185L), false);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // message cannot be null
         //
         verifyException(""org.apache.commons.net.ntp.TimeInfo"", e);
      }
  }"
969,"    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis) {
        this(message, returnTimeMillis, null, true);
    }","  public void test16()  throws Throwable  {
      TimeInfo timeInfo0 = null;
      try {
        timeInfo0 = new TimeInfo((NtpV3Packet) null, (-1406L));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // message cannot be null
         //
         verifyException(""org.apache.commons.net.ntp.TimeInfo"", e);
      }
  }"
970,"    public void computeDetails()
    {
        if (detailsComputed) {
            return; // details already computed - do nothing
        }
        detailsComputed = true;
        if (comments == null) {
            comments = new ArrayList<>();
        }

        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
        final long origTimeMillis = origNtpTime.getTime();

        // Receive Time is time request received by server (t2)
        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
        final long rcvTimeMillis = rcvNtpTime.getTime();

        // Transmit time is time reply sent by server (t3)
        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
        final long xmitTimeMillis = xmitNtpTime.getTime();

        /*
         * Round-trip network delay and local clock offset (or time drift) is calculated
         * according to this standard NTP equation:
         *
         * LocalClockOffset = ((ReceiveTimestamp - OriginateTimestamp) +
         *                     (TransmitTimestamp - DestinationTimestamp)) / 2
         *
         * equations from RFC-1305 (NTPv3)
         *      roundtrip delay = (t4 - t1) - (t3 - t2)
         *      local clock offset = ((t2 - t1) + (t3 - t4)) / 2
         *
         * It takes into account network delays and assumes that they are symmetrical.
         *
         * Note the typo in SNTP RFCs 1769/2030 which state that the delay
         * is (T4 - T1) - (T2 - T3) with the ""T2"" and ""T3"" switched.
         */
        if (origNtpTime.ntpValue() == 0)
        {
            // without originate time cannot determine when packet went out
            // might be via a broadcast NTP packet...
            if (xmitNtpTime.ntpValue() != 0)
            {
                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
                comments.add(""Error: zero orig time -- cannot compute delay"");
            } else {
                comments.add(""Error: zero orig time -- cannot compute delay/offset"");
            }
        } else if (rcvNtpTime.ntpValue() == 0 || xmitNtpTime.ntpValue() == 0) {
            comments.add(""Warning: zero rcvNtpTime or xmitNtpTime"");
            // assert destTime >= origTime since network delay cannot be negative
            if (origTimeMillis > returnTimeMillis) {
                comments.add(""Error: OrigTime > DestRcvTime"");
            } else {
                // without receive or xmit time cannot figure out processing time
                // so delay is simply the network travel time
                delayMillis = Long.valueOf(returnTimeMillis - origTimeMillis);
            }
            // TODO: is offset still valid if rcvNtpTime=0 || xmitNtpTime=0 ???
            // Could always hash origNtpTime (sendTime) but if host doesn't set it
            // then it's an malformed ntp host anyway and we don't care?
            // If server is in broadcast mode then we never send out a query in first place...
            if (rcvNtpTime.ntpValue() != 0)
            {
                // xmitTime is 0 just use rcv time
                offsetMillis = Long.valueOf(rcvTimeMillis - origTimeMillis);
            } else if (xmitNtpTime.ntpValue() != 0)
            {
                // rcvTime is 0 just use xmitTime time
                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
            }
        } else
        {
             long delayValueMillis = returnTimeMillis - origTimeMillis;
             // assert xmitTime >= rcvTime: difference typically < 1ms
             if (xmitTimeMillis < rcvTimeMillis)
             {
                 // server cannot send out a packet before receiving it...
                 comments.add(""Error: xmitTime < rcvTime""); // time-travel not allowed
             } else
             {
                 // subtract processing time from round-trip network delay
                 final long deltaMillis = xmitTimeMillis - rcvTimeMillis;
                 // in normal cases the processing delta is less than
                 // the total roundtrip network travel time.
                 if (deltaMillis <= delayValueMillis)
                 {
                     delayValueMillis -= deltaMillis; // delay = (t4 - t1) - (t3 - t2)
                 } else
                 {
                     // if delta - delayValue == 1 ms then it's a round-off error
                     // e.g. delay=3ms, processing=4ms
                     if (deltaMillis - delayValueMillis == 1)
                     {
                         // delayValue == 0 -> local clock saw no tick change but destination clock did
                         if (delayValueMillis != 0)
                         {
                             comments.add(""Info: processing time > total network time by 1 ms -> assume zero delay"");
                             delayValueMillis = 0;
                         }
                     } else {
                        comments.add(""Warning: processing time > total network time"");
                    }
                 }
             }
             delayMillis = Long.valueOf(delayValueMillis);
            if (origTimeMillis > returnTimeMillis) {
                comments.add(""Error: OrigTime > DestRcvTime"");
            }

            offsetMillis = Long.valueOf(((rcvTimeMillis - origTimeMillis) + (xmitTimeMillis - returnTimeMillis)) / 2);
        }
    }","  public void test17()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 222L, linkedList0, false);
      timeInfo0.computeDetails();
}"
971,"    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis) {
        this(message, returnTimeMillis, null, true);
    }","  public void test18()  throws Throwable  {
      LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0);
      TimeInfo timeInfo0 = null;
      try {
        timeInfo0 = new TimeInfo((NtpV3Packet) null, (-2455L), list0, false);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // message cannot be null
         //
         verifyException(""org.apache.commons.net.ntp.TimeInfo"", e);
      }
  }"
972,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test19()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-2208988800011L), false);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo1 = new TimeInfo(ntpV3Impl0, 303L, linkedList0);
      boolean boolean0 = timeInfo0.equals(timeInfo1);
}"
973,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test20()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-2208988800011L), false);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo1 = new TimeInfo(ntpV3Impl0, 303L, linkedList0);
      boolean boolean0 = timeInfo0.equals(timeInfo1);
}"
974,"    public List<String> getComments()
    {
        return comments;
    }","  public void test21()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 221L);
      List<String> list0 = timeInfo0.getComments();
}"
975,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test22()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 221L);
      List<String> list0 = timeInfo0.getComments();
      boolean boolean0 = timeInfo0.equals(list0);
}"
976,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test23()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 221L);
      List<String> list0 = timeInfo0.getComments();
      boolean boolean0 = timeInfo0.equals(list0);
}"
977,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test24()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 221L);
      List<String> list0 = timeInfo0.getComments();
      boolean boolean0 = timeInfo0.equals(list0);
}"
978,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test25()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 222L, linkedList0, false);
      TimeInfo timeInfo1 = new TimeInfo(ntpV3Impl0, 222L, linkedList0);
      boolean boolean0 = timeInfo0.equals(timeInfo1);
}"
979,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test26()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 222L, linkedList0, false);
      TimeInfo timeInfo1 = new TimeInfo(ntpV3Impl0, 222L, linkedList0);
      boolean boolean0 = timeInfo0.equals(timeInfo1);
}"
980,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test27()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-2583L), linkedList0, true);
      boolean boolean0 = timeInfo0.equals(timeInfo0);
}"
981,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test28()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-2583L), linkedList0, true);
      boolean boolean0 = timeInfo0.equals(timeInfo0);
}"
982,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final TimeInfo other = (TimeInfo) obj;
        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
    }","  public void test29()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 0L);
      boolean boolean0 = timeInfo0.equals((Object) null);
}"
983,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test30()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-1L), false);
      timeInfo0.getAddress();
}"
984,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test31()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-1L), false);
      timeInfo0.computeDetails();
      timeInfo0.computeDetails();
}"
985,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test32()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-2208988800011L), false);
      timeInfo0.addComment(""[3hyH&(\""-"");
}"
986,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test33()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-1L), false);
      timeInfo0.computeDetails();
      timeInfo0.addComment(""The list of prefixes must not be null"");
}"
987,"    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis) {
        this(message, returnTimeMillis, null, true);
    }","  public void test34()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = null;
      try {
        timeInfo0 = new TimeInfo((NtpV3Packet) null, (-3051L), linkedList0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // message cannot be null
         //
         verifyException(""org.apache.commons.net.ntp.TimeInfo"", e);
      }
  }"
988,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test35()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 221L);
      timeInfo0.getDelay();
}"
989,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test36()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-1L), false);
      List<String> list0 = timeInfo0.getComments();
}"
990,"    public List<String> getComments()
    {
        return comments;
    }","  public void test37()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-1L), false);
      List<String> list0 = timeInfo0.getComments();
}"
991,"    public int hashCode()
    {
        final int prime = 31;
        int result = (int)returnTimeMillis;
        result = prime * result + message.hashCode();
        return result;
    }","  public void test38()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-2583L), linkedList0, true);
      timeInfo0.hashCode();
}"
992,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test39()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 965L);
      timeInfo0.getMessage();
}"
993,"    public Long getOffset()
    {
        return offsetMillis;
    }","  public void test40()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, (-2583L), linkedList0, true);
      timeInfo0.getOffset();
}"
994,"    public long getReturnTime()
    {
        return returnTimeMillis;
    }","  public void test41()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 965L);
      long long0 = timeInfo0.getReturnTime();
}"
995,"    public String getReferenceIdString()
    {
        final int version = getVersion();
        final int stratum = getStratum();
        if (version == VERSION_3 || version == VERSION_4) {
            if (stratum == 0 || stratum == 1) {
                return idAsString(); // 4-character ASCII string (e.g. GPS, USNO)
            }
            // in NTPv4 servers this is latest transmit timestamp of ref source
            if (version == VERSION_4) {
                return idAsHex();
            }
        }

        // Stratum 2 and higher this is a four-octet IPv4 address
        // of the primary reference host.
        if (stratum >= 2) {
            return idAsIPAddress();
        }
        return idAsHex();
    }","  public void test0()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setStratum(2);
      String string0 = ntpV3Impl0.getReferenceIdString();
}"
996,"    public int getStratum()
    {
        return ui(buf[STRATUM_INDEX]);
    }","  public void test1()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setStratum(2);
      String string0 = ntpV3Impl0.getReferenceIdString();
}"
997,"    public int getVersion()
    {
        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
    }","  public void test2()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setVersion((-297));
      ntpV3Impl0.toString();
}"
998,"    protected static final long ul(final byte b)
    {
        final long i = b & 0xFF;
        return i;
    }","  public void test3()  throws Throwable  {
      long long0 = NtpV3Impl.ul((byte)0);
}"
999,"    protected static final long ul(final byte b)
    {
        final long i = b & 0xFF;
        return i;
    }","  public void test4()  throws Throwable  {
      long long0 = NtpV3Impl.ul((byte) (-60));
}"
1000,"    protected static final int ui(final byte b)
    {
        final int i = b & 0xFF;
        return i;
    }","  public void test5()  throws Throwable  {
      int int0 = NtpV3Impl.ui((byte)0);
}"
1001,"    protected static final int ui(final byte b)
    {
        final int i = b & 0xFF;
        return i;
    }","  public void test6()  throws Throwable  {
      int int0 = NtpV3Impl.ui((byte) (-106));
}"
1002,"    public int getRootDelay()
    {
        return getInt(ROOT_DELAY_INDEX);
    }","  public void test7()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setVersion((-359));
      int int0 = ntpV3Impl0.getVersion();
}"
1003,"    public int getVersion()
    {
        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
    }","  public void test8()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setVersion((-359));
      int int0 = ntpV3Impl0.getVersion();
}"
1004,"    public TimeStamp getTransmitTimeStamp()
    {
        return getTimestamp(TRANSMIT_TIMESTAMP_INDEX);
    }","  public void test9()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      ntpV3Impl0.setTransmitTime(timeStamp0);
      TimeStamp timeStamp1 = ntpV3Impl0.getTransmitTimeStamp();
}"
1005,"    public int getStratum()
    {
        return ui(buf[STRATUM_INDEX]);
    }","  public void test10()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setStratum(599);
      int int0 = ntpV3Impl0.getStratum();
}"
1006,"    public long getRootDispersionInMillis()
    {
        final long l = getRootDispersion();
        return (l * 1000) / 65536L;
    }","  public void test11()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDispersion(248);
      double double0 = ntpV3Impl0.getRootDispersionInMillisDouble();
}"
1007,"    public double getRootDispersionInMillisDouble()
    {
        final double l = getRootDispersion();
        return l / 65.536;
    }","  public void test12()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDispersion(248);
      double double0 = ntpV3Impl0.getRootDispersionInMillisDouble();
}"
1008,"    public double getRootDispersionInMillisDouble()
    {
        final double l = getRootDispersion();
        return l / 65.536;
    }","  public void test13()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDispersion(248);
      long long0 = ntpV3Impl0.getRootDispersionInMillis();
}"
1009,"    public long getRootDispersionInMillis()
    {
        final long l = getRootDispersion();
        return (l * 1000) / 65536L;
    }","  public void test14()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDispersion(248);
      long long0 = ntpV3Impl0.getRootDispersionInMillis();
}"
1010,"    public double getRootDispersionInMillisDouble()
    {
        final double l = getRootDispersion();
        return l / 65.536;
    }","  public void test15()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDispersion((-411));
      long long0 = ntpV3Impl0.getRootDispersionInMillis();
}"
1011,"    public long getRootDispersionInMillis()
    {
        final long l = getRootDispersion();
        return (l * 1000) / 65536L;
    }","  public void test16()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDispersion((-411));
      long long0 = ntpV3Impl0.getRootDispersionInMillis();
}"
1012,"    public int getRootDispersion()
    {
        return getInt(ROOT_DISPERSION_INDEX);
    }","  public void test17()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDispersion(248);
      int int0 = ntpV3Impl0.getRootDispersion();
}"
1013,"    public double getRootDelayInMillisDouble()
    {
        final double l = getRootDelay();
        return l / 65.536;
    }","  public void test18()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDelay(2048);
      double double0 = ntpV3Impl0.getRootDelayInMillisDouble();
}"
1014,"    public int getRootDelay()
    {
        return getInt(ROOT_DELAY_INDEX);
    }","  public void test19()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDelay((-411));
      double double0 = ntpV3Impl0.getRootDelayInMillisDouble();
}"
1015,"    public double getRootDelayInMillisDouble()
    {
        final double l = getRootDelay();
        return l / 65.536;
    }","  public void test20()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDelay((-411));
      double double0 = ntpV3Impl0.getRootDelayInMillisDouble();
}"
1016,"    public int getRootDelay()
    {
        return getInt(ROOT_DELAY_INDEX);
    }","  public void test21()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDelay(143);
      int int0 = ntpV3Impl0.getRootDelay();
}"
1017,"    public double getRootDelayInMillisDouble()
    {
        final double l = getRootDelay();
        return l / 65.536;
    }","  public void test22()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDelay((-1735));
      int int0 = ntpV3Impl0.getRootDelay();
}"
1018,"    public int getRootDelay()
    {
        return getInt(ROOT_DELAY_INDEX);
    }","  public void test23()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setRootDelay((-1735));
      int int0 = ntpV3Impl0.getRootDelay();
}"
1019,"    public TimeStamp getReferenceTimeStamp()
    {
        return getTimestamp(REFERENCE_TIMESTAMP_INDEX);
    }","  public void test24()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      ntpV3Impl0.setReferenceTime(timeStamp0);
      TimeStamp timeStamp1 = ntpV3Impl0.getReferenceTimeStamp();
}"
1020,"    public int getReferenceId()
    {
        return getInt(REFERENCE_ID_INDEX);
    }","  public void test25()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setReferenceId(1120);
      int int0 = ntpV3Impl0.getReferenceId();
}"
1021,"    public TimeStamp getReceiveTimeStamp()
    {
        return getTimestamp(RECEIVE_TIMESTAMP_INDEX);
    }","  public void test26()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = new TimeStamp(531L);
      ntpV3Impl0.setReceiveTimeStamp(timeStamp0);
      TimeStamp timeStamp1 = ntpV3Impl0.getReceiveTimeStamp();
}"
1022,"    public TimeStamp getReceiveTimeStamp()
    {
        return getTimestamp(RECEIVE_TIMESTAMP_INDEX);
    }","  public void test27()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      ntpV3Impl0.setReceiveTimeStamp(timeStamp0);
      TimeStamp timeStamp1 = ntpV3Impl0.getReceiveTimeStamp();
}"
1023,"    public int getPrecision()
    {
        return buf[PRECISION_INDEX];
    }","  public void test28()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setPrecision(4404);
      int int0 = ntpV3Impl0.getPrecision();
}"
1024,"    public int getPrecision()
    {
        return buf[PRECISION_INDEX];
    }","  public void test29()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setPrecision((-4366));
      int int0 = ntpV3Impl0.getPrecision();
}"
1025,"    public int getPoll()
    {
        return buf[POLL_INDEX];
    }","  public void test30()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setPoll(6);
      int int0 = ntpV3Impl0.getPoll();
}"
1026,"    public int getPoll()
    {
        return buf[POLL_INDEX];
    }","  public void test31()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setPoll(199);
      int int0 = ntpV3Impl0.getPoll();
}"
1027,"    public TimeStamp getOriginateTimeStamp()
    {
        return getTimestamp(ORIGINATE_TIMESTAMP_INDEX);
    }","  public void test32()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = TimeStamp.getCurrentTime();
      ntpV3Impl0.setOriginateTimeStamp(timeStamp0);
      TimeStamp timeStamp1 = ntpV3Impl0.getOriginateTimeStamp();
}"
1028,"    public long getRootDispersionInMillis()
    {
        final long l = getRootDispersion();
        return (l * 1000) / 65536L;
    }","  public void test33()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setMode(230);
      int int0 = ntpV3Impl0.getMode();
}"
1029,"    public int getMode()
    {
        return (ui(buf[MODE_INDEX]) >> MODE_SHIFT) & 0x7;
    }","  public void test34()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setMode(230);
      int int0 = ntpV3Impl0.getMode();
}"
1030,"    public int getLeapIndicator()
    {
        return (ui(buf[LI_INDEX]) >> LI_SHIFT) & 0x3;
    }","  public void test35()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setLeapIndicator(230);
      int int0 = ntpV3Impl0.getLeapIndicator();
}"
1031,"    public synchronized DatagramPacket getDatagramPacket()
    {
        if (dp == null) {
            dp = new DatagramPacket(buf, buf.length);
            dp.setPort(NTP_PORT);
        }
        return dp;
    }","  public void test36()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
}"
1032,"    public synchronized DatagramPacket getDatagramPacket()
    {
        if (dp == null) {
            dp = new DatagramPacket(buf, buf.length);
            dp.setPort(NTP_PORT);
        }
        return dp;
    }","  public void test37()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      datagramPacket0.setPort(0);
      DatagramPacket datagramPacket1 = ntpV3Impl0.getDatagramPacket();
}"
1033,"    public synchronized DatagramPacket getDatagramPacket()
    {
        if (dp == null) {
            dp = new DatagramPacket(buf, buf.length);
            dp.setPort(NTP_PORT);
        }
        return dp;
    }","  public void test38()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
}"
1034,"    public synchronized DatagramPacket getDatagramPacket()
    {
        if (dp == null) {
            dp = new DatagramPacket(buf, buf.length);
            dp.setPort(NTP_PORT);
        }
        return dp;
    }","  public void test39()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      datagramPacket0.setLength(0);
      DatagramPacket datagramPacket1 = ntpV3Impl0.getDatagramPacket();
}"
1035,"    public int getReferenceId()
    {
        return getInt(REFERENCE_ID_INDEX);
    }","  public void test40()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getReferenceId();
}"
1036,"    public int getMode()
    {
        return (ui(buf[MODE_INDEX]) >> MODE_SHIFT) & 0x7;
    }","  public void test41()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getMode();
}"
1037,"    public int getRootDelay()
    {
        return getInt(ROOT_DELAY_INDEX);
    }","  public void test42()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getRootDelay();
}"
1038,"    public int getMode()
    {
        return (ui(buf[MODE_INDEX]) >> MODE_SHIFT) & 0x7;
    }","  public void test43()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getVersion();
}"
1039,"    public int getVersion()
    {
        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
    }","  public void test44()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getVersion();
}"
1040,"    public int getPoll()
    {
        return buf[POLL_INDEX];
    }","  public void test45()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getPoll();
}"
1041,"    public int getStratum()
    {
        return ui(buf[STRATUM_INDEX]);
    }","  public void test46()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getStratum();
}"
1042,"    public int getPrecision()
    {
        return buf[PRECISION_INDEX];
    }","  public void test47()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getPrecision();
}"
1043,"    public TimeStamp getTransmitTimeStamp()
    {
        return getTimestamp(TRANSMIT_TIMESTAMP_INDEX);
    }","  public void test48()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = ntpV3Impl0.getTransmitTimeStamp();
}"
1044,"    public int getRootDispersion()
    {
        return getInt(ROOT_DISPERSION_INDEX);
    }","  public void test49()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getRootDispersion();
}"
1045,"    public double getRootDispersionInMillisDouble()
    {
        final double l = getRootDispersion();
        return l / 65.536;
    }","  public void test50()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      double double0 = ntpV3Impl0.getRootDispersionInMillisDouble();
}"
1046,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final NtpV3Impl other = (NtpV3Impl) obj;
        return java.util.Arrays.equals(buf, other.buf);
    }","  public void test51()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      NtpV3Impl ntpV3Impl1 = new NtpV3Impl();
      boolean boolean0 = ntpV3Impl0.equals(ntpV3Impl1);
}"
1047,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final NtpV3Impl other = (NtpV3Impl) obj;
        return java.util.Arrays.equals(buf, other.buf);
    }","  public void test52()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      boolean boolean0 = ntpV3Impl0.equals((Object) null);
}"
1048,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final NtpV3Impl other = (NtpV3Impl) obj;
        return java.util.Arrays.equals(buf, other.buf);
    }","  public void test53()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      boolean boolean0 = ntpV3Impl0.equals(ntpV3Impl0);
}"
1049,"    public boolean equals(final Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final NtpV3Impl other = (NtpV3Impl) obj;
        return java.util.Arrays.equals(buf, other.buf);
    }","  public void test54()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      Object object0 = new Object();
      boolean boolean0 = ntpV3Impl0.equals(object0);
}"
1050,"    public void setDatagramPacket(final DatagramPacket srcDp)
    {
        if (srcDp == null || srcDp.getLength() < buf.length) {
            throw new IllegalArgumentException();
        }
        final byte[] incomingBuf = srcDp.getData();
        int len = srcDp.getLength();
        if (len > buf.length) {
            len = buf.length;
        }
        System.arraycopy(incomingBuf, 0, buf, 0, len);
        final DatagramPacket dp = getDatagramPacket();
        dp.setAddress(srcDp.getAddress());
        final int port = srcDp.getPort();
        dp.setPort(port > 0 ? port : NTP_PORT);
        dp.setData(buf);
    }","  public void test55()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      MockInetSocketAddress mockInetSocketAddress0 = new MockInetSocketAddress(0);
      datagramPacket0.setSocketAddress(mockInetSocketAddress0);
      ntpV3Impl0.setDatagramPacket(datagramPacket0);
}"
1051,"    public void setDatagramPacket(final DatagramPacket srcDp)
    {
        if (srcDp == null || srcDp.getLength() < buf.length) {
            throw new IllegalArgumentException();
        }
        final byte[] incomingBuf = srcDp.getData();
        int len = srcDp.getLength();
        if (len > buf.length) {
            len = buf.length;
        }
        System.arraycopy(incomingBuf, 0, buf, 0, len);
        final DatagramPacket dp = getDatagramPacket();
        dp.setAddress(srcDp.getAddress());
        final int port = srcDp.getPort();
        dp.setPort(port > 0 ? port : NTP_PORT);
        dp.setData(buf);
    }","  public void test56()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      datagramPacket0.setLength(0);
      // Undeclared exception!
      try { 
        ntpV3Impl0.setDatagramPacket(datagramPacket0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ntp.NtpV3Impl"", e);
      }
  }"
1052,"    public void setDatagramPacket(final DatagramPacket srcDp)
    {
        if (srcDp == null || srcDp.getLength() < buf.length) {
            throw new IllegalArgumentException();
        }
        final byte[] incomingBuf = srcDp.getData();
        int len = srcDp.getLength();
        if (len > buf.length) {
            len = buf.length;
        }
        System.arraycopy(incomingBuf, 0, buf, 0, len);
        final DatagramPacket dp = getDatagramPacket();
        dp.setAddress(srcDp.getAddress());
        final int port = srcDp.getPort();
        dp.setPort(port > 0 ? port : NTP_PORT);
        dp.setData(buf);
    }","  public void test57()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      // Undeclared exception!
      try { 
        ntpV3Impl0.setDatagramPacket((DatagramPacket) null);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ntp.NtpV3Impl"", e);
      }
  }"
1053,"    public synchronized DatagramPacket getDatagramPacket()
    {
        if (dp == null) {
            dp = new DatagramPacket(buf, buf.length);
            dp.setPort(NTP_PORT);
        }
        return dp;
    }","  public void test58()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
}"
1054,"    public void setDatagramPacket(final DatagramPacket srcDp)
    {
        if (srcDp == null || srcDp.getLength() < buf.length) {
            throw new IllegalArgumentException();
        }
        final byte[] incomingBuf = srcDp.getData();
        int len = srcDp.getLength();
        if (len > buf.length) {
            len = buf.length;
        }
        System.arraycopy(incomingBuf, 0, buf, 0, len);
        final DatagramPacket dp = getDatagramPacket();
        dp.setAddress(srcDp.getAddress());
        final int port = srcDp.getPort();
        dp.setPort(port > 0 ? port : NTP_PORT);
        dp.setData(buf);
    }","  public void test59()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      ntpV3Impl0.setDatagramPacket(datagramPacket0);
}"
1055,"    public void setDatagramPacket(final DatagramPacket srcDp)
    {
        if (srcDp == null || srcDp.getLength() < buf.length) {
            throw new IllegalArgumentException();
        }
        final byte[] incomingBuf = srcDp.getData();
        int len = srcDp.getLength();
        if (len > buf.length) {
            len = buf.length;
        }
        System.arraycopy(incomingBuf, 0, buf, 0, len);
        final DatagramPacket dp = getDatagramPacket();
        dp.setAddress(srcDp.getAddress());
        final int port = srcDp.getPort();
        dp.setPort(port > 0 ? port : NTP_PORT);
        dp.setData(buf);
    }","  public void test60()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      DatagramPacket datagramPacket0 = ntpV3Impl0.getDatagramPacket();
      ntpV3Impl0.setDatagramPacket(datagramPacket0);
}"
1056,"    public int getVersion()
    {
        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
    }","  public void test61()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setVersion((-3500));
      ntpV3Impl0.setReferenceId((-3500));
      ntpV3Impl0.getReferenceIdString();
}"
1057,"    public int getVersion()
    {
        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
    }","  public void test62()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setVersion((-3500));
      ntpV3Impl0.getReferenceIdString();
}"
1058,"    public int getReferenceId()
    {
        return getInt(REFERENCE_ID_INDEX);
    }","  public void test63()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setReferenceId((-3500));
      int int0 = ntpV3Impl0.getReferenceId();
}"
1059,"    public int hashCode()
    {
        return java.util.Arrays.hashCode(buf);
    }","  public void test64()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.hashCode();
  }"
1060,"    public void setReferenceTime(final TimeStamp ts)
    {
        setTimestamp(REFERENCE_TIMESTAMP_INDEX, ts);
    }","  public void test65()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = ntpV3Impl0.getReceiveTimeStamp();
      ntpV3Impl0.setReferenceTime(timeStamp0);
}"
1061,"    public void setReferenceTime(final TimeStamp ts)
    {
        setTimestamp(REFERENCE_TIMESTAMP_INDEX, ts);
    }","  public void test66()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = ntpV3Impl0.getReceiveTimeStamp();
      ntpV3Impl0.setReferenceTime(timeStamp0);
}"
1062,"    public int getVersion()
    {
        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
    }","  public void test67()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setVersion(3);
      ntpV3Impl0.getReferenceIdString();
}"
1063,"    public int getPoll()
    {
        return buf[POLL_INDEX];
    }","  public void test68()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setTransmitTime((TimeStamp) null);
}"
1064,"    public int getReferenceId()
    {
        return getInt(REFERENCE_ID_INDEX);
    }","  public void test69()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      long long0 = ntpV3Impl0.getRootDispersionInMillis();
}"
1065,"    public long getRootDispersionInMillis()
    {
        final long l = getRootDispersion();
        return (l * 1000) / 65536L;
    }","  public void test70()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      long long0 = ntpV3Impl0.getRootDispersionInMillis();
}"
1066,"    public String getType()
    {
        return ""NTP"";
    }","  public void test71()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      String string0 = ntpV3Impl0.getType();
}"
1067,"    public String getModeName()
    {
        return NtpUtils.getModeName(getMode());
    }","  public void test72()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      String string0 = ntpV3Impl0.getModeName();
}"
1068,"    public int getLeapIndicator()
    {
        return (ui(buf[LI_INDEX]) >> LI_SHIFT) & 0x3;
    }","  public void test73()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getLeapIndicator();
}"
1069,"    public double getRootDispersionInMillisDouble()
    {
        final double l = getRootDispersion();
        return l / 65.536;
    }","  public void test74()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      int int0 = ntpV3Impl0.getLeapIndicator();
}"
1070,"    public void setOriginateTimeStamp(final TimeStamp ts)
    {
        setTimestamp(ORIGINATE_TIMESTAMP_INDEX, ts);
    }","  public void test75()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = ntpV3Impl0.getOriginateTimeStamp();
      ntpV3Impl0.setOriginateTimeStamp(timeStamp0);
}"
1071,"    public void setOriginateTimeStamp(final TimeStamp ts)
    {
        setTimestamp(ORIGINATE_TIMESTAMP_INDEX, ts);
    }","  public void test76()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = ntpV3Impl0.getOriginateTimeStamp();
      ntpV3Impl0.setOriginateTimeStamp(timeStamp0);
}"
1072,"    public int getStratum()
    {
        return ui(buf[STRATUM_INDEX]);
    }","  public void test77()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setStratum(3);
      String string0 = ntpV3Impl0.getReferenceIdString();
}"
1073,"    public String getReferenceIdString()
    {
        final int version = getVersion();
        final int stratum = getStratum();
        if (version == VERSION_3 || version == VERSION_4) {
            if (stratum == 0 || stratum == 1) {
                return idAsString(); // 4-character ASCII string (e.g. GPS, USNO)
            }
            // in NTPv4 servers this is latest transmit timestamp of ref source
            if (version == VERSION_4) {
                return idAsHex();
            }
        }

        // Stratum 2 and higher this is a four-octet IPv4 address
        // of the primary reference host.
        if (stratum >= 2) {
            return idAsIPAddress();
        }
        return idAsHex();
    }","  public void test78()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      ntpV3Impl0.setStratum(3);
      String string0 = ntpV3Impl0.getReferenceIdString();
}"
1074,"    public int getMode()
    {
        return (ui(buf[MODE_INDEX]) >> MODE_SHIFT) & 0x7;
    }","  public void test79()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeStamp timeStamp0 = ntpV3Impl0.getReferenceTimeStamp();
      ntpV3Impl0.setReceiveTimeStamp(timeStamp0);
}"
1075,"    public double getRootDelayInMillisDouble()
    {
        final double l = getRootDelay();
        return l / 65.536;
    }","  public void test80()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      double double0 = ntpV3Impl0.getRootDelayInMillisDouble();
}"
1076,"    public String getReferenceIdString()
    {
        final int version = getVersion();
        final int stratum = getStratum();
        if (version == VERSION_3 || version == VERSION_4) {
            if (stratum == 0 || stratum == 1) {
                return idAsString(); // 4-character ASCII string (e.g. GPS, USNO)
            }
            // in NTPv4 servers this is latest transmit timestamp of ref source
            if (version == VERSION_4) {
                return idAsHex();
            }
        }

        // Stratum 2 and higher this is a four-octet IPv4 address
        // of the primary reference host.
        if (stratum >= 2) {
            return idAsIPAddress();
        }
        return idAsHex();
    }","  public void test81()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      String string0 = ntpV3Impl0.getReferenceIdString();
}"
1077,"    public int getVersion()
    {
        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
    }","  public void test82()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      String string0 = ntpV3Impl0.getReferenceIdString();
}"
1078,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test0()  throws Throwable  {
      DiscardTCPClient discardTCPClient0 = new DiscardTCPClient();
      discardTCPClient0.getOutputStream();
}"
1079,"    public void send(final byte[] data, final int length, final InetAddress host, final int port)
    throws IOException
    {
        sendPacket.setData(data);
        sendPacket.setLength(length);
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test0()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      byte[] byteArray0 = new byte[0];
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      discardUDPClient0.open(0);
      discardUDPClient0.send(byteArray0, 0, inetAddress0, 0);
}"
1080,"    public int getDefaultTimeout()
    {
        return _timeout_;
    }","  public void test1()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      byte[] byteArray0 = new byte[0];
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      discardUDPClient0.open(0);
      discardUDPClient0.send(byteArray0, inetAddress0);
}"
1081,"    public void send(final byte[] data, final int length, final InetAddress host, final int port)
    throws IOException
    {
        sendPacket.setData(data);
        sendPacket.setLength(length);
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test2()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      byte[] byteArray0 = new byte[0];
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      discardUDPClient0.open(0);
      discardUDPClient0.send(byteArray0, 0, inetAddress0);
}"
1082,"    public void send(final byte[] data, final int length, final InetAddress host, final int port)
    throws IOException
    {
        sendPacket.setData(data);
        sendPacket.setLength(length);
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test3()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      byte[] byteArray0 = new byte[0];
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      // Undeclared exception!
      try { 
        discardUDPClient0.send(byteArray0, 9, inetAddress0, 618);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // illegal length
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
1083,"    public void send(final byte[] data, final int length, final InetAddress host, final int port)
    throws IOException
    {
        sendPacket.setData(data);
        sendPacket.setLength(length);
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test4()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      byte[] byteArray0 = new byte[2];
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        discardUDPClient0.send(byteArray0, 215, inetAddress0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // illegal length
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
1084,"    public void send(final byte[] data, final int length, final InetAddress host, final int port)
    throws IOException
    {
        sendPacket.setData(data);
        sendPacket.setLength(length);
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test5()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      byte[] byteArray0 = new byte[0];
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        discardUDPClient0.send(byteArray0, 0, inetAddress0, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.discard.DiscardUDPClient"", e);
      }
  }"
1085,"    public void send(final byte[] data, final int length, final InetAddress host, final int port)
    throws IOException
    {
        sendPacket.setData(data);
        sendPacket.setLength(length);
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test6()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      byte[] byteArray0 = new byte[0];
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        discardUDPClient0.send(byteArray0, inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.discard.DiscardUDPClient"", e);
      }
  }"
1086,"    public void send(final byte[] data, final int length, final InetAddress host, final int port)
    throws IOException
    {
        sendPacket.setData(data);
        sendPacket.setLength(length);
        sendPacket.setAddress(host);
        sendPacket.setPort(port);
        _socket_.send(sendPacket);
    }","  public void test7()  throws Throwable  {
      DiscardUDPClient discardUDPClient0 = new DiscardUDPClient();
      byte[] byteArray0 = new byte[0];
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        discardUDPClient0.send(byteArray0, 0, inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.discard.DiscardUDPClient"", e);
      }
  }"
1087,"    public SMTPConnectionClosedException()
    {
    }","  public void test0()  throws Throwable  {
      SMTPConnectionClosedException sMTPConnectionClosedException0 = new SMTPConnectionClosedException(""w[V"");
  }"
1088,"    public SMTPConnectionClosedException()
    {
    }","  public void test1()  throws Throwable  {
      SMTPConnectionClosedException sMTPConnectionClosedException0 = new SMTPConnectionClosedException();
  }"
1089,"    public int[] getEnhancedReplyCode()
    {
        final String reply = getReplyString().substring(4);
        final String[] parts = reply.substring(0, reply.indexOf(' ')).split (""\\."");
        final int[] res = new int[parts.length];
        for (int i = 0; i < parts.length; i++)
        {
            res[i] = Integer.parseInt (parts[i]);
        }
        return res;
    }","  public void test0()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient("""");
      // Undeclared exception!
      try { 
        authenticatingSMTPClient0.getEnhancedReplyCode();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.AuthenticatingSMTPClient"", e);
      }
  }"
1090,,"  public void test1()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.XOAUTH;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1091,,"  public void test2()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.XOAUTH;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1092,,"  public void test3()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.LOGIN;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1093,,"  public void test4()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.LOGIN;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1094,,"  public void test5()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.CRAM_MD5;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1095,,"  public void test6()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.CRAM_MD5;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1096,"    public int ehlo(final String hostname) throws IOException
    {
        return sendCommand(SMTPCommand.EHLO, hostname);
    }","  public void test7()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient((String) null);
      // Undeclared exception!
      try { 
        authenticatingSMTPClient0.ehlo(""yRFr>M\rEolR!"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1097,,"  public void test8()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.XOAUTH2;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1098,,"  public void test9()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.XOAUTH2;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1099,,"  public void test10()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.PLAIN;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1100,,"  public void test11()  throws Throwable  {
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.PLAIN;
      String string0 = AuthenticatingSMTPClient.AUTH_METHOD.getAuthName(authenticatingSMTPClient_AUTH_METHOD0);
}"
1101,"    public boolean auth(final AuthenticatingSMTPClient.AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        if (!SMTPReply.isPositiveIntermediate(sendCommand(SMTPCommand.AUTH,
                AUTH_METHOD.getAuthName(method)))) {
            return false;
        }

        if (method.equals(AUTH_METHOD.PLAIN))
        {
            // the server sends an empty response (""334 ""), so we don't have to read it.
            return SMTPReply.isPositiveCompletion(sendCommand(
                    Base64.encodeBase64StringUnChunked((""\000"" + username + ""\000"" + password).getBytes(getCharset()))
                ));
        }
        else if (method.equals(AUTH_METHOD.CRAM_MD5))
        {
            // get the CRAM challenge
            final byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(4).trim());
            // get the Mac instance
            final Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
            hmac_md5.init(new SecretKeySpec(password.getBytes(getCharset()), ""HmacMD5""));
            // compute the result:
            final byte[] hmacResult = convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes(getCharset());
            // join the byte arrays to form the reply
            final byte[] usernameBytes = username.getBytes(getCharset());
            final byte[] toEncode = new byte[usernameBytes.length + 1 /* the space */ + hmacResult.length];
            System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
            toEncode[usernameBytes.length] = ' ';
            System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
            // send the reply and read the server code:
            return SMTPReply.isPositiveCompletion(sendCommand(
                Base64.encodeBase64StringUnChunked(toEncode)));
        }
        else if (method.equals(AUTH_METHOD.LOGIN))
        {
            // the server sends fixed responses (base64(""Username"") and
            // base64(""Password"")), so we don't have to read them.
            if (!SMTPReply.isPositiveIntermediate(sendCommand(
                Base64.encodeBase64StringUnChunked(username.getBytes(getCharset()))))) {
                return false;
            }
            return SMTPReply.isPositiveCompletion(sendCommand(
                Base64.encodeBase64StringUnChunked(password.getBytes(getCharset()))));
        }
        else if (method.equals(AUTH_METHOD.XOAUTH) || method.equals(AUTH_METHOD.XOAUTH2))
        {
            return SMTPReply.isPositiveIntermediate(sendCommand(
                    Base64.encodeBase64StringUnChunked(username.getBytes(getCharset()))
            ));
        } else {
            return false; // safety check
        }
    }","  public void test12()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient(""./'B#6j8H"", false);
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.XOAUTH;
      // Undeclared exception!
      try { 
        authenticatingSMTPClient0.auth(authenticatingSMTPClient_AUTH_METHOD0, ""./'B#6j8H"", ""./'B#6j8H"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1102,"    public boolean elogin(final String hostname) throws IOException
    {
        return SMTPReply.isPositiveCompletion(ehlo(hostname));
    }","  public void test13()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient("""", """");
      // Undeclared exception!
      try { 
        authenticatingSMTPClient0.elogin("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1103,"    public boolean auth(final AuthenticatingSMTPClient.AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        if (!SMTPReply.isPositiveIntermediate(sendCommand(SMTPCommand.AUTH,
                AUTH_METHOD.getAuthName(method)))) {
            return false;
        }

        if (method.equals(AUTH_METHOD.PLAIN))
        {
            // the server sends an empty response (""334 ""), so we don't have to read it.
            return SMTPReply.isPositiveCompletion(sendCommand(
                    Base64.encodeBase64StringUnChunked((""\000"" + username + ""\000"" + password).getBytes(getCharset()))
                ));
        }
        else if (method.equals(AUTH_METHOD.CRAM_MD5))
        {
            // get the CRAM challenge
            final byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(4).trim());
            // get the Mac instance
            final Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
            hmac_md5.init(new SecretKeySpec(password.getBytes(getCharset()), ""HmacMD5""));
            // compute the result:
            final byte[] hmacResult = convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes(getCharset());
            // join the byte arrays to form the reply
            final byte[] usernameBytes = username.getBytes(getCharset());
            final byte[] toEncode = new byte[usernameBytes.length + 1 /* the space */ + hmacResult.length];
            System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
            toEncode[usernameBytes.length] = ' ';
            System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
            // send the reply and read the server code:
            return SMTPReply.isPositiveCompletion(sendCommand(
                Base64.encodeBase64StringUnChunked(toEncode)));
        }
        else if (method.equals(AUTH_METHOD.LOGIN))
        {
            // the server sends fixed responses (base64(""Username"") and
            // base64(""Password"")), so we don't have to read them.
            if (!SMTPReply.isPositiveIntermediate(sendCommand(
                Base64.encodeBase64StringUnChunked(username.getBytes(getCharset()))))) {
                return false;
            }
            return SMTPReply.isPositiveCompletion(sendCommand(
                Base64.encodeBase64StringUnChunked(password.getBytes(getCharset()))));
        }
        else if (method.equals(AUTH_METHOD.XOAUTH) || method.equals(AUTH_METHOD.XOAUTH2))
        {
            return SMTPReply.isPositiveIntermediate(sendCommand(
                    Base64.encodeBase64StringUnChunked(username.getBytes(getCharset()))
            ));
        } else {
            return false; // safety check
        }
    }","  public void test14()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient();
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.LOGIN;
      // Undeclared exception!
      try { 
        authenticatingSMTPClient0.auth(authenticatingSMTPClient_AUTH_METHOD0, ""t>+WEX?Ays"", ""t>+WEX?Ays"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1104,"    public boolean elogin(final String hostname) throws IOException
    {
        return SMTPReply.isPositiveCompletion(ehlo(hostname));
    }","  public void test15()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient(false, (SSLContext) null);
      // Undeclared exception!
      try { 
        authenticatingSMTPClient0.elogin();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1105,"    public boolean auth(final AuthenticatingSMTPClient.AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        if (!SMTPReply.isPositiveIntermediate(sendCommand(SMTPCommand.AUTH,
                AUTH_METHOD.getAuthName(method)))) {
            return false;
        }

        if (method.equals(AUTH_METHOD.PLAIN))
        {
            // the server sends an empty response (""334 ""), so we don't have to read it.
            return SMTPReply.isPositiveCompletion(sendCommand(
                    Base64.encodeBase64StringUnChunked((""\000"" + username + ""\000"" + password).getBytes(getCharset()))
                ));
        }
        else if (method.equals(AUTH_METHOD.CRAM_MD5))
        {
            // get the CRAM challenge
            final byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(4).trim());
            // get the Mac instance
            final Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
            hmac_md5.init(new SecretKeySpec(password.getBytes(getCharset()), ""HmacMD5""));
            // compute the result:
            final byte[] hmacResult = convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes(getCharset());
            // join the byte arrays to form the reply
            final byte[] usernameBytes = username.getBytes(getCharset());
            final byte[] toEncode = new byte[usernameBytes.length + 1 /* the space */ + hmacResult.length];
            System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
            toEncode[usernameBytes.length] = ' ';
            System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
            // send the reply and read the server code:
            return SMTPReply.isPositiveCompletion(sendCommand(
                Base64.encodeBase64StringUnChunked(toEncode)));
        }
        else if (method.equals(AUTH_METHOD.LOGIN))
        {
            // the server sends fixed responses (base64(""Username"") and
            // base64(""Password"")), so we don't have to read them.
            if (!SMTPReply.isPositiveIntermediate(sendCommand(
                Base64.encodeBase64StringUnChunked(username.getBytes(getCharset()))))) {
                return false;
            }
            return SMTPReply.isPositiveCompletion(sendCommand(
                Base64.encodeBase64StringUnChunked(password.getBytes(getCharset()))));
        }
        else if (method.equals(AUTH_METHOD.XOAUTH) || method.equals(AUTH_METHOD.XOAUTH2))
        {
            return SMTPReply.isPositiveIntermediate(sendCommand(
                    Base64.encodeBase64StringUnChunked(username.getBytes(getCharset()))
            ));
        } else {
            return false; // safety check
        }
    }","  public void test16()  throws Throwable  {
      AuthenticatingSMTPClient authenticatingSMTPClient0 = new AuthenticatingSMTPClient(""9JqR`O"", false, ""9JqR`O"");
      AuthenticatingSMTPClient.AUTH_METHOD authenticatingSMTPClient_AUTH_METHOD0 = AuthenticatingSMTPClient.AUTH_METHOD.CRAM_MD5;
      // Undeclared exception!
      try { 
        authenticatingSMTPClient0.auth(authenticatingSMTPClient_AUTH_METHOD0, ""\r\n"", ""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1106,"    public String toString()
    {
        final StringBuilder header = new StringBuilder();

        final String pattern = ""EEE, dd MMM yyyy HH:mm:ss Z""; // Fri, 21 Nov 1997 09:55:06 -0600
        final SimpleDateFormat format = new SimpleDateFormat(pattern, Locale.ENGLISH);

        if (!hasHeaderDate) {
            addHeaderField(""Date"", format.format(new Date()));
        }
        if (headerFields.length() > 0) {
            header.append(headerFields.toString());
        }

        header.append(""From: "").append(from).append(""\n"");

        if (to != null) {
            header.append(""To: "").append(to).append(""\n"");
        }

        if (cc != null)
        {
            header.append(""Cc: "").append(cc.toString()).append(""\n"");
        }

        if (subject != null)
        {
            header.append(""Subject: "").append(subject).append(""\n"");
        }

        header.append('\n'); // end of headers; body follows

        return header.toString();
    }","  public void test0()  throws Throwable  {
      SimpleSMTPHeader simpleSMTPHeader0 = new SimpleSMTPHeader("""", """", """");
      simpleSMTPHeader0.addCC("""");
      String string0 = simpleSMTPHeader0.toString();
}"
1107,"    public String toString()
    {
        final StringBuilder header = new StringBuilder();

        final String pattern = ""EEE, dd MMM yyyy HH:mm:ss Z""; // Fri, 21 Nov 1997 09:55:06 -0600
        final SimpleDateFormat format = new SimpleDateFormat(pattern, Locale.ENGLISH);

        if (!hasHeaderDate) {
            addHeaderField(""Date"", format.format(new Date()));
        }
        if (headerFields.length() > 0) {
            header.append(headerFields.toString());
        }

        header.append(""From: "").append(from).append(""\n"");

        if (to != null) {
            header.append(""To: "").append(to).append(""\n"");
        }

        if (cc != null)
        {
            header.append(""Cc: "").append(cc.toString()).append(""\n"");
        }

        if (subject != null)
        {
            header.append(""Subject: "").append(subject).append(""\n"");
        }

        header.append('\n'); // end of headers; body follows

        return header.toString();
    }","  public void test1()  throws Throwable  {
      SimpleSMTPHeader simpleSMTPHeader0 = new SimpleSMTPHeader(""R?egUKA0h8<XH)T+M "", (String) null, (String) null);
      String string0 = simpleSMTPHeader0.toString();
}"
1108,"    public String toString()
    {
        final StringBuilder header = new StringBuilder();

        final String pattern = ""EEE, dd MMM yyyy HH:mm:ss Z""; // Fri, 21 Nov 1997 09:55:06 -0600
        final SimpleDateFormat format = new SimpleDateFormat(pattern, Locale.ENGLISH);

        if (!hasHeaderDate) {
            addHeaderField(""Date"", format.format(new Date()));
        }
        if (headerFields.length() > 0) {
            header.append(headerFields.toString());
        }

        header.append(""From: "").append(from).append(""\n"");

        if (to != null) {
            header.append(""To: "").append(to).append(""\n"");
        }

        if (cc != null)
        {
            header.append(""Cc: "").append(cc.toString()).append(""\n"");
        }

        if (subject != null)
        {
            header.append(""Subject: "").append(subject).append(""\n"");
        }

        header.append('\n'); // end of headers; body follows

        return header.toString();
    }","  public void test2()  throws Throwable  {
      SimpleSMTPHeader simpleSMTPHeader0 = new SimpleSMTPHeader("""", """", """");
      simpleSMTPHeader0.addHeaderField(""Date"", ""EEE, dd MMM yyyy HH:mm:ss Z"");
      String string0 = simpleSMTPHeader0.toString();
}"
1109,"    public void addCC(final String address)
    {
        if (cc == null) {
            cc = new StringBuffer();
        } else {
            cc.append("", "");
        }

        cc.append(address);
    }","  public void test3()  throws Throwable  {
      SimpleSMTPHeader simpleSMTPHeader0 = new SimpleSMTPHeader("""", """", """");
      simpleSMTPHeader0.addCC("""");
      simpleSMTPHeader0.addCC(""e_y71TSIs*S2S ljL'"");
  }"
1110,"    public void addHeaderField(final String headerField, final String value)
    {
        if (!hasHeaderDate && ""Date"".equals(headerField)) {
            hasHeaderDate = true;
        }
        headerFields.append(headerField);
        headerFields.append("": "");
        headerFields.append(value);
        headerFields.append('\n');
    }","  public void test4()  throws Throwable  {
      SimpleSMTPHeader simpleSMTPHeader0 = new SimpleSMTPHeader("""", """", """");
      simpleSMTPHeader0.addHeaderField("""", ""Date"");
  }"
1111,"    public SimpleSMTPHeader(final String from, final String to, final String subject)
    {
        if (from == null) {
            throw new IllegalArgumentException(""From cannot be null"");
        }
        this.to = to;
        this.from = from;
        this.subject = subject;
        this.headerFields = new StringBuffer();
        this.cc = null;
    }","  public void test5()  throws Throwable  {
      SimpleSMTPHeader simpleSMTPHeader0 = null;
      try {
        simpleSMTPHeader0 = new SimpleSMTPHeader((String) null, (String) null, (String) null);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // From cannot be null
         //
         verifyException(""org.apache.commons.net.smtp.SimpleSMTPHeader"", e);
      }
  }"
1112,"    public void addHeaderField(final String headerField, final String value)
    {
        if (!hasHeaderDate && ""Date"".equals(headerField)) {
            hasHeaderDate = true;
        }
        headerFields.append(headerField);
        headerFields.append("": "");
        headerFields.append(value);
        headerFields.append('\n');
    }","  public void test6()  throws Throwable  {
      SimpleSMTPHeader simpleSMTPHeader0 = new SimpleSMTPHeader("""", """", """");
      simpleSMTPHeader0.addHeaderField(""Date"", ""EEE, dd MMM yyyy HH:mm:ss Z"");
      simpleSMTPHeader0.addHeaderField("""", """");
  }"
1113,"    public String toString()
    {
        final StringBuilder buffer = new StringBuilder();
        final Enumeration<String> hosts;

        buffer.append('<');

        hosts = path.elements();

        if (hosts.hasMoreElements())
        {
            buffer.append('@');
            buffer.append(hosts.nextElement());

            while (hosts.hasMoreElements())
            {
                buffer.append("",@"");
                buffer.append(hosts.nextElement());
            }
            buffer.append(':');
        }

        buffer.append(emailAddress);
        buffer.append('>');

        return buffer.toString();
    }","  public void test0()  throws Throwable  {
      RelayPath relayPath0 = new RelayPath((String) null);
      relayPath0.addRelay(""<null>"");
      relayPath0.addRelay((String) null);
      String string0 = relayPath0.toString();
}"
1114,"    public String toString()
    {
        final StringBuilder buffer = new StringBuilder();
        final Enumeration<String> hosts;

        buffer.append('<');

        hosts = path.elements();

        if (hosts.hasMoreElements())
        {
            buffer.append('@');
            buffer.append(hosts.nextElement());

            while (hosts.hasMoreElements())
            {
                buffer.append("",@"");
                buffer.append(hosts.nextElement());
            }
            buffer.append(':');
        }

        buffer.append(emailAddress);
        buffer.append('>');

        return buffer.toString();
    }","  public void test1()  throws Throwable  {
      RelayPath relayPath0 = new RelayPath((String) null);
      String string0 = relayPath0.toString();
}"
1115,"    public static String getCommand(final int command)
    {
        return commands[command];
    }","  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        SMTPCommand.getCommand(2642);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2642
         //
         verifyException(""org.apache.commons.net.smtp.SMTPCommand"", e);
      }
  }"
1116,"    public static String getCommand(final int command)
    {
        return commands[command];
    }","  public void test1()  throws Throwable  {
      String string0 = SMTPCommand.getCommand(1);
}"
1117,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test0()  throws Throwable  {
      boolean boolean0 = SMTPReply.isNegativePermanent(600);
}"
1118,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test1()  throws Throwable  {
      boolean boolean0 = SMTPReply.isNegativePermanent(500);
}"
1119,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test2()  throws Throwable  {
      boolean boolean0 = SMTPReply.isNegativeTransient(500);
}"
1120,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test3()  throws Throwable  {
      boolean boolean0 = SMTPReply.isNegativeTransient(400);
}"
1121,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test4()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositiveIntermediate(400);
}"
1122,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test5()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositiveIntermediate(300);
}"
1123,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test6()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositiveCompletion(300);
}"
1124,"    public static boolean isPositivePreliminary(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test7()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositivePreliminary(200);
}"
1125,"    public static boolean isPositivePreliminary(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test8()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositivePreliminary(100);
}"
1126,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test9()  throws Throwable  {
      boolean boolean0 = SMTPReply.isNegativePermanent(884);
}"
1127,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test10()  throws Throwable  {
      boolean boolean0 = SMTPReply.isNegativePermanent(1);
}"
1128,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test11()  throws Throwable  {
      boolean boolean0 = SMTPReply.isNegativeTransient(884);
}"
1129,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test12()  throws Throwable  {
      boolean boolean0 = SMTPReply.isNegativeTransient(138);
}"
1130,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test13()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositiveIntermediate(554);
}"
1131,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test14()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositiveIntermediate(0);
}"
1132,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test15()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositiveCompletion(2479);
}"
1133,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test16()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositiveCompletion(200);
}"
1134,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test17()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositiveCompletion(138);
}"
1135,"    public static boolean isPositivePreliminary(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test18()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositivePreliminary(524);
}"
1136,"    public static boolean isPositivePreliminary(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test19()  throws Throwable  {
      boolean boolean0 = SMTPReply.isPositivePreliminary((-18));
}"
1137,"    public boolean sendSimpleMessage(final String sender, final String recipient,
                                     final String message)
    throws IOException
    {
        if (!setSender(sender)) {
            return false;
        }

        if (!addRecipient(recipient)) {
            return false;
        }

        return sendShortMessageData(message);
    }","  public void test0()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      // Undeclared exception!
      try { 
        sMTPClient0.sendSimpleMessage("""", """", """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1138,"    public boolean verify(final String username) throws IOException
    {
        final int result;

        result = vrfy(username);

        return result == SMTPReply.ACTION_OK ||
                result == SMTPReply.USER_NOT_LOCAL_WILL_FORWARD;
    }","  public void test1()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient("""");
      // Undeclared exception!
      try { 
        sMTPClient0.verify("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1139,"    public boolean sendShortMessageData(final String message) throws IOException
    {
        try (final Writer writer = sendMessageData()) {

            if (writer == null) {
                return false;
            }

            writer.write(message);
        }

        return completePendingCommand();
    }","  public void test2()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient(""sj@x^'!Kd2"");
      // Undeclared exception!
      try { 
        sMTPClient0.sendShortMessageData(""u[oeA|;Zr^"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1140,"    public Writer sendMessageData() throws IOException
    {
        if (!SMTPReply.isPositiveIntermediate(data())) {
            return null;
        }

        return new DotTerminatedMessageWriter(writer);
    }","  public void test3()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient(""Nj%o92"");
      // Undeclared exception!
      try { 
        sMTPClient0.sendMessageData();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1141,"    public boolean login(final String hostname) throws IOException
    {
        return SMTPReply.isPositiveCompletion(helo(hostname));
    }","  public void test4()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      // Undeclared exception!
      try { 
        sMTPClient0.login();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1142,"    public String listHelp() throws IOException
    {
        if (SMTPReply.isPositiveCompletion(help())) {
            return getReplyString();
        }
        return null;
    }","  public void test5()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient("""");
      // Undeclared exception!
      try { 
        sMTPClient0.listHelp(""{FPucL^#5"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1143,"    public String listHelp() throws IOException
    {
        if (SMTPReply.isPositiveCompletion(help())) {
            return getReplyString();
        }
        return null;
    }","  public void test6()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      // Undeclared exception!
      try { 
        sMTPClient0.listHelp();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1144,"    public boolean completePendingCommand() throws IOException
    {
        return SMTPReply.isPositiveCompletion(getReply());
    }","  public void test7()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 25);
      sMTPClient0.reader = bufferedReader0;
      try { 
        sMTPClient0.completePendingCommand();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Truncated server reply: 
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1145,"    public boolean completePendingCommand() throws IOException
    {
        return SMTPReply.isPositiveCompletion(getReply());
    }","  public void test8()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient("""");
      PipedReader pipedReader0 = new PipedReader();
      BufferedReader bufferedReader0 = new BufferedReader(pipedReader0, 25);
      sMTPClient0.reader = bufferedReader0;
      try { 
        sMTPClient0.completePendingCommand();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedReader"", e);
      }
  }"
1146,"    public boolean addRecipient(final RelayPath path) throws IOException
    {
        return SMTPReply.isPositiveCompletion(rcpt(path.toString()));
    }","  public void test9()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      // Undeclared exception!
      try { 
        sMTPClient0.addRecipient(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1147,"    public boolean addRecipient(final RelayPath path) throws IOException
    {
        return SMTPReply.isPositiveCompletion(rcpt(path.toString()));
    }","  public void test10()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      RelayPath relayPath0 = new RelayPath(""\r\n"");
      // Undeclared exception!
      try { 
        sMTPClient0.addRecipient(relayPath0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1148,"    public boolean logout() throws IOException
    {
        return SMTPReply.isPositiveCompletion(quit());
    }","  public void test11()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      // Undeclared exception!
      try { 
        sMTPClient0.logout();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1149,"    public boolean sendSimpleMessage(final String sender, final String recipient,
                                     final String message)
    throws IOException
    {
        if (!setSender(sender)) {
            return false;
        }

        if (!addRecipient(recipient)) {
            return false;
        }

        return sendShortMessageData(message);
    }","  public void test12()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient(""org.apache.commons.et.smtp.SMTPClent"");
      String[] stringArray0 = new String[11];
      // Undeclared exception!
      try { 
        sMTPClient0.sendSimpleMessage(""org.apache.commons.et.smtp.SMTPClent"", stringArray0, stringArray0[2]);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1150,"    public boolean reset() throws IOException
    {
        return SMTPReply.isPositiveCompletion(rset());
    }","  public void test13()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      // Undeclared exception!
      try { 
        sMTPClient0.reset();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1151,"    public boolean sendNoOp() throws IOException
    {
        return SMTPReply.isPositiveCompletion(noop());
    }","  public void test14()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      // Undeclared exception!
      try { 
        sMTPClient0.sendNoOp();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1152,"    public boolean login(final String hostname) throws IOException
    {
        return SMTPReply.isPositiveCompletion(helo(hostname));
    }","  public void test15()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      // Undeclared exception!
      try { 
        sMTPClient0.login(""_@S<-r%|Lt^7z"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1153,"    public boolean setSender(final RelayPath path) throws IOException
    {
        return SMTPReply.isPositiveCompletion(mail(path.toString()));
    }","  public void test16()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      RelayPath relayPath0 = new RelayPath(""\r\n"");
      // Undeclared exception!
      try { 
        sMTPClient0.setSender(relayPath0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1154,"    public boolean setSender(final RelayPath path) throws IOException
    {
        return SMTPReply.isPositiveCompletion(mail(path.toString()));
    }","  public void test17()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient("""");
      // Undeclared exception!
      try { 
        sMTPClient0.setSender("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1155,"    public boolean completePendingCommand() throws IOException
    {
        return SMTPReply.isPositiveCompletion(getReply());
    }","  public void test18()  throws Throwable  {
      SMTPClient sMTPClient0 = new SMTPClient();
      // Undeclared exception!
      try { 
        sMTPClient0.completePendingCommand();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1156,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test0()  throws Throwable  {
      SMTP sMTP0 = new SMTP(""uyPuFj9VkB."");
      sMTP0.getCommandSupport();
}"
1157,"    private int sendCommand(final String command, final String args, final boolean includeSpace)
    throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            if (includeSpace) {
                __commandBuffer.append(' ');
            }
            __commandBuffer.append(args);
        }

        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test1()  throws Throwable  {
      SMTP sMTP0 = new SMTP("""");
      // Undeclared exception!
      try { 
        sMTP0.sendCommand(0, ""S^;a6,N.i3dypWR{^"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1158,"    private int sendCommand(final String command, final String args, final boolean includeSpace)
    throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            if (includeSpace) {
                __commandBuffer.append(' ');
            }
            __commandBuffer.append(args);
        }

        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test2()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.sendCommand(952);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 952
         //
         verifyException(""org.apache.commons.net.smtp.SMTPCommand"", e);
      }
  }"
1159,"    public int getReply() throws IOException
    {
        final int length;

        newReplyString = true;
        replyLines.clear();

        String line = reader.readLine();

        if (line == null) {
            throw new SMTPConnectionClosedException(
                ""Connection closed without indication."");
        }

        // In case we run into an anomaly we don't want fatal index exceptions
        // to be thrown.
        length = line.length();
        if (length < 3) {
            throw new MalformedServerReplyException(
                ""Truncated server reply: "" + line);
        }

        try
        {
            final String code = line.substring(0, 3);
            replyCode = Integer.parseInt(code);
        }
        catch (final NumberFormatException e)
        {
            throw new MalformedServerReplyException(
                ""Could not parse response code.\nServer Reply: "" + line);
        }

        replyLines.add(line);

        // Get extra lines if message continues.
        if (length > 3 && line.charAt(3) == '-')
        {
            do
            {
                line = reader.readLine();

                if (line == null) {
                    throw new SMTPConnectionClosedException(
                        ""Connection closed without indication."");
                }

                replyLines.add(line);

                // The length() check handles problems that could arise from readLine()
                // returning too soon after encountering a naked CR or some other
                // anomaly.
            }
            while (!(line.length() >= 4 && line.charAt(3) != '-' &&
                     Character.isDigit(line.charAt(0))));
            // This is too strong a condition because a non-conforming server
            // could screw things up like ftp.funet.fi does for FTP
            // line.startsWith(code)));
        }

        fireReplyReceived(replyCode, getReplyString());

        if (replyCode == SMTPReply.SERVICE_NOT_AVAILABLE) {
            throw new SMTPConnectionClosedException(
                ""SMTP response 421 received.  Server closed connection."");
        }
        return replyCode;
    }","  public void test3()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.getReply();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1160,"    public int getReply() throws IOException
    {
        final int length;

        newReplyString = true;
        replyLines.clear();

        String line = reader.readLine();

        if (line == null) {
            throw new SMTPConnectionClosedException(
                ""Connection closed without indication."");
        }

        // In case we run into an anomaly we don't want fatal index exceptions
        // to be thrown.
        length = line.length();
        if (length < 3) {
            throw new MalformedServerReplyException(
                ""Truncated server reply: "" + line);
        }

        try
        {
            final String code = line.substring(0, 3);
            replyCode = Integer.parseInt(code);
        }
        catch (final NumberFormatException e)
        {
            throw new MalformedServerReplyException(
                ""Could not parse response code.\nServer Reply: "" + line);
        }

        replyLines.add(line);

        // Get extra lines if message continues.
        if (length > 3 && line.charAt(3) == '-')
        {
            do
            {
                line = reader.readLine();

                if (line == null) {
                    throw new SMTPConnectionClosedException(
                        ""Connection closed without indication."");
                }

                replyLines.add(line);

                // The length() check handles problems that could arise from readLine()
                // returning too soon after encountering a naked CR or some other
                // anomaly.
            }
            while (!(line.length() >= 4 && line.charAt(3) != '-' &&
                     Character.isDigit(line.charAt(0))));
            // This is too strong a condition because a non-conforming server
            // could screw things up like ftp.funet.fi does for FTP
            // line.startsWith(code)));
        }

        fireReplyReceived(replyCode, getReplyString());

        if (replyCode == SMTPReply.SERVICE_NOT_AVAILABLE) {
            throw new SMTPConnectionClosedException(
                ""SMTP response 421 received.  Server closed connection."");
        }
        return replyCode;
    }","  public void test4()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      PipedReader pipedReader0 = new PipedReader();
      BufferedReader bufferedReader0 = new BufferedReader(pipedReader0);
      sMTP0.reader = bufferedReader0;
      try { 
        sMTP0.getReply();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedReader"", e);
      }
  }"
1161,"    private int sendCommand(final String command, final String args, final boolean includeSpace)
    throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            if (includeSpace) {
                __commandBuffer.append(' ');
            }
            __commandBuffer.append(args);
        }

        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test5()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.sendCommand(8);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1162,"    private int sendCommand(final String command, final String args, final boolean includeSpace)
    throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            if (includeSpace) {
                __commandBuffer.append(' ');
            }
            __commandBuffer.append(args);
        }

        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test6()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.sendCommand("""", """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1163,"    private int sendCommand(final String command, final String args, final boolean includeSpace)
    throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            if (includeSpace) {
                __commandBuffer.append(' ');
            }
            __commandBuffer.append(args);
        }

        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test7()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.sendCommand((-619), ""Invalid IOCase name: "");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -619
         //
         verifyException(""org.apache.commons.net.smtp.SMTPCommand"", e);
      }
  }"
1164,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test8()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      String string0 = sMTP0.getReplyString();
}"
1165,"    public String getReplyString()
    {
        final StringBuilder buffer;

        if (!newReplyString) {
            return replyString;
        }

        buffer = new StringBuilder();

        for (final String line : replyLines)
        {
            buffer.append(line);
            buffer.append(SocketClient.NETASCII_EOL);
        }

        newReplyString = false;

        replyString = buffer.toString();
        return replyString;
    }","  public void test9()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      String string0 = sMTP0.getReplyString();
}"
1166,"    public int vrfy(final String user) throws IOException
    {
        return sendCommand(SMTPCommand.VRFY, user);
    }","  public void test10()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.vrfy(""Could not parse response code.\nServer Reply: "");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1167,"    public int noop() throws IOException
    {
        return sendCommand(SMTPCommand.NOOP);
    }","  public void test11()  throws Throwable  {
      SMTP sMTP0 = new SMTP("""");
      // Undeclared exception!
      try { 
        sMTP0.noop();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1168,"    public int saml(final String reversePath) throws IOException
    {
        return sendCommand(SMTPCommand.SAML, reversePath);
    }","  public void test12()  throws Throwable  {
      SMTP sMTP0 = new SMTP("""");
      // Undeclared exception!
      try { 
        sMTP0.saml("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1169,"    public int turn() throws IOException
    {
        return sendCommand(SMTPCommand.TURN);
    }","  public void test13()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.turn();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1170,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test14()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      PrintCommandListener printCommandListener0 = new PrintCommandListener((PrintWriter) null, false);
      sMTP0.removeProtocolCommandistener(printCommandListener0);
}"
1171,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test15()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      sMTP0.disconnect();
}"
1172,"    public int send(final String reversePath) throws IOException
    {
        return sendCommand(SMTPCommand.SEND, reversePath);
    }","  public void test16()  throws Throwable  {
      SMTP sMTP0 = new SMTP(""/fr5\"";c(}l9~0@T"");
      // Undeclared exception!
      try { 
        sMTP0.send(""/fr5\"";c(}l9~0@T"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1173,"    public int helo(final String hostname) throws IOException
    {
        return sendCommand(SMTPCommand.HELO, hostname);
    }","  public void test17()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.helo(""TURN"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1174,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test18()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      int int0 = sMTP0.getReplyCode();
}"
1175,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test19()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      int int0 = sMTP0.getReplyCode();
}"
1176,"    public int rcpt(final String forwardPath) throws IOException
    {
        return sendCommand(SMTPCommand.RCPT, forwardPath, false);
    }","  public void test20()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.rcpt(""'LrRB8A1YL_f"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1177,"    protected void _connectAction_() throws IOException
    {
        super._connectAction_();
        reader =
            new CRLFLineReader(new InputStreamReader(_input_,
                                                    encoding));
        writer =
            new BufferedWriter(new OutputStreamWriter(_output_,
                                                      encoding));
        getReply();
    }","  public void test21()  throws Throwable  {
      SMTP sMTP0 = new SMTP("""");
      // Undeclared exception!
      try { 
        sMTP0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1178,"    public int data() throws IOException
    {
        return sendCommand(SMTPCommand.DATA);
    }","  public void test22()  throws Throwable  {
      SMTP sMTP0 = new SMTP(""7Od.r"");
      // Undeclared exception!
      try { 
        sMTP0.data();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1179,"    private int sendCommand(final String command, final String args, final boolean includeSpace)
    throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            if (includeSpace) {
                __commandBuffer.append(' ');
            }
            __commandBuffer.append(args);
        }

        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test23()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.sendCommand("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1180,"    public int help() throws IOException
    {
        return sendCommand(SMTPCommand.HELP);
    }","  public void test24()  throws Throwable  {
      SMTP sMTP0 = new SMTP(""X"");
      // Undeclared exception!
      try { 
        sMTP0.help();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1181,"    public int help() throws IOException
    {
        return sendCommand(SMTPCommand.HELP);
    }","  public void test25()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.help(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1182,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test26()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      sMTP0.getReplyStrings();
}"
1183,"    public int quit() throws IOException
    {
        return sendCommand(SMTPCommand.QUIT);
    }","  public void test27()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.quit();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1184,"    public int expn(final String name) throws IOException
    {
        return sendCommand(SMTPCommand.EXPN, name);
    }","  public void test28()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.expn(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1185,"    public int mail(final String reversePath) throws IOException
    {
        return sendCommand(SMTPCommand.MAIL, reversePath, false);
    }","  public void test29()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.mail(""sdO?>UGUn"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1186,"    public int soml(final String reversePath) throws IOException
    {
        return sendCommand(SMTPCommand.SOML, reversePath);
    }","  public void test30()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.soml("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1187,"    public int rset() throws IOException
    {
        return sendCommand(SMTPCommand.RSET);
    }","  public void test31()  throws Throwable  {
      SMTP sMTP0 = new SMTP();
      // Undeclared exception!
      try { 
        sMTP0.rset();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1188,"    public void setEnabledCipherSuites(final String[] cipherSuites)
    {
        suites = cipherSuites.clone();
    }","  public void test0()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient();
      String[] stringArray0 = new String[2];
      sMTPSClient0.setEnabledCipherSuites(stringArray0);
}"
1189,"    public void setEnabledProtocols(final String[] protocolVersions)
    {
        protocols = protocolVersions.clone();
    }","  public void test1()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient(true);
      // Undeclared exception!
      try { 
        sMTPSClient0.setEnabledProtocols((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTPSClient"", e);
      }
  }"
1190,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test2()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      SMTPSClient sMTPSClient0 = new SMTPSClient(true, sSLContext0);
}"
1191,"    public SMTPSClient()
    {
        this(DEFAULT_PROTOCOL, false);
    }","  public void test3()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient(""n"", true);
}"
1192,"    public String[] getEnabledProtocols()
    {
        if (_socket_ instanceof SSLSocket)
        {
            return ((SSLSocket)_socket_).getEnabledProtocols();
        }
        return null;
    }","  public void test4()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient();
      String[] stringArray0 = sMTPSClient0.getEnabledProtocols();
}"
1193,"    public String[] getEnabledCipherSuites()
    {
        if (_socket_ instanceof SSLSocket)
        {
            return ((SSLSocket)_socket_).getEnabledCipherSuites();
        }
        return null;
    }","  public void test5()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient();
      String[] stringArray0 = sMTPSClient0.getEnabledCipherSuites();
}"
1194,"    protected void _connectAction_() throws IOException
    {
        // Implicit mode.
        if (isImplicit) {
            applySocketAttributes();
            performSSLNegotiation();
        }
        super._connectAction_();
        // Explicit mode - don't do anything. The user calls execTLS()
    }","  public void test6()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient();
      // Undeclared exception!
      try { 
        sMTPSClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1195,"    public KeyManager getKeyManager()
    {
        return keyManager;
    }","  public void test7()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient((SSLContext) null);
      ExtendedAliasKeyManager extendedAliasKeyManager0 = new ExtendedAliasKeyManager((KeyManager) null, """");
      AliasKeyManager aliasKeyManager0 = new AliasKeyManager(extendedAliasKeyManager0, ""\r\n"");
      sMTPSClient0.setKeyManager(aliasKeyManager0);
      KeyManager keyManager0 = sMTPSClient0.getKeyManager();
}"
1196,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test8()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient((SSLContext) null);
      boolean boolean0 = sMTPSClient0.isEndpointCheckingEnabled();
}"
1197,"    public void setEnabledProtocols(final String[] protocolVersions)
    {
        protocols = protocolVersions.clone();
    }","  public void test9()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient();
      String[] stringArray0 = Locale.getISOLanguages();
      sMTPSClient0.setEnabledProtocols(stringArray0);
}"
1198,"    public void setHostnameVerifier(final HostnameVerifier newHostnameVerifier)
    {
        hostnameVerifier = newHostnameVerifier;
    }","  public void test10()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient();
      sMTPSClient0.setHostnameVerifier((HostnameVerifier) null);
}"
1199,"    protected void _connectAction_() throws IOException
    {
        // Implicit mode.
        if (isImplicit) {
            applySocketAttributes();
            performSSLNegotiation();
        }
        super._connectAction_();
        // Explicit mode - don't do anything. The user calls execTLS()
    }","  public void test11()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient(true);
      // Undeclared exception!
      try { 
        sMTPSClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1200,"    public void setTrustManager(final TrustManager newTrustManager)
    {
        trustManager = newTrustManager;
    }","  public void test12()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient((SSLContext) null);
      sMTPSClient0.setTrustManager((TrustManager) null);
}"
1201,"    public TrustManager getTrustManager()
    {
        return trustManager;
    }","  public void test13()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient((SSLContext) null);
      TrustManager trustManager0 = sMTPSClient0.getTrustManager();
}"
1202,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test14()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient(""\r\n"", false, """");
}"
1203,"    public void setEnabledCipherSuites(final String[] cipherSuites)
    {
        suites = cipherSuites.clone();
    }","  public void test15()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient((SSLContext) null);
      // Undeclared exception!
      try { 
        sMTPSClient0.setEnabledCipherSuites((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTPSClient"", e);
      }
  }"
1204,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test16()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient();
      sMTPSClient0.setEndpointCheckingEnabled(true);
      boolean boolean0 = sMTPSClient0.isEndpointCheckingEnabled();
}"
1205,"    public KeyManager getKeyManager()
    {
        return keyManager;
    }","  public void test17()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient((SSLContext) null);
      KeyManager keyManager0 = sMTPSClient0.getKeyManager();
}"
1206,"    public boolean execTLS() throws IOException
    {
        if (!SMTPReply.isPositiveCompletion(sendCommand(""STARTTLS"")))
        {
            return false;
            //throw new SSLException(getReplyString());
        }
        performSSLNegotiation();
        return true;
    }","  public void test18()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient("""");
      // Undeclared exception!
      try { 
        sMTPSClient0.execTLS();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.smtp.SMTP"", e);
      }
  }"
1207,"    public HostnameVerifier getHostnameVerifier()
    {
        return hostnameVerifier;
    }","  public void test19()  throws Throwable  {
      SMTPSClient sMTPSClient0 = new SMTPSClient((SSLContext) null);
      HostnameVerifier hostnameVerifier0 = sMTPSClient0.getHostnameVerifier();
}"
1208,"    public String getTime() throws IOException
    {
        int read;
        final StringBuilder result = new StringBuilder(buffer.length);
        final BufferedReader reader;

        reader = new BufferedReader(new InputStreamReader(_input_, getCharset()));

        while (true)
        {
            read = reader.read(buffer, 0, buffer.length);
            if (read <= 0) {
                break;
            }
            result.append(buffer, 0, read);
        }

        return result.toString();
    }","  public void test0()  throws Throwable  {
      DaytimeTCPClient daytimeTCPClient0 = new DaytimeTCPClient();
      // Undeclared exception!
      try { 
        daytimeTCPClient0.getTime();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Reader"", e);
      }
  }"
1209,"    public String getTime(final InetAddress host, final int port) throws IOException
    {
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        return new String(receivePacket.getData(), 0, receivePacket.getLength(), getCharset()); // Java 1.6 can use getCharset()
    }","  public void test0()  throws Throwable  {
      DaytimeUDPClient daytimeUDPClient0 = new DaytimeUDPClient();
      daytimeUDPClient0.open();
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      byte[] byteArray0 = new byte[4];
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 13);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      String string0 = daytimeUDPClient0.getTime(inetAddress0, 1);
}"
1210,"    public String getTime(final InetAddress host, final int port) throws IOException
    {
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        return new String(receivePacket.getData(), 0, receivePacket.getLength(), getCharset()); // Java 1.6 can use getCharset()
    }","  public void test1()  throws Throwable  {
      DaytimeUDPClient daytimeUDPClient0 = new DaytimeUDPClient();
      daytimeUDPClient0.open();
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      byte[] byteArray0 = new byte[4];
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 13);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      String string0 = daytimeUDPClient0.getTime(inetAddress0);
}"
1211,"    public String getTime(final InetAddress host, final int port) throws IOException
    {
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        return new String(receivePacket.getData(), 0, receivePacket.getLength(), getCharset()); // Java 1.6 can use getCharset()
    }","  public void test2()  throws Throwable  {
      DaytimeUDPClient daytimeUDPClient0 = new DaytimeUDPClient();
      daytimeUDPClient0.open();
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, (byte[]) null);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      String string0 = daytimeUDPClient0.getTime(inetAddress0);
}"
1212,"    public String getTime(final InetAddress host, final int port) throws IOException
    {
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        return new String(receivePacket.getData(), 0, receivePacket.getLength(), getCharset()); // Java 1.6 can use getCharset()
    }","  public void test3()  throws Throwable  {
      DaytimeUDPClient daytimeUDPClient0 = new DaytimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      // Undeclared exception!
      try { 
        daytimeUDPClient0.getTime(inetAddress0, 2008);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.daytime.DaytimeUDPClient"", e);
      }
  }"
1213,"    public String getTime(final InetAddress host, final int port) throws IOException
    {
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        return new String(receivePacket.getData(), 0, receivePacket.getLength(), getCharset()); // Java 1.6 can use getCharset()
    }","  public void test4()  throws Throwable  {
      DaytimeUDPClient daytimeUDPClient0 = new DaytimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      daytimeUDPClient0.open();
      try { 
        daytimeUDPClient0.getTime(inetAddress0, 358);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
1214,"    public String getTime(final InetAddress host, final int port) throws IOException
    {
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        return new String(receivePacket.getData(), 0, receivePacket.getLength(), getCharset()); // Java 1.6 can use getCharset()
    }","  public void test5()  throws Throwable  {
      DaytimeUDPClient daytimeUDPClient0 = new DaytimeUDPClient();
      daytimeUDPClient0.open();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      try { 
        daytimeUDPClient0.getTime(inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
1215,"    public String getTime(final InetAddress host, final int port) throws IOException
    {
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        return new String(receivePacket.getData(), 0, receivePacket.getLength(), getCharset()); // Java 1.6 can use getCharset()
    }","  public void test6()  throws Throwable  {
      DaytimeUDPClient daytimeUDPClient0 = new DaytimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        daytimeUDPClient0.getTime(inetAddress0, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-1
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
1216,"    public String getTime(final InetAddress host, final int port) throws IOException
    {
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        return new String(receivePacket.getData(), 0, receivePacket.getLength(), getCharset()); // Java 1.6 can use getCharset()
    }","  public void test7()  throws Throwable  {
      DaytimeUDPClient daytimeUDPClient0 = new DaytimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        daytimeUDPClient0.getTime(inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.daytime.DaytimeUDPClient"", e);
      }
  }"
1217,"    public static void main(final String[] args) throws Throwable  {
        final Properties fp = new Properties();
        final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
        if (ras != null) {
            fp.load(ras);
        } else {
            System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
        }
        if (args.length == 0) {
            if (Thread.currentThread().getStackTrace().length > 2) { // called by Maven
                System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" +
                                    "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
                System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" +
                                    "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
            } else {
                if (fromJar()) {
                    System.out.println(
                        ""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
                } else {
                    System.out.println(
                        ""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
                }
            }
            @SuppressWarnings(""unchecked"") // property names are Strings
            final
            List<String> l = (List<String>) Collections.list(fp.propertyNames());
            if (l.isEmpty()) {
                return;
            }
            Collections.sort(l);
            System.out.println(""\nAliases and their classes:"");
            for(final String s : l) {
                System.out.printf(""%-25s %s%n"",s,fp.getProperty(s));
            }
            return;
        }

        final String shortName = args[0];
        String fullName = fp.getProperty(shortName);
        if (fullName == null) {
            fullName = shortName;
        }
        fullName = fullName.replace('/', '.');
        try {
            final Class<?> clazz = Class.forName(fullName);
            final Method m = clazz.getDeclaredMethod(""main"", args.getClass());
            final String[] args2 = new String[args.length-1];
            System.arraycopy(args, 1, args2, 0, args2.length);
            try {
                m.invoke(null, (Object)args2);
            } catch (final InvocationTargetException ite) {
                final Throwable cause = ite.getCause();
                if (cause != null) {
                    throw cause;
                }
                throw ite;
            }
        } catch (final ClassNotFoundException e) {
            System.out.println(e);
        }
    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""org.apache.commons.net.examples.Main"";
      stringArray0[1] = ""@4tB4.PYsvL>XkH"";
      Main.main(stringArray0);
}"
1218,"    public static void main(final String[] args) throws Throwable  {
        final Properties fp = new Properties();
        final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
        if (ras != null) {
            fp.load(ras);
        } else {
            System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
        }
        if (args.length == 0) {
            if (Thread.currentThread().getStackTrace().length > 2) { // called by Maven
                System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" +
                                    "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
                System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" +
                                    "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
            } else {
                if (fromJar()) {
                    System.out.println(
                        ""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
                } else {
                    System.out.println(
                        ""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
                }
            }
            @SuppressWarnings(""unchecked"") // property names are Strings
            final
            List<String> l = (List<String>) Collections.list(fp.propertyNames());
            if (l.isEmpty()) {
                return;
            }
            Collections.sort(l);
            System.out.println(""\nAliases and their classes:"");
            for(final String s : l) {
                System.out.printf(""%-25s %s%n"",s,fp.getProperty(s));
            }
            return;
        }

        final String shortName = args[0];
        String fullName = fp.getProperty(shortName);
        if (fullName == null) {
            fullName = shortName;
        }
        fullName = fullName.replace('/', '.');
        try {
            final Class<?> clazz = Class.forName(fullName);
            final Method m = clazz.getDeclaredMethod(""main"", args.getClass());
            final String[] args2 = new String[args.length-1];
            System.arraycopy(args, 1, args2, 0, args2.length);
            try {
                m.invoke(null, (Object)args2);
            } catch (final InvocationTargetException ite) {
                final Throwable cause = ite.getCause();
                if (cause != null) {
                    throw cause;
                }
                throw ite;
            }
        } catch (final ClassNotFoundException e) {
            System.out.println(e);
        }
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""org.apache.commons.net.examples.Main"";
      try { 
        Main.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1219,"    public static void main(final String[] args) throws Throwable  {
        final Properties fp = new Properties();
        final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
        if (ras != null) {
            fp.load(ras);
        } else {
            System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
        }
        if (args.length == 0) {
            if (Thread.currentThread().getStackTrace().length > 2) { // called by Maven
                System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" +
                                    "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
                System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" +
                                    "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
            } else {
                if (fromJar()) {
                    System.out.println(
                        ""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
                } else {
                    System.out.println(
                        ""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
                }
            }
            @SuppressWarnings(""unchecked"") // property names are Strings
            final
            List<String> l = (List<String>) Collections.list(fp.propertyNames());
            if (l.isEmpty()) {
                return;
            }
            Collections.sort(l);
            System.out.println(""\nAliases and their classes:"");
            for(final String s : l) {
                System.out.printf(""%-25s %s%n"",s,fp.getProperty(s));
            }
            return;
        }

        final String shortName = args[0];
        String fullName = fp.getProperty(shortName);
        if (fullName == null) {
            fullName = shortName;
        }
        fullName = fullName.replace('/', '.');
        try {
            final Class<?> clazz = Class.forName(fullName);
            final Method m = clazz.getDeclaredMethod(""main"", args.getClass());
            final String[] args2 = new String[args.length-1];
            System.arraycopy(args, 1, args2, 0, args2.length);
            try {
                m.invoke(null, (Object)args2);
            } catch (final InvocationTargetException ite) {
                final Throwable cause = ite.getCause();
                if (cause != null) {
                    throw cause;
                }
                throw ite;
            }
        } catch (final ClassNotFoundException e) {
            System.out.println(e);
        }
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[0];
      Main.main(stringArray0);
}"
1220,,"  public void test3()  throws Throwable  {
      Main main0 = new Main();
  }"
1221,"    public static void main(final String[] args)
    {
        if (args.length < 3)
        {
            System.err.println(
                ""Usage: POP3Mail <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[0].split("":"");
        final String server=arg0[0];
        final String username = args[1];
        String password = args[2];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = args.length > 3 ? args[3] : null;
        final boolean implicit = args.length > 4 ? Boolean.parseBoolean(args[4]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        // suppress login details
        pop3.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);

            final POP3MessageInfo[] messages = pop3.listMessages();

            if (messages == null)
            {
                System.err.println(""Could not retrieve message list."");
                pop3.logout();
                pop3.disconnect();
                return;
            }
            else if (messages.length == 0)
            {
                System.out.println(""No messages"");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Message count: "" + messages.length);

            for (final POP3MessageInfo msginfo : messages) {
                final BufferedReader reader = (BufferedReader) pop3.retrieveMessageTop(msginfo.number, 0);

                if (reader == null) {
                    System.err.println(""Could not retrieve message header."");
                    pop3.logout();
                    pop3.disconnect();
                    return;
                }
                printMessageInfo(reader, msginfo.number);
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""  Subject: "";
      stringArray0[2] = ""MD5"";
      // Undeclared exception!
      try { 
        POP3Mail.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // For input string: \"" \""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
1222,"    public static void printMessageInfo(final BufferedReader reader, final int id) throws IOException  {
        String from = """";
        String subject = """";
        String line;
        while ((line = reader.readLine()) != null)
        {
            final String lower = line.toLowerCase(Locale.ENGLISH);
            if (lower.startsWith(""from: "")) {
                from = line.substring(6).trim();
            }  else if (lower.startsWith(""subject: "")) {
                subject = line.substring(9).trim();
            }
        }

        System.out.println(Integer.toString(id) + "" From: "" + from + ""  Subject: "" + subject);
    }","  public void test1()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""from: hostname doesn't mOtch certificate"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      POP3Mail.printMessageInfo(bufferedReader0, (-1890));
  }"
1223,"    public static void main(final String[] args)
    {
        if (args.length < 3)
        {
            System.err.println(
                ""Usage: POP3Mail <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[0].split("":"");
        final String server=arg0[0];
        final String username = args[1];
        String password = args[2];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = args.length > 3 ? args[3] : null;
        final boolean implicit = args.length > 4 ? Boolean.parseBoolean(args[4]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        // suppress login details
        pop3.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);

            final POP3MessageInfo[] messages = pop3.listMessages();

            if (messages == null)
            {
                System.err.println(""Could not retrieve message list."");
                pop3.logout();
                pop3.disconnect();
                return;
            }
            else if (messages.length == 0)
            {
                System.out.println(""No messages"");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Message count: "" + messages.length);

            for (final POP3MessageInfo msginfo : messages) {
                final BufferedReader reader = (BufferedReader) pop3.retrieveMessageTop(msginfo.number, 0);

                if (reader == null) {
                    System.err.println(""Could not retrieve message header."");
                    pop3.logout();
                    pop3.disconnect();
                    return;
                }
                printMessageInfo(reader, msginfo.number);
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[10];
      stringArray0[0] = ""B6S]-$[Sav@ -lr"";
      stringArray0[2] = ""*"";
      POP3Mail.main(stringArray0);
}"
1224,"    public static void printMessageInfo(final BufferedReader reader, final int id) throws IOException  {
        String from = """";
        String subject = """";
        String line;
        while ((line = reader.readLine()) != null)
        {
            final String lower = line.toLowerCase(Locale.ENGLISH);
            if (lower.startsWith(""from: "")) {
                from = line.substring(6).trim();
            }  else if (lower.startsWith(""subject: "")) {
                subject = line.substring(9).trim();
            }
        }

        System.out.println(Integer.toString(id) + "" From: "" + from + ""  Subject: "" + subject);
    }","  public void test3()  throws Throwable  {
      // Undeclared exception!
      try { 
        POP3Mail.printMessageInfo((BufferedReader) null, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.mail.POP3Mail"", e);
      }
  }"
1225,"    public static void printMessageInfo(final BufferedReader reader, final int id) throws IOException  {
        String from = """";
        String subject = """";
        String line;
        while ((line = reader.readLine()) != null)
        {
            final String lower = line.toLowerCase(Locale.ENGLISH);
            if (lower.startsWith(""from: "")) {
                from = line.substring(6).trim();
            }  else if (lower.startsWith(""subject: "")) {
                subject = line.substring(9).trim();
            }
        }

        System.out.println(Integer.toString(id) + "" From: "" + from + ""  Subject: "" + subject);
    }","  public void test4()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""@+SSf"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 6730);
      bufferedReader0.close();
      try { 
        POP3Mail.printMessageInfo(bufferedReader0, 6730);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedReader"", e);
      }
  }"
1226,"    public static void main(final String[] args)
    {
        if (args.length < 3)
        {
            System.err.println(
                ""Usage: POP3Mail <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[0].split("":"");
        final String server=arg0[0];
        final String username = args[1];
        String password = args[2];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = args.length > 3 ? args[3] : null;
        final boolean implicit = args.length > 4 ? Boolean.parseBoolean(args[4]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        // suppress login details
        pop3.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);

            final POP3MessageInfo[] messages = pop3.listMessages();

            if (messages == null)
            {
                System.err.println(""Could not retrieve message list."");
                pop3.logout();
                pop3.disconnect();
                return;
            }
            else if (messages.length == 0)
            {
                System.out.println(""No messages"");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Message count: "" + messages.length);

            for (final POP3MessageInfo msginfo : messages) {
                final BufferedReader reader = (BufferedReader) pop3.retrieveMessageTop(msginfo.number, 0);

                if (reader == null) {
                    System.err.println(""Could not retrieve message header."");
                    pop3.logout();
                    pop3.disconnect();
                    return;
                }
                printMessageInfo(reader, msginfo.number);
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[7];
      stringArray0[0] = "":"";
      // Undeclared exception!
      try { 
        POP3Mail.main(stringArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 0
         //
         verifyException(""org.apache.commons.net.examples.mail.POP3Mail"", e);
      }
  }"
1227,"    public static void main(final String[] args)
    {
        if (args.length < 3)
        {
            System.err.println(
                ""Usage: POP3Mail <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[0].split("":"");
        final String server=arg0[0];
        final String username = args[1];
        String password = args[2];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = args.length > 3 ? args[3] : null;
        final boolean implicit = args.length > 4 ? Boolean.parseBoolean(args[4]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        // suppress login details
        pop3.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);

            final POP3MessageInfo[] messages = pop3.listMessages();

            if (messages == null)
            {
                System.err.println(""Could not retrieve message list."");
                pop3.logout();
                pop3.disconnect();
                return;
            }
            else if (messages.length == 0)
            {
                System.out.println(""No messages"");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Message count: "" + messages.length);

            for (final POP3MessageInfo msginfo : messages) {
                final BufferedReader reader = (BufferedReader) pop3.retrieveMessageTop(msginfo.number, 0);

                if (reader == null) {
                    System.err.println(""Could not retrieve message header."");
                    pop3.logout();
                    pop3.disconnect();
                    return;
                }
                printMessageInfo(reader, msginfo.number);
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test6()  throws Throwable  {
      String[] stringArray0 = new String[8];
      stringArray0[0] = ""Could not retrieve password: "";
      stringArray0[2] = ""  J|,{W[m|;[\""z0"";
      stringArray0[3] = ""!Df"";
      // Undeclared exception!
      try { 
        POP3Mail.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // For input string: \"" \""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
1228,"    public static void main(final String[] args)
    {
        if (args.length < 3)
        {
            System.err.println(
                ""Usage: POP3Mail <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[0].split("":"");
        final String server=arg0[0];
        final String username = args[1];
        String password = args[2];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = args.length > 3 ? args[3] : null;
        final boolean implicit = args.length > 4 ? Boolean.parseBoolean(args[4]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        // suppress login details
        pop3.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);

            final POP3MessageInfo[] messages = pop3.listMessages();

            if (messages == null)
            {
                System.err.println(""Could not retrieve message list."");
                pop3.logout();
                pop3.disconnect();
                return;
            }
            else if (messages.length == 0)
            {
                System.out.println(""No messages"");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Message count: "" + messages.length);

            for (final POP3MessageInfo msginfo : messages) {
                final BufferedReader reader = (BufferedReader) pop3.retrieveMessageTop(msginfo.number, 0);

                if (reader == null) {
                    System.err.println(""Could not retrieve message header."");
                    pop3.logout();
                    pop3.disconnect();
                    return;
                }
                printMessageInfo(reader, msginfo.number);
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test7()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[3];
          stringArray0[0] = ""p.Nx<Ipzym <;DM"";
          stringArray0[2] = ""p.Nx<Ipzym <;DM"";
          // Undeclared exception!
          try { 
            POP3Mail.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:110\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.mail.POP3Mail.main(POP3Mail.java:107)
             // sun.reflect.GeneratedMethodAccessor147.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1229,"    public static void main(final String[] args)
    {
        if (args.length < 3)
        {
            System.err.println(
                ""Usage: POP3Mail <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[0].split("":"");
        final String server=arg0[0];
        final String username = args[1];
        String password = args[2];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = args.length > 3 ? args[3] : null;
        final boolean implicit = args.length > 4 ? Boolean.parseBoolean(args[4]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        // suppress login details
        pop3.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);

            final POP3MessageInfo[] messages = pop3.listMessages();

            if (messages == null)
            {
                System.err.println(""Could not retrieve message list."");
                pop3.logout();
                pop3.disconnect();
                return;
            }
            else if (messages.length == 0)
            {
                System.out.println(""No messages"");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Message count: "" + messages.length);

            for (final POP3MessageInfo msginfo : messages) {
                final BufferedReader reader = (BufferedReader) pop3.retrieveMessageTop(msginfo.number, 0);

                if (reader == null) {
                    System.err.println(""Could not retrieve message header."");
                    pop3.logout();
                    pop3.disconnect();
                    return;
                }
                printMessageInfo(reader, msginfo.number);
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test8()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        POP3Mail.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1230,"    public static void main(final String[] args)
    {
        if (args.length < 3)
        {
            System.err.println(
                ""Usage: POP3Mail <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[0].split("":"");
        final String server=arg0[0];
        final String username = args[1];
        String password = args[2];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = args.length > 3 ? args[3] : null;
        final boolean implicit = args.length > 4 ? Boolean.parseBoolean(args[4]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        // suppress login details
        pop3.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);

            final POP3MessageInfo[] messages = pop3.listMessages();

            if (messages == null)
            {
                System.err.println(""Could not retrieve message list."");
                pop3.logout();
                pop3.disconnect();
                return;
            }
            else if (messages.length == 0)
            {
                System.out.println(""No messages"");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Message count: "" + messages.length);

            for (final POP3MessageInfo msginfo : messages) {
                final BufferedReader reader = (BufferedReader) pop3.retrieveMessageTop(msginfo.number, 0);

                if (reader == null) {
                    System.err.println(""Could not retrieve message header."");
                    pop3.logout();
                    pop3.disconnect();
                    return;
                }
                printMessageInfo(reader, msginfo.number);
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test9()  throws Throwable  {
      String[] stringArray0 = new String[7];
      // Undeclared exception!
      try { 
        POP3Mail.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.mail.POP3Mail"", e);
      }
  }"
1231,"    public static void printMessageInfo(final BufferedReader reader, final int id) throws IOException  {
        String from = """";
        String subject = """";
        String line;
        while ((line = reader.readLine()) != null)
        {
            final String lower = line.toLowerCase(Locale.ENGLISH);
            if (lower.startsWith(""from: "")) {
                from = line.substring(6).trim();
            }  else if (lower.startsWith(""subject: "")) {
                subject = line.substring(9).trim();
            }
        }

        System.out.println(Integer.toString(id) + "" From: "" + from + ""  Subject: "" + subject);
    }","  public void test10()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""irom: @M|gKTo"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 22);
      POP3Mail.printMessageInfo(bufferedReader0, 22);
  }"
1232,"    public static void printMessageInfo(final BufferedReader reader, final int id) throws IOException  {
        String from = """";
        String subject = """";
        String line;
        while ((line = reader.readLine()) != null)
        {
            final String lower = line.toLowerCase(Locale.ENGLISH);
            if (lower.startsWith(""from: "")) {
                from = line.substring(6).trim();
            }  else if (lower.startsWith(""subject: "")) {
                subject = line.substring(9).trim();
            }
        }

        System.out.println(Integer.toString(id) + "" From: "" + from + ""  Subject: "" + subject);
    }","  public void test11()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""subject: s%bj;ct: 8ijqI]jliu) c["");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      POP3Mail.printMessageInfo(bufferedReader0, 10);
  }"
1233,,"  public void test12()  throws Throwable  {
      POP3Mail pOP3Mail0 = new POP3Mail();
  }"
1234,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[7];
      stringArray0[0] = ""-."";
      stringArray0[1] = ""Pmzqccl2F8Y$'"";
      stringArray0[2] = ""O(Rc5eyi"";
      stringArray0[3] = ""sCL{]mmWRE.!'oz"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Missing userInfo details
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPUtils"", e);
      }
  }"
1235,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = ""-R"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPExportMbox"", e);
      }
  }"
1236,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[2];
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""m5 Uq>["");
      FileSystemHandling.appendStringToFile(evoSuiteFile0, ""_ri"");
      stringArray0[0] = ""_ri"";
      stringArray0[1] = ""m5 Uq>["";
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // mailbox file: m5 Uq>[ already exists and is non-empty!
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPExportMbox"", e);
      }
  }"
1237,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[40];
      stringArray0[0] = ""+(@VNK"";
      stringArray0[1] = """";
      stringArray0[2] = ""+(@VNK"";
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: FileNotFoundException"");
      } catch(FileNotFoundException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileOutputStream"", e);
      }
  }"
1238,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""-CRLF"";
      stringArray0[1] = """";
      stringArray0[2] = ""-CRLF"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid folderPath: ''
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPExportMbox"", e);
      }
  }"
1239,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[9];
      stringArray0[0] = ""xB:27*!OAUL@eWcyF"";
      stringArray0[1] = ""=k~0VyxM-~*?/"";
      stringArray0[2] = ""0[|awYC[Q4"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid folderPath: 'null'
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPExportMbox"", e);
      }
  }"
1240,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test6()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = "";06"";
      stringArray0[1] = ""-"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Missing userInfo details
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPUtils"", e);
      }
  }"
1241,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test7()  throws Throwable  {
      String[] stringArray0 = new String[9];
      stringArray0[0] = ""xB:27*!OAUL@eWcyF"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1242,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test8()  throws Throwable  {
      String[] stringArray0 = new String[5];
      stringArray0[0] = ""~0m)UAN:y"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal character in scheme name at index 0: ~0m)UAN:y
         //
         verifyException(""java.net.URI"", e);
      }
  }"
1243,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test9()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = ""-X"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1244,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test10()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-R"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // null
         //
         verifyException(""java.lang.Integer"", e);
      }
  }"
1245,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test11()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-r"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // null
         //
         verifyException(""java.lang.Integer"", e);
      }
  }"
1246,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test12()  throws Throwable  {
      String[] stringArray0 = new String[10];
      stringArray0[0] = ""-c"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // null
         //
         verifyException(""java.lang.Integer"", e);
      }
  }"
1247,,"  public void test13()  throws Throwable  {
      IMAPExportMbox iMAPExportMbox0 = new IMAPExportMbox();
  }"
1248,"    public static void main(final String[] args) throws IOException, URISyntaxException
    {
        int connect_timeout = CONNECT_TIMEOUT;
        int read_timeout = READ_TIMEOUT;

        int argIdx = 0;
        String eol = EOL_DEFAULT;
        boolean printHash = false;
        boolean printMarker = false;
        int retryWaitSecs = 0;

        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-c"")) {
                connect_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-r"")) {
                read_timeout = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-R"")) {
                retryWaitSecs = Integer.parseInt(args[++argIdx]);
            } else if (args[argIdx].equals(""-LF"")) {
                eol = LF;
            } else if (args[argIdx].equals(""-CRLF"")) {
                eol = CRLF;
            } else if (args[argIdx].equals(""-."")) {
                printHash = true;
            } else if (args[argIdx].equals(""-X"")) {
                printMarker = true;
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;

        if (argCount < 2)
        {
            System.err.println(""Usage: IMAPExportMbox [-LF|-CRLF] [-c n] [-r n] [-R n] [-.] [-X]"" +
                               "" imap[s]://user:password@host[:port]/folder/path [+|-]<mboxfile> [sequence-set] [itemnames]"");
            System.err.println(""\t-LF | -CRLF set end-of-line to LF or CRLF (default is the line.separator system property)"");
            System.err.println(""\t-c connect timeout in seconds (default 10)"");
            System.err.println(""\t-r read timeout in seconds (default 10)"");
            System.err.println(""\t-R temporary failure retry wait in seconds (default 0; i.e. disabled)"");
            System.err.println(""\t-. print a . for each complete message received"");
            System.err.println(""\t-X print the X-IMAP line for each complete message received"");
            System.err.println(""\tthe mboxfile is where the messages are stored; use '-' to write to standard output."");
            System.err.println(""\tPrefix file name with '+' to append to the file. Prefix with '-' to allow overwrite."");
            System.err.println(""\ta sequence-set is a list of numbers/number ranges e.g. 1,2,3-10,20:* - default 1:*"");
            System.err.println(""\titemnames are the message data item name(s) e.g. BODY.PEEK[HEADER.FIELDS (SUBJECT)]"" +
                               "" or a macro e.g. ALL - default (INTERNALDATE BODY.PEEK[])"");
            System.exit(1);
        }

        final String uriString = args[argIdx++];
        URI uri;
        try {
            uri = URI.create(uriString);
        } catch(final IllegalArgumentException e) { // cannot parse the path as is; let's pull it apart and try again
            final Matcher m = Pattern.compile(""(imaps?://[^/]+)(/.*)"").matcher(uriString);
            if (m.matches()) {
                uri = URI.create(m.group(1)); // Just the scheme and auth parts
                uri = new URI(uri.getScheme(), uri.getAuthority(), m.group(2), null, null);
            } else {
                throw e;
            }
        }
        final String file  = args[argIdx++];
        String sequenceSet = argCount > 2 ? args[argIdx++] : ""1:*"";
        final String itemNames;
        // Handle 0, 1 or multiple item names
        if (argCount > 3) {
            if (argCount > 4) {
                final StringBuilder sb = new StringBuilder();
                sb.append(""("");
                for(int i=4; i <= argCount; i++) {
                    if (i>4) {
                        sb.append("" "");
                    }
                    sb.append(args[argIdx++]);
                }
                sb.append("")"");
                itemNames = sb.toString();
            } else {
                itemNames = args[argIdx++];
            }
        } else {
            itemNames = ""(INTERNALDATE BODY.PEEK[])"";
        }

        final boolean checkSequence = sequenceSet.matches(""\\d+:(\\d+|\\*)""); // are we expecting a sequence?
        final MboxListener mboxListener;
        if (file.equals(""-"")) {
            mboxListener = null;
        } else if (file.startsWith(""+"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Appending to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, true)), eol, printHash, printMarker, checkSequence);
        } else if (file.startsWith(""-"")) {
            final File mbox = new File(file.substring(1));
            System.out.println(""Writing to file "" + mbox);
            mboxListener = new MboxListener(
                new BufferedWriter(new FileWriter(mbox, false)), eol, printHash, printMarker, checkSequence);
        } else {
            final File mboxFile = new File(file);
            if (mboxFile.exists() && mboxFile.length() > 0) {
                throw new IOException(""mailbox file: "" + mboxFile + "" already exists and is non-empty!"");
            }
            System.out.println(""Creating file "" + mboxFile);
            mboxListener = new MboxListener(new BufferedWriter(new FileWriter(mboxFile)), eol, printHash, printMarker,
                    checkSequence);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        // suppress login details
        final PrintCommandListener listener = new PrintCommandListener(System.out, true) {
            @Override
            public void protocolReplyReceived(final ProtocolCommandEvent event) {
                if (event.getReplyCode() != IMAPReply.PARTIAL){ // This is dealt with by the chunk listener
                    super.protocolReplyReceived(event);
                }
            }
        };

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, connect_timeout * 1000, listener);

        String maxIndexInFolder = null;

        try {

            imap.setSoTimeout(read_timeout * 1000);

            if (!imap.select(folder)){
                throw new IOException(""Could not select folder: "" + folder);
            }

            for(final String line : imap.getReplyStrings()) {
                maxIndexInFolder = matches(line, PATEXISTS, 1);
                if (maxIndexInFolder != null) {
                    break;
                }
            }

            if (mboxListener != null) {
                imap.setChunkListener(mboxListener);
            } // else the command listener displays the full output without processing


            while (true) {
                final boolean ok = imap.fetch(sequenceSet, itemNames);
                // If the fetch failed, can we retry?
                if (!ok && retryWaitSecs > 0 && mboxListener != null && checkSequence) {
                    final String replyString = imap.getReplyString(); //includes EOL
                    if (startsWith(replyString, PATTEMPFAIL)) {
                        System.err.println(""Temporary error detected, will retry in "" + retryWaitSecs + ""seconds"");
                        sequenceSet = mboxListener.lastSeq+1+"":*"";
                        try {
                            Thread.sleep(retryWaitSecs * 1000);
                        } catch (final InterruptedException e) {
                            // ignored
                        }
                    } else {
                        throw new IOException(""FETCH "" + sequenceSet + "" "" + itemNames+ "" failed with "" + replyString);
                    }
                } else {
                    break;
                }
            }

        } catch (final IOException ioe) {
            final String count = mboxListener == null ? ""?"" : mboxListener.total.toString();
            System.err.println(
                    ""FETCH "" + sequenceSet + "" "" + itemNames + "" failed after processing "" + count + "" complete messages "");
            if (mboxListener != null) {
                System.err.println(""Last complete response seen: ""+mboxListener.lastFetched);
            }
            throw ioe;
        } finally {

            if (printHash) {
                System.err.println();
            }

            if (mboxListener != null) {
                mboxListener.close();
                final Iterator<String> missingIds = mboxListener.missingIds.iterator();
                if (missingIds.hasNext()) {
                    final StringBuilder sb = new StringBuilder();
                    for(;;) {
                        sb.append(missingIds.next());
                        if (!missingIds.hasNext()) {
                            break;
                        }
                        sb.append("","");
                    }
                    System.err.println(""*** Missing ids: "" + sb.toString());
                }
            }
            imap.logout();
            imap.disconnect();
        }
        if (mboxListener != null) {
            System.out.println(""Processed "" + mboxListener.total + "" messages."");
        }
        if (maxIndexInFolder != null) {
            System.out.println(""Folder contained "" + maxIndexInFolder + "" messages."");
        }
    }","  public void test14()  throws Throwable  {
      String[] stringArray0 = new String[5];
      stringArray0[0] = ""-LF"";
      stringArray0[1] = ""+m"";
      stringArray0[2] = ""+m"";
      stringArray0[3] = ""-LF"";
      // Undeclared exception!
      try { 
        IMAPExportMbox.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Missing userInfo details
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPUtils"", e);
      }
  }"
1249,"    public static void main(final String[] args) throws IOException
    {
        if (args.length < 2)
        {
            System.err.println(""Usage: IMAPImportMbox imap[s]://user:password@host[:port]/folder/path <mboxfile> [selectors]"");
            System.err.println(""\tWhere: a selector is a list of numbers/number ranges - 1,2,3-10"" +
                               "" - or a list of strings to match in the initial From line"");
            System.exit(1);
        }

        final URI uri      = URI.create(args[0]);
        final String file  = args[1];

        final File mbox = new File(file);
        if (!mbox.isFile() || !mbox.canRead()) {
            throw new IOException(""Cannot read mailbox file: "" + mbox);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        final List<String> contains = new ArrayList<>(); // list of strings to find
        final BitSet msgNums = new BitSet(); // list of message numbers

        for(int i = 2; i < args.length; i++) {
            final String arg = args[i];
            if (arg.matches(""\\d+(-\\d+)?(,\\d+(-\\d+)?)*"")) { // number,m-n
                for(final String entry : arg.split("","")) {
                    final String []parts = entry.split(""-"");
                    if (parts.length == 2) { // m-n
                        final int low = Integer.parseInt(parts[0]);
                        final int high = Integer.parseInt(parts[1]);
                        for(int j=low; j <= high; j++) {
                            msgNums.set(j);
                        }
                    } else {
                        msgNums.set(Integer.parseInt(entry));
                    }
                }
            } else {
                contains.add(arg); // not a number/number range
            }
        }
//        System.out.println(msgNums.toString());
//        System.out.println(java.util.Arrays.toString(contains.toArray()));

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        int total = 0;
        int loaded = 0;
        try {
            imap.setSoTimeout(6000);

            final BufferedReader br = new BufferedReader(new FileReader(file)); // TODO charset?

            String line;
            final StringBuilder sb = new StringBuilder();
            boolean wanted = false; // Skip any leading rubbish
            while((line=br.readLine())!=null) {
                if (line.startsWith(""From "")) { // start of message; i.e. end of previous (if any)
                    if (process(sb, imap, folder, total)) { // process previous message (if any)
                        loaded++;
                    }
                    sb.setLength(0);
                    total ++;
                    wanted = wanted(total, line, msgNums, contains);
                } else if (startsWith(line, PATFROM)) { // Unescape "">+From "" in body text
                    line = line.substring(1);
                }
                // TODO process first Received: line to determine arrival date?
                if (wanted) {
                    sb.append(line);
                    sb.append(CRLF);
                }
            }
            br.close();
            if (wanted && process(sb, imap, folder, total)) { // last message (if any)
                loaded++;
            }
        } catch (final IOException e) {
            System.out.println(""Error processing msg: "" + total + "" "" + imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
        System.out.println(""Processed "" + total + "" messages, loaded "" + loaded);
    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        IMAPImportMbox.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1250,"    public static void main(final String[] args) throws IOException
    {
        if (args.length < 2)
        {
            System.err.println(""Usage: IMAPImportMbox imap[s]://user:password@host[:port]/folder/path <mboxfile> [selectors]"");
            System.err.println(""\tWhere: a selector is a list of numbers/number ranges - 1,2,3-10"" +
                               "" - or a list of strings to match in the initial From line"");
            System.exit(1);
        }

        final URI uri      = URI.create(args[0]);
        final String file  = args[1];

        final File mbox = new File(file);
        if (!mbox.isFile() || !mbox.canRead()) {
            throw new IOException(""Cannot read mailbox file: "" + mbox);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        final List<String> contains = new ArrayList<>(); // list of strings to find
        final BitSet msgNums = new BitSet(); // list of message numbers

        for(int i = 2; i < args.length; i++) {
            final String arg = args[i];
            if (arg.matches(""\\d+(-\\d+)?(,\\d+(-\\d+)?)*"")) { // number,m-n
                for(final String entry : arg.split("","")) {
                    final String []parts = entry.split(""-"");
                    if (parts.length == 2) { // m-n
                        final int low = Integer.parseInt(parts[0]);
                        final int high = Integer.parseInt(parts[1]);
                        for(int j=low; j <= high; j++) {
                            msgNums.set(j);
                        }
                    } else {
                        msgNums.set(Integer.parseInt(entry));
                    }
                }
            } else {
                contains.add(arg); // not a number/number range
            }
        }
//        System.out.println(msgNums.toString());
//        System.out.println(java.util.Arrays.toString(contains.toArray()));

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        int total = 0;
        int loaded = 0;
        try {
            imap.setSoTimeout(6000);

            final BufferedReader br = new BufferedReader(new FileReader(file)); // TODO charset?

            String line;
            final StringBuilder sb = new StringBuilder();
            boolean wanted = false; // Skip any leading rubbish
            while((line=br.readLine())!=null) {
                if (line.startsWith(""From "")) { // start of message; i.e. end of previous (if any)
                    if (process(sb, imap, folder, total)) { // process previous message (if any)
                        loaded++;
                    }
                    sb.setLength(0);
                    total ++;
                    wanted = wanted(total, line, msgNums, contains);
                } else if (startsWith(line, PATFROM)) { // Unescape "">+From "" in body text
                    line = line.substring(1);
                }
                // TODO process first Received: line to determine arrival date?
                if (wanted) {
                    sb.append(line);
                    sb.append(CRLF);
                }
            }
            br.close();
            if (wanted && process(sb, imap, folder, total)) { // last message (if any)
                loaded++;
            }
        } catch (final IOException e) {
            System.out.println(""Error processing msg: "" + total + "" "" + imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
        System.out.println(""Processed "" + total + "" messages, loaded "" + loaded);
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[6];
      stringArray0[0] = """";
      stringArray0[1] = ""From S+ +S+ (S+)  ?(S+) (S+) (S+)"";
      try { 
        IMAPImportMbox.main(stringArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Cannot read mailbox file: From S+ +S+ (S+)  ?(S+) (S+) (S+)
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPImportMbox"", e);
      }
  }"
1251,"    public static void main(final String[] args) throws IOException
    {
        if (args.length < 2)
        {
            System.err.println(""Usage: IMAPImportMbox imap[s]://user:password@host[:port]/folder/path <mboxfile> [selectors]"");
            System.err.println(""\tWhere: a selector is a list of numbers/number ranges - 1,2,3-10"" +
                               "" - or a list of strings to match in the initial From line"");
            System.exit(1);
        }

        final URI uri      = URI.create(args[0]);
        final String file  = args[1];

        final File mbox = new File(file);
        if (!mbox.isFile() || !mbox.canRead()) {
            throw new IOException(""Cannot read mailbox file: "" + mbox);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        final List<String> contains = new ArrayList<>(); // list of strings to find
        final BitSet msgNums = new BitSet(); // list of message numbers

        for(int i = 2; i < args.length; i++) {
            final String arg = args[i];
            if (arg.matches(""\\d+(-\\d+)?(,\\d+(-\\d+)?)*"")) { // number,m-n
                for(final String entry : arg.split("","")) {
                    final String []parts = entry.split(""-"");
                    if (parts.length == 2) { // m-n
                        final int low = Integer.parseInt(parts[0]);
                        final int high = Integer.parseInt(parts[1]);
                        for(int j=low; j <= high; j++) {
                            msgNums.set(j);
                        }
                    } else {
                        msgNums.set(Integer.parseInt(entry));
                    }
                }
            } else {
                contains.add(arg); // not a number/number range
            }
        }
//        System.out.println(msgNums.toString());
//        System.out.println(java.util.Arrays.toString(contains.toArray()));

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        int total = 0;
        int loaded = 0;
        try {
            imap.setSoTimeout(6000);

            final BufferedReader br = new BufferedReader(new FileReader(file)); // TODO charset?

            String line;
            final StringBuilder sb = new StringBuilder();
            boolean wanted = false; // Skip any leading rubbish
            while((line=br.readLine())!=null) {
                if (line.startsWith(""From "")) { // start of message; i.e. end of previous (if any)
                    if (process(sb, imap, folder, total)) { // process previous message (if any)
                        loaded++;
                    }
                    sb.setLength(0);
                    total ++;
                    wanted = wanted(total, line, msgNums, contains);
                } else if (startsWith(line, PATFROM)) { // Unescape "">+From "" in body text
                    line = line.substring(1);
                }
                // TODO process first Received: line to determine arrival date?
                if (wanted) {
                    sb.append(line);
                    sb.append(CRLF);
                }
            }
            br.close();
            if (wanted && process(sb, imap, folder, total)) { // last message (if any)
                loaded++;
            }
        } catch (final IOException e) {
            System.out.println(""Error processing msg: "" + total + "" "" + imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
        System.out.println(""Processed "" + total + "" messages, loaded "" + loaded);
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[6];
      stringArray0[0] = ""[#_"";
      // Undeclared exception!
      try { 
        IMAPImportMbox.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal character in path at index 0: [#_
         //
         verifyException(""java.net.URI"", e);
      }
  }"
1252,"    public static void main(final String[] args) throws IOException
    {
        if (args.length < 2)
        {
            System.err.println(""Usage: IMAPImportMbox imap[s]://user:password@host[:port]/folder/path <mboxfile> [selectors]"");
            System.err.println(""\tWhere: a selector is a list of numbers/number ranges - 1,2,3-10"" +
                               "" - or a list of strings to match in the initial From line"");
            System.exit(1);
        }

        final URI uri      = URI.create(args[0]);
        final String file  = args[1];

        final File mbox = new File(file);
        if (!mbox.isFile() || !mbox.canRead()) {
            throw new IOException(""Cannot read mailbox file: "" + mbox);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        final List<String> contains = new ArrayList<>(); // list of strings to find
        final BitSet msgNums = new BitSet(); // list of message numbers

        for(int i = 2; i < args.length; i++) {
            final String arg = args[i];
            if (arg.matches(""\\d+(-\\d+)?(,\\d+(-\\d+)?)*"")) { // number,m-n
                for(final String entry : arg.split("","")) {
                    final String []parts = entry.split(""-"");
                    if (parts.length == 2) { // m-n
                        final int low = Integer.parseInt(parts[0]);
                        final int high = Integer.parseInt(parts[1]);
                        for(int j=low; j <= high; j++) {
                            msgNums.set(j);
                        }
                    } else {
                        msgNums.set(Integer.parseInt(entry));
                    }
                }
            } else {
                contains.add(arg); // not a number/number range
            }
        }
//        System.out.println(msgNums.toString());
//        System.out.println(java.util.Arrays.toString(contains.toArray()));

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        int total = 0;
        int loaded = 0;
        try {
            imap.setSoTimeout(6000);

            final BufferedReader br = new BufferedReader(new FileReader(file)); // TODO charset?

            String line;
            final StringBuilder sb = new StringBuilder();
            boolean wanted = false; // Skip any leading rubbish
            while((line=br.readLine())!=null) {
                if (line.startsWith(""From "")) { // start of message; i.e. end of previous (if any)
                    if (process(sb, imap, folder, total)) { // process previous message (if any)
                        loaded++;
                    }
                    sb.setLength(0);
                    total ++;
                    wanted = wanted(total, line, msgNums, contains);
                } else if (startsWith(line, PATFROM)) { // Unescape "">+From "" in body text
                    line = line.substring(1);
                }
                // TODO process first Received: line to determine arrival date?
                if (wanted) {
                    sb.append(line);
                    sb.append(CRLF);
                }
            }
            br.close();
            if (wanted && process(sb, imap, folder, total)) { // last message (if any)
                loaded++;
            }
        } catch (final IOException e) {
            System.out.println(""Error processing msg: "" + total + "" "" + imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
        System.out.println(""Processed "" + total + "" messages, loaded "" + loaded);
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[4];
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""0"");
      FileSystemHandling.appendStringToFile(evoSuiteFile0, ""SP\""c@(BlorSnw7}9(K&"");
      stringArray0[0] = ""0"";
      stringArray0[1] = ""0"";
      stringArray0[2] = ""0"";
      stringArray0[3] = """";
      // Undeclared exception!
      try { 
        IMAPImportMbox.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Missing userInfo details
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPUtils"", e);
      }
  }"
1253,"    public static void main(final String[] args) throws IOException
    {
        if (args.length < 2)
        {
            System.err.println(""Usage: IMAPImportMbox imap[s]://user:password@host[:port]/folder/path <mboxfile> [selectors]"");
            System.err.println(""\tWhere: a selector is a list of numbers/number ranges - 1,2,3-10"" +
                               "" - or a list of strings to match in the initial From line"");
            System.exit(1);
        }

        final URI uri      = URI.create(args[0]);
        final String file  = args[1];

        final File mbox = new File(file);
        if (!mbox.isFile() || !mbox.canRead()) {
            throw new IOException(""Cannot read mailbox file: "" + mbox);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        final List<String> contains = new ArrayList<>(); // list of strings to find
        final BitSet msgNums = new BitSet(); // list of message numbers

        for(int i = 2; i < args.length; i++) {
            final String arg = args[i];
            if (arg.matches(""\\d+(-\\d+)?(,\\d+(-\\d+)?)*"")) { // number,m-n
                for(final String entry : arg.split("","")) {
                    final String []parts = entry.split(""-"");
                    if (parts.length == 2) { // m-n
                        final int low = Integer.parseInt(parts[0]);
                        final int high = Integer.parseInt(parts[1]);
                        for(int j=low; j <= high; j++) {
                            msgNums.set(j);
                        }
                    } else {
                        msgNums.set(Integer.parseInt(entry));
                    }
                }
            } else {
                contains.add(arg); // not a number/number range
            }
        }
//        System.out.println(msgNums.toString());
//        System.out.println(java.util.Arrays.toString(contains.toArray()));

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        int total = 0;
        int loaded = 0;
        try {
            imap.setSoTimeout(6000);

            final BufferedReader br = new BufferedReader(new FileReader(file)); // TODO charset?

            String line;
            final StringBuilder sb = new StringBuilder();
            boolean wanted = false; // Skip any leading rubbish
            while((line=br.readLine())!=null) {
                if (line.startsWith(""From "")) { // start of message; i.e. end of previous (if any)
                    if (process(sb, imap, folder, total)) { // process previous message (if any)
                        loaded++;
                    }
                    sb.setLength(0);
                    total ++;
                    wanted = wanted(total, line, msgNums, contains);
                } else if (startsWith(line, PATFROM)) { // Unescape "">+From "" in body text
                    line = line.substring(1);
                }
                // TODO process first Received: line to determine arrival date?
                if (wanted) {
                    sb.append(line);
                    sb.append(CRLF);
                }
            }
            br.close();
            if (wanted && process(sb, imap, folder, total)) { // last message (if any)
                loaded++;
            }
        } catch (final IOException e) {
            System.out.println(""Error processing msg: "" + total + "" "" + imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
        System.out.println(""Processed "" + total + "" messages, loaded "" + loaded);
    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[7];
      stringArray0[0] = """";
      stringArray0[1] = """";
      try { 
        IMAPImportMbox.main(stringArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Cannot read mailbox file: 
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPImportMbox"", e);
      }
  }"
1254,"    public static void main(final String[] args) throws IOException
    {
        if (args.length < 2)
        {
            System.err.println(""Usage: IMAPImportMbox imap[s]://user:password@host[:port]/folder/path <mboxfile> [selectors]"");
            System.err.println(""\tWhere: a selector is a list of numbers/number ranges - 1,2,3-10"" +
                               "" - or a list of strings to match in the initial From line"");
            System.exit(1);
        }

        final URI uri      = URI.create(args[0]);
        final String file  = args[1];

        final File mbox = new File(file);
        if (!mbox.isFile() || !mbox.canRead()) {
            throw new IOException(""Cannot read mailbox file: "" + mbox);
        }

        final String path = uri.getPath();
        if (path == null || path.length() < 1) {
            throw new IllegalArgumentException(""Invalid folderPath: '"" + path + ""'"");
        }
        final String folder = path.substring(1); // skip the leading /

        final List<String> contains = new ArrayList<>(); // list of strings to find
        final BitSet msgNums = new BitSet(); // list of message numbers

        for(int i = 2; i < args.length; i++) {
            final String arg = args[i];
            if (arg.matches(""\\d+(-\\d+)?(,\\d+(-\\d+)?)*"")) { // number,m-n
                for(final String entry : arg.split("","")) {
                    final String []parts = entry.split(""-"");
                    if (parts.length == 2) { // m-n
                        final int low = Integer.parseInt(parts[0]);
                        final int high = Integer.parseInt(parts[1]);
                        for(int j=low; j <= high; j++) {
                            msgNums.set(j);
                        }
                    } else {
                        msgNums.set(Integer.parseInt(entry));
                    }
                }
            } else {
                contains.add(arg); // not a number/number range
            }
        }
//        System.out.println(msgNums.toString());
//        System.out.println(java.util.Arrays.toString(contains.toArray()));

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        int total = 0;
        int loaded = 0;
        try {
            imap.setSoTimeout(6000);

            final BufferedReader br = new BufferedReader(new FileReader(file)); // TODO charset?

            String line;
            final StringBuilder sb = new StringBuilder();
            boolean wanted = false; // Skip any leading rubbish
            while((line=br.readLine())!=null) {
                if (line.startsWith(""From "")) { // start of message; i.e. end of previous (if any)
                    if (process(sb, imap, folder, total)) { // process previous message (if any)
                        loaded++;
                    }
                    sb.setLength(0);
                    total ++;
                    wanted = wanted(total, line, msgNums, contains);
                } else if (startsWith(line, PATFROM)) { // Unescape "">+From "" in body text
                    line = line.substring(1);
                }
                // TODO process first Received: line to determine arrival date?
                if (wanted) {
                    sb.append(line);
                    sb.append(CRLF);
                }
            }
            br.close();
            if (wanted && process(sb, imap, folder, total)) { // last message (if any)
                loaded++;
            }
        } catch (final IOException e) {
            System.out.println(""Error processing msg: "" + total + "" "" + imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
        System.out.println(""Processed "" + total + "" messages, loaded "" + loaded);
    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[1];
      // Undeclared exception!
      try { 
        IMAPImportMbox.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1255,,"  public void test6()  throws Throwable  {
      IMAPImportMbox iMAPImportMbox0 = new IMAPImportMbox();
  }"
1256,"    public static void main(final String[] args)
    {
        final String sender;
        final String recipient;
        final String subject;
        final String fileName;
        final String server;
        String cc;
        final List<String> ccList = new ArrayList<>();
        final BufferedReader stdin;
        FileReader fileReader = null;
        final Writer writer;
        final SimpleSMTPHeader header;
        final SMTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: SMTPMail <smtpserver>"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            sender = stdin.readLine();

            System.out.print(""To: "");
            System.out.flush();

            recipient = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleSMTPHeader(sender, recipient, subject);


            while (true)
            {
                System.out.print(""CC <enter one address per line, hit enter to end>: "");
                System.out.flush();

                cc = stdin.readLine();

                if (cc== null || cc.isEmpty()) {
                    break;
                }

                header.addCC(cc.trim());
                ccList.add(cc.trim());
            }

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
            }

            client = new SMTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!SMTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""SMTP server refused connection."");
                System.exit(1);
            }

            client.login();

            client.setSender(sender);
            client.addRecipient(recipient);



            for (final String recpt : ccList) {
                client.addRecipient(recpt);
            }

            writer = client.sendMessageData();

            if (writer != null)
            {
                writer.write(header.toString());
                Util.copyReader(fileReader, writer);
                writer.close();
                client.completePendingCommand();
            }

            if (fileReader != null ) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[18];
          EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""Fl,p"");
          FileSystemHandling.appendLineToFile(evoSuiteFile0, ""ISO-8859-1"");
          SystemInUtil.addInputLine("""");
          SystemInUtil.addInputLine("""");
          SystemInUtil.addInputLine("""");
          SystemInUtil.addInputLine("""");
          SystemInUtil.addInputLine(""Fl,p"");
          // Undeclared exception!
          try { 
            SMTPMail.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:25\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.mail.SMTPMail.main(SMTPMail.java:123)
             // sun.reflect.GeneratedMethodAccessor24.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1257,"    public static void main(final String[] args)
    {
        final String sender;
        final String recipient;
        final String subject;
        final String fileName;
        final String server;
        String cc;
        final List<String> ccList = new ArrayList<>();
        final BufferedReader stdin;
        FileReader fileReader = null;
        final Writer writer;
        final SimpleSMTPHeader header;
        final SMTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: SMTPMail <smtpserver>"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            sender = stdin.readLine();

            System.out.print(""To: "");
            System.out.flush();

            recipient = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleSMTPHeader(sender, recipient, subject);


            while (true)
            {
                System.out.print(""CC <enter one address per line, hit enter to end>: "");
                System.out.flush();

                cc = stdin.readLine();

                if (cc== null || cc.isEmpty()) {
                    break;
                }

                header.addCC(cc.trim());
                ccList.add(cc.trim());
            }

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
            }

            client = new SMTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!SMTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""SMTP server refused connection."");
                System.exit(1);
            }

            client.login();

            client.setSender(sender);
            client.addRecipient(recipient);



            for (final String recpt : ccList) {
                client.addRecipient(recpt);
            }

            writer = client.sendMessageData();

            if (writer != null)
            {
                writer.write(header.toString());
                Util.copyReader(fileReader, writer);
                writer.close();
                client.completePendingCommand();
            }

            if (fileReader != null ) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[18];
          SystemInUtil.addInputLine("""");
          SystemInUtil.addInputLine("""");
          SystemInUtil.addInputLine("""");
          SystemInUtil.addInputLine("""");
          SystemInUtil.addInputLine(""Fl,p"");
          // Undeclared exception!
          try { 
            SMTPMail.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:25\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.mail.SMTPMail.main(SMTPMail.java:123)
             // sun.reflect.GeneratedMethodAccessor24.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1258,"    public static void main(final String[] args)
    {
        final String sender;
        final String recipient;
        final String subject;
        final String fileName;
        final String server;
        String cc;
        final List<String> ccList = new ArrayList<>();
        final BufferedReader stdin;
        FileReader fileReader = null;
        final Writer writer;
        final SimpleSMTPHeader header;
        final SMTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: SMTPMail <smtpserver>"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            sender = stdin.readLine();

            System.out.print(""To: "");
            System.out.flush();

            recipient = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleSMTPHeader(sender, recipient, subject);


            while (true)
            {
                System.out.print(""CC <enter one address per line, hit enter to end>: "");
                System.out.flush();

                cc = stdin.readLine();

                if (cc== null || cc.isEmpty()) {
                    break;
                }

                header.addCC(cc.trim());
                ccList.add(cc.trim());
            }

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
            }

            client = new SMTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!SMTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""SMTP server refused connection."");
                System.exit(1);
            }

            client.login();

            client.setSender(sender);
            client.addRecipient(recipient);



            for (final String recpt : ccList) {
                client.addRecipient(recpt);
            }

            writer = client.sendMessageData();

            if (writer != null)
            {
                writer.write(header.toString());
                Util.copyReader(fileReader, writer);
                writer.close();
                client.completePendingCommand();
            }

            if (fileReader != null ) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        SMTPMail.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.mail.SMTPMail"", e);
      }
  }"
1259,"    public static void main(final String[] args)
    {
        final String sender;
        final String recipient;
        final String subject;
        final String fileName;
        final String server;
        String cc;
        final List<String> ccList = new ArrayList<>();
        final BufferedReader stdin;
        FileReader fileReader = null;
        final Writer writer;
        final SimpleSMTPHeader header;
        final SMTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: SMTPMail <smtpserver>"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            sender = stdin.readLine();

            System.out.print(""To: "");
            System.out.flush();

            recipient = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleSMTPHeader(sender, recipient, subject);


            while (true)
            {
                System.out.print(""CC <enter one address per line, hit enter to end>: "");
                System.out.flush();

                cc = stdin.readLine();

                if (cc== null || cc.isEmpty()) {
                    break;
                }

                header.addCC(cc.trim());
                ccList.add(cc.trim());
            }

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
            }

            client = new SMTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!SMTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""SMTP server refused connection."");
                System.exit(1);
            }

            client.login();

            client.setSender(sender);
            client.addRecipient(recipient);



            for (final String recpt : ccList) {
                client.addRecipient(recpt);
            }

            writer = client.sendMessageData();

            if (writer != null)
            {
                writer.write(header.toString());
                Util.copyReader(fileReader, writer);
                writer.close();
                client.completePendingCommand();
            }

            if (fileReader != null ) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[4];
      SystemInUtil.addInputLine("""");
      SystemInUtil.addInputLine("""");
      SystemInUtil.addInputLine("""");
      SystemInUtil.addInputLine("""");
      // Undeclared exception!
      try { 
        SMTPMail.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1260,"    public static void main(final String[] args)
    {
        final String sender;
        final String recipient;
        final String subject;
        final String fileName;
        final String server;
        String cc;
        final List<String> ccList = new ArrayList<>();
        final BufferedReader stdin;
        FileReader fileReader = null;
        final Writer writer;
        final SimpleSMTPHeader header;
        final SMTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: SMTPMail <smtpserver>"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            sender = stdin.readLine();

            System.out.print(""To: "");
            System.out.flush();

            recipient = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleSMTPHeader(sender, recipient, subject);


            while (true)
            {
                System.out.print(""CC <enter one address per line, hit enter to end>: "");
                System.out.flush();

                cc = stdin.readLine();

                if (cc== null || cc.isEmpty()) {
                    break;
                }

                header.addCC(cc.trim());
                ccList.add(cc.trim());
            }

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
            }

            client = new SMTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!SMTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""SMTP server refused connection."");
                System.exit(1);
            }

            client.login();

            client.setSender(sender);
            client.addRecipient(recipient);



            for (final String recpt : ccList) {
                client.addRecipient(recpt);
            }

            writer = client.sendMessageData();

            if (writer != null)
            {
                writer.write(header.toString());
                Util.copyReader(fileReader, writer);
                writer.close();
                client.completePendingCommand();
            }

            if (fileReader != null ) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[4];
      SystemInUtil.addInputLine("""");
      SystemInUtil.addInputLine("""");
      SystemInUtil.addInputLine("""");
      SystemInUtil.addInputLine(""org.apache.commons.net.MalformedServerReplyException"");
      // Undeclared exception!
      try { 
        SMTPMail.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1261,"    public static void main(final String[] args)
    {
        final String sender;
        final String recipient;
        final String subject;
        final String fileName;
        final String server;
        String cc;
        final List<String> ccList = new ArrayList<>();
        final BufferedReader stdin;
        FileReader fileReader = null;
        final Writer writer;
        final SimpleSMTPHeader header;
        final SMTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: SMTPMail <smtpserver>"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            sender = stdin.readLine();

            System.out.print(""To: "");
            System.out.flush();

            recipient = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleSMTPHeader(sender, recipient, subject);


            while (true)
            {
                System.out.print(""CC <enter one address per line, hit enter to end>: "");
                System.out.flush();

                cc = stdin.readLine();

                if (cc== null || cc.isEmpty()) {
                    break;
                }

                header.addCC(cc.trim());
                ccList.add(cc.trim());
            }

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
            }

            client = new SMTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!SMTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""SMTP server refused connection."");
                System.exit(1);
            }

            client.login();

            client.setSender(sender);
            client.addRecipient(recipient);



            for (final String recpt : ccList) {
                client.addRecipient(recpt);
            }

            writer = client.sendMessageData();

            if (writer != null)
            {
                writer.write(header.toString());
                Util.copyReader(fileReader, writer);
                writer.close();
                client.completePendingCommand();
            }

            if (fileReader != null ) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        SMTPMail.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1262,,"  public void test6()  throws Throwable  {
      SMTPMail sMTPMail0 = new SMTPMail();
  }"
1263,"    static String getPassword(final String username, String password) throws IOException {
        if (""-"".equals(password)) { // stdin
            final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            password = in.readLine();
        } else if (""*"".equals(password)) { // console
            final Console con = System.console(); // Java 1.6
            if (con != null) {
                final char[] pwd = con.readPassword(""Password for "" + username + "": "");
                password = new String(pwd);
            } else {
                throw new IOException(""Cannot access Console"");
            }
        } else if (password.equals(password.toUpperCase(Locale.ROOT))) { // environment variable name
            final String tmp = System.getenv(password);
            if (tmp != null) { // don't overwrite if variable does not exist (just in case password is all uppers)
                password=tmp;
            }
        }
        return password;
    }","  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        Utils.getPassword("""", (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.mail.Utils"", e);
      }
  }"
1264,"    static String getPassword(final String username, String password) throws IOException {
        if (""-"".equals(password)) { // stdin
            final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            password = in.readLine();
        } else if (""*"".equals(password)) { // console
            final Console con = System.console(); // Java 1.6
            if (con != null) {
                final char[] pwd = con.readPassword(""Password for "" + username + "": "");
                password = new String(pwd);
            } else {
                throw new IOException(""Cannot access Console"");
            }
        } else if (password.equals(password.toUpperCase(Locale.ROOT))) { // environment variable name
            final String tmp = System.getenv(password);
            if (tmp != null) { // don't overwrite if variable does not exist (just in case password is all uppers)
                password=tmp;
            }
        }
        return password;
    }","  public void test1()  throws Throwable  {
      String string0 = Utils.getPassword(""_"", ""_"");
}"
1265,"    static String getPassword(final String username, String password) throws IOException {
        if (""-"".equals(password)) { // stdin
            final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            password = in.readLine();
        } else if (""*"".equals(password)) { // console
            final Console con = System.console(); // Java 1.6
            if (con != null) {
                final char[] pwd = con.readPassword(""Password for "" + username + "": "");
                password = new String(pwd);
            } else {
                throw new IOException(""Cannot access Console"");
            }
        } else if (password.equals(password.toUpperCase(Locale.ROOT))) { // environment variable name
            final String tmp = System.getenv(password);
            if (tmp != null) { // don't overwrite if variable does not exist (just in case password is all uppers)
                password=tmp;
            }
        }
        return password;
    }","  public void test2()  throws Throwable  {
      String string0 = Utils.getPassword(""_"", ""_"");
}"
1266,"    static String getPassword(final String username, String password) throws IOException {
        if (""-"".equals(password)) { // stdin
            final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            password = in.readLine();
        } else if (""*"".equals(password)) { // console
            final Console con = System.console(); // Java 1.6
            if (con != null) {
                final char[] pwd = con.readPassword(""Password for "" + username + "": "");
                password = new String(pwd);
            } else {
                throw new IOException(""Cannot access Console"");
            }
        } else if (password.equals(password.toUpperCase(Locale.ROOT))) { // environment variable name
            final String tmp = System.getenv(password);
            if (tmp != null) { // don't overwrite if variable does not exist (just in case password is all uppers)
                password=tmp;
            }
        }
        return password;
    }","  public void test3()  throws Throwable  {
      String string0 = Utils.getPassword("""", ""Password for "");
}"
1267,"    static String getPassword(final String username, String password) throws IOException {
        if (""-"".equals(password)) { // stdin
            final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            password = in.readLine();
        } else if (""*"".equals(password)) { // console
            final Console con = System.console(); // Java 1.6
            if (con != null) {
                final char[] pwd = con.readPassword(""Password for "" + username + "": "");
                password = new String(pwd);
            } else {
                throw new IOException(""Cannot access Console"");
            }
        } else if (password.equals(password.toUpperCase(Locale.ROOT))) { // environment variable name
            final String tmp = System.getenv(password);
            if (tmp != null) { // don't overwrite if variable does not exist (just in case password is all uppers)
                password=tmp;
            }
        }
        return password;
    }","  public void test4()  throws Throwable  {
      String string0 = Utils.getPassword("""", ""Password for "");
}"
1268,"    static String getPassword(final String username, String password) throws IOException {
        if (""-"".equals(password)) { // stdin
            final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            password = in.readLine();
        } else if (""*"".equals(password)) { // console
            final Console con = System.console(); // Java 1.6
            if (con != null) {
                final char[] pwd = con.readPassword(""Password for "" + username + "": "");
                password = new String(pwd);
            } else {
                throw new IOException(""Cannot access Console"");
            }
        } else if (password.equals(password.toUpperCase(Locale.ROOT))) { // environment variable name
            final String tmp = System.getenv(password);
            if (tmp != null) { // don't overwrite if variable does not exist (just in case password is all uppers)
                password=tmp;
            }
        }
        return password;
    }","  public void test5()  throws Throwable  {
      try { 
        Utils.getPassword("""", ""*"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Cannot access Console
         //
         verifyException(""org.apache.commons.net.examples.mail.Utils"", e);
      }
  }"
1269,"    static String getPassword(final String username, String password) throws IOException {
        if (""-"".equals(password)) { // stdin
            final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            password = in.readLine();
        } else if (""*"".equals(password)) { // console
            final Console con = System.console(); // Java 1.6
            if (con != null) {
                final char[] pwd = con.readPassword(""Password for "" + username + "": "");
                password = new String(pwd);
            } else {
                throw new IOException(""Cannot access Console"");
            }
        } else if (password.equals(password.toUpperCase(Locale.ROOT))) { // environment variable name
            final String tmp = System.getenv(password);
            if (tmp != null) { // don't overwrite if variable does not exist (just in case password is all uppers)
                password=tmp;
            }
        }
        return password;
    }","  public void test6()  throws Throwable  {
      String string0 = Utils.getPassword((String) null, ""-"");
}"
1270,"    static String getPassword(final String username, String password) throws IOException {
        if (""-"".equals(password)) { // stdin
            final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            password = in.readLine();
        } else if (""*"".equals(password)) { // console
            final Console con = System.console(); // Java 1.6
            if (con != null) {
                final char[] pwd = con.readPassword(""Password for "" + username + "": "");
                password = new String(pwd);
            } else {
                throw new IOException(""Cannot access Console"");
            }
        } else if (password.equals(password.toUpperCase(Locale.ROOT))) { // environment variable name
            final String tmp = System.getenv(password);
            if (tmp != null) { // don't overwrite if variable does not exist (just in case password is all uppers)
                password=tmp;
            }
        }
        return password;
    }","  public void test7()  throws Throwable  {
      String string0 = Utils.getPassword(""d%0tqlXK"", """");
}"
1271,"    static String getPassword(final String username, String password) throws IOException {
        if (""-"".equals(password)) { // stdin
            final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            password = in.readLine();
        } else if (""*"".equals(password)) { // console
            final Console con = System.console(); // Java 1.6
            if (con != null) {
                final char[] pwd = con.readPassword(""Password for "" + username + "": "");
                password = new String(pwd);
            } else {
                throw new IOException(""Cannot access Console"");
            }
        } else if (password.equals(password.toUpperCase(Locale.ROOT))) { // environment variable name
            final String tmp = System.getenv(password);
            if (tmp != null) { // don't overwrite if variable does not exist (just in case password is all uppers)
                password=tmp;
            }
        }
        return password;
    }","  public void test8()  throws Throwable  {
      String string0 = Utils.getPassword(""d%0tqlXK"", """");
}"
1272,"    public static void main(final String[] args)
    {
        int argIdx;
        String file = null;
        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-F"")) {
                file = args[++argIdx];
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;
        if (argCount < 3)
        {
            System.err.println(
                ""Usage: POP3Mail [-F file/directory] <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[argIdx++].split("":"");
        final String server=arg0[0];
        final String username = args[argIdx++];
        String password = args[argIdx++];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = argCount > 3 ? args[argIdx++] : null;
        final boolean implicit = argCount > 4 ? Boolean.parseBoolean(args[argIdx++]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);
            final int count = status.number;
            if (file != null) {
                System.out.println(""Getting messages: "" + count);
                final File mbox = new File(file);
                if (mbox.isDirectory()) {
                    System.out.println(""Writing dir: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    for (int i = 1; i <= count; i++) {
                        try (final OutputStreamWriter fw = new OutputStreamWriter(
                                new FileOutputStream(new File(mbox, i + "".eml"")), StandardCharsets.ISO_8859_1)) {
                            writeFile(pop3, fw, i);
                        }
                    }
                } else {
                    System.out.println(""Writing file: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    try (final OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(mbox),
                            StandardCharsets.ISO_8859_1)) {
                        for (int i = 1; i <= count; i++) {
                            writeMbox(pop3, fw, i);
                        }
                    }
                }
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""J}!&gUc:ksGtrM"";
      stringArray0[1] = ""60h86i|?Cp!S:n'`V%i"";
      // Undeclared exception!
      try { 
        POP3ExportMbox.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.mail.Utils"", e);
      }
  }"
1273,"    public static void main(final String[] args)
    {
        int argIdx;
        String file = null;
        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-F"")) {
                file = args[++argIdx];
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;
        if (argCount < 3)
        {
            System.err.println(
                ""Usage: POP3Mail [-F file/directory] <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[argIdx++].split("":"");
        final String server=arg0[0];
        final String username = args[argIdx++];
        String password = args[argIdx++];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = argCount > 3 ? args[argIdx++] : null;
        final boolean implicit = argCount > 4 ? Boolean.parseBoolean(args[argIdx++]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);
            final int count = status.number;
            if (file != null) {
                System.out.println(""Getting messages: "" + count);
                final File mbox = new File(file);
                if (mbox.isDirectory()) {
                    System.out.println(""Writing dir: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    for (int i = 1; i <= count; i++) {
                        try (final OutputStreamWriter fw = new OutputStreamWriter(
                                new FileOutputStream(new File(mbox, i + "".eml"")), StandardCharsets.ISO_8859_1)) {
                            writeFile(pop3, fw, i);
                        }
                    }
                } else {
                    System.out.println(""Writing file: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    try (final OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(mbox),
                            StandardCharsets.ISO_8859_1)) {
                        for (int i = 1; i <= count; i++) {
                            writeMbox(pop3, fw, i);
                        }
                    }
                }
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[5];
      stringArray0[0] = ""K6KNOwsz]w!E@"";
      stringArray0[2] = ""*"";
      POP3ExportMbox.main(stringArray0);
}"
1274,"    public static void main(final String[] args)
    {
        int argIdx;
        String file = null;
        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-F"")) {
                file = args[++argIdx];
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;
        if (argCount < 3)
        {
            System.err.println(
                ""Usage: POP3Mail [-F file/directory] <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[argIdx++].split("":"");
        final String server=arg0[0];
        final String username = args[argIdx++];
        String password = args[argIdx++];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = argCount > 3 ? args[argIdx++] : null;
        final boolean implicit = argCount > 4 ? Boolean.parseBoolean(args[argIdx++]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);
            final int count = status.number;
            if (file != null) {
                System.out.println(""Getting messages: "" + count);
                final File mbox = new File(file);
                if (mbox.isDirectory()) {
                    System.out.println(""Writing dir: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    for (int i = 1; i <= count; i++) {
                        try (final OutputStreamWriter fw = new OutputStreamWriter(
                                new FileOutputStream(new File(mbox, i + "".eml"")), StandardCharsets.ISO_8859_1)) {
                            writeFile(pop3, fw, i);
                        }
                    }
                } else {
                    System.out.println(""Writing file: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    try (final OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(mbox),
                            StandardCharsets.ISO_8859_1)) {
                        for (int i = 1; i <= count; i++) {
                            writeMbox(pop3, fw, i);
                        }
                    }
                }
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = ""-F"";
      // Undeclared exception!
      try { 
        POP3ExportMbox.main(stringArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.examples.mail.POP3ExportMbox"", e);
      }
  }"
1275,"    public static void main(final String[] args)
    {
        int argIdx;
        String file = null;
        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-F"")) {
                file = args[++argIdx];
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;
        if (argCount < 3)
        {
            System.err.println(
                ""Usage: POP3Mail [-F file/directory] <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[argIdx++].split("":"");
        final String server=arg0[0];
        final String username = args[argIdx++];
        String password = args[argIdx++];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = argCount > 3 ? args[argIdx++] : null;
        final boolean implicit = argCount > 4 ? Boolean.parseBoolean(args[argIdx++]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);
            final int count = status.number;
            if (file != null) {
                System.out.println(""Getting messages: "" + count);
                final File mbox = new File(file);
                if (mbox.isDirectory()) {
                    System.out.println(""Writing dir: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    for (int i = 1; i <= count; i++) {
                        try (final OutputStreamWriter fw = new OutputStreamWriter(
                                new FileOutputStream(new File(mbox, i + "".eml"")), StandardCharsets.ISO_8859_1)) {
                            writeFile(pop3, fw, i);
                        }
                    }
                } else {
                    System.out.println(""Writing file: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    try (final OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(mbox),
                            StandardCharsets.ISO_8859_1)) {
                        for (int i = 1; i <= count; i++) {
                            writeMbox(pop3, fw, i);
                        }
                    }
                }
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test3()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[5];
          stringArray0[0] = ""-G"";
          stringArray0[2] = ""-G"";
          // Undeclared exception!
          try { 
            POP3ExportMbox.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:110\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.mail.POP3ExportMbox.main(POP3ExportMbox.java:109)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1276,"    public static void main(final String[] args)
    {
        int argIdx;
        String file = null;
        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-F"")) {
                file = args[++argIdx];
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;
        if (argCount < 3)
        {
            System.err.println(
                ""Usage: POP3Mail [-F file/directory] <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[argIdx++].split("":"");
        final String server=arg0[0];
        final String username = args[argIdx++];
        String password = args[argIdx++];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = argCount > 3 ? args[argIdx++] : null;
        final boolean implicit = argCount > 4 ? Boolean.parseBoolean(args[argIdx++]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);
            final int count = status.number;
            if (file != null) {
                System.out.println(""Getting messages: "" + count);
                final File mbox = new File(file);
                if (mbox.isDirectory()) {
                    System.out.println(""Writing dir: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    for (int i = 1; i <= count; i++) {
                        try (final OutputStreamWriter fw = new OutputStreamWriter(
                                new FileOutputStream(new File(mbox, i + "".eml"")), StandardCharsets.ISO_8859_1)) {
                            writeFile(pop3, fw, i);
                        }
                    }
                } else {
                    System.out.println(""Writing file: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    try (final OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(mbox),
                            StandardCharsets.ISO_8859_1)) {
                        for (int i = 1; i <= count; i++) {
                            writeMbox(pop3, fw, i);
                        }
                    }
                }
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[8];
      stringArray0[0] = ""O:'1Y/'w\""/e$"";
      stringArray0[2] = ""org.apache.commons.net.examples.mail.POP3ExportMbox"";
      stringArray0[3] = ""]J"";
      // Undeclared exception!
      try { 
        POP3ExportMbox.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // For input string: \""'1Y/'w\""/e$\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
1277,"    public static void main(final String[] args)
    {
        int argIdx;
        String file = null;
        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-F"")) {
                file = args[++argIdx];
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;
        if (argCount < 3)
        {
            System.err.println(
                ""Usage: POP3Mail [-F file/directory] <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[argIdx++].split("":"");
        final String server=arg0[0];
        final String username = args[argIdx++];
        String password = args[argIdx++];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = argCount > 3 ? args[argIdx++] : null;
        final boolean implicit = argCount > 4 ? Boolean.parseBoolean(args[argIdx++]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);
            final int count = status.number;
            if (file != null) {
                System.out.println(""Getting messages: "" + count);
                final File mbox = new File(file);
                if (mbox.isDirectory()) {
                    System.out.println(""Writing dir: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    for (int i = 1; i <= count; i++) {
                        try (final OutputStreamWriter fw = new OutputStreamWriter(
                                new FileOutputStream(new File(mbox, i + "".eml"")), StandardCharsets.ISO_8859_1)) {
                            writeFile(pop3, fw, i);
                        }
                    }
                } else {
                    System.out.println(""Writing file: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    try (final OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(mbox),
                            StandardCharsets.ISO_8859_1)) {
                        for (int i = 1; i <= count; i++) {
                            writeMbox(pop3, fw, i);
                        }
                    }
                }
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test5()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[5];
          stringArray0[0] = ""-F"";
          stringArray0[2] = ""Rxsy~:894"";
          stringArray0[4] = ""Rxsy~:894"";
          // Undeclared exception!
          try { 
            POP3ExportMbox.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:110\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.mail.POP3ExportMbox.main(POP3ExportMbox.java:109)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1278,"    public static void main(final String[] args)
    {
        int argIdx;
        String file = null;
        for(argIdx = 0; argIdx < args.length; argIdx++) {
            if (args[argIdx].equals(""-F"")) {
                file = args[++argIdx];
            } else {
                break;
            }
        }

        final int argCount = args.length - argIdx;
        if (argCount < 3)
        {
            System.err.println(
                ""Usage: POP3Mail [-F file/directory] <server[:port]> <username> <password|-|*|VARNAME> [TLS [true=implicit]]"");
            System.exit(1);
        }

        final String arg0[] = args[argIdx++].split("":"");
        final String server=arg0[0];
        final String username = args[argIdx++];
        String password = args[argIdx++];
        // prompt for the password if necessary
        try {
            password = Utils.getPassword(username, password);
        } catch (final IOException e1) {
            System.err.println(""Could not retrieve password: "" + e1.getMessage());
            return;
        }

        final String proto = argCount > 3 ? args[argIdx++] : null;
        final boolean implicit = argCount > 4 ? Boolean.parseBoolean(args[argIdx++]) : false;

        final POP3Client pop3;

        if (proto != null) {
            System.out.println(""Using secure protocol: ""+proto);
            pop3 = new POP3SClient(proto, implicit);
        } else {
            pop3 = new POP3Client();
        }

        final int port;
        if (arg0.length == 2) {
            port = Integer.parseInt(arg0[1]);
        } else {
            port = pop3.getDefaultPort();
        }
        System.out.println(""Connecting to server ""+server+"" on ""+port);

        // We want to timeout if a response takes longer than 60 seconds
        pop3.setDefaultTimeout(60000);

        try
        {
            pop3.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            return;
        }

        try
        {
            if (!pop3.login(username, password))
            {
                System.err.println(""Could not login to server.  Check password."");
                pop3.disconnect();
                return;
            }

            final POP3MessageInfo status = pop3.status();
            if (status == null) {
                System.err.println(""Could not retrieve status."");
                pop3.logout();
                pop3.disconnect();
                return;
            }

            System.out.println(""Status: "" + status);
            final int count = status.number;
            if (file != null) {
                System.out.println(""Getting messages: "" + count);
                final File mbox = new File(file);
                if (mbox.isDirectory()) {
                    System.out.println(""Writing dir: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    for (int i = 1; i <= count; i++) {
                        try (final OutputStreamWriter fw = new OutputStreamWriter(
                                new FileOutputStream(new File(mbox, i + "".eml"")), StandardCharsets.ISO_8859_1)) {
                            writeFile(pop3, fw, i);
                        }
                    }
                } else {
                    System.out.println(""Writing file: "" + mbox);
                    // Currently POP3Client uses iso-8859-1
                    try (final OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(mbox),
                            StandardCharsets.ISO_8859_1)) {
                        for (int i = 1; i <= count; i++) {
                            writeMbox(pop3, fw, i);
                        }
                    }
                }
            }

            pop3.logout();
            pop3.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            return;
        }
    }","  public void test6()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        POP3ExportMbox.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1279,,"  public void test7()  throws Throwable  {
      POP3ExportMbox pOP3ExportMbox0 = new POP3ExportMbox();
  }"
1280,"    public static void main(final String[] args) throws IOException {
        if (args.length != 1)
        {
            System.err.println(
                ""Usage: IMAPMail imap[s]://username:password@server/"");
            System.err.println(""Connects to server; lists capabilities and shows Inbox status"");
            System.exit(1);
        }

        final URI uri = URI.create(args[0]);

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        // suppress login details
        imap.addProtocolCommandListener(new PrintCommandListener(System.out, true));

        try {
            imap.setSoTimeout(6000);

            imap.capability();

            imap.select(""inbox"");

            imap.examine(""inbox"");

            imap.status(""inbox"", new String[]{""MESSAGES""});

            imap.list("""", ""*""); // Show the folders

        } catch (final IOException e) {
            System.out.println(imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = ""Q:NMD$U`"";
      // Undeclared exception!
      try { 
        IMAPMail.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal character in opaque part at index 7: Q:NMD$U`
         //
         verifyException(""java.net.URI"", e);
      }
  }"
1281,"    public static void main(final String[] args) throws IOException {
        if (args.length != 1)
        {
            System.err.println(
                ""Usage: IMAPMail imap[s]://username:password@server/"");
            System.err.println(""Connects to server; lists capabilities and shows Inbox status"");
            System.exit(1);
        }

        final URI uri = URI.create(args[0]);

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        // suppress login details
        imap.addProtocolCommandListener(new PrintCommandListener(System.out, true));

        try {
            imap.setSoTimeout(6000);

            imap.capability();

            imap.select(""inbox"");

            imap.examine(""inbox"");

            imap.status(""inbox"", new String[]{""MESSAGES""});

            imap.list("""", ""*""); // Show the folders

        } catch (final IOException e) {
            System.out.println(imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = ""Uy8C"";
      // Undeclared exception!
      try { 
        IMAPMail.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Missing userInfo details
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPUtils"", e);
      }
  }"
1282,"    public static void main(final String[] args) throws IOException {
        if (args.length != 1)
        {
            System.err.println(
                ""Usage: IMAPMail imap[s]://username:password@server/"");
            System.err.println(""Connects to server; lists capabilities and shows Inbox status"");
            System.exit(1);
        }

        final URI uri = URI.create(args[0]);

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        // suppress login details
        imap.addProtocolCommandListener(new PrintCommandListener(System.out, true));

        try {
            imap.setSoTimeout(6000);

            imap.capability();

            imap.select(""inbox"");

            imap.examine(""inbox"");

            imap.status(""inbox"", new String[]{""MESSAGES""});

            imap.list("""", ""*""); // Show the folders

        } catch (final IOException e) {
            System.out.println(imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[9];
      // Undeclared exception!
      try { 
        IMAPMail.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1283,"    public static void main(final String[] args) throws IOException {
        if (args.length != 1)
        {
            System.err.println(
                ""Usage: IMAPMail imap[s]://username:password@server/"");
            System.err.println(""Connects to server; lists capabilities and shows Inbox status"");
            System.exit(1);
        }

        final URI uri = URI.create(args[0]);

        // Connect and login
        final IMAPClient imap = IMAPUtils.imapLogin(uri, 10000, null);

        // suppress login details
        imap.addProtocolCommandListener(new PrintCommandListener(System.out, true));

        try {
            imap.setSoTimeout(6000);

            imap.capability();

            imap.select(""inbox"");

            imap.examine(""inbox"");

            imap.status(""inbox"", new String[]{""MESSAGES""});

            imap.list("""", ""*""); // Show the folders

        } catch (final IOException e) {
            System.out.println(imap.getReplyString());
            e.printStackTrace();
            System.exit(10);
            return;
        } finally {
            imap.logout();
            imap.disconnect();
        }
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[1];
      // Undeclared exception!
      try { 
        IMAPMail.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.net.URI$Parser"", e);
      }
  }"
1284,,"  public void test4()  throws Throwable  {
      IMAPMail iMAPMail0 = new IMAPMail();
  }"
1285,"    static IMAPClient imapLogin(final URI uri, final int defaultTimeout, final ProtocolCommandListener listener)
            throws IOException {
        final String userInfo = uri.getUserInfo();
        if (userInfo == null) {
            throw new IllegalArgumentException(""Missing userInfo details"");
        }

        final String []userpass = userInfo.split("":"");
        if (userpass.length != 2) {
            throw new IllegalArgumentException(""Invalid userInfo details: '"" + userInfo + ""'"");
        }

        final String username = userpass[0];
        String password = userpass[1];
        // prompt for the password if necessary
        password = Utils.getPassword(username, password);

        final IMAPClient imap;

        final String scheme = uri.getScheme();
        if (""imaps"".equalsIgnoreCase(scheme)) {
            System.out.println(""Using secure protocol"");
            imap = new IMAPSClient(true); // implicit
        } else if (""imap"".equalsIgnoreCase(scheme)) {
            imap = new IMAPClient();
        } else {
            throw new IllegalArgumentException(""Invalid protocol: "" + scheme);
        }
        final int port = uri.getPort();
        if (port != -1) {
            imap.setDefaultPort(port);
        }

        imap.setDefaultTimeout(defaultTimeout);

        if (listener != null) {
            imap.addProtocolCommandListener(listener);
        }

        final String server = uri.getHost();
        System.out.println(""Connecting to server "" + server + "" on "" + imap.getDefaultPort());

        try {
            imap.connect(server);
            System.out.println(""Successfully connected"");
        } catch (final IOException e) {
            throw new RuntimeException(""Could not connect to server."", e);
        }

        if (!imap.login(username, password)) {
            imap.disconnect();
            throw new RuntimeException(""Could not login to server. Check login details."");
        }

        return imap;
    }","  public void test0()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""org.apache.commons.io.filefilter.WildcardFileFilter"", ""m"");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintStream0);
      // Undeclared exception!
      try { 
        IMAPUtils.imapLogin((URI) null, (-1), printCommandListener0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockURI"", e);
      }
  }"
1286,"    static IMAPClient imapLogin(final URI uri, final int defaultTimeout, final ProtocolCommandListener listener)
            throws IOException {
        final String userInfo = uri.getUserInfo();
        if (userInfo == null) {
            throw new IllegalArgumentException(""Missing userInfo details"");
        }

        final String []userpass = userInfo.split("":"");
        if (userpass.length != 2) {
            throw new IllegalArgumentException(""Invalid userInfo details: '"" + userInfo + ""'"");
        }

        final String username = userpass[0];
        String password = userpass[1];
        // prompt for the password if necessary
        password = Utils.getPassword(username, password);

        final IMAPClient imap;

        final String scheme = uri.getScheme();
        if (""imaps"".equalsIgnoreCase(scheme)) {
            System.out.println(""Using secure protocol"");
            imap = new IMAPSClient(true); // implicit
        } else if (""imap"".equalsIgnoreCase(scheme)) {
            imap = new IMAPClient();
        } else {
            throw new IllegalArgumentException(""Invalid protocol: "" + scheme);
        }
        final int port = uri.getPort();
        if (port != -1) {
            imap.setDefaultPort(port);
        }

        imap.setDefaultTimeout(defaultTimeout);

        if (listener != null) {
            imap.addProtocolCommandListener(listener);
        }

        final String server = uri.getHost();
        System.out.println(""Connecting to server "" + server + "" on "" + imap.getDefaultPort());

        try {
            imap.connect(server);
            System.out.println(""Successfully connected"");
        } catch (final IOException e) {
            throw new RuntimeException(""Could not connect to server."", e);
        }

        if (!imap.login(username, password)) {
            imap.disconnect();
            throw new RuntimeException(""Could not login to server. Check login details."");
        }

        return imap;
    }","  public void test1()  throws Throwable  {
      URI uRI0 = MockURI.aFileURI;
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(""E>3T;2UzHTGjPM"");
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, false);
      // Undeclared exception!
      try { 
        IMAPUtils.imapLogin(uRI0, 1, printCommandListener0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Missing userInfo details
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPUtils"", e);
      }
  }"
1287,"    static IMAPClient imapLogin(final URI uri, final int defaultTimeout, final ProtocolCommandListener listener)
            throws IOException {
        final String userInfo = uri.getUserInfo();
        if (userInfo == null) {
            throw new IllegalArgumentException(""Missing userInfo details"");
        }

        final String []userpass = userInfo.split("":"");
        if (userpass.length != 2) {
            throw new IllegalArgumentException(""Invalid userInfo details: '"" + userInfo + ""'"");
        }

        final String username = userpass[0];
        String password = userpass[1];
        // prompt for the password if necessary
        password = Utils.getPassword(username, password);

        final IMAPClient imap;

        final String scheme = uri.getScheme();
        if (""imaps"".equalsIgnoreCase(scheme)) {
            System.out.println(""Using secure protocol"");
            imap = new IMAPSClient(true); // implicit
        } else if (""imap"".equalsIgnoreCase(scheme)) {
            imap = new IMAPClient();
        } else {
            throw new IllegalArgumentException(""Invalid protocol: "" + scheme);
        }
        final int port = uri.getPort();
        if (port != -1) {
            imap.setDefaultPort(port);
        }

        imap.setDefaultTimeout(defaultTimeout);

        if (listener != null) {
            imap.addProtocolCommandListener(listener);
        }

        final String server = uri.getHost();
        System.out.println(""Connecting to server "" + server + "" on "" + imap.getDefaultPort());

        try {
            imap.connect(server);
            System.out.println(""Successfully connected"");
        } catch (final IOException e) {
            throw new RuntimeException(""Could not connect to server."", e);
        }

        if (!imap.login(username, password)) {
            imap.disconnect();
            throw new RuntimeException(""Could not login to server. Check login details."");
        }

        return imap;
    }","  public void test2()  throws Throwable  {
      URI uRI0 = MockURI.URI(""APAB3oSLITY"", ""APAB3oSLITY"", ""APAB3oSLITY"", 1912, """", ""APAB3oSLITY"", ""APAB3oSLITY"");
      // Undeclared exception!
      try { 
        IMAPUtils.imapLogin(uRI0, 1912, (ProtocolCommandListener) null);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid userInfo details: 'APAB3oSLITY'
         //
         verifyException(""org.apache.commons.net.examples.mail.IMAPUtils"", e);
      }
  }"
1288,,"  public void test3()  throws Throwable  {
      IMAPUtils iMAPUtils0 = new IMAPUtils();
  }"
1289,"    public static void main(final String[] args) {
        final String subnet = ""192.168.0.3/31"";
        final SubnetUtils utils = new SubnetUtils(subnet);
        final SubnetInfo info = utils.getInfo();

        System.out.printf(""Subnet Information for %s:%n"", subnet);
        System.out.println(""--------------------------------------"");
        System.out.printf(""IP Address:\t\t\t%s\t[%s]%n"", info.getAddress(),
                Integer.toBinaryString(info.asInteger(info.getAddress())));
        System.out.printf(""Netmask:\t\t\t%s\t[%s]%n"", info.getNetmask(),
                Integer.toBinaryString(info.asInteger(info.getNetmask())));
        System.out.printf(""CIDR Representation:\t\t%s%n%n"", info.getCidrSignature());

        System.out.printf(""Supplied IP Address:\t\t%s%n%n"", info.getAddress());

        System.out.printf(""Network Address:\t\t%s\t[%s]%n"", info.getNetworkAddress(),
                Integer.toBinaryString(info.asInteger(info.getNetworkAddress())));
        System.out.printf(""Broadcast Address:\t\t%s\t[%s]%n"", info.getBroadcastAddress(),
                Integer.toBinaryString(info.asInteger(info.getBroadcastAddress())));
        System.out.printf(""Low Address:\t\t\t%s\t[%s]%n"", info.getLowAddress(),
                Integer.toBinaryString(info.asInteger(info.getLowAddress())));
        System.out.printf(""High Address:\t\t\t%s\t[%s]%n"", info.getHighAddress(),
                Integer.toBinaryString(info.asInteger(info.getHighAddress())));

        System.out.printf(""Total usable addresses: \t%d%n"", Long.valueOf(info.getAddressCountLong()));
        System.out.printf(""Address List: %s%n%n"", Arrays.toString(info.getAllAddresses()));

        final String prompt = ""Enter an IP address (e.g. 192.168.0.10):"";
        System.out.println(prompt);
        try (final Scanner scanner = new Scanner(System.in)) {
            while (scanner.hasNextLine()) {
                final String address = scanner.nextLine();
                System.out.println(""The IP address ["" + address + ""] is "" + (info.isInRange(address) ? """" : ""not "")
                        + ""within the subnet ["" + subnet + ""]"");
                System.out.println(prompt);
            }
        }
    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[22];
      SystemInUtil.addInputLine("""");
      // Undeclared exception!
      try { 
        SubnetUtilsExample.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Could not parse []
         //
         verifyException(""org.apache.commons.net.util.SubnetUtils"", e);
      }
  }"
1290,"    public static void main(final String[] args) {
        final String subnet = ""192.168.0.3/31"";
        final SubnetUtils utils = new SubnetUtils(subnet);
        final SubnetInfo info = utils.getInfo();

        System.out.printf(""Subnet Information for %s:%n"", subnet);
        System.out.println(""--------------------------------------"");
        System.out.printf(""IP Address:\t\t\t%s\t[%s]%n"", info.getAddress(),
                Integer.toBinaryString(info.asInteger(info.getAddress())));
        System.out.printf(""Netmask:\t\t\t%s\t[%s]%n"", info.getNetmask(),
                Integer.toBinaryString(info.asInteger(info.getNetmask())));
        System.out.printf(""CIDR Representation:\t\t%s%n%n"", info.getCidrSignature());

        System.out.printf(""Supplied IP Address:\t\t%s%n%n"", info.getAddress());

        System.out.printf(""Network Address:\t\t%s\t[%s]%n"", info.getNetworkAddress(),
                Integer.toBinaryString(info.asInteger(info.getNetworkAddress())));
        System.out.printf(""Broadcast Address:\t\t%s\t[%s]%n"", info.getBroadcastAddress(),
                Integer.toBinaryString(info.asInteger(info.getBroadcastAddress())));
        System.out.printf(""Low Address:\t\t\t%s\t[%s]%n"", info.getLowAddress(),
                Integer.toBinaryString(info.asInteger(info.getLowAddress())));
        System.out.printf(""High Address:\t\t\t%s\t[%s]%n"", info.getHighAddress(),
                Integer.toBinaryString(info.asInteger(info.getHighAddress())));

        System.out.printf(""Total usable addresses: \t%d%n"", Long.valueOf(info.getAddressCountLong()));
        System.out.printf(""Address List: %s%n%n"", Arrays.toString(info.getAllAddresses()));

        final String prompt = ""Enter an IP address (e.g. 192.168.0.10):"";
        System.out.println(prompt);
        try (final Scanner scanner = new Scanner(System.in)) {
            while (scanner.hasNextLine()) {
                final String address = scanner.nextLine();
                System.out.println(""The IP address ["" + address + ""] is "" + (info.isInRange(address) ? """" : ""not "")
                        + ""within the subnet ["" + subnet + ""]"");
                System.out.println(prompt);
            }
        }
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[22];
      SubnetUtilsExample.main(stringArray0);
}"
1291,,"  public void test2()  throws Throwable  {
      SubnetUtilsExample subnetUtilsExample0 = new SubnetUtilsExample();
  }"
1292,"    public static void readWrite(final InputStream remoteInput,
                                       final OutputStream remoteOutput,
                                       final InputStream localInput,
                                       final OutputStream localOutput)
    {
        final Thread reader;
        final Thread writer;

        reader = new Thread()
                 {
                     @Override
                     public void run()
                     {
                         int ch;

                         try
                         {
                             while (!interrupted() && (ch = localInput.read()) != -1)
                             {
                                 remoteOutput.write(ch);
                                 remoteOutput.flush();
                             }
                         }
                         catch (final IOException e)
                         {
                             //e.printStackTrace();
                         }
                     }
                 }
                 ;


        writer = new Thread()
                 {
                     @Override
                     public void run()
                     {
                         try
                         {
                             Util.copyStream(remoteInput, localOutput);
                         }
                         catch (final IOException e)
                         {
                             e.printStackTrace();
                             System.exit(1);
                         }
                     }
                 };


        writer.setPriority(Thread.currentThread().getPriority() + 1);

        writer.start();
        reader.setDaemon(true);
        reader.start();

        try
        {
            writer.join();
            reader.interrupt();
        }
        catch (final InterruptedException e)
        {
            // Ignored
        }
    }","  public void test0()  throws Throwable  {
      Enumeration<SequenceInputStream> enumeration0 = (Enumeration<SequenceInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("" wW;*OYgCB&"", true);
      byte[] byteArray0 = new byte[8];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      IOUtil.readWrite(byteArrayInputStream0, mockFileOutputStream0, sequenceInputStream0, mockFileOutputStream0);
}"
1293,"    public static void readWrite(final InputStream remoteInput,
                                       final OutputStream remoteOutput,
                                       final InputStream localInput,
                                       final OutputStream localOutput)
    {
        final Thread reader;
        final Thread writer;

        reader = new Thread()
                 {
                     @Override
                     public void run()
                     {
                         int ch;

                         try
                         {
                             while (!interrupted() && (ch = localInput.read()) != -1)
                             {
                                 remoteOutput.write(ch);
                                 remoteOutput.flush();
                             }
                         }
                         catch (final IOException e)
                         {
                             //e.printStackTrace();
                         }
                     }
                 }
                 ;


        writer = new Thread()
                 {
                     @Override
                     public void run()
                     {
                         try
                         {
                             Util.copyStream(remoteInput, localOutput);
                         }
                         catch (final IOException e)
                         {
                             e.printStackTrace();
                             System.exit(1);
                         }
                     }
                 };


        writer.setPriority(Thread.currentThread().getPriority() + 1);

        writer.start();
        reader.setDaemon(true);
        reader.start();

        try
        {
            writer.join();
            reader.interrupt();
        }
        catch (final InterruptedException e)
        {
            // Ignored
        }
    }","  public void test1()  throws Throwable  {
      Enumeration<SequenceInputStream> enumeration0 = (Enumeration<SequenceInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("" wW;*OYgCB&"", true);
      IOUtil.readWrite(sequenceInputStream0, mockFileOutputStream0, sequenceInputStream0, (OutputStream) null);
  }"
1294,,"  public void test2()  throws Throwable  {
      IOUtil iOUtil0 = new IOUtil();
  }"
1295,"    public static void main(final String[] args)
    {
        if (args.length == 0) {
            System.err.println(""Usage: NTPClient <hostname-or-address-list>"");
            System.exit(1);
        }

        final NTPUDPClient client = new NTPUDPClient();
        // We want to timeout if a response takes longer than 10 seconds
        client.setDefaultTimeout(10000);
        try {
            client.open();
            for (final String arg : args)
            {
                System.out.println();
                try {
                    final InetAddress hostAddr = InetAddress.getByName(arg);
                    System.out.println(""> "" + hostAddr.getHostName() + ""/"" + hostAddr.getHostAddress());
                    final TimeInfo info = client.getTime(hostAddr);
                    processResponse(info);
                } catch (final IOException ioe) {
                    ioe.printStackTrace();
                }
            }
        } catch (final SocketException e) {
            e.printStackTrace();
        }

        client.close();
    }","  public void test0()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.1"", 123);
      byte[] byteArray0 = new byte[5];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      String[] stringArray0 = new String[2];
      NTPClient.main(stringArray0);
}"
1296,"    public static void processResponse(final TimeInfo info)
    {
        final NtpV3Packet message = info.getMessage();
        final int stratum = message.getStratum();
        final String refType;
        if (stratum <= 0) {
            refType = ""(Unspecified or Unavailable)"";
        } else if (stratum == 1) {
            refType = ""(Primary Reference; e.g., GPS)""; // GPS, radio clock, etc.
        } else {
            refType = ""(Secondary Reference; e.g. via NTP or SNTP)"";
        }
        // stratum should be 0..15...
        System.out.println("" Stratum: "" + stratum + "" "" + refType);
        final int version = message.getVersion();
        final int li = message.getLeapIndicator();
        System.out.println("" leap="" + li + "", version=""
                + version + "", precision="" + message.getPrecision());

        System.out.println("" mode: "" + message.getModeName() + "" ("" + message.getMode() + "")"");
        final int poll = message.getPoll();
        // poll value typically btwn MINPOLL (4) and MAXPOLL (14)
        System.out.println("" poll: "" + (poll <= 0 ? 1 : (int) Math.pow(2, poll))
                + "" seconds"" + "" (2 ** "" + poll + "")"");
        final double disp = message.getRootDispersionInMillisDouble();
        System.out.println("" rootdelay="" + numberFormat.format(message.getRootDelayInMillisDouble())
                + "", rootdispersion(ms): "" + numberFormat.format(disp));

        final int refId = message.getReferenceId();
        String refAddr = NtpUtils.getHostAddress(refId);
        String refName = null;
        if (refId != 0) {
            if (refAddr.equals(""127.127.1.0"")) {
                refName = ""LOCAL""; // This is the ref address for the Local Clock
            } else if (stratum >= 2) {
                // If reference id has 127.127 prefix then it uses its own reference clock
                // defined in the form 127.127.clock-type.unit-num (e.g. 127.127.8.0 mode 5
                // for GENERIC DCF77 AM; see refclock.htm from the NTP software distribution.
                if (!refAddr.startsWith(""127.127"")) {
                    try {
                        final InetAddress addr = InetAddress.getByName(refAddr);
                        final String name = addr.getHostName();
                        if (name != null && !name.equals(refAddr)) {
                            refName = name;
                        }
                    } catch (final UnknownHostException e) {
                        // some stratum-2 servers sync to ref clock device but fudge stratum level higher... (e.g. 2)
                        // ref not valid host maybe it's a reference clock name?
                        // otherwise just show the ref IP address.
                        refName = NtpUtils.getReferenceClock(message);
                    }
                }
            } else if (version >= 3 && (stratum == 0 || stratum == 1)) {
                refName = NtpUtils.getReferenceClock(message);
                // refname usually have at least 3 characters (e.g. GPS, WWV, LCL, etc.)
            }
            // otherwise give up on naming the beast...
        }
        if (refName != null && refName.length() > 1) {
            refAddr += "" ("" + refName + "")"";
        }
        System.out.println("" Reference Identifier:\t"" + refAddr);

        final TimeStamp refNtpTime = message.getReferenceTimeStamp();
        System.out.println("" Reference Timestamp:\t"" + refNtpTime + ""  "" + refNtpTime.toDateString());

        // Originate Time is time request sent by client (t1)
        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
        System.out.println("" Originate Timestamp:\t"" + origNtpTime + ""  "" + origNtpTime.toDateString());

        final long destTimeMillis = info.getReturnTime();
        // Receive Time is time request received by server (t2)
        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
        System.out.println("" Receive Timestamp:\t"" + rcvNtpTime + ""  "" + rcvNtpTime.toDateString());

        // Transmit time is time reply sent by server (t3)
        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
        System.out.println("" Transmit Timestamp:\t"" + xmitNtpTime + ""  "" + xmitNtpTime.toDateString());

        // Destination time is time reply received by client (t4)
        final TimeStamp destNtpTime = TimeStamp.getNtpTime(destTimeMillis);
        System.out.println("" Destination Timestamp:\t"" + destNtpTime + ""  "" + destNtpTime.toDateString());

        info.computeDetails(); // compute offset/delay if not already done
        final Long offsetMillis = info.getOffset();
        final Long delayMillis = info.getDelay();
        final String delay = delayMillis == null ? ""N/A"" : delayMillis.toString();
        final String offset = offsetMillis == null ? ""N/A"" : offsetMillis.toString();

        System.out.println("" Roundtrip delay(ms)="" + delay
                + "", clock offset(ms)="" + offset); // offset in ms
    }","  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        NTPClient.processResponse((TimeInfo) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.ntp.NTPClient"", e);
      }
  }"
1297,"    public static void main(final String[] args)
    {
        if (args.length == 0) {
            System.err.println(""Usage: NTPClient <hostname-or-address-list>"");
            System.exit(1);
        }

        final NTPUDPClient client = new NTPUDPClient();
        // We want to timeout if a response takes longer than 10 seconds
        client.setDefaultTimeout(10000);
        try {
            client.open();
            for (final String arg : args)
            {
                System.out.println();
                try {
                    final InetAddress hostAddr = InetAddress.getByName(arg);
                    System.out.println(""> "" + hostAddr.getHostName() + ""/"" + hostAddr.getHostAddress());
                    final TimeInfo info = client.getTime(hostAddr);
                    processResponse(info);
                } catch (final IOException ioe) {
                    ioe.printStackTrace();
                }
            }
        } catch (final SocketException e) {
            e.printStackTrace();
        }

        client.close();
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        NTPClient.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.ntp.NTPClient"", e);
      }
  }"
1298,"    public static void main(final String[] args)
    {
        if (args.length == 0) {
            System.err.println(""Usage: NTPClient <hostname-or-address-list>"");
            System.exit(1);
        }

        final NTPUDPClient client = new NTPUDPClient();
        // We want to timeout if a response takes longer than 10 seconds
        client.setDefaultTimeout(10000);
        try {
            client.open();
            for (final String arg : args)
            {
                System.out.println();
                try {
                    final InetAddress hostAddr = InetAddress.getByName(arg);
                    System.out.println(""> "" + hostAddr.getHostName() + ""/"" + hostAddr.getHostAddress());
                    final TimeInfo info = client.getTime(hostAddr);
                    processResponse(info);
                } catch (final IOException ioe) {
                    ioe.printStackTrace();
                }
            }
        } catch (final SocketException e) {
            e.printStackTrace();
        }

        client.close();
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        NTPClient.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1299,"    public static void processResponse(final TimeInfo info)
    {
        final NtpV3Packet message = info.getMessage();
        final int stratum = message.getStratum();
        final String refType;
        if (stratum <= 0) {
            refType = ""(Unspecified or Unavailable)"";
        } else if (stratum == 1) {
            refType = ""(Primary Reference; e.g., GPS)""; // GPS, radio clock, etc.
        } else {
            refType = ""(Secondary Reference; e.g. via NTP or SNTP)"";
        }
        // stratum should be 0..15...
        System.out.println("" Stratum: "" + stratum + "" "" + refType);
        final int version = message.getVersion();
        final int li = message.getLeapIndicator();
        System.out.println("" leap="" + li + "", version=""
                + version + "", precision="" + message.getPrecision());

        System.out.println("" mode: "" + message.getModeName() + "" ("" + message.getMode() + "")"");
        final int poll = message.getPoll();
        // poll value typically btwn MINPOLL (4) and MAXPOLL (14)
        System.out.println("" poll: "" + (poll <= 0 ? 1 : (int) Math.pow(2, poll))
                + "" seconds"" + "" (2 ** "" + poll + "")"");
        final double disp = message.getRootDispersionInMillisDouble();
        System.out.println("" rootdelay="" + numberFormat.format(message.getRootDelayInMillisDouble())
                + "", rootdispersion(ms): "" + numberFormat.format(disp));

        final int refId = message.getReferenceId();
        String refAddr = NtpUtils.getHostAddress(refId);
        String refName = null;
        if (refId != 0) {
            if (refAddr.equals(""127.127.1.0"")) {
                refName = ""LOCAL""; // This is the ref address for the Local Clock
            } else if (stratum >= 2) {
                // If reference id has 127.127 prefix then it uses its own reference clock
                // defined in the form 127.127.clock-type.unit-num (e.g. 127.127.8.0 mode 5
                // for GENERIC DCF77 AM; see refclock.htm from the NTP software distribution.
                if (!refAddr.startsWith(""127.127"")) {
                    try {
                        final InetAddress addr = InetAddress.getByName(refAddr);
                        final String name = addr.getHostName();
                        if (name != null && !name.equals(refAddr)) {
                            refName = name;
                        }
                    } catch (final UnknownHostException e) {
                        // some stratum-2 servers sync to ref clock device but fudge stratum level higher... (e.g. 2)
                        // ref not valid host maybe it's a reference clock name?
                        // otherwise just show the ref IP address.
                        refName = NtpUtils.getReferenceClock(message);
                    }
                }
            } else if (version >= 3 && (stratum == 0 || stratum == 1)) {
                refName = NtpUtils.getReferenceClock(message);
                // refname usually have at least 3 characters (e.g. GPS, WWV, LCL, etc.)
            }
            // otherwise give up on naming the beast...
        }
        if (refName != null && refName.length() > 1) {
            refAddr += "" ("" + refName + "")"";
        }
        System.out.println("" Reference Identifier:\t"" + refAddr);

        final TimeStamp refNtpTime = message.getReferenceTimeStamp();
        System.out.println("" Reference Timestamp:\t"" + refNtpTime + ""  "" + refNtpTime.toDateString());

        // Originate Time is time request sent by client (t1)
        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
        System.out.println("" Originate Timestamp:\t"" + origNtpTime + ""  "" + origNtpTime.toDateString());

        final long destTimeMillis = info.getReturnTime();
        // Receive Time is time request received by server (t2)
        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
        System.out.println("" Receive Timestamp:\t"" + rcvNtpTime + ""  "" + rcvNtpTime.toDateString());

        // Transmit time is time reply sent by server (t3)
        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
        System.out.println("" Transmit Timestamp:\t"" + xmitNtpTime + ""  "" + xmitNtpTime.toDateString());

        // Destination time is time reply received by client (t4)
        final TimeStamp destNtpTime = TimeStamp.getNtpTime(destTimeMillis);
        System.out.println("" Destination Timestamp:\t"" + destNtpTime + ""  "" + destNtpTime.toDateString());

        info.computeDetails(); // compute offset/delay if not already done
        final Long offsetMillis = info.getOffset();
        final Long delayMillis = info.getDelay();
        final String delay = delayMillis == null ? ""N/A"" : delayMillis.toString();
        final String offset = offsetMillis == null ? ""N/A"" : offsetMillis.toString();

        System.out.println("" Roundtrip delay(ms)="" + delay
                + "", clock offset(ms)="" + offset); // offset in ms
    }","  public void test4()  throws Throwable  {
      NtpV3Impl ntpV3Impl0 = new NtpV3Impl();
      TimeInfo timeInfo0 = new TimeInfo(ntpV3Impl0, 4294967296L, true);
      NTPClient.processResponse(timeInfo0);
}"
1300,,"  public void test5()  throws Throwable  {
      NTPClient nTPClient0 = new NTPClient();
  }"
1301,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: TimeClient [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        TimeClient.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1302,"    public static void timeUDP(final String host) throws IOException
    {
        final TimeUDPClient client = new TimeUDPClient();

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.open();
        System.out.println(client.getDate(InetAddress.getByName(host)));
        client.close();
    }","  public void test1()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 37);
      byte[] byteArray0 = new byte[9];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      TimeClient.timeUDP(""wgwss"");
  }"
1303,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: TimeClient [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[2];
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 37);
      byte[] byteArray0 = new byte[0];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      stringArray0[0] = ""-udp"";
      TimeClient.main(stringArray0);
}"
1304,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: TimeClient [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test3()  throws Throwable  {
      // Undeclared exception!
      try { 
        TimeClient.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.ntp.TimeClient"", e);
      }
  }"
1305,"    public static void timeTCP(final String host) throws IOException
    {
        final TimeTCPClient client = new TimeTCPClient();
    try {
          // We want to timeout if a response takes longer than 60 seconds
          client.setDefaultTimeout(60000);
      client.connect(host);
          System.out.println(client.getDate());
    } finally {
          client.disconnect();
    }
    }","  public void test4()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          // Undeclared exception!
          try { 
            TimeClient.timeTCP("""");
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:37\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ntp.TimeClient.timeTCP(TimeClient.java:47)
             // sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
             // sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1306,"    public static void timeUDP(final String host) throws IOException
    {
        final TimeUDPClient client = new TimeUDPClient();

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.open();
        System.out.println(client.getDate(InetAddress.getByName(host)));
        client.close();
    }","  public void test5()  throws Throwable  {
      try { 
        TimeClient.timeUDP("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
1307,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: TimeClient [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test6()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-wdp"";
      // Undeclared exception!
      try { 
        TimeClient.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1308,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: TimeClient [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test7()  throws Throwable  {
      String[] stringArray0 = new String[11];
      // Undeclared exception!
      try { 
        TimeClient.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1309,,"  public void test8()  throws Throwable  {
      TimeClient timeClient0 = new TimeClient();
  }"
1310,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: TimeClient [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test9()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-udp"";
      // Undeclared exception!
      try { 
        TimeClient.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1311,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: TimeClient [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test10()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          // Undeclared exception!
          try { 
            TimeClient.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:37\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ntp.TimeClient.timeTCP(TimeClient.java:47)
             // org.apache.commons.net.examples.ntp.TimeClient.main(TimeClient.java:72)
             // sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1312,"    public static void main(final String[] args)
    {
        final String server;
        final String username;
        final String password;
        final String command;
        final RExecClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rexec <hostname> <username> <password> <command>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RExecClient();

        server = args[0];
        username = args[1];
        password = args[2];
        command = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rexec(username, password, command);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""Could not execute command."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[4];
          stringArray0[0] = """";
          // Undeclared exception!
          try { 
            rexec.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:512\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.rexec.main(rexec.java:67)
             // sun.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1313,"    public static void main(final String[] args)
    {
        final String server;
        final String username;
        final String password;
        final String command;
        final RExecClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rexec <hostname> <username> <password> <command>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RExecClient();

        server = args[0];
        username = args[1];
        password = args[2];
        command = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rexec(username, password, command);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""Could not execute command."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[3];
      // Undeclared exception!
      try { 
        rexec.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1314,"    public static void main(final String[] args)
    {
        final String server;
        final String username;
        final String password;
        final String command;
        final RExecClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rexec <hostname> <username> <password> <command>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RExecClient();

        server = args[0];
        username = args[1];
        password = args[2];
        command = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rexec(username, password, command);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""Could not execute command."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        rexec.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.unix.rexec"", e);
      }
  }"
1315,"    public static void main(final String[] args)
    {
        final String server;
        final String username;
        final String password;
        final String command;
        final RExecClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rexec <hostname> <username> <password> <command>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RExecClient();

        server = args[0];
        username = args[1];
        password = args[2];
        command = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rexec(username, password, command);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""Could not execute command."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[8];
      // Undeclared exception!
      try { 
        rexec.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1316,,"  public void test4()  throws Throwable  {
      rexec rexec0 = new rexec();
  }"
1317,"    public static void main(final String[] args)
    {
        final int index;
        final String handle;
        final String host;
        InetAddress address = null;
        final WhoisClient whois;

        if (args.length != 1)
        {
            System.err.println(""usage: fwhois handle[@<server>]"");
            System.exit(1);
        }

        index = args[0].lastIndexOf('@');

        whois = new WhoisClient();
        // We want to timeout if a response takes longer than 60 seconds
        whois.setDefaultTimeout(60000);

        if (index == -1)
        {
            handle = args[0];
            host = WhoisClient.DEFAULT_HOST;
        }
        else
        {
            handle = args[0].substring(0, index);
            host = args[0].substring(index + 1);
        }

        try
        {
            address = InetAddress.getByName(host);
            System.out.println(""["" + address.getHostName() + ""]"");
        }
        catch (final UnknownHostException e)
        {
            System.err.println(""Error unknown host: "" + e.getMessage());
            System.exit(1);
        }

        try
        {
            whois.connect(address);
            System.out.print(whois.query(handle));
            whois.disconnect();
        }
        catch (final IOException e)
        {
            System.err.println(""Error I/O exception: "" + e.getMessage());
            System.exit(1);
        }
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          stringArray0[0] = ""h6EQ~&$"";
          // Undeclared exception!
          try { 
            fwhois.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:43\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:191)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:297)
             // org.apache.commons.net.examples.unix.fwhois.main(fwhois.java:77)
             // sun.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1318,"    public static void main(final String[] args)
    {
        final int index;
        final String handle;
        final String host;
        InetAddress address = null;
        final WhoisClient whois;

        if (args.length != 1)
        {
            System.err.println(""usage: fwhois handle[@<server>]"");
            System.exit(1);
        }

        index = args[0].lastIndexOf('@');

        whois = new WhoisClient();
        // We want to timeout if a response takes longer than 60 seconds
        whois.setDefaultTimeout(60000);

        if (index == -1)
        {
            handle = args[0];
            host = WhoisClient.DEFAULT_HOST;
        }
        else
        {
            handle = args[0].substring(0, index);
            host = args[0].substring(index + 1);
        }

        try
        {
            address = InetAddress.getByName(host);
            System.out.println(""["" + address.getHostName() + ""]"");
        }
        catch (final UnknownHostException e)
        {
            System.err.println(""Error unknown host: "" + e.getMessage());
            System.exit(1);
        }

        try
        {
            whois.connect(address);
            System.out.print(whois.query(handle));
            whois.disconnect();
        }
        catch (final IOException e)
        {
            System.err.println(""Error I/O exception: "" + e.getMessage());
            System.exit(1);
        }
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          stringArray0[0] = ""e.^^@tY7:1;CL"";
          // Undeclared exception!
          try { 
            fwhois.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:43\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:191)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:297)
             // org.apache.commons.net.examples.unix.fwhois.main(fwhois.java:77)
             // sun.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1319,"    public static void main(final String[] args)
    {
        final int index;
        final String handle;
        final String host;
        InetAddress address = null;
        final WhoisClient whois;

        if (args.length != 1)
        {
            System.err.println(""usage: fwhois handle[@<server>]"");
            System.exit(1);
        }

        index = args[0].lastIndexOf('@');

        whois = new WhoisClient();
        // We want to timeout if a response takes longer than 60 seconds
        whois.setDefaultTimeout(60000);

        if (index == -1)
        {
            handle = args[0];
            host = WhoisClient.DEFAULT_HOST;
        }
        else
        {
            handle = args[0].substring(0, index);
            host = args[0].substring(index + 1);
        }

        try
        {
            address = InetAddress.getByName(host);
            System.out.println(""["" + address.getHostName() + ""]"");
        }
        catch (final UnknownHostException e)
        {
            System.err.println(""Error unknown host: "" + e.getMessage());
            System.exit(1);
        }

        try
        {
            whois.connect(address);
            System.out.print(whois.query(handle));
            whois.disconnect();
        }
        catch (final IOException e)
        {
            System.err.println(""Error I/O exception: "" + e.getMessage());
            System.exit(1);
        }
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        fwhois.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1320,"    public static void main(final String[] args)
    {
        final int index;
        final String handle;
        final String host;
        InetAddress address = null;
        final WhoisClient whois;

        if (args.length != 1)
        {
            System.err.println(""usage: fwhois handle[@<server>]"");
            System.exit(1);
        }

        index = args[0].lastIndexOf('@');

        whois = new WhoisClient();
        // We want to timeout if a response takes longer than 60 seconds
        whois.setDefaultTimeout(60000);

        if (index == -1)
        {
            handle = args[0];
            host = WhoisClient.DEFAULT_HOST;
        }
        else
        {
            handle = args[0].substring(0, index);
            host = args[0].substring(index + 1);
        }

        try
        {
            address = InetAddress.getByName(host);
            System.out.println(""["" + address.getHostName() + ""]"");
        }
        catch (final UnknownHostException e)
        {
            System.err.println(""Error unknown host: "" + e.getMessage());
            System.exit(1);
        }

        try
        {
            whois.connect(address);
            System.out.print(whois.query(handle));
            whois.disconnect();
        }
        catch (final IOException e)
        {
            System.err.println(""Error I/O exception: "" + e.getMessage());
            System.exit(1);
        }
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[1];
      // Undeclared exception!
      try { 
        fwhois.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.unix.fwhois"", e);
      }
  }"
1321,,"  public void test4()  throws Throwable  {
      fwhois fwhois0 = new fwhois();
  }"
1322,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                chargenTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                chargenUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: chargen [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        chargen.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1323,"    public static void chargenTCP(final String host) throws IOException
    {
        int lines = 100;
        String line;
        final CharGenTCPClient client = new CharGenTCPClient();

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.connect(host);
        try (final BufferedReader chargenInput = new BufferedReader(new InputStreamReader(client.getInputStream()))) {

            // We assume the chargen service outputs lines, but it really doesn't
            // have to, so this code might actually not work if no newlines are
            // present.
            while (lines-- > 0) {
                if ((line = chargenInput.readLine()) == null) {
                    break;
                }
                System.out.println(line);
            }
        }
        client.disconnect();
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          // Undeclared exception!
          try { 
            chargen.chargenTCP("""");
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:19\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.chargen.chargenTCP(chargen.java:53)
             // sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
             // sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1324,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                chargenTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                chargenUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: chargen [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test2()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""127.0.0.1"", 19);
      byte[] byteArray0 = new byte[2];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-udp"";
      // Undeclared exception!
      try { 
        chargen.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1325,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                chargenTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                chargenUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: chargen [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""2udp"";
      // Undeclared exception!
      try { 
        chargen.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1326,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                chargenTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                chargenUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: chargen [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[5];
      // Undeclared exception!
      try { 
        chargen.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1327,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                chargenTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                chargenUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: chargen [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test5()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          // Undeclared exception!
          try { 
            chargen.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:19\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.chargen.chargenTCP(chargen.java:53)
             // org.apache.commons.net.examples.unix.chargen.main(chargen.java:124)
             // sun.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1328,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                chargenTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                chargenUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: chargen [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test6()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        chargen.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1329,"    public static void chargenUDP(final String host) throws IOException
    {
        int packets = 50;
        byte[] data;
        final InetAddress address;
        final CharGenUDPClient client;

        address = InetAddress.getByName(host);
        client = new CharGenUDPClient();

        client.open();
        // If we don't receive a return packet within 5 seconds, assume
        // the packet is lost.
        client.setSoTimeout(5000);

        while (packets-- > 0)
        {
            client.send(address);

            try
            {
                data = client.receive();
            }
            // Here we catch both SocketException and InterruptedIOException,
            // because even though the JDK 1.1 docs claim that
            // InterruptedIOException is thrown on a timeout, it seems
            // SocketException is also thrown.
            catch (final SocketException e)
            {
                // We timed out and assume the packet is lost.
                System.err.println(""SocketException: Timed out and dropped packet"");
                continue;
            }
            catch (final InterruptedIOException e)
            {
                // We timed out and assume the packet is lost.
                System.err.println(
                    ""InterruptedIOException: Timed out and dropped packet"");
                continue;
            }
            System.out.write(data);
            System.out.flush();
        }

        client.close();
    }","  public void test7()  throws Throwable  {
      try { 
        chargen.chargenUDP(""X`@.1t"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
1330,,"  public void test8()  throws Throwable  {
      chargen chargen0 = new chargen();
  }"
1331,"    public static void main(final String[] args)
    {
        final String server;
        final String localuser;
        final String remoteuser;
        final String terminal;
        final RLoginClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rlogin <hostname> <localuser> <remoteuser> <terminal>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RLoginClient();

        server = args[0];
        localuser = args[1];
        remoteuser = args[2];
        terminal = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rlogin(localuser, remoteuser, terminal);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""rlogin authentication failed."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[4];
          stringArray0[0] = ""org.apache.commons.net.examples.unix.rlogin"";
          // Undeclared exception!
          try { 
            rlogin.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:1023\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.Socket.bind(Socket.java:660)
             // java.net.Socket.<init>(Socket.java:451)
             // java.net.Socket.<init>(Socket.java:346)
             // javax.net.DefaultSocketFactory.createSocket(SocketFactory.java:291)
             // org.apache.commons.net.bsd.RCommandClient.connect(RCommandClient.java:193)
             // org.apache.commons.net.bsd.RCommandClient.connect(RCommandClient.java:254)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.rlogin.main(rlogin.java:78)
             // sun.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1332,"    public static void main(final String[] args)
    {
        final String server;
        final String localuser;
        final String remoteuser;
        final String terminal;
        final RLoginClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rlogin <hostname> <localuser> <remoteuser> <terminal>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RLoginClient();

        server = args[0];
        localuser = args[1];
        remoteuser = args[2];
        terminal = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rlogin(localuser, remoteuser, terminal);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""rlogin authentication failed."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[8];
      // Undeclared exception!
      try { 
        rlogin.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1333,"    public static void main(final String[] args)
    {
        final String server;
        final String localuser;
        final String remoteuser;
        final String terminal;
        final RLoginClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rlogin <hostname> <localuser> <remoteuser> <terminal>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RLoginClient();

        server = args[0];
        localuser = args[1];
        remoteuser = args[2];
        terminal = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rlogin(localuser, remoteuser, terminal);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""rlogin authentication failed."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        rlogin.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.unix.rlogin"", e);
      }
  }"
1334,"    public static void main(final String[] args)
    {
        final String server;
        final String localuser;
        final String remoteuser;
        final String terminal;
        final RLoginClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rlogin <hostname> <localuser> <remoteuser> <terminal>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RLoginClient();

        server = args[0];
        localuser = args[1];
        remoteuser = args[2];
        terminal = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rlogin(localuser, remoteuser, terminal);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""rlogin authentication failed."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        rlogin.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1335,,"  public void test4()  throws Throwable  {
      rlogin rlogin0 = new rlogin();
  }"
1336,"    public static void main(final String[] args)
    {
        boolean longOutput = false;
        int arg = 0, index;
        String handle, host;
        final FingerClient finger;
        InetAddress address = null;

        // Get flags.  If an invalid flag is present, exit with usage message.
        while (arg < args.length && args[arg].startsWith(""-""))
        {
            if (args[arg].equals(""-l"")) {
                longOutput = true;
            } else {
                System.err.println(""usage: finger [-l] [[[handle][@<server>]] ...]"");
                System.exit(1);
            }
            ++arg;
        }


        finger = new FingerClient();
        // We want to timeout if a response takes longer than 60 seconds
        finger.setDefaultTimeout(60000);

        if (arg >= args.length)
        {
            // Finger local host

            try
            {
                address = InetAddress.getLocalHost();
            }
            catch (final UnknownHostException e)
            {
                System.err.println(""Error unknown host: "" + e.getMessage());
                System.exit(1);
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            return ;
        }

        // Finger each argument
        while (arg < args.length)
        {

            index = args[arg].lastIndexOf('@');

            if (index == -1)
            {
                handle = args[arg];
                try
                {
                    address = InetAddress.getLocalHost();
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }
            else
            {
                handle = args[arg].substring(0, index);
                host = args[arg].substring(index + 1);

                try
                {
                    address = InetAddress.getByName(host);
                    System.out.println(""["" + address.getHostName() + ""]"");
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput, handle));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            ++arg;
            if (arg != args.length) {
                System.out.print(""\n"");
            }
        }
    }","  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        finger.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.unix.finger"", e);
      }
  }"
1337,"    public static void main(final String[] args)
    {
        boolean longOutput = false;
        int arg = 0, index;
        String handle, host;
        final FingerClient finger;
        InetAddress address = null;

        // Get flags.  If an invalid flag is present, exit with usage message.
        while (arg < args.length && args[arg].startsWith(""-""))
        {
            if (args[arg].equals(""-l"")) {
                longOutput = true;
            } else {
                System.err.println(""usage: finger [-l] [[[handle][@<server>]] ...]"");
                System.exit(1);
            }
            ++arg;
        }


        finger = new FingerClient();
        // We want to timeout if a response takes longer than 60 seconds
        finger.setDefaultTimeout(60000);

        if (arg >= args.length)
        {
            // Finger local host

            try
            {
                address = InetAddress.getLocalHost();
            }
            catch (final UnknownHostException e)
            {
                System.err.println(""Error unknown host: "" + e.getMessage());
                System.exit(1);
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            return ;
        }

        // Finger each argument
        while (arg < args.length)
        {

            index = args[arg].lastIndexOf('@');

            if (index == -1)
            {
                handle = args[arg];
                try
                {
                    address = InetAddress.getLocalHost();
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }
            else
            {
                handle = args[arg].substring(0, index);
                host = args[arg].substring(index + 1);

                try
                {
                    address = InetAddress.getByName(host);
                    System.out.println(""["" + address.getHostName() + ""]"");
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput, handle));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            ++arg;
            if (arg != args.length) {
                System.out.print(""\n"");
            }
        }
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[8];
          stringArray0[0] = "",MSR0-ohmZ?8"";
          // Undeclared exception!
          try { 
            finger.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""192.168.1.42:79\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:191)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:297)
             // org.apache.commons.net.examples.unix.finger.main(finger.java:130)
             // sun.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1338,"    public static void main(final String[] args)
    {
        boolean longOutput = false;
        int arg = 0, index;
        String handle, host;
        final FingerClient finger;
        InetAddress address = null;

        // Get flags.  If an invalid flag is present, exit with usage message.
        while (arg < args.length && args[arg].startsWith(""-""))
        {
            if (args[arg].equals(""-l"")) {
                longOutput = true;
            } else {
                System.err.println(""usage: finger [-l] [[[handle][@<server>]] ...]"");
                System.exit(1);
            }
            ++arg;
        }


        finger = new FingerClient();
        // We want to timeout if a response takes longer than 60 seconds
        finger.setDefaultTimeout(60000);

        if (arg >= args.length)
        {
            // Finger local host

            try
            {
                address = InetAddress.getLocalHost();
            }
            catch (final UnknownHostException e)
            {
                System.err.println(""Error unknown host: "" + e.getMessage());
                System.exit(1);
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            return ;
        }

        // Finger each argument
        while (arg < args.length)
        {

            index = args[arg].lastIndexOf('@');

            if (index == -1)
            {
                handle = args[arg];
                try
                {
                    address = InetAddress.getLocalHost();
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }
            else
            {
                handle = args[arg].substring(0, index);
                host = args[arg].substring(index + 1);

                try
                {
                    address = InetAddress.getByName(host);
                    System.out.println(""["" + address.getHostName() + ""]"");
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput, handle));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            ++arg;
            if (arg != args.length) {
                System.out.print(""\n"");
            }
        }
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[6];
      stringArray0[0] = ""-,u"";
      // Undeclared exception!
      try { 
        finger.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1339,"    public static void main(final String[] args)
    {
        boolean longOutput = false;
        int arg = 0, index;
        String handle, host;
        final FingerClient finger;
        InetAddress address = null;

        // Get flags.  If an invalid flag is present, exit with usage message.
        while (arg < args.length && args[arg].startsWith(""-""))
        {
            if (args[arg].equals(""-l"")) {
                longOutput = true;
            } else {
                System.err.println(""usage: finger [-l] [[[handle][@<server>]] ...]"");
                System.exit(1);
            }
            ++arg;
        }


        finger = new FingerClient();
        // We want to timeout if a response takes longer than 60 seconds
        finger.setDefaultTimeout(60000);

        if (arg >= args.length)
        {
            // Finger local host

            try
            {
                address = InetAddress.getLocalHost();
            }
            catch (final UnknownHostException e)
            {
                System.err.println(""Error unknown host: "" + e.getMessage());
                System.exit(1);
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            return ;
        }

        // Finger each argument
        while (arg < args.length)
        {

            index = args[arg].lastIndexOf('@');

            if (index == -1)
            {
                handle = args[arg];
                try
                {
                    address = InetAddress.getLocalHost();
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }
            else
            {
                handle = args[arg].substring(0, index);
                host = args[arg].substring(index + 1);

                try
                {
                    address = InetAddress.getByName(host);
                    System.out.println(""["" + address.getHostName() + ""]"");
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput, handle));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            ++arg;
            if (arg != args.length) {
                System.out.print(""\n"");
            }
        }
    }","  public void test3()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          stringArray0[0] = ""SR{3@38.1(X5 s'"";
          // Undeclared exception!
          try { 
            finger.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:79\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:191)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:297)
             // org.apache.commons.net.examples.unix.finger.main(finger.java:130)
             // sun.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1340,"    public static void main(final String[] args)
    {
        boolean longOutput = false;
        int arg = 0, index;
        String handle, host;
        final FingerClient finger;
        InetAddress address = null;

        // Get flags.  If an invalid flag is present, exit with usage message.
        while (arg < args.length && args[arg].startsWith(""-""))
        {
            if (args[arg].equals(""-l"")) {
                longOutput = true;
            } else {
                System.err.println(""usage: finger [-l] [[[handle][@<server>]] ...]"");
                System.exit(1);
            }
            ++arg;
        }


        finger = new FingerClient();
        // We want to timeout if a response takes longer than 60 seconds
        finger.setDefaultTimeout(60000);

        if (arg >= args.length)
        {
            // Finger local host

            try
            {
                address = InetAddress.getLocalHost();
            }
            catch (final UnknownHostException e)
            {
                System.err.println(""Error unknown host: "" + e.getMessage());
                System.exit(1);
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            return ;
        }

        // Finger each argument
        while (arg < args.length)
        {

            index = args[arg].lastIndexOf('@');

            if (index == -1)
            {
                handle = args[arg];
                try
                {
                    address = InetAddress.getLocalHost();
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }
            else
            {
                handle = args[arg].substring(0, index);
                host = args[arg].substring(index + 1);

                try
                {
                    address = InetAddress.getByName(host);
                    System.out.println(""["" + address.getHostName() + ""]"");
                }
                catch (final UnknownHostException e)
                {
                    System.err.println(""Error unknown host: "" + e.getMessage());
                    System.exit(1);
                }
            }

            try
            {
                finger.connect(address);
                System.out.print(finger.query(longOutput, handle));
                finger.disconnect();
            }
            catch (final IOException e)
            {
                System.err.println(""Error I/O exception: "" + e.getMessage());
                System.exit(1);
            }

            ++arg;
            if (arg != args.length) {
                System.out.print(""\n"");
            }
        }
    }","  public void test4()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          stringArray0[0] = ""-l"";
          // Undeclared exception!
          try { 
            finger.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""192.168.1.42:79\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:191)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:297)
             // org.apache.commons.net.examples.unix.finger.main(finger.java:79)
             // sun.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1341,,"  public void test5()  throws Throwable  {
      finger finger0 = new finger();
  }"
1342,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                daytimeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                daytimeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: daytime [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        daytime.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1343,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                daytimeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                daytimeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: daytime [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test1()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""127.0.0.1"", 13);
      byte[] byteArray0 = new byte[4];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-udp"";
      daytime.main(stringArray0);
}"
1344,"    public static void daytimeUDP(final String host) throws IOException
    {
        final DaytimeUDPClient client = new DaytimeUDPClient();

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.open();
        System.out.println(client.getTime(
                                          InetAddress.getByName(host)).trim());
        client.close();
    }","  public void test2()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""127.0.0.1"", 13);
      byte[] byteArray0 = new byte[7];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      daytime.daytimeUDP("""");
  }"
1345,"    public static void daytimeTCP(final String host) throws IOException
    {
        final DaytimeTCPClient client = new DaytimeTCPClient();

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.connect(host);
        System.out.println(client.getTime().trim());
        client.disconnect();
    }","  public void test3()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          // Undeclared exception!
          try { 
            daytime.daytimeTCP("""");
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:13\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.daytime.daytimeTCP(daytime.java:45)
             // sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
             // sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1346,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                daytimeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                daytimeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: daytime [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-udp"";
      // Undeclared exception!
      try { 
        daytime.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1347,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                daytimeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                daytimeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: daytime [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-xdp"";
      // Undeclared exception!
      try { 
        daytime.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1348,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                daytimeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                daytimeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: daytime [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test6()  throws Throwable  {
      String[] stringArray0 = new String[6];
      // Undeclared exception!
      try { 
        daytime.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1349,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                daytimeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                daytimeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: daytime [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test7()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        daytime.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1350,,"  public void test8()  throws Throwable  {
      daytime daytime0 = new daytime();
  }"
1351,"    public static void daytimeUDP(final String host) throws IOException
    {
        final DaytimeUDPClient client = new DaytimeUDPClient();

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.open();
        System.out.println(client.getTime(
                                          InetAddress.getByName(host)).trim());
        client.close();
    }","  public void test9()  throws Throwable  {
      try { 
        daytime.daytimeUDP(""BN1$m^b!isi"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
1352,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                daytimeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                daytimeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: daytime [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test10()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          // Undeclared exception!
          try { 
            daytime.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:13\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.daytime.daytimeTCP(daytime.java:45)
             // org.apache.commons.net.examples.unix.daytime.main(daytime.java:70)
             // sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1353,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                echoTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                echoUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: echo [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        echo.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1354,"    public static void echoTCP(final String host) throws IOException
    {
        final EchoTCPClient client = new EchoTCPClient();
        final BufferedReader input;
        final BufferedReader echoInput;
        final PrintWriter echoOutput;
        String line;

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.connect(host);
        System.out.println(""Connected to "" + host + ""."");
        input = new BufferedReader(new InputStreamReader(System.in));
        echoOutput =
            new PrintWriter(new OutputStreamWriter(client.getOutputStream()), true);
        echoInput =
            new BufferedReader(new InputStreamReader(client.getInputStream()));

        while ((line = input.readLine()) != null)
        {
            echoOutput.println(line);
            System.out.println(echoInput.readLine());
        }
        echoOutput.close();
        echoInput.close();
        echoInput.close();
        client.disconnect();
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          // Undeclared exception!
          try { 
            echo.echoTCP("""");
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:7\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.echo.echoTCP(echo.java:55)
             // sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
             // sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1355,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                echoTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                echoUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: echo [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-udp"";
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40001);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""127.0.0.1"", 7);
      byte[] byteArray0 = new byte[2];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, (byte[]) null);
      SystemInUtil.addInputLine(""\r\n"");
      // Undeclared exception!
      try { 
        echo.main(stringArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
1356,"    public static void echoUDP(final String host) throws IOException
    {
        int length, count;
        byte[] data;
        String line;
        final BufferedReader input;
        final InetAddress address;
        final EchoUDPClient client;

        input = new BufferedReader(new InputStreamReader(System.in));
        address = InetAddress.getByName(host);
        client = new EchoUDPClient();

        client.open();
        // If we don't receive an echo within 5 seconds, assume the packet is lost.
        client.setSoTimeout(5000);
        System.out.println(""Ready to echo to "" + host + ""."");

        // Remember, there are no guarantees about the ordering of returned
        // UDP packets, so there is a chance the output may be jumbled.
        while ((line = input.readLine()) != null)
        {
            data = line.getBytes();
            client.send(data, address);
            count = 0;
            do
            {
                try
                {
                    length = client.receive(data);
                }
                // Here we catch both SocketException and InterruptedIOException,
                // because even though the JDK 1.1 docs claim that
                // InterruptedIOException is thrown on a timeout, it seems
                // SocketException is also thrown.
                catch (final SocketException e)
                {
                    // We timed out and assume the packet is lost.
                    System.err.println(
                        ""SocketException: Timed out and dropped packet"");
                    break;
                }
                catch (final InterruptedIOException e)
                {
                    // We timed out and assume the packet is lost.
                    System.err.println(
                        ""InterruptedIOException: Timed out and dropped packet"");
                    break;
                }
                System.out.print(new String(data, 0, length));
                count += length;
            }
            while (count < data.length);

            System.out.println();
        }

        client.close();
    }","  public void test3()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      SystemInUtil.addInputLine(""-#mH"");
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""org.apache.commons.net.DatagramSocketClient"", 1);
      byte[] byteArray0 = new byte[5];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      // Undeclared exception!
      try { 
        echo.echoUDP(""%5;zve"");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
1357,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                echoTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                echoUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: echo [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-udp"";
      echo.main(stringArray0);
      // Undeclared exception!
      try { 
        echo.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1358,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                echoTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                echoUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: echo [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-ucp"";
      // Undeclared exception!
      try { 
        echo.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1359,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                echoTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                echoUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: echo [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test6()  throws Throwable  {
      String[] stringArray0 = new String[5];
      // Undeclared exception!
      try { 
        echo.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1360,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                echoTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                echoUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: echo [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test7()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          // Undeclared exception!
          try { 
            echo.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:7\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.echo.echoTCP(echo.java:55)
             // org.apache.commons.net.examples.unix.echo.main(echo.java:142)
             // sun.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1361,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                echoTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                echoUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: echo [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test8()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        echo.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1362,"    public static void echoUDP(final String host) throws IOException
    {
        int length, count;
        byte[] data;
        String line;
        final BufferedReader input;
        final InetAddress address;
        final EchoUDPClient client;

        input = new BufferedReader(new InputStreamReader(System.in));
        address = InetAddress.getByName(host);
        client = new EchoUDPClient();

        client.open();
        // If we don't receive an echo within 5 seconds, assume the packet is lost.
        client.setSoTimeout(5000);
        System.out.println(""Ready to echo to "" + host + ""."");

        // Remember, there are no guarantees about the ordering of returned
        // UDP packets, so there is a chance the output may be jumbled.
        while ((line = input.readLine()) != null)
        {
            data = line.getBytes();
            client.send(data, address);
            count = 0;
            do
            {
                try
                {
                    length = client.receive(data);
                }
                // Here we catch both SocketException and InterruptedIOException,
                // because even though the JDK 1.1 docs claim that
                // InterruptedIOException is thrown on a timeout, it seems
                // SocketException is also thrown.
                catch (final SocketException e)
                {
                    // We timed out and assume the packet is lost.
                    System.err.println(
                        ""SocketException: Timed out and dropped packet"");
                    break;
                }
                catch (final InterruptedIOException e)
                {
                    // We timed out and assume the packet is lost.
                    System.err.println(
                        ""InterruptedIOException: Timed out and dropped packet"");
                    break;
                }
                System.out.print(new String(data, 0, length));
                count += length;
            }
            while (count < data.length);

            System.out.println();
        }

        client.close();
    }","  public void test9()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      SystemInUtil.addInputLine(""J\""F$QKb`5\""m0;"");
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 7);
      byte[] byteArray0 = new byte[9];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      try { 
        echo.echoUDP(""J\""F$QKb`5\""m0;"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated exception in System.in
         //
         verifyException(""org.evosuite.runtime.util.SystemInUtil"", e);
      }
  }"
1363,"    public static void echoUDP(final String host) throws IOException
    {
        int length, count;
        byte[] data;
        String line;
        final BufferedReader input;
        final InetAddress address;
        final EchoUDPClient client;

        input = new BufferedReader(new InputStreamReader(System.in));
        address = InetAddress.getByName(host);
        client = new EchoUDPClient();

        client.open();
        // If we don't receive an echo within 5 seconds, assume the packet is lost.
        client.setSoTimeout(5000);
        System.out.println(""Ready to echo to "" + host + ""."");

        // Remember, there are no guarantees about the ordering of returned
        // UDP packets, so there is a chance the output may be jumbled.
        while ((line = input.readLine()) != null)
        {
            data = line.getBytes();
            client.send(data, address);
            count = 0;
            do
            {
                try
                {
                    length = client.receive(data);
                }
                // Here we catch both SocketException and InterruptedIOException,
                // because even though the JDK 1.1 docs claim that
                // InterruptedIOException is thrown on a timeout, it seems
                // SocketException is also thrown.
                catch (final SocketException e)
                {
                    // We timed out and assume the packet is lost.
                    System.err.println(
                        ""SocketException: Timed out and dropped packet"");
                    break;
                }
                catch (final InterruptedIOException e)
                {
                    // We timed out and assume the packet is lost.
                    System.err.println(
                        ""InterruptedIOException: Timed out and dropped packet"");
                    break;
                }
                System.out.print(new String(data, 0, length));
                count += length;
            }
            while (count < data.length);

            System.out.println();
        }

        client.close();
    }","  public void test10()  throws Throwable  {
      echo.echoUDP(""cCsZ_K"");
  }"
1364,,"  public void test11()  throws Throwable  {
      echo echo0 = new echo();
  }"
1365,"    public static void main(final String[] args)
    {
        final String server;
        final String localuser;
        final String remoteuser;
        final String command;
        final RCommandClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rshell <hostname> <localuser> <remoteuser> <command>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RCommandClient();

        server = args[0];
        localuser = args[1];
        remoteuser = args[2];
        command = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rcommand(localuser, remoteuser, command);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""Could not execute command."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[4];
          stringArray0[0] = """";
          // Undeclared exception!
          try { 
            rshell.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:1023\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.Socket.bind(Socket.java:660)
             // java.net.Socket.<init>(Socket.java:451)
             // java.net.Socket.<init>(Socket.java:346)
             // javax.net.DefaultSocketFactory.createSocket(SocketFactory.java:291)
             // org.apache.commons.net.bsd.RCommandClient.connect(RCommandClient.java:193)
             // org.apache.commons.net.bsd.RCommandClient.connect(RCommandClient.java:254)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.rshell.main(rshell.java:71)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1366,"    public static void main(final String[] args)
    {
        final String server;
        final String localuser;
        final String remoteuser;
        final String command;
        final RCommandClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rshell <hostname> <localuser> <remoteuser> <command>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RCommandClient();

        server = args[0];
        localuser = args[1];
        remoteuser = args[2];
        command = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rcommand(localuser, remoteuser, command);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""Could not execute command."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        rshell.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1367,"    public static void main(final String[] args)
    {
        final String server;
        final String localuser;
        final String remoteuser;
        final String command;
        final RCommandClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rshell <hostname> <localuser> <remoteuser> <command>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RCommandClient();

        server = args[0];
        localuser = args[1];
        remoteuser = args[2];
        command = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rcommand(localuser, remoteuser, command);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""Could not execute command."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        rshell.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.unix.rshell"", e);
      }
  }"
1368,"    public static void main(final String[] args)
    {
        final String server;
        final String localuser;
        final String remoteuser;
        final String command;
        final RCommandClient client;

        if (args.length != 4)
        {
            System.err.println(
                ""Usage: rshell <hostname> <localuser> <remoteuser> <command>"");
            System.exit(1);
            return ; // so compiler can do proper flow control analysis
        }

        client = new RCommandClient();

        server = args[0];
        localuser = args[1];
        remoteuser = args[2];
        command = args[3];

        try
        {
            client.connect(server);
        }
        catch (final IOException e)
        {
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            client.rcommand(localuser, remoteuser, command);
        }
        catch (final IOException e)
        {
            try
            {
                client.disconnect();
            }
            catch (final IOException f)
            {/* ignored */}
            e.printStackTrace();
            System.err.println(""Could not execute command."");
            System.exit(1);
        }


        IOUtil.readWrite(client.getInputStream(), client.getOutputStream(),
                         System.in, System.out);

        try
        {
            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[5];
      // Undeclared exception!
      try { 
        rshell.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1369,,"  public void test4()  throws Throwable  {
      rshell rshell0 = new rshell();
  }"
1370,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: rdate [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        rdate.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1371,"    public static void timeUDP(final String host) throws IOException
    {
        final TimeUDPClient client = new TimeUDPClient();

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.open();
        System.out.println(client.getDate(InetAddress.getByName(host)).toString());
        client.close();
    }","  public void test1()  throws Throwable  {
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""127.0.0.1"", 37);
      byte[] byteArray0 = new byte[8];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      rdate.timeUDP("""");
  }"
1372,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: rdate [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[2];
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 37);
      byte[] byteArray0 = new byte[5];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      stringArray0[0] = ""-udp"";
      rdate.main(stringArray0);
}"
1373,"    public static void timeTCP(final String host) throws IOException
    {
        final TimeTCPClient client = new TimeTCPClient();

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.connect(host);
        System.out.println(client.getDate().toString());
        client.disconnect();
    }","  public void test3()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          // Undeclared exception!
          try { 
            rdate.timeTCP("""");
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:37\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.rdate.timeTCP(rdate.java:46)
             // sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
             // sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1374,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: rdate [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-udp"";
      // Undeclared exception!
      try { 
        rdate.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1375,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: rdate [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-uep"";
      // Undeclared exception!
      try { 
        rdate.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1376,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: rdate [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test6()  throws Throwable  {
      String[] stringArray0 = new String[4];
      // Undeclared exception!
      try { 
        rdate.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1377,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: rdate [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test7()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        rdate.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1378,"    public static void main(final String[] args)
    {

        if (args.length == 1)
        {
            try
            {
                timeTCP(args[0]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else if (args.length == 2 && args[0].equals(""-udp""))
        {
            try
            {
                timeUDP(args[1]);
            }
            catch (final IOException e)
            {
                e.printStackTrace();
                System.exit(1);
            }
        }
        else
        {
            System.err.println(""Usage: rdate [-udp] <hostname>"");
            System.exit(1);
        }

    }","  public void test8()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          // Undeclared exception!
          try { 
            rdate.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:37\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.unix.rdate.timeTCP(rdate.java:46)
             // org.apache.commons.net.examples.unix.rdate.main(rdate.java:70)
             // sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1379,,"  public void test9()  throws Throwable  {
      rdate rdate0 = new rdate();
  }"
1380,"    public static void timeUDP(final String host) throws IOException
    {
        final TimeUDPClient client = new TimeUDPClient();

        // We want to timeout if a response takes longer than 60 seconds
        client.setDefaultTimeout(60000);
        client.open();
        System.out.println(client.getDate(InetAddress.getByName(host)).toString());
        client.close();
    }","  public void test10()  throws Throwable  {
      try { 
        rdate.timeUDP("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
1381,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 3 && args.length != 5) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<article specifier> [<user> <password>]]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];
        // Article specifier can be numeric or Id in form <m.n.o.x@host>
        final String articleSpec = args.length >= 3 ? args[2] : null;

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 5) { // Optional auth
            final String user = args[3];
            final String password = args[4];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final BufferedReader brHdr;
        String line;
        if (articleSpec != null) {
            brHdr = (BufferedReader) client.retrieveArticleHeader(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brHdr = client.retrieveArticleHeader(articleNum);
        }
        if (brHdr != null) {
            while((line=brHdr.readLine()) != null) {
                System.out.println(line);
            }
            brHdr.close();
        }
        final BufferedReader brBody;
        if (articleSpec != null) {
            brBody = (BufferedReader) client.retrieveArticleBody(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brBody = client.retrieveArticleBody(articleNum);
        }
        if (brBody != null) {
            while((line=brBody.readLine()) != null) {
                System.out.println(line);
            }
            brBody.close();
        }
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[2];
          stringArray0[0] = """";
          // Undeclared exception!
          try { 
            ArticleReader.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.ArticleReader.main(ArticleReader.java:48)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1382,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 3 && args.length != 5) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<article specifier> [<user> <password>]]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];
        // Article specifier can be numeric or Id in form <m.n.o.x@host>
        final String articleSpec = args.length >= 3 ? args[2] : null;

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 5) { // Optional auth
            final String user = args[3];
            final String password = args[4];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final BufferedReader brHdr;
        String line;
        if (articleSpec != null) {
            brHdr = (BufferedReader) client.retrieveArticleHeader(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brHdr = client.retrieveArticleHeader(articleNum);
        }
        if (brHdr != null) {
            while((line=brHdr.readLine()) != null) {
                System.out.println(line);
            }
            brHdr.close();
        }
        final BufferedReader brBody;
        if (articleSpec != null) {
            brBody = (BufferedReader) client.retrieveArticleBody(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brBody = client.retrieveArticleBody(articleNum);
        }
        if (brBody != null) {
            while((line=brBody.readLine()) != null) {
                System.out.println(line);
            }
            brBody.close();
        }
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[0];
      ArticleReader.main(stringArray0);
}"
1383,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 3 && args.length != 5) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<article specifier> [<user> <password>]]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];
        // Article specifier can be numeric or Id in form <m.n.o.x@host>
        final String articleSpec = args.length >= 3 ? args[2] : null;

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 5) { // Optional auth
            final String user = args[3];
            final String password = args[4];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final BufferedReader brHdr;
        String line;
        if (articleSpec != null) {
            brHdr = (BufferedReader) client.retrieveArticleHeader(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brHdr = client.retrieveArticleHeader(articleNum);
        }
        if (brHdr != null) {
            while((line=brHdr.readLine()) != null) {
                System.out.println(line);
            }
            brHdr.close();
        }
        final BufferedReader brBody;
        if (articleSpec != null) {
            brBody = (BufferedReader) client.retrieveArticleBody(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brBody = client.retrieveArticleBody(articleNum);
        }
        if (brBody != null) {
            while((line=brBody.readLine()) != null) {
                System.out.println(line);
            }
            brBody.close();
        }
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        ArticleReader.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.nntp.ArticleReader"", e);
      }
  }"
1384,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 3 && args.length != 5) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<article specifier> [<user> <password>]]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];
        // Article specifier can be numeric or Id in form <m.n.o.x@host>
        final String articleSpec = args.length >= 3 ? args[2] : null;

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 5) { // Optional auth
            final String user = args[3];
            final String password = args[4];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final BufferedReader brHdr;
        String line;
        if (articleSpec != null) {
            brHdr = (BufferedReader) client.retrieveArticleHeader(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brHdr = client.retrieveArticleHeader(articleNum);
        }
        if (brHdr != null) {
            while((line=brHdr.readLine()) != null) {
                System.out.println(line);
            }
            brHdr.close();
        }
        final BufferedReader brBody;
        if (articleSpec != null) {
            brBody = (BufferedReader) client.retrieveArticleBody(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brBody = client.retrieveArticleBody(articleNum);
        }
        if (brBody != null) {
            while((line=brBody.readLine()) != null) {
                System.out.println(line);
            }
            brBody.close();
        }
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[6];
      ArticleReader.main(stringArray0);
}"
1385,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 3 && args.length != 5) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<article specifier> [<user> <password>]]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];
        // Article specifier can be numeric or Id in form <m.n.o.x@host>
        final String articleSpec = args.length >= 3 ? args[2] : null;

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 5) { // Optional auth
            final String user = args[3];
            final String password = args[4];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final BufferedReader brHdr;
        String line;
        if (articleSpec != null) {
            brHdr = (BufferedReader) client.retrieveArticleHeader(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brHdr = client.retrieveArticleHeader(articleNum);
        }
        if (brHdr != null) {
            while((line=brHdr.readLine()) != null) {
                System.out.println(line);
            }
            brHdr.close();
        }
        final BufferedReader brBody;
        if (articleSpec != null) {
            brBody = (BufferedReader) client.retrieveArticleBody(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brBody = client.retrieveArticleBody(articleNum);
        }
        if (brBody != null) {
            while((line=brBody.readLine()) != null) {
                System.out.println(line);
            }
            brBody.close();
        }
    }","  public void test4()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[5];
          // Undeclared exception!
          try { 
            ArticleReader.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.ArticleReader.main(ArticleReader.java:48)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1386,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 3 && args.length != 5) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<article specifier> [<user> <password>]]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];
        // Article specifier can be numeric or Id in form <m.n.o.x@host>
        final String articleSpec = args.length >= 3 ? args[2] : null;

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 5) { // Optional auth
            final String user = args[3];
            final String password = args[4];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final BufferedReader brHdr;
        String line;
        if (articleSpec != null) {
            brHdr = (BufferedReader) client.retrieveArticleHeader(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brHdr = client.retrieveArticleHeader(articleNum);
        }
        if (brHdr != null) {
            while((line=brHdr.readLine()) != null) {
                System.out.println(line);
            }
            brHdr.close();
        }
        final BufferedReader brBody;
        if (articleSpec != null) {
            brBody = (BufferedReader) client.retrieveArticleBody(articleSpec);
        } else {
            final long articleNum = group.getLastArticleLong();
            brBody = client.retrieveArticleBody(articleNum);
        }
        if (brBody != null) {
            while((line=brBody.readLine()) != null) {
                System.out.println(line);
            }
            brBody.close();
        }
    }","  public void test5()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[3];
          // Undeclared exception!
          try { 
            ArticleReader.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.ArticleReader.main(ArticleReader.java:48)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1387,,"  public void test6()  throws Throwable  {
      ArticleReader articleReader0 = new ArticleReader();
  }"
1388,"    public  static List<Article> getArticleInfo(final NNTPClient client, final long lowArticleNumber, final long highArticleNumber)
    throws IOException {
        final List<Article> articles = new ArrayList<>();
        final Iterable<Article> arts = client.iterateArticleInfo(lowArticleNumber, highArticleNumber);
        for(final Article article : arts){
            articles.add(article);
        }
        return articles;
    }","  public void test0()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        NNTPUtils.getArticleInfo(nNTPClient0, (-1015L), 119);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1389,,"  public void test1()  throws Throwable  {
      NNTPUtils nNTPUtils0 = new NNTPUtils();
  }"
1390,"    public static void main(final String[] args)
    {
        final String from;
        final String subject;
        String newsgroup;
        final String fileName;
        final String server;
        final String organization;
        final String references;
        final BufferedReader stdin;
        FileReader fileReader = null;
        final SimpleNNTPHeader header;
        final NNTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: post newsserver"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            from = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleNNTPHeader(from, subject);

            System.out.print(""Newsgroup: "");
            System.out.flush();

            newsgroup = stdin.readLine();
            header.addNewsgroup(newsgroup);

            while (true)
            {
                System.out.print(""Additional Newsgroup <Hit enter to end>: "");
                System.out.flush();

                newsgroup = stdin.readLine();
                if (newsgroup == null) {
                    break;
                }

                newsgroup = newsgroup.trim();

                if (newsgroup.isEmpty()) {
                    break;
                }

                header.addNewsgroup(newsgroup);
            }

            System.out.print(""Organization: "");
            System.out.flush();

            organization = stdin.readLine();

            System.out.print(""References: "");
            System.out.flush();

            references = stdin.readLine();

            if (organization != null && !organization.isEmpty()) {
                header.addHeaderField(""Organization"", organization);
            }

            if (references != null && !references.isEmpty()) {
                header.addHeaderField(""References"", references);
            }

            header.addHeaderField(""X-Newsreader"", ""NetComponents"");

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
                System.exit(1);
            }

            client = new NNTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!NNTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""NNTP server refused connection."");
                System.exit(1);
            }

            if (client.isAllowedToPost())
            {
                final Writer writer = client.postArticle();

                if (writer != null)
                {
                    writer.write(header.toString());
                    Util.copyReader(fileReader, writer);
                    writer.close();
                    client.completePendingCommand();
                }
            }

            if (fileReader != null) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          SystemInUtil.addInputLine(""\nNewsGroups: "");
          SystemInUtil.addInputLine(""\nNewsGroups: "");
          EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""NewsGroups: "");
          FileSystemHandling.appendStringToFile(evoSuiteFile0, ""\nNewsGroups: "");
          SystemInUtil.addInputLine(""\nNewsGroups: "");
          SystemInUtil.addInputLine(""\nNewsGroups: "");
          String[] stringArray0 = new String[3];
          // Undeclared exception!
          try { 
            PostMessage.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.PostMessage.main(PostMessage.java:146)
             // sun.reflect.GeneratedMethodAccessor24.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1391,"    public static void main(final String[] args)
    {
        final String from;
        final String subject;
        String newsgroup;
        final String fileName;
        final String server;
        final String organization;
        final String references;
        final BufferedReader stdin;
        FileReader fileReader = null;
        final SimpleNNTPHeader header;
        final NNTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: post newsserver"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            from = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleNNTPHeader(from, subject);

            System.out.print(""Newsgroup: "");
            System.out.flush();

            newsgroup = stdin.readLine();
            header.addNewsgroup(newsgroup);

            while (true)
            {
                System.out.print(""Additional Newsgroup <Hit enter to end>: "");
                System.out.flush();

                newsgroup = stdin.readLine();
                if (newsgroup == null) {
                    break;
                }

                newsgroup = newsgroup.trim();

                if (newsgroup.isEmpty()) {
                    break;
                }

                header.addNewsgroup(newsgroup);
            }

            System.out.print(""Organization: "");
            System.out.flush();

            organization = stdin.readLine();

            System.out.print(""References: "");
            System.out.flush();

            references = stdin.readLine();

            if (organization != null && !organization.isEmpty()) {
                header.addHeaderField(""Organization"", organization);
            }

            if (references != null && !references.isEmpty()) {
                header.addHeaderField(""References"", references);
            }

            header.addHeaderField(""X-Newsreader"", ""NetComponents"");

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
                System.exit(1);
            }

            client = new NNTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!NNTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""NNTP server refused connection."");
                System.exit(1);
            }

            if (client.isAllowedToPost())
            {
                final Writer writer = client.postArticle();

                if (writer != null)
                {
                    writer.write(header.toString());
                    Util.copyReader(fileReader, writer);
                    writer.close();
                    client.completePendingCommand();
                }
            }

            if (fileReader != null) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        PostMessage.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.nntp.PostMessage"", e);
      }
  }"
1392,"    public static void main(final String[] args)
    {
        final String from;
        final String subject;
        String newsgroup;
        final String fileName;
        final String server;
        final String organization;
        final String references;
        final BufferedReader stdin;
        FileReader fileReader = null;
        final SimpleNNTPHeader header;
        final NNTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: post newsserver"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            from = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleNNTPHeader(from, subject);

            System.out.print(""Newsgroup: "");
            System.out.flush();

            newsgroup = stdin.readLine();
            header.addNewsgroup(newsgroup);

            while (true)
            {
                System.out.print(""Additional Newsgroup <Hit enter to end>: "");
                System.out.flush();

                newsgroup = stdin.readLine();
                if (newsgroup == null) {
                    break;
                }

                newsgroup = newsgroup.trim();

                if (newsgroup.isEmpty()) {
                    break;
                }

                header.addNewsgroup(newsgroup);
            }

            System.out.print(""Organization: "");
            System.out.flush();

            organization = stdin.readLine();

            System.out.print(""References: "");
            System.out.flush();

            references = stdin.readLine();

            if (organization != null && !organization.isEmpty()) {
                header.addHeaderField(""Organization"", organization);
            }

            if (references != null && !references.isEmpty()) {
                header.addHeaderField(""References"", references);
            }

            header.addHeaderField(""X-Newsreader"", ""NetComponents"");

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
                System.exit(1);
            }

            client = new NNTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!NNTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""NNTP server refused connection."");
                System.exit(1);
            }

            if (client.isAllowedToPost())
            {
                final Writer writer = client.postArticle();

                if (writer != null)
                {
                    writer.write(header.toString());
                    Util.copyReader(fileReader, writer);
                    writer.close();
                    client.completePendingCommand();
                }
            }

            if (fileReader != null) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test2()  throws Throwable  {
      SystemInUtil.addInputLine("""");
      String[] stringArray0 = new String[4];
      SystemInUtil.addInputLine(""Usage: post newsserver"");
      SystemInUtil.addInputLine("""");
      SystemInUtil.addInputLine("""");
      SystemInUtil.addInputLine("""");
      SystemInUtil.addInputLine(""YiU2d=oYX|]s31-Hq"");
      // Undeclared exception!
      try { 
        PostMessage.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1393,"    public static void main(final String[] args)
    {
        final String from;
        final String subject;
        String newsgroup;
        final String fileName;
        final String server;
        final String organization;
        final String references;
        final BufferedReader stdin;
        FileReader fileReader = null;
        final SimpleNNTPHeader header;
        final NNTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: post newsserver"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            from = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleNNTPHeader(from, subject);

            System.out.print(""Newsgroup: "");
            System.out.flush();

            newsgroup = stdin.readLine();
            header.addNewsgroup(newsgroup);

            while (true)
            {
                System.out.print(""Additional Newsgroup <Hit enter to end>: "");
                System.out.flush();

                newsgroup = stdin.readLine();
                if (newsgroup == null) {
                    break;
                }

                newsgroup = newsgroup.trim();

                if (newsgroup.isEmpty()) {
                    break;
                }

                header.addNewsgroup(newsgroup);
            }

            System.out.print(""Organization: "");
            System.out.flush();

            organization = stdin.readLine();

            System.out.print(""References: "");
            System.out.flush();

            references = stdin.readLine();

            if (organization != null && !organization.isEmpty()) {
                header.addHeaderField(""Organization"", organization);
            }

            if (references != null && !references.isEmpty()) {
                header.addHeaderField(""References"", references);
            }

            header.addHeaderField(""X-Newsreader"", ""NetComponents"");

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
                System.exit(1);
            }

            client = new NNTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!NNTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""NNTP server refused connection."");
                System.exit(1);
            }

            if (client.isAllowedToPost())
            {
                final Writer writer = client.postArticle();

                if (writer != null)
                {
                    writer.write(header.toString());
                    Util.copyReader(fileReader, writer);
                    writer.close();
                    client.completePendingCommand();
                }
            }

            if (fileReader != null) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test3()  throws Throwable  {
      SystemInUtil.addInputLine(""\nN&csG/{u+V[p5g "");
      SystemInUtil.addInputLine(""\nN&csG/{u+V[p5g "");
      SystemInUtil.addInputLine(""\nN&csG/{u+V[p5g "");
      SystemInUtil.addInputLine(""\nN&csG/{u+V[p5g "");
      String[] stringArray0 = new String[6];
      // Undeclared exception!
      try { 
        PostMessage.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1394,"    public static void main(final String[] args)
    {
        final String from;
        final String subject;
        String newsgroup;
        final String fileName;
        final String server;
        final String organization;
        final String references;
        final BufferedReader stdin;
        FileReader fileReader = null;
        final SimpleNNTPHeader header;
        final NNTPClient client;

        if (args.length < 1)
        {
            System.err.println(""Usage: post newsserver"");
            System.exit(1);
        }

        server = args[0];

        stdin = new BufferedReader(new InputStreamReader(System.in));

        try
        {
            System.out.print(""From: "");
            System.out.flush();

            from = stdin.readLine();

            System.out.print(""Subject: "");
            System.out.flush();

            subject = stdin.readLine();

            header = new SimpleNNTPHeader(from, subject);

            System.out.print(""Newsgroup: "");
            System.out.flush();

            newsgroup = stdin.readLine();
            header.addNewsgroup(newsgroup);

            while (true)
            {
                System.out.print(""Additional Newsgroup <Hit enter to end>: "");
                System.out.flush();

                newsgroup = stdin.readLine();
                if (newsgroup == null) {
                    break;
                }

                newsgroup = newsgroup.trim();

                if (newsgroup.isEmpty()) {
                    break;
                }

                header.addNewsgroup(newsgroup);
            }

            System.out.print(""Organization: "");
            System.out.flush();

            organization = stdin.readLine();

            System.out.print(""References: "");
            System.out.flush();

            references = stdin.readLine();

            if (organization != null && !organization.isEmpty()) {
                header.addHeaderField(""Organization"", organization);
            }

            if (references != null && !references.isEmpty()) {
                header.addHeaderField(""References"", references);
            }

            header.addHeaderField(""X-Newsreader"", ""NetComponents"");

            System.out.print(""Filename: "");
            System.out.flush();

            fileName = stdin.readLine();

            try
            {
                fileReader = new FileReader(fileName);
            }
            catch (final FileNotFoundException e)
            {
                System.err.println(""File not found. "" + e.getMessage());
                System.exit(1);
            }

            client = new NNTPClient();
            client.addProtocolCommandListener(new PrintCommandListener(
                                                  new PrintWriter(System.out), true));

            client.connect(server);

            if (!NNTPReply.isPositiveCompletion(client.getReplyCode()))
            {
                client.disconnect();
                System.err.println(""NNTP server refused connection."");
                System.exit(1);
            }

            if (client.isAllowedToPost())
            {
                final Writer writer = client.postArticle();

                if (writer != null)
                {
                    writer.write(header.toString());
                    Util.copyReader(fileReader, writer);
                    writer.close();
                    client.completePendingCommand();
                }
            }

            if (fileReader != null) {
                fileReader.close();
            }

            client.logout();

            client.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        PostMessage.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1395,,"  public void test5()  throws Throwable  {
      PostMessage postMessage0 = new PostMessage();
  }"
1396,"    public static void main(final String[] args)
    {
        if (args.length < 1)
        {
            System.err.println(""Usage: newsgroups newsserver [pattern]"");
            return;
        }

        final NNTPClient client = new NNTPClient();
        final String pattern = args.length >= 2 ? args[1] : """";

        try
        {
            client.connect(args[0]);

            int j = 0;
            try {
                for(final String s : client.iterateNewsgroupListing(pattern)) {
                    j++;
                    System.out.println(s);
                }
            } catch (final IOException e1) {
                e1.printStackTrace();
            }
            System.out.println(j);

            j = 0;
            for(final NewsgroupInfo n : client.iterateNewsgroups(pattern)) {
                j++;
                System.out.println(n.getNewsgroup());
            }
            System.out.println(j);
        }
        catch (final IOException e)
        {
            e.printStackTrace();
        }
        finally
        {
            try
            {
                if (client.isConnected()) {
                    client.disconnect();
                }
            }
            catch (final IOException e)
            {
                System.err.println(""Error disconnecting from server."");
                e.printStackTrace();
                System.exit(1);
            }
        }

    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[2];
          // Undeclared exception!
          try { 
            ListNewsgroups.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.ListNewsgroups.main(ListNewsgroups.java:49)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1397,"    public static void main(final String[] args)
    {
        if (args.length < 1)
        {
            System.err.println(""Usage: newsgroups newsserver [pattern]"");
            return;
        }

        final NNTPClient client = new NNTPClient();
        final String pattern = args.length >= 2 ? args[1] : """";

        try
        {
            client.connect(args[0]);

            int j = 0;
            try {
                for(final String s : client.iterateNewsgroupListing(pattern)) {
                    j++;
                    System.out.println(s);
                }
            } catch (final IOException e1) {
                e1.printStackTrace();
            }
            System.out.println(j);

            j = 0;
            for(final NewsgroupInfo n : client.iterateNewsgroups(pattern)) {
                j++;
                System.out.println(n.getNewsgroup());
            }
            System.out.println(j);
        }
        catch (final IOException e)
        {
            e.printStackTrace();
        }
        finally
        {
            try
            {
                if (client.isConnected()) {
                    client.disconnect();
                }
            }
            catch (final IOException e)
            {
                System.err.println(""Error disconnecting from server."");
                e.printStackTrace();
                System.exit(1);
            }
        }

    }","  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        ListNewsgroups.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.nntp.ListNewsgroups"", e);
      }
  }"
1398,"    public static void main(final String[] args)
    {
        if (args.length < 1)
        {
            System.err.println(""Usage: newsgroups newsserver [pattern]"");
            return;
        }

        final NNTPClient client = new NNTPClient();
        final String pattern = args.length >= 2 ? args[1] : """";

        try
        {
            client.connect(args[0]);

            int j = 0;
            try {
                for(final String s : client.iterateNewsgroupListing(pattern)) {
                    j++;
                    System.out.println(s);
                }
            } catch (final IOException e1) {
                e1.printStackTrace();
            }
            System.out.println(j);

            j = 0;
            for(final NewsgroupInfo n : client.iterateNewsgroups(pattern)) {
                j++;
                System.out.println(n.getNewsgroup());
            }
            System.out.println(j);
        }
        catch (final IOException e)
        {
            e.printStackTrace();
        }
        finally
        {
            try
            {
                if (client.isConnected()) {
                    client.disconnect();
                }
            }
            catch (final IOException e)
            {
                System.err.println(""Error disconnecting from server."");
                e.printStackTrace();
                System.exit(1);
            }
        }

    }","  public void test2()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          // Undeclared exception!
          try { 
            ListNewsgroups.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.ListNewsgroups.main(ListNewsgroups.java:49)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1399,"    public static void main(final String[] args)
    {
        if (args.length < 1)
        {
            System.err.println(""Usage: newsgroups newsserver [pattern]"");
            return;
        }

        final NNTPClient client = new NNTPClient();
        final String pattern = args.length >= 2 ? args[1] : """";

        try
        {
            client.connect(args[0]);

            int j = 0;
            try {
                for(final String s : client.iterateNewsgroupListing(pattern)) {
                    j++;
                    System.out.println(s);
                }
            } catch (final IOException e1) {
                e1.printStackTrace();
            }
            System.out.println(j);

            j = 0;
            for(final NewsgroupInfo n : client.iterateNewsgroups(pattern)) {
                j++;
                System.out.println(n.getNewsgroup());
            }
            System.out.println(j);
        }
        catch (final IOException e)
        {
            e.printStackTrace();
        }
        finally
        {
            try
            {
                if (client.isConnected()) {
                    client.disconnect();
                }
            }
            catch (final IOException e)
            {
                System.err.println(""Error disconnecting from server."");
                e.printStackTrace();
                System.exit(1);
            }
        }

    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[0];
      ListNewsgroups.main(stringArray0);
}"
1400,"    public static void main(final String[] args)
    {
        if (args.length < 1)
        {
            System.err.println(""Usage: newsgroups newsserver [pattern]"");
            return;
        }

        final NNTPClient client = new NNTPClient();
        final String pattern = args.length >= 2 ? args[1] : """";

        try
        {
            client.connect(args[0]);

            int j = 0;
            try {
                for(final String s : client.iterateNewsgroupListing(pattern)) {
                    j++;
                    System.out.println(s);
                }
            } catch (final IOException e1) {
                e1.printStackTrace();
            }
            System.out.println(j);

            j = 0;
            for(final NewsgroupInfo n : client.iterateNewsgroups(pattern)) {
                j++;
                System.out.println(n.getNewsgroup());
            }
            System.out.println(j);
        }
        catch (final IOException e)
        {
            e.printStackTrace();
        }
        finally
        {
            try
            {
                if (client.isConnected()) {
                    client.disconnect();
                }
            }
            catch (final IOException e)
            {
                System.err.println(""Error disconnecting from server."");
                e.printStackTrace();
                System.exit(1);
            }
        }

    }","  public void test4()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[18];
          // Undeclared exception!
          try { 
            ListNewsgroups.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.ListNewsgroups.main(ListNewsgroups.java:49)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1401,,"  public void test5()  throws Throwable  {
      ListNewsgroups listNewsgroups0 = new ListNewsgroups();
  }"
1402,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 4) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<user> <password>]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 4) { // Optional auth
            final String user = args[2];
            final String password = args[3];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final String fmt[] = client.listOverviewFmt();
        if (fmt != null) {
            System.out.println(""LIST OVERVIEW.FMT:"");
            for(final String s : fmt) {
                System.out.println(s);
            }
        } else {
            System.out.println(""Failed to get OVERVIEW.FMT"");
        }
        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final long lowArticleNumber = group.getFirstArticleLong();
        final long highArticleNumber = lowArticleNumber + 5000;

        System.out.println(""Retrieving articles between ["" + lowArticleNumber + ""] and ["" + highArticleNumber + ""]"");
        final Iterable<Article> articles = client.iterateArticleInfo(lowArticleNumber, highArticleNumber);

        System.out.println(""Building message thread tree..."");
        final Threader threader = new Threader();
        final Article root = (Article)threader.thread(articles);

        Article.printThread(root, 0);
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[4];
          stringArray0[0] = ""3mHd*,cpk :bh\""~"";
          // Undeclared exception!
          try { 
            MessageThreading.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.MessageThreading.main(MessageThreading.java:50)
             // sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1403,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 4) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<user> <password>]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 4) { // Optional auth
            final String user = args[2];
            final String password = args[3];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final String fmt[] = client.listOverviewFmt();
        if (fmt != null) {
            System.out.println(""LIST OVERVIEW.FMT:"");
            for(final String s : fmt) {
                System.out.println(s);
            }
        } else {
            System.out.println(""Failed to get OVERVIEW.FMT"");
        }
        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final long lowArticleNumber = group.getFirstArticleLong();
        final long highArticleNumber = lowArticleNumber + 5000;

        System.out.println(""Retrieving articles between ["" + lowArticleNumber + ""] and ["" + highArticleNumber + ""]"");
        final Iterable<Article> articles = client.iterateArticleInfo(lowArticleNumber, highArticleNumber);

        System.out.println(""Building message thread tree..."");
        final Threader threader = new Threader();
        final Article root = (Article)threader.thread(articles);

        Article.printThread(root, 0);
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[0];
      MessageThreading.main(stringArray0);
}"
1404,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 4) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<user> <password>]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 4) { // Optional auth
            final String user = args[2];
            final String password = args[3];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final String fmt[] = client.listOverviewFmt();
        if (fmt != null) {
            System.out.println(""LIST OVERVIEW.FMT:"");
            for(final String s : fmt) {
                System.out.println(s);
            }
        } else {
            System.out.println(""Failed to get OVERVIEW.FMT"");
        }
        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final long lowArticleNumber = group.getFirstArticleLong();
        final long highArticleNumber = lowArticleNumber + 5000;

        System.out.println(""Retrieving articles between ["" + lowArticleNumber + ""] and ["" + highArticleNumber + ""]"");
        final Iterable<Article> articles = client.iterateArticleInfo(lowArticleNumber, highArticleNumber);

        System.out.println(""Building message thread tree..."");
        final Threader threader = new Threader();
        final Article root = (Article)threader.thread(articles);

        Article.printThread(root, 0);
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        MessageThreading.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.nntp.MessageThreading"", e);
      }
  }"
1405,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 4) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<user> <password>]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 4) { // Optional auth
            final String user = args[2];
            final String password = args[3];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final String fmt[] = client.listOverviewFmt();
        if (fmt != null) {
            System.out.println(""LIST OVERVIEW.FMT:"");
            for(final String s : fmt) {
                System.out.println(s);
            }
        } else {
            System.out.println(""Failed to get OVERVIEW.FMT"");
        }
        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final long lowArticleNumber = group.getFirstArticleLong();
        final long highArticleNumber = lowArticleNumber + 5000;

        System.out.println(""Retrieving articles between ["" + lowArticleNumber + ""] and ["" + highArticleNumber + ""]"");
        final Iterable<Article> articles = client.iterateArticleInfo(lowArticleNumber, highArticleNumber);

        System.out.println(""Building message thread tree..."");
        final Threader threader = new Threader();
        final Article root = (Article)threader.thread(articles);

        Article.printThread(root, 0);
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[7];
      MessageThreading.main(stringArray0);
}"
1406,"    public static void main(final String[] args) throws SocketException, IOException {

        if (args.length != 2 && args.length != 4) {
            System.out.println(""Usage: MessageThreading <hostname> <groupname> [<user> <password>]"");
            return;
        }

        final String hostname = args[0];
        final String newsgroup = args[1];

        final NNTPClient client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
        client.connect(hostname);

        if (args.length == 4) { // Optional auth
            final String user = args[2];
            final String password = args[3];
            if(!client.authenticate(user, password)) {
                System.out.println(""Authentication failed for user "" + user + ""!"");
                System.exit(1);
            }
        }

        final String fmt[] = client.listOverviewFmt();
        if (fmt != null) {
            System.out.println(""LIST OVERVIEW.FMT:"");
            for(final String s : fmt) {
                System.out.println(s);
            }
        } else {
            System.out.println(""Failed to get OVERVIEW.FMT"");
        }
        final NewsgroupInfo group = new NewsgroupInfo();
        client.selectNewsgroup(newsgroup, group);

        final long lowArticleNumber = group.getFirstArticleLong();
        final long highArticleNumber = lowArticleNumber + 5000;

        System.out.println(""Retrieving articles between ["" + lowArticleNumber + ""] and ["" + highArticleNumber + ""]"");
        final Iterable<Article> articles = client.iterateArticleInfo(lowArticleNumber, highArticleNumber);

        System.out.println(""Building message thread tree..."");
        final Threader threader = new Threader();
        final Article root = (Article)threader.thread(articles);

        Article.printThread(root, 0);
    }","  public void test4()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[2];
          // Undeclared exception!
          try { 
            MessageThreading.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.MessageThreading.main(MessageThreading.java:50)
             // sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1407,"    public MessageThreading() {
    }","  public void test5()  throws Throwable  {
      MessageThreading messageThreading0 = new MessageThreading();
  }"
1408,"    public static void main(final String[] args) {
        final ExtendedNNTPOps ops;

        final int argc = args.length;
        if (argc < 1) {
            System.err.println(""usage: ExtendedNNTPOps nntpserver [username password]"");
            System.exit(1);
        }

        ops = new ExtendedNNTPOps();
        ops.demo(args[0], argc >=3 ? args[1] : null, argc >=3 ? args[2] : null);
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[3];
          // Undeclared exception!
          try { 
            ExtendedNNTPOps.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.ExtendedNNTPOps.demo(ExtendedNNTPOps.java:45)
             // org.apache.commons.net.examples.nntp.ExtendedNNTPOps.main(ExtendedNNTPOps.java:94)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1409,"    public static void main(final String[] args) {
        final ExtendedNNTPOps ops;

        final int argc = args.length;
        if (argc < 1) {
            System.err.println(""usage: ExtendedNNTPOps nntpserver [username password]"");
            System.exit(1);
        }

        ops = new ExtendedNNTPOps();
        ops.demo(args[0], argc >=3 ? args[1] : null, argc >=3 ? args[2] : null);
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[1];
          stringArray0[0] = """";
          // Undeclared exception!
          try { 
            ExtendedNNTPOps.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.ExtendedNNTPOps.demo(ExtendedNNTPOps.java:45)
             // org.apache.commons.net.examples.nntp.ExtendedNNTPOps.main(ExtendedNNTPOps.java:94)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1410,"    public static void main(final String[] args) {
        final ExtendedNNTPOps ops;

        final int argc = args.length;
        if (argc < 1) {
            System.err.println(""usage: ExtendedNNTPOps nntpserver [username password]"");
            System.exit(1);
        }

        ops = new ExtendedNNTPOps();
        ops.demo(args[0], argc >=3 ? args[1] : null, argc >=3 ? args[2] : null);
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        ExtendedNNTPOps.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.nntp.ExtendedNNTPOps"", e);
      }
  }"
1411,"    public ExtendedNNTPOps() {
        client = new NNTPClient();
        client.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
    }","  public void test3()  throws Throwable  {
      ExtendedNNTPOps extendedNNTPOps0 = new ExtendedNNTPOps();
  }"
1412,"    public static void main(final String[] args) {
        final ExtendedNNTPOps ops;

        final int argc = args.length;
        if (argc < 1) {
            System.err.println(""usage: ExtendedNNTPOps nntpserver [username password]"");
            System.exit(1);
        }

        ops = new ExtendedNNTPOps();
        ops.demo(args[0], argc >=3 ? args[1] : null, argc >=3 ? args[2] : null);
    }","  public void test4()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[6];
          // Undeclared exception!
          try { 
            ExtendedNNTPOps.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:119\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.nntp.ExtendedNNTPOps.demo(ExtendedNNTPOps.java:45)
             // org.apache.commons.net.examples.nntp.ExtendedNNTPOps.main(ExtendedNNTPOps.java:94)
             // sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1413,"    public static void main(final String[] args) {
        final ExtendedNNTPOps ops;

        final int argc = args.length;
        if (argc < 1) {
            System.err.println(""usage: ExtendedNNTPOps nntpserver [username password]"");
            System.exit(1);
        }

        ops = new ExtendedNNTPOps();
        ops.demo(args[0], argc >=3 ? args[1] : null, argc >=3 ? args[2] : null);
    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        ExtendedNNTPOps.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1414,,"  public void test0()  throws Throwable  {
      WeatherTelnet weatherTelnet0 = new WeatherTelnet();
  }"
1415,"    public static void main(final String[] args)
    {
        final TelnetClient telnet;

        telnet = new TelnetClient();

        try
        {
            telnet.connect(""rainmaker.wunderground.com"", 3000);
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        IOUtil.readWrite(telnet.getInputStream(), telnet.getOutputStream(),
                         System.in, System.out);

        try
        {
            telnet.disconnect();
        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }

        System.exit(0);
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[11];
          // Undeclared exception!
          try { 
            WeatherTelnet.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:3000\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.examples.telnet.WeatherTelnet.main(WeatherTelnet.java:49)
             // sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
             // sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1416,"    public static void main(final String[] args) throws Exception
    {
        FileOutputStream fout = null;

        if(args.length < 1)
        {
            System.err.println(""Usage: TelnetClientExample <remote-ip> [<remote-port>]"");
            System.exit(1);
        }

        final String remoteip = args[0];

        final int remoteport;

        if (args.length > 1)
        {
            remoteport = Integer.parseInt(args[1]);
        }
        else
        {
            remoteport = 23;
        }

        try
        {
            fout = new FileOutputStream (""spy.log"", true);
        }
        catch (final IOException e)
        {
            System.err.println(
                ""Exception while opening the spy file: ""
                + e.getMessage());
        }

        tc = new TelnetClient();

        final TerminalTypeOptionHandler ttopt = new TerminalTypeOptionHandler(""VT100"", false, false, true, false);
        final EchoOptionHandler echoopt = new EchoOptionHandler(true, false, true, false);
        final SuppressGAOptionHandler gaopt = new SuppressGAOptionHandler(true, true, true, true);

        try
        {
            tc.addOptionHandler(ttopt);
            tc.addOptionHandler(echoopt);
            tc.addOptionHandler(gaopt);
        }
        catch (final InvalidTelnetOptionException e)
        {
            System.err.println(""Error registering option handlers: "" + e.getMessage());
        }

        while (true)
        {
            boolean end_loop = false;
            try
            {
                tc.connect(remoteip, remoteport);


                final Thread reader = new Thread (new TelnetClientExample());
                tc.registerNotifHandler(new TelnetClientExample());
                System.out.println(""TelnetClientExample"");
                System.out.println(""Type AYT to send an AYT telnet command"");
                System.out.println(""Type OPT to print a report of status of options (0-24)"");
                System.out.println(""Type REGISTER to register a new SimpleOptionHandler"");
                System.out.println(""Type UNREGISTER to unregister an OptionHandler"");
                System.out.println(""Type SPY to register the spy (connect to port 3333 to spy)"");
                System.out.println(""Type UNSPY to stop spying the connection"");
                System.out.println(""Type ^[A-Z] to send the control character; use ^^ to send ^"");

                reader.start();
                final OutputStream outstr = tc.getOutputStream();

                final byte[] buff = new byte[1024];
                int ret_read = 0;

                do
                {
                    try
                    {
                        ret_read = System.in.read(buff);
                        if(ret_read > 0)
                        {
                            final String line = new String(buff, 0, ret_read); // deliberate use of default charset
                            if(line.startsWith(""AYT""))
                            {
                                try
                                {
                                    System.out.println(""Sending AYT"");

                                    System.out.println(""AYT response:"" + tc.sendAYT(5000));
                                }
                                catch (final IOException e)
                                {
                                    System.err.println(""Exception waiting AYT response: "" + e.getMessage());
                                }
                            }
                            else if(line.startsWith(""OPT""))
                            {
                                 System.out.println(""Status of options:"");
                                 for(int ii=0; ii<25; ii++) {
                                     System.out.println(""Local Option "" + ii + "":"" + tc.getLocalOptionState(ii) +
                                                        "" Remote Option "" + ii + "":"" + tc.getRemoteOptionState(ii));
                                 }
                            }
                            else if(line.startsWith(""REGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    final boolean initlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean initremote = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptremote = Boolean.parseBoolean(st.nextToken());
                                    final SimpleOptionHandler opthand = new SimpleOptionHandler(opcode, initlocal, initremote,
                                                                    acceptlocal, acceptremote);
                                    tc.addOptionHandler(opthand);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error registering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid REGISTER command."");
                                        System.err.println(""Use REGISTER optcode initlocal initremote acceptlocal acceptremote"");
                                        System.err.println(""(optcode is an integer.)"");
                                        System.err.println(""(initlocal, initremote, acceptlocal, acceptremote are boolean)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""UNREGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    tc.deleteOptionHandler(opcode);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error unregistering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid UNREGISTER command."");
                                        System.err.println(""Use UNREGISTER optcode"");
                                        System.err.println(""(optcode is an integer)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""SPY""))
                            {
                                tc.registerSpyStream(fout);
                            }
                            else if(line.startsWith(""UNSPY""))
                            {
                                tc.stopSpyStream();
                            }
                            else if(line.matches(""^\\^[A-Z^]\\r?\\n?$""))
                            {
                                final byte toSend = buff[1];
                                if (toSend == '^') {
                                    outstr.write(toSend);
                                } else {
                                    outstr.write(toSend - 'A' + 1);
                                }
                                outstr.flush();
                            }
                            else
                            {
                                try
                                {
                                        outstr.write(buff, 0 , ret_read);
                                        outstr.flush();
                                }
                                catch (final IOException e)
                                {
                                        end_loop = true;
                                }
                            }
                        }
                    }
                    catch (final IOException e)
                    {
                        System.err.println(""Exception while reading keyboard:"" + e.getMessage());
                        end_loop = true;
                    }
                }
                while(ret_read > 0 && end_loop == false);

                try
                {
                    tc.disconnect();
                }
                catch (final IOException e)
                {
                          System.err.println(""Exception while connecting:"" + e.getMessage());
                }
            }
            catch (final IOException e)
            {
                    System.err.println(""Exception while connecting:"" + e.getMessage());
                    System.exit(1);
            }
        }
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""spy.log"");
          FileSystemHandling.createFolder(evoSuiteFile0);
          String[] stringArray0 = new String[1];
          try { 
            TelnetClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:23\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.examples.telnet.TelnetClientExample.main(TelnetClientExample.java:113)
             // sun.reflect.GeneratedMethodAccessor27.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1417,"    public void run()
    {
        final InputStream instr = tc.getInputStream();

        try
        {
            final byte[] buff = new byte[1024];
            int ret_read = 0;

            do
            {
                ret_read = instr.read(buff);
                if(ret_read > 0)
                {
                    System.out.print(new String(buff, 0, ret_read));
                }
            }
            while (ret_read >= 0);
        }
        catch (final IOException e)
        {
            System.err.println(""Exception while reading socket:"" + e.getMessage());
        }

        try
        {
            tc.disconnect();
        }
        catch (final IOException e)
        {
            System.err.println(""Exception while closing telnet:"" + e.getMessage());
        }
    }","  public void test1()  throws Throwable  {
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      // Undeclared exception!
      try { 
        telnetClientExample0.run();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.telnet.TelnetClientExample"", e);
      }
  }"
1418,"    public static void main(final String[] args) throws Exception
    {
        FileOutputStream fout = null;

        if(args.length < 1)
        {
            System.err.println(""Usage: TelnetClientExample <remote-ip> [<remote-port>]"");
            System.exit(1);
        }

        final String remoteip = args[0];

        final int remoteport;

        if (args.length > 1)
        {
            remoteport = Integer.parseInt(args[1]);
        }
        else
        {
            remoteport = 23;
        }

        try
        {
            fout = new FileOutputStream (""spy.log"", true);
        }
        catch (final IOException e)
        {
            System.err.println(
                ""Exception while opening the spy file: ""
                + e.getMessage());
        }

        tc = new TelnetClient();

        final TerminalTypeOptionHandler ttopt = new TerminalTypeOptionHandler(""VT100"", false, false, true, false);
        final EchoOptionHandler echoopt = new EchoOptionHandler(true, false, true, false);
        final SuppressGAOptionHandler gaopt = new SuppressGAOptionHandler(true, true, true, true);

        try
        {
            tc.addOptionHandler(ttopt);
            tc.addOptionHandler(echoopt);
            tc.addOptionHandler(gaopt);
        }
        catch (final InvalidTelnetOptionException e)
        {
            System.err.println(""Error registering option handlers: "" + e.getMessage());
        }

        while (true)
        {
            boolean end_loop = false;
            try
            {
                tc.connect(remoteip, remoteport);


                final Thread reader = new Thread (new TelnetClientExample());
                tc.registerNotifHandler(new TelnetClientExample());
                System.out.println(""TelnetClientExample"");
                System.out.println(""Type AYT to send an AYT telnet command"");
                System.out.println(""Type OPT to print a report of status of options (0-24)"");
                System.out.println(""Type REGISTER to register a new SimpleOptionHandler"");
                System.out.println(""Type UNREGISTER to unregister an OptionHandler"");
                System.out.println(""Type SPY to register the spy (connect to port 3333 to spy)"");
                System.out.println(""Type UNSPY to stop spying the connection"");
                System.out.println(""Type ^[A-Z] to send the control character; use ^^ to send ^"");

                reader.start();
                final OutputStream outstr = tc.getOutputStream();

                final byte[] buff = new byte[1024];
                int ret_read = 0;

                do
                {
                    try
                    {
                        ret_read = System.in.read(buff);
                        if(ret_read > 0)
                        {
                            final String line = new String(buff, 0, ret_read); // deliberate use of default charset
                            if(line.startsWith(""AYT""))
                            {
                                try
                                {
                                    System.out.println(""Sending AYT"");

                                    System.out.println(""AYT response:"" + tc.sendAYT(5000));
                                }
                                catch (final IOException e)
                                {
                                    System.err.println(""Exception waiting AYT response: "" + e.getMessage());
                                }
                            }
                            else if(line.startsWith(""OPT""))
                            {
                                 System.out.println(""Status of options:"");
                                 for(int ii=0; ii<25; ii++) {
                                     System.out.println(""Local Option "" + ii + "":"" + tc.getLocalOptionState(ii) +
                                                        "" Remote Option "" + ii + "":"" + tc.getRemoteOptionState(ii));
                                 }
                            }
                            else if(line.startsWith(""REGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    final boolean initlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean initremote = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptremote = Boolean.parseBoolean(st.nextToken());
                                    final SimpleOptionHandler opthand = new SimpleOptionHandler(opcode, initlocal, initremote,
                                                                    acceptlocal, acceptremote);
                                    tc.addOptionHandler(opthand);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error registering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid REGISTER command."");
                                        System.err.println(""Use REGISTER optcode initlocal initremote acceptlocal acceptremote"");
                                        System.err.println(""(optcode is an integer.)"");
                                        System.err.println(""(initlocal, initremote, acceptlocal, acceptremote are boolean)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""UNREGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    tc.deleteOptionHandler(opcode);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error unregistering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid UNREGISTER command."");
                                        System.err.println(""Use UNREGISTER optcode"");
                                        System.err.println(""(optcode is an integer)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""SPY""))
                            {
                                tc.registerSpyStream(fout);
                            }
                            else if(line.startsWith(""UNSPY""))
                            {
                                tc.stopSpyStream();
                            }
                            else if(line.matches(""^\\^[A-Z^]\\r?\\n?$""))
                            {
                                final byte toSend = buff[1];
                                if (toSend == '^') {
                                    outstr.write(toSend);
                                } else {
                                    outstr.write(toSend - 'A' + 1);
                                }
                                outstr.flush();
                            }
                            else
                            {
                                try
                                {
                                        outstr.write(buff, 0 , ret_read);
                                        outstr.flush();
                                }
                                catch (final IOException e)
                                {
                                        end_loop = true;
                                }
                            }
                        }
                    }
                    catch (final IOException e)
                    {
                        System.err.println(""Exception while reading keyboard:"" + e.getMessage());
                        end_loop = true;
                    }
                }
                while(ret_read > 0 && end_loop == false);

                try
                {
                    tc.disconnect();
                }
                catch (final IOException e)
                {
                          System.err.println(""Exception while connecting:"" + e.getMessage());
                }
            }
            catch (final IOException e)
            {
                    System.err.println(""Exception while connecting:"" + e.getMessage());
                    System.exit(1);
            }
        }
    }","  public void test2()  throws Throwable  {
      try { 
        TelnetClientExample.main((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.telnet.TelnetClientExample"", e);
      }
  }"
1419,"    public static void main(final String[] args) throws Exception
    {
        FileOutputStream fout = null;

        if(args.length < 1)
        {
            System.err.println(""Usage: TelnetClientExample <remote-ip> [<remote-port>]"");
            System.exit(1);
        }

        final String remoteip = args[0];

        final int remoteport;

        if (args.length > 1)
        {
            remoteport = Integer.parseInt(args[1]);
        }
        else
        {
            remoteport = 23;
        }

        try
        {
            fout = new FileOutputStream (""spy.log"", true);
        }
        catch (final IOException e)
        {
            System.err.println(
                ""Exception while opening the spy file: ""
                + e.getMessage());
        }

        tc = new TelnetClient();

        final TerminalTypeOptionHandler ttopt = new TerminalTypeOptionHandler(""VT100"", false, false, true, false);
        final EchoOptionHandler echoopt = new EchoOptionHandler(true, false, true, false);
        final SuppressGAOptionHandler gaopt = new SuppressGAOptionHandler(true, true, true, true);

        try
        {
            tc.addOptionHandler(ttopt);
            tc.addOptionHandler(echoopt);
            tc.addOptionHandler(gaopt);
        }
        catch (final InvalidTelnetOptionException e)
        {
            System.err.println(""Error registering option handlers: "" + e.getMessage());
        }

        while (true)
        {
            boolean end_loop = false;
            try
            {
                tc.connect(remoteip, remoteport);


                final Thread reader = new Thread (new TelnetClientExample());
                tc.registerNotifHandler(new TelnetClientExample());
                System.out.println(""TelnetClientExample"");
                System.out.println(""Type AYT to send an AYT telnet command"");
                System.out.println(""Type OPT to print a report of status of options (0-24)"");
                System.out.println(""Type REGISTER to register a new SimpleOptionHandler"");
                System.out.println(""Type UNREGISTER to unregister an OptionHandler"");
                System.out.println(""Type SPY to register the spy (connect to port 3333 to spy)"");
                System.out.println(""Type UNSPY to stop spying the connection"");
                System.out.println(""Type ^[A-Z] to send the control character; use ^^ to send ^"");

                reader.start();
                final OutputStream outstr = tc.getOutputStream();

                final byte[] buff = new byte[1024];
                int ret_read = 0;

                do
                {
                    try
                    {
                        ret_read = System.in.read(buff);
                        if(ret_read > 0)
                        {
                            final String line = new String(buff, 0, ret_read); // deliberate use of default charset
                            if(line.startsWith(""AYT""))
                            {
                                try
                                {
                                    System.out.println(""Sending AYT"");

                                    System.out.println(""AYT response:"" + tc.sendAYT(5000));
                                }
                                catch (final IOException e)
                                {
                                    System.err.println(""Exception waiting AYT response: "" + e.getMessage());
                                }
                            }
                            else if(line.startsWith(""OPT""))
                            {
                                 System.out.println(""Status of options:"");
                                 for(int ii=0; ii<25; ii++) {
                                     System.out.println(""Local Option "" + ii + "":"" + tc.getLocalOptionState(ii) +
                                                        "" Remote Option "" + ii + "":"" + tc.getRemoteOptionState(ii));
                                 }
                            }
                            else if(line.startsWith(""REGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    final boolean initlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean initremote = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptremote = Boolean.parseBoolean(st.nextToken());
                                    final SimpleOptionHandler opthand = new SimpleOptionHandler(opcode, initlocal, initremote,
                                                                    acceptlocal, acceptremote);
                                    tc.addOptionHandler(opthand);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error registering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid REGISTER command."");
                                        System.err.println(""Use REGISTER optcode initlocal initremote acceptlocal acceptremote"");
                                        System.err.println(""(optcode is an integer.)"");
                                        System.err.println(""(initlocal, initremote, acceptlocal, acceptremote are boolean)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""UNREGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    tc.deleteOptionHandler(opcode);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error unregistering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid UNREGISTER command."");
                                        System.err.println(""Use UNREGISTER optcode"");
                                        System.err.println(""(optcode is an integer)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""SPY""))
                            {
                                tc.registerSpyStream(fout);
                            }
                            else if(line.startsWith(""UNSPY""))
                            {
                                tc.stopSpyStream();
                            }
                            else if(line.matches(""^\\^[A-Z^]\\r?\\n?$""))
                            {
                                final byte toSend = buff[1];
                                if (toSend == '^') {
                                    outstr.write(toSend);
                                } else {
                                    outstr.write(toSend - 'A' + 1);
                                }
                                outstr.flush();
                            }
                            else
                            {
                                try
                                {
                                        outstr.write(buff, 0 , ret_read);
                                        outstr.flush();
                                }
                                catch (final IOException e)
                                {
                                        end_loop = true;
                                }
                            }
                        }
                    }
                    catch (final IOException e)
                    {
                        System.err.println(""Exception while reading keyboard:"" + e.getMessage());
                        end_loop = true;
                    }
                }
                while(ret_read > 0 && end_loop == false);

                try
                {
                    tc.disconnect();
                }
                catch (final IOException e)
                {
                          System.err.println(""Exception while connecting:"" + e.getMessage());
                }
            }
            catch (final IOException e)
            {
                    System.err.println(""Exception while connecting:"" + e.getMessage());
                    System.exit(1);
            }
        }
    }","  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[1] = ""-8"";
      try { 
        TelnetClientExample.main(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-8
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
1420,"    public void receivedNegotiation(final int negotiation_code, final int option_code)
    {
        String command = null;
        switch (negotiation_code) {
            case TelnetNotificationHandler.RECEIVED_DO:
                command = ""DO"";
                break;
            case TelnetNotificationHandler.RECEIVED_DONT:
                command = ""DONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_WILL:
                command = ""WILL"";
                break;
            case TelnetNotificationHandler.RECEIVED_WONT:
                command = ""WONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_COMMAND:
                command = ""COMMAND"";
                break;
            default:
                command = Integer.toString(negotiation_code); // Should not happen
                break;
        }
        System.out.println(""Received "" + command + "" for option code "" + option_code);
   }","  public void test4()  throws Throwable  {
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnetClientExample0.receivedNegotiation(5, 5);
  }"
1421,"    public void receivedNegotiation(final int negotiation_code, final int option_code)
    {
        String command = null;
        switch (negotiation_code) {
            case TelnetNotificationHandler.RECEIVED_DO:
                command = ""DO"";
                break;
            case TelnetNotificationHandler.RECEIVED_DONT:
                command = ""DONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_WILL:
                command = ""WILL"";
                break;
            case TelnetNotificationHandler.RECEIVED_WONT:
                command = ""WONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_COMMAND:
                command = ""COMMAND"";
                break;
            default:
                command = Integer.toString(negotiation_code); // Should not happen
                break;
        }
        System.out.println(""Received "" + command + "" for option code "" + option_code);
   }","  public void test5()  throws Throwable  {
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnetClientExample0.receivedNegotiation(4, 4);
  }"
1422,"    public void receivedNegotiation(final int negotiation_code, final int option_code)
    {
        String command = null;
        switch (negotiation_code) {
            case TelnetNotificationHandler.RECEIVED_DO:
                command = ""DO"";
                break;
            case TelnetNotificationHandler.RECEIVED_DONT:
                command = ""DONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_WILL:
                command = ""WILL"";
                break;
            case TelnetNotificationHandler.RECEIVED_WONT:
                command = ""WONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_COMMAND:
                command = ""COMMAND"";
                break;
            default:
                command = Integer.toString(negotiation_code); // Should not happen
                break;
        }
        System.out.println(""Received "" + command + "" for option code "" + option_code);
   }","  public void test6()  throws Throwable  {
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnetClientExample0.receivedNegotiation(3, 3);
  }"
1423,"    public void receivedNegotiation(final int negotiation_code, final int option_code)
    {
        String command = null;
        switch (negotiation_code) {
            case TelnetNotificationHandler.RECEIVED_DO:
                command = ""DO"";
                break;
            case TelnetNotificationHandler.RECEIVED_DONT:
                command = ""DONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_WILL:
                command = ""WILL"";
                break;
            case TelnetNotificationHandler.RECEIVED_WONT:
                command = ""WONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_COMMAND:
                command = ""COMMAND"";
                break;
            default:
                command = Integer.toString(negotiation_code); // Should not happen
                break;
        }
        System.out.println(""Received "" + command + "" for option code "" + option_code);
   }","  public void test7()  throws Throwable  {
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnetClientExample0.receivedNegotiation(2, 1699);
  }"
1424,"    public void receivedNegotiation(final int negotiation_code, final int option_code)
    {
        String command = null;
        switch (negotiation_code) {
            case TelnetNotificationHandler.RECEIVED_DO:
                command = ""DO"";
                break;
            case TelnetNotificationHandler.RECEIVED_DONT:
                command = ""DONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_WILL:
                command = ""WILL"";
                break;
            case TelnetNotificationHandler.RECEIVED_WONT:
                command = ""WONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_COMMAND:
                command = ""COMMAND"";
                break;
            default:
                command = Integer.toString(negotiation_code); // Should not happen
                break;
        }
        System.out.println(""Received "" + command + "" for option code "" + option_code);
   }","  public void test8()  throws Throwable  {
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnetClientExample0.receivedNegotiation(1148, 1);
  }"
1425,"    public static void main(final String[] args) throws Exception
    {
        FileOutputStream fout = null;

        if(args.length < 1)
        {
            System.err.println(""Usage: TelnetClientExample <remote-ip> [<remote-port>]"");
            System.exit(1);
        }

        final String remoteip = args[0];

        final int remoteport;

        if (args.length > 1)
        {
            remoteport = Integer.parseInt(args[1]);
        }
        else
        {
            remoteport = 23;
        }

        try
        {
            fout = new FileOutputStream (""spy.log"", true);
        }
        catch (final IOException e)
        {
            System.err.println(
                ""Exception while opening the spy file: ""
                + e.getMessage());
        }

        tc = new TelnetClient();

        final TerminalTypeOptionHandler ttopt = new TerminalTypeOptionHandler(""VT100"", false, false, true, false);
        final EchoOptionHandler echoopt = new EchoOptionHandler(true, false, true, false);
        final SuppressGAOptionHandler gaopt = new SuppressGAOptionHandler(true, true, true, true);

        try
        {
            tc.addOptionHandler(ttopt);
            tc.addOptionHandler(echoopt);
            tc.addOptionHandler(gaopt);
        }
        catch (final InvalidTelnetOptionException e)
        {
            System.err.println(""Error registering option handlers: "" + e.getMessage());
        }

        while (true)
        {
            boolean end_loop = false;
            try
            {
                tc.connect(remoteip, remoteport);


                final Thread reader = new Thread (new TelnetClientExample());
                tc.registerNotifHandler(new TelnetClientExample());
                System.out.println(""TelnetClientExample"");
                System.out.println(""Type AYT to send an AYT telnet command"");
                System.out.println(""Type OPT to print a report of status of options (0-24)"");
                System.out.println(""Type REGISTER to register a new SimpleOptionHandler"");
                System.out.println(""Type UNREGISTER to unregister an OptionHandler"");
                System.out.println(""Type SPY to register the spy (connect to port 3333 to spy)"");
                System.out.println(""Type UNSPY to stop spying the connection"");
                System.out.println(""Type ^[A-Z] to send the control character; use ^^ to send ^"");

                reader.start();
                final OutputStream outstr = tc.getOutputStream();

                final byte[] buff = new byte[1024];
                int ret_read = 0;

                do
                {
                    try
                    {
                        ret_read = System.in.read(buff);
                        if(ret_read > 0)
                        {
                            final String line = new String(buff, 0, ret_read); // deliberate use of default charset
                            if(line.startsWith(""AYT""))
                            {
                                try
                                {
                                    System.out.println(""Sending AYT"");

                                    System.out.println(""AYT response:"" + tc.sendAYT(5000));
                                }
                                catch (final IOException e)
                                {
                                    System.err.println(""Exception waiting AYT response: "" + e.getMessage());
                                }
                            }
                            else if(line.startsWith(""OPT""))
                            {
                                 System.out.println(""Status of options:"");
                                 for(int ii=0; ii<25; ii++) {
                                     System.out.println(""Local Option "" + ii + "":"" + tc.getLocalOptionState(ii) +
                                                        "" Remote Option "" + ii + "":"" + tc.getRemoteOptionState(ii));
                                 }
                            }
                            else if(line.startsWith(""REGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    final boolean initlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean initremote = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptremote = Boolean.parseBoolean(st.nextToken());
                                    final SimpleOptionHandler opthand = new SimpleOptionHandler(opcode, initlocal, initremote,
                                                                    acceptlocal, acceptremote);
                                    tc.addOptionHandler(opthand);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error registering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid REGISTER command."");
                                        System.err.println(""Use REGISTER optcode initlocal initremote acceptlocal acceptremote"");
                                        System.err.println(""(optcode is an integer.)"");
                                        System.err.println(""(initlocal, initremote, acceptlocal, acceptremote are boolean)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""UNREGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    tc.deleteOptionHandler(opcode);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error unregistering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid UNREGISTER command."");
                                        System.err.println(""Use UNREGISTER optcode"");
                                        System.err.println(""(optcode is an integer)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""SPY""))
                            {
                                tc.registerSpyStream(fout);
                            }
                            else if(line.startsWith(""UNSPY""))
                            {
                                tc.stopSpyStream();
                            }
                            else if(line.matches(""^\\^[A-Z^]\\r?\\n?$""))
                            {
                                final byte toSend = buff[1];
                                if (toSend == '^') {
                                    outstr.write(toSend);
                                } else {
                                    outstr.write(toSend - 'A' + 1);
                                }
                                outstr.flush();
                            }
                            else
                            {
                                try
                                {
                                        outstr.write(buff, 0 , ret_read);
                                        outstr.flush();
                                }
                                catch (final IOException e)
                                {
                                        end_loop = true;
                                }
                            }
                        }
                    }
                    catch (final IOException e)
                    {
                        System.err.println(""Exception while reading keyboard:"" + e.getMessage());
                        end_loop = true;
                    }
                }
                while(ret_read > 0 && end_loop == false);

                try
                {
                    tc.disconnect();
                }
                catch (final IOException e)
                {
                          System.err.println(""Exception while connecting:"" + e.getMessage());
                }
            }
            catch (final IOException e)
            {
                    System.err.println(""Exception while connecting:"" + e.getMessage());
                    System.exit(1);
            }
        }
    }","  public void test9()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        TelnetClientExample.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1426,"    public static void main(final String[] args) throws Exception
    {
        FileOutputStream fout = null;

        if(args.length < 1)
        {
            System.err.println(""Usage: TelnetClientExample <remote-ip> [<remote-port>]"");
            System.exit(1);
        }

        final String remoteip = args[0];

        final int remoteport;

        if (args.length > 1)
        {
            remoteport = Integer.parseInt(args[1]);
        }
        else
        {
            remoteport = 23;
        }

        try
        {
            fout = new FileOutputStream (""spy.log"", true);
        }
        catch (final IOException e)
        {
            System.err.println(
                ""Exception while opening the spy file: ""
                + e.getMessage());
        }

        tc = new TelnetClient();

        final TerminalTypeOptionHandler ttopt = new TerminalTypeOptionHandler(""VT100"", false, false, true, false);
        final EchoOptionHandler echoopt = new EchoOptionHandler(true, false, true, false);
        final SuppressGAOptionHandler gaopt = new SuppressGAOptionHandler(true, true, true, true);

        try
        {
            tc.addOptionHandler(ttopt);
            tc.addOptionHandler(echoopt);
            tc.addOptionHandler(gaopt);
        }
        catch (final InvalidTelnetOptionException e)
        {
            System.err.println(""Error registering option handlers: "" + e.getMessage());
        }

        while (true)
        {
            boolean end_loop = false;
            try
            {
                tc.connect(remoteip, remoteport);


                final Thread reader = new Thread (new TelnetClientExample());
                tc.registerNotifHandler(new TelnetClientExample());
                System.out.println(""TelnetClientExample"");
                System.out.println(""Type AYT to send an AYT telnet command"");
                System.out.println(""Type OPT to print a report of status of options (0-24)"");
                System.out.println(""Type REGISTER to register a new SimpleOptionHandler"");
                System.out.println(""Type UNREGISTER to unregister an OptionHandler"");
                System.out.println(""Type SPY to register the spy (connect to port 3333 to spy)"");
                System.out.println(""Type UNSPY to stop spying the connection"");
                System.out.println(""Type ^[A-Z] to send the control character; use ^^ to send ^"");

                reader.start();
                final OutputStream outstr = tc.getOutputStream();

                final byte[] buff = new byte[1024];
                int ret_read = 0;

                do
                {
                    try
                    {
                        ret_read = System.in.read(buff);
                        if(ret_read > 0)
                        {
                            final String line = new String(buff, 0, ret_read); // deliberate use of default charset
                            if(line.startsWith(""AYT""))
                            {
                                try
                                {
                                    System.out.println(""Sending AYT"");

                                    System.out.println(""AYT response:"" + tc.sendAYT(5000));
                                }
                                catch (final IOException e)
                                {
                                    System.err.println(""Exception waiting AYT response: "" + e.getMessage());
                                }
                            }
                            else if(line.startsWith(""OPT""))
                            {
                                 System.out.println(""Status of options:"");
                                 for(int ii=0; ii<25; ii++) {
                                     System.out.println(""Local Option "" + ii + "":"" + tc.getLocalOptionState(ii) +
                                                        "" Remote Option "" + ii + "":"" + tc.getRemoteOptionState(ii));
                                 }
                            }
                            else if(line.startsWith(""REGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    final boolean initlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean initremote = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptlocal = Boolean.parseBoolean(st.nextToken());
                                    final boolean acceptremote = Boolean.parseBoolean(st.nextToken());
                                    final SimpleOptionHandler opthand = new SimpleOptionHandler(opcode, initlocal, initremote,
                                                                    acceptlocal, acceptremote);
                                    tc.addOptionHandler(opthand);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error registering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid REGISTER command."");
                                        System.err.println(""Use REGISTER optcode initlocal initremote acceptlocal acceptremote"");
                                        System.err.println(""(optcode is an integer.)"");
                                        System.err.println(""(initlocal, initremote, acceptlocal, acceptremote are boolean)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""UNREGISTER""))
                            {
                                final StringTokenizer st = new StringTokenizer(new String(buff));
                                try
                                {
                                    st.nextToken();
                                    final int opcode = Integer.parseInt(st.nextToken());
                                    tc.deleteOptionHandler(opcode);
                                }
                                catch (final Exception e)
                                {
                                    if(e instanceof InvalidTelnetOptionException)
                                    {
                                        System.err.println(""Error unregistering option: "" + e.getMessage());
                                    }
                                    else
                                    {
                                        System.err.println(""Invalid UNREGISTER command."");
                                        System.err.println(""Use UNREGISTER optcode"");
                                        System.err.println(""(optcode is an integer)"");
                                    }
                                }
                            }
                            else if(line.startsWith(""SPY""))
                            {
                                tc.registerSpyStream(fout);
                            }
                            else if(line.startsWith(""UNSPY""))
                            {
                                tc.stopSpyStream();
                            }
                            else if(line.matches(""^\\^[A-Z^]\\r?\\n?$""))
                            {
                                final byte toSend = buff[1];
                                if (toSend == '^') {
                                    outstr.write(toSend);
                                } else {
                                    outstr.write(toSend - 'A' + 1);
                                }
                                outstr.flush();
                            }
                            else
                            {
                                try
                                {
                                        outstr.write(buff, 0 , ret_read);
                                        outstr.flush();
                                }
                                catch (final IOException e)
                                {
                                        end_loop = true;
                                }
                            }
                        }
                    }
                    catch (final IOException e)
                    {
                        System.err.println(""Exception while reading keyboard:"" + e.getMessage());
                        end_loop = true;
                    }
                }
                while(ret_read > 0 && end_loop == false);

                try
                {
                    tc.disconnect();
                }
                catch (final IOException e)
                {
                          System.err.println(""Exception while connecting:"" + e.getMessage());
                }
            }
            catch (final IOException e)
            {
                    System.err.println(""Exception while connecting:"" + e.getMessage());
                    System.exit(1);
            }
        }
    }","  public void test10()  throws Throwable  {
      String[] stringArray0 = new String[3];
      try { 
        TelnetClientExample.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // null
         //
         verifyException(""java.lang.Integer"", e);
      }
  }"
1427,"    public void receivedNegotiation(final int negotiation_code, final int option_code)
    {
        String command = null;
        switch (negotiation_code) {
            case TelnetNotificationHandler.RECEIVED_DO:
                command = ""DO"";
                break;
            case TelnetNotificationHandler.RECEIVED_DONT:
                command = ""DONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_WILL:
                command = ""WILL"";
                break;
            case TelnetNotificationHandler.RECEIVED_WONT:
                command = ""WONT"";
                break;
            case TelnetNotificationHandler.RECEIVED_COMMAND:
                command = ""COMMAND"";
                break;
            default:
                command = Integer.toString(negotiation_code); // Should not happen
                break;
        }
        System.out.println(""Received "" + command + "" for option code "" + option_code);
   }","  public void test11()  throws Throwable  {
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnetClientExample0.receivedNegotiation(1, 1);
  }"
1428,"    public static void main(final String[] args)
    {
        String server1;
        final String username1;
        final String password1;
        final String file1;
        String server2;
        final String username2;
        final String password2;
        final String file2;
        String [] parts;
        int port1=0, port2=0;
        final FTPClient ftp1;
        final FTPClient ftp2;
        final ProtocolCommandListener listener;

        if (args.length < 8)
        {
            System.err.println(
                ""Usage: ftp <host1> <user1> <pass1> <file1> <host2> <user2> <pass2> <file2>""
            );
            System.exit(1);
        }

        server1 = args[0];
        parts = server1.split("":"");
        if (parts.length == 2) {
            server1=parts[0];
            port1 = Integer.parseInt(parts[1]);
        }
        username1 = args[1];
        password1 = args[2];
        file1 = args[3];
        server2 = args[4];
        parts = server2.split("":"");
        if (parts.length == 2) {
            server2=parts[0];
            port2 = Integer.parseInt(parts[1]);
        }
        username2 = args[5];
        password2 = args[6];
        file2 = args[7];

        listener = new PrintCommandListener(new PrintWriter(System.out), true);
        ftp1 = new FTPClient();
        ftp1.addProtocolCommandListener(listener);
        ftp2 = new FTPClient();
        ftp2.addProtocolCommandListener(listener);

        try
        {
            final int reply;
            if (port1 > 0) {
                ftp1.connect(server1, port1);
            } else {
                ftp1.connect(server1);
            }
            System.out.println(""Connected to "" + server1 + ""."");

            reply = ftp1.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp1.disconnect();
                System.err.println(""FTP server1 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp1.isConnected())
            {
                try
                {
                    ftp1.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server1."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            final int reply;
            if (port2 > 0) {
                ftp2.connect(server2, port2);
            } else {
                ftp2.connect(server2);
            }
            System.out.println(""Connected to "" + server2 + ""."");

            reply = ftp2.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp2.disconnect();
                System.err.println(""FTP server2 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp2.isConnected())
            {
                try
                {
                    ftp2.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server2."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp1.login(username1, password1))
            {
                System.err.println(""Could not login to "" + server1);
                break __main;
            }

            if (!ftp2.login(username2, password2))
            {
                System.err.println(""Could not login to "" + server2);
                break __main;
            }

            // Let's just assume success for now.
            ftp2.enterRemotePassiveMode();

            ftp1.enterRemoteActiveMode(InetAddress.getByName(ftp2.getPassiveHost()),
                                       ftp2.getPassivePort());

            // Although you would think the store command should be sent to server2
            // first, in reality, ftp servers like wu-ftpd start accepting data
            // connections right after entering passive mode.  Additionally, they
            // don't even send the positive preliminary reply until after the
            // transfer is completed (in the case of passive mode transfers).
            // Therefore, calling store first would hang waiting for a preliminary
            // reply.
            if (ftp1.remoteRetrieve(file1) && ftp2.remoteStoreUnique(file2))
            {
                //      if(ftp1.remoteRetrieve(file1) && ftp2.remoteStore(file2)) {
                // We have to fetch the positive completion reply.
                ftp1.completePendingCommand();
                ftp2.completePendingCommand();
            }
            else
            {
                System.err.println(
                    ""Couldn't initiate transfer. Check that file names are valid."");
                break __main;
            }

        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
        finally
        {
            try
            {
                if (ftp1.isConnected())
                {
                    ftp1.logout();
                    ftp1.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }

            try
            {
                if (ftp2.isConnected())
                {
                    ftp2.logout();
                    ftp2.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }
        }
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[8];
          stringArray0[0] = """";
          stringArray0[4] = ""A4XFN:!C:@ZzG"";
          // Undeclared exception!
          try { 
            ServerToServerFTP.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""127.0.0.1:21\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.ServerToServerFTP.main(ServerToServerFTP.java:97)
             // sun.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1429,"    public static void main(final String[] args)
    {
        String server1;
        final String username1;
        final String password1;
        final String file1;
        String server2;
        final String username2;
        final String password2;
        final String file2;
        String [] parts;
        int port1=0, port2=0;
        final FTPClient ftp1;
        final FTPClient ftp2;
        final ProtocolCommandListener listener;

        if (args.length < 8)
        {
            System.err.println(
                ""Usage: ftp <host1> <user1> <pass1> <file1> <host2> <user2> <pass2> <file2>""
            );
            System.exit(1);
        }

        server1 = args[0];
        parts = server1.split("":"");
        if (parts.length == 2) {
            server1=parts[0];
            port1 = Integer.parseInt(parts[1]);
        }
        username1 = args[1];
        password1 = args[2];
        file1 = args[3];
        server2 = args[4];
        parts = server2.split("":"");
        if (parts.length == 2) {
            server2=parts[0];
            port2 = Integer.parseInt(parts[1]);
        }
        username2 = args[5];
        password2 = args[6];
        file2 = args[7];

        listener = new PrintCommandListener(new PrintWriter(System.out), true);
        ftp1 = new FTPClient();
        ftp1.addProtocolCommandListener(listener);
        ftp2 = new FTPClient();
        ftp2.addProtocolCommandListener(listener);

        try
        {
            final int reply;
            if (port1 > 0) {
                ftp1.connect(server1, port1);
            } else {
                ftp1.connect(server1);
            }
            System.out.println(""Connected to "" + server1 + ""."");

            reply = ftp1.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp1.disconnect();
                System.err.println(""FTP server1 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp1.isConnected())
            {
                try
                {
                    ftp1.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server1."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            final int reply;
            if (port2 > 0) {
                ftp2.connect(server2, port2);
            } else {
                ftp2.connect(server2);
            }
            System.out.println(""Connected to "" + server2 + ""."");

            reply = ftp2.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp2.disconnect();
                System.err.println(""FTP server2 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp2.isConnected())
            {
                try
                {
                    ftp2.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server2."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp1.login(username1, password1))
            {
                System.err.println(""Could not login to "" + server1);
                break __main;
            }

            if (!ftp2.login(username2, password2))
            {
                System.err.println(""Could not login to "" + server2);
                break __main;
            }

            // Let's just assume success for now.
            ftp2.enterRemotePassiveMode();

            ftp1.enterRemoteActiveMode(InetAddress.getByName(ftp2.getPassiveHost()),
                                       ftp2.getPassivePort());

            // Although you would think the store command should be sent to server2
            // first, in reality, ftp servers like wu-ftpd start accepting data
            // connections right after entering passive mode.  Additionally, they
            // don't even send the positive preliminary reply until after the
            // transfer is completed (in the case of passive mode transfers).
            // Therefore, calling store first would hang waiting for a preliminary
            // reply.
            if (ftp1.remoteRetrieve(file1) && ftp2.remoteStoreUnique(file2))
            {
                //      if(ftp1.remoteRetrieve(file1) && ftp2.remoteStore(file2)) {
                // We have to fetch the positive completion reply.
                ftp1.completePendingCommand();
                ftp2.completePendingCommand();
            }
            else
            {
                System.err.println(
                    ""Couldn't initiate transfer. Check that file names are valid."");
                break __main;
            }

        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
        finally
        {
            try
            {
                if (ftp1.isConnected())
                {
                    ftp1.logout();
                    ftp1.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }

            try
            {
                if (ftp2.isConnected())
                {
                    ftp2.logout();
                    ftp2.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }
        }
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[10];
          stringArray0[0] = ""5:3"";
          stringArray0[4] = ""5:3"";
          // Undeclared exception!
          try { 
            ServerToServerFTP.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""0.0.0.5:3\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.examples.ftp.ServerToServerFTP.main(ServerToServerFTP.java:95)
             // sun.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1430,"    public static void main(final String[] args)
    {
        String server1;
        final String username1;
        final String password1;
        final String file1;
        String server2;
        final String username2;
        final String password2;
        final String file2;
        String [] parts;
        int port1=0, port2=0;
        final FTPClient ftp1;
        final FTPClient ftp2;
        final ProtocolCommandListener listener;

        if (args.length < 8)
        {
            System.err.println(
                ""Usage: ftp <host1> <user1> <pass1> <file1> <host2> <user2> <pass2> <file2>""
            );
            System.exit(1);
        }

        server1 = args[0];
        parts = server1.split("":"");
        if (parts.length == 2) {
            server1=parts[0];
            port1 = Integer.parseInt(parts[1]);
        }
        username1 = args[1];
        password1 = args[2];
        file1 = args[3];
        server2 = args[4];
        parts = server2.split("":"");
        if (parts.length == 2) {
            server2=parts[0];
            port2 = Integer.parseInt(parts[1]);
        }
        username2 = args[5];
        password2 = args[6];
        file2 = args[7];

        listener = new PrintCommandListener(new PrintWriter(System.out), true);
        ftp1 = new FTPClient();
        ftp1.addProtocolCommandListener(listener);
        ftp2 = new FTPClient();
        ftp2.addProtocolCommandListener(listener);

        try
        {
            final int reply;
            if (port1 > 0) {
                ftp1.connect(server1, port1);
            } else {
                ftp1.connect(server1);
            }
            System.out.println(""Connected to "" + server1 + ""."");

            reply = ftp1.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp1.disconnect();
                System.err.println(""FTP server1 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp1.isConnected())
            {
                try
                {
                    ftp1.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server1."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            final int reply;
            if (port2 > 0) {
                ftp2.connect(server2, port2);
            } else {
                ftp2.connect(server2);
            }
            System.out.println(""Connected to "" + server2 + ""."");

            reply = ftp2.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp2.disconnect();
                System.err.println(""FTP server2 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp2.isConnected())
            {
                try
                {
                    ftp2.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server2."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp1.login(username1, password1))
            {
                System.err.println(""Could not login to "" + server1);
                break __main;
            }

            if (!ftp2.login(username2, password2))
            {
                System.err.println(""Could not login to "" + server2);
                break __main;
            }

            // Let's just assume success for now.
            ftp2.enterRemotePassiveMode();

            ftp1.enterRemoteActiveMode(InetAddress.getByName(ftp2.getPassiveHost()),
                                       ftp2.getPassivePort());

            // Although you would think the store command should be sent to server2
            // first, in reality, ftp servers like wu-ftpd start accepting data
            // connections right after entering passive mode.  Additionally, they
            // don't even send the positive preliminary reply until after the
            // transfer is completed (in the case of passive mode transfers).
            // Therefore, calling store first would hang waiting for a preliminary
            // reply.
            if (ftp1.remoteRetrieve(file1) && ftp2.remoteStoreUnique(file2))
            {
                //      if(ftp1.remoteRetrieve(file1) && ftp2.remoteStore(file2)) {
                // We have to fetch the positive completion reply.
                ftp1.completePendingCommand();
                ftp2.completePendingCommand();
            }
            else
            {
                System.err.println(
                    ""Couldn't initiate transfer. Check that file names are valid."");
                break __main;
            }

        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
        finally
        {
            try
            {
                if (ftp1.isConnected())
                {
                    ftp1.logout();
                    ftp1.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }

            try
            {
                if (ftp2.isConnected())
                {
                    ftp2.logout();
                    ftp2.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }
        }
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[9];
      stringArray0[0] = """";
      stringArray0[4] = ""zYkbi=;b_[:sLCLW]dh"";
      // Undeclared exception!
      try { 
        ServerToServerFTP.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // For input string: \""sLCLW]dh\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
1431,"    public static void main(final String[] args)
    {
        String server1;
        final String username1;
        final String password1;
        final String file1;
        String server2;
        final String username2;
        final String password2;
        final String file2;
        String [] parts;
        int port1=0, port2=0;
        final FTPClient ftp1;
        final FTPClient ftp2;
        final ProtocolCommandListener listener;

        if (args.length < 8)
        {
            System.err.println(
                ""Usage: ftp <host1> <user1> <pass1> <file1> <host2> <user2> <pass2> <file2>""
            );
            System.exit(1);
        }

        server1 = args[0];
        parts = server1.split("":"");
        if (parts.length == 2) {
            server1=parts[0];
            port1 = Integer.parseInt(parts[1]);
        }
        username1 = args[1];
        password1 = args[2];
        file1 = args[3];
        server2 = args[4];
        parts = server2.split("":"");
        if (parts.length == 2) {
            server2=parts[0];
            port2 = Integer.parseInt(parts[1]);
        }
        username2 = args[5];
        password2 = args[6];
        file2 = args[7];

        listener = new PrintCommandListener(new PrintWriter(System.out), true);
        ftp1 = new FTPClient();
        ftp1.addProtocolCommandListener(listener);
        ftp2 = new FTPClient();
        ftp2.addProtocolCommandListener(listener);

        try
        {
            final int reply;
            if (port1 > 0) {
                ftp1.connect(server1, port1);
            } else {
                ftp1.connect(server1);
            }
            System.out.println(""Connected to "" + server1 + ""."");

            reply = ftp1.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp1.disconnect();
                System.err.println(""FTP server1 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp1.isConnected())
            {
                try
                {
                    ftp1.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server1."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            final int reply;
            if (port2 > 0) {
                ftp2.connect(server2, port2);
            } else {
                ftp2.connect(server2);
            }
            System.out.println(""Connected to "" + server2 + ""."");

            reply = ftp2.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp2.disconnect();
                System.err.println(""FTP server2 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp2.isConnected())
            {
                try
                {
                    ftp2.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server2."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp1.login(username1, password1))
            {
                System.err.println(""Could not login to "" + server1);
                break __main;
            }

            if (!ftp2.login(username2, password2))
            {
                System.err.println(""Could not login to "" + server2);
                break __main;
            }

            // Let's just assume success for now.
            ftp2.enterRemotePassiveMode();

            ftp1.enterRemoteActiveMode(InetAddress.getByName(ftp2.getPassiveHost()),
                                       ftp2.getPassivePort());

            // Although you would think the store command should be sent to server2
            // first, in reality, ftp servers like wu-ftpd start accepting data
            // connections right after entering passive mode.  Additionally, they
            // don't even send the positive preliminary reply until after the
            // transfer is completed (in the case of passive mode transfers).
            // Therefore, calling store first would hang waiting for a preliminary
            // reply.
            if (ftp1.remoteRetrieve(file1) && ftp2.remoteStoreUnique(file2))
            {
                //      if(ftp1.remoteRetrieve(file1) && ftp2.remoteStore(file2)) {
                // We have to fetch the positive completion reply.
                ftp1.completePendingCommand();
                ftp2.completePendingCommand();
            }
            else
            {
                System.err.println(
                    ""Couldn't initiate transfer. Check that file names are valid."");
                break __main;
            }

        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
        finally
        {
            try
            {
                if (ftp1.isConnected())
                {
                    ftp1.logout();
                    ftp1.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }

            try
            {
                if (ftp2.isConnected())
                {
                    ftp2.logout();
                    ftp2.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }
        }
    }","  public void test3()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
          String[] stringArray0 = new String[8];
          stringArray0[0] = ""?gB(\\-A:s^:|4(rgI"";
          stringArray0[4] = ""v"";
          // Undeclared exception!
          try { 
            ServerToServerFTP.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:21\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.ServerToServerFTP.main(ServerToServerFTP.java:97)
             // sun.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1432,"    public static void main(final String[] args)
    {
        String server1;
        final String username1;
        final String password1;
        final String file1;
        String server2;
        final String username2;
        final String password2;
        final String file2;
        String [] parts;
        int port1=0, port2=0;
        final FTPClient ftp1;
        final FTPClient ftp2;
        final ProtocolCommandListener listener;

        if (args.length < 8)
        {
            System.err.println(
                ""Usage: ftp <host1> <user1> <pass1> <file1> <host2> <user2> <pass2> <file2>""
            );
            System.exit(1);
        }

        server1 = args[0];
        parts = server1.split("":"");
        if (parts.length == 2) {
            server1=parts[0];
            port1 = Integer.parseInt(parts[1]);
        }
        username1 = args[1];
        password1 = args[2];
        file1 = args[3];
        server2 = args[4];
        parts = server2.split("":"");
        if (parts.length == 2) {
            server2=parts[0];
            port2 = Integer.parseInt(parts[1]);
        }
        username2 = args[5];
        password2 = args[6];
        file2 = args[7];

        listener = new PrintCommandListener(new PrintWriter(System.out), true);
        ftp1 = new FTPClient();
        ftp1.addProtocolCommandListener(listener);
        ftp2 = new FTPClient();
        ftp2.addProtocolCommandListener(listener);

        try
        {
            final int reply;
            if (port1 > 0) {
                ftp1.connect(server1, port1);
            } else {
                ftp1.connect(server1);
            }
            System.out.println(""Connected to "" + server1 + ""."");

            reply = ftp1.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp1.disconnect();
                System.err.println(""FTP server1 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp1.isConnected())
            {
                try
                {
                    ftp1.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server1."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            final int reply;
            if (port2 > 0) {
                ftp2.connect(server2, port2);
            } else {
                ftp2.connect(server2);
            }
            System.out.println(""Connected to "" + server2 + ""."");

            reply = ftp2.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp2.disconnect();
                System.err.println(""FTP server2 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp2.isConnected())
            {
                try
                {
                    ftp2.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server2."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp1.login(username1, password1))
            {
                System.err.println(""Could not login to "" + server1);
                break __main;
            }

            if (!ftp2.login(username2, password2))
            {
                System.err.println(""Could not login to "" + server2);
                break __main;
            }

            // Let's just assume success for now.
            ftp2.enterRemotePassiveMode();

            ftp1.enterRemoteActiveMode(InetAddress.getByName(ftp2.getPassiveHost()),
                                       ftp2.getPassivePort());

            // Although you would think the store command should be sent to server2
            // first, in reality, ftp servers like wu-ftpd start accepting data
            // connections right after entering passive mode.  Additionally, they
            // don't even send the positive preliminary reply until after the
            // transfer is completed (in the case of passive mode transfers).
            // Therefore, calling store first would hang waiting for a preliminary
            // reply.
            if (ftp1.remoteRetrieve(file1) && ftp2.remoteStoreUnique(file2))
            {
                //      if(ftp1.remoteRetrieve(file1) && ftp2.remoteStore(file2)) {
                // We have to fetch the positive completion reply.
                ftp1.completePendingCommand();
                ftp2.completePendingCommand();
            }
            else
            {
                System.err.println(
                    ""Couldn't initiate transfer. Check that file names are valid."");
                break __main;
            }

        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
        finally
        {
            try
            {
                if (ftp1.isConnected())
                {
                    ftp1.logout();
                    ftp1.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }

            try
            {
                if (ftp2.isConnected())
                {
                    ftp2.logout();
                    ftp2.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }
        }
    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[10];
      stringArray0[0] = ""5:3"";
      // Undeclared exception!
      try { 
        ServerToServerFTP.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.examples.ftp.ServerToServerFTP"", e);
      }
  }"
1433,"    public static void main(final String[] args)
    {
        String server1;
        final String username1;
        final String password1;
        final String file1;
        String server2;
        final String username2;
        final String password2;
        final String file2;
        String [] parts;
        int port1=0, port2=0;
        final FTPClient ftp1;
        final FTPClient ftp2;
        final ProtocolCommandListener listener;

        if (args.length < 8)
        {
            System.err.println(
                ""Usage: ftp <host1> <user1> <pass1> <file1> <host2> <user2> <pass2> <file2>""
            );
            System.exit(1);
        }

        server1 = args[0];
        parts = server1.split("":"");
        if (parts.length == 2) {
            server1=parts[0];
            port1 = Integer.parseInt(parts[1]);
        }
        username1 = args[1];
        password1 = args[2];
        file1 = args[3];
        server2 = args[4];
        parts = server2.split("":"");
        if (parts.length == 2) {
            server2=parts[0];
            port2 = Integer.parseInt(parts[1]);
        }
        username2 = args[5];
        password2 = args[6];
        file2 = args[7];

        listener = new PrintCommandListener(new PrintWriter(System.out), true);
        ftp1 = new FTPClient();
        ftp1.addProtocolCommandListener(listener);
        ftp2 = new FTPClient();
        ftp2.addProtocolCommandListener(listener);

        try
        {
            final int reply;
            if (port1 > 0) {
                ftp1.connect(server1, port1);
            } else {
                ftp1.connect(server1);
            }
            System.out.println(""Connected to "" + server1 + ""."");

            reply = ftp1.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp1.disconnect();
                System.err.println(""FTP server1 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp1.isConnected())
            {
                try
                {
                    ftp1.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server1."");
            e.printStackTrace();
            System.exit(1);
        }

        try
        {
            final int reply;
            if (port2 > 0) {
                ftp2.connect(server2, port2);
            } else {
                ftp2.connect(server2);
            }
            System.out.println(""Connected to "" + server2 + ""."");

            reply = ftp2.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp2.disconnect();
                System.err.println(""FTP server2 refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp2.isConnected())
            {
                try
                {
                    ftp2.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server2."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp1.login(username1, password1))
            {
                System.err.println(""Could not login to "" + server1);
                break __main;
            }

            if (!ftp2.login(username2, password2))
            {
                System.err.println(""Could not login to "" + server2);
                break __main;
            }

            // Let's just assume success for now.
            ftp2.enterRemotePassiveMode();

            ftp1.enterRemoteActiveMode(InetAddress.getByName(ftp2.getPassiveHost()),
                                       ftp2.getPassivePort());

            // Although you would think the store command should be sent to server2
            // first, in reality, ftp servers like wu-ftpd start accepting data
            // connections right after entering passive mode.  Additionally, they
            // don't even send the positive preliminary reply until after the
            // transfer is completed (in the case of passive mode transfers).
            // Therefore, calling store first would hang waiting for a preliminary
            // reply.
            if (ftp1.remoteRetrieve(file1) && ftp2.remoteStoreUnique(file2))
            {
                //      if(ftp1.remoteRetrieve(file1) && ftp2.remoteStore(file2)) {
                // We have to fetch the positive completion reply.
                ftp1.completePendingCommand();
                ftp2.completePendingCommand();
            }
            else
            {
                System.err.println(
                    ""Couldn't initiate transfer. Check that file names are valid."");
                break __main;
            }

        }
        catch (final IOException e)
        {
            e.printStackTrace();
            System.exit(1);
        }
        finally
        {
            try
            {
                if (ftp1.isConnected())
                {
                    ftp1.logout();
                    ftp1.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }

            try
            {
                if (ftp2.isConnected())
                {
                    ftp2.logout();
                    ftp2.disconnect();
                }
            }
            catch (final IOException e)
            {
                // do nothing
            }
        }
    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[1];
      // Undeclared exception!
      try { 
        ServerToServerFTP.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1434,,"  public void test6()  throws Throwable  {
      ServerToServerFTP serverToServerFTP0 = new ServerToServerFTP();
  }"
1435,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[6];
      stringArray0[0] = ""-c"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1436,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[7];
          stringArray0[0] = ""-Y"";
          stringArray0[1] = ""-i"";
          stringArray0[2] = ""-i"";
          stringArray0[3] = ""WINDOWS"";
          // Undeclared exception!
          try { 
            FTPClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:21\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.FTPClientExample.main(FTPClientExample.java:335)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1437,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test2()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[9];
          stringArray0[0] = ""-#"";
          stringArray0[1] = ""-#"";
          stringArray0[2] = ""-y"";
          stringArray0[3] = ""-y"";
          stringArray0[4] = ""Kser.'ame"";
          // Undeclared exception!
          try { 
            FTPClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:21\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.FTPClientExample.main(FTPClientExample.java:335)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1438,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test3()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[9];
          stringArray0[0] = ""-#"";
          stringArray0[1] = ""-#"";
          stringArray0[2] = ""-S"";
          stringArray0[3] = ""-#"";
          stringArray0[4] = ""user.name"";
          // Undeclared exception!
          try { 
            FTPClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:21\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.FTPClientExample.main(FTPClientExample.java:335)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1439,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test4()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[8];
          stringArray0[1] = ""0T"";
          stringArray0[2] = ""0T"";
          stringArray0[0] = ""-E"";
          // Undeclared exception!
          try { 
            FTPClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:21\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.FTPClientExample.main(FTPClientExample.java:335)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1440,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test5()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[7];
          stringArray0[0] = ""-p"";
          stringArray0[1] = ""yxlkwZ\""@5F,rq&"";
          stringArray0[2] = ""yxlkwZ\""@5F,rq&"";
          // Undeclared exception!
          try { 
            FTPClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:21\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.FTPClientExample.main(FTPClientExample.java:335)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1441,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test6()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[14];
          stringArray0[0] = ""-PrH"";
          stringArray0[1] = ""-PrH"";
          stringArray0[2] = ""!aY`F`nCCOPp7Y'"";
          // Undeclared exception!
          try { 
            FTPClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""-PrH\"" \""resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1048)
             // java.net.InetAddress.getAllByName0(InetAddress.java:1269)
             // java.net.InetAddress.getAllByName(InetAddress.java:1193)
             // java.net.InetAddress.getAllByName(InetAddress.java:1127)
             // java.net.InetAddress.getByName(InetAddress.java:1077)
             // java.net.InetSocketAddress.<init>(InetSocketAddress.java:220)
             // java.net.Socket.<init>(Socket.java:229)
             // javax.net.DefaultSocketFactory.createSocket(SocketFactory.java:271)
             // org.apache.commons.net.ftp.FTPHTTPClient.connect(FTPHTTPClient.java:176)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.FTPClientExample.main(FTPClientExample.java:335)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1442,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test7()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[7];
          stringArray0[0] = ""-p"";
          stringArray0[1] = ""di]d"";
          stringArray0[2] = ""di]d"";
          // Undeclared exception!
          try { 
            FTPClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:21\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.FTPClientExample.main(FTPClientExample.java:335)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1443,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test8()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[4];
          stringArray0[0] = ""-m"";
          stringArray0[1] = ""7a-3sR8<)c'.ijf?b:6"";
          // Undeclared exception!
          try { 
            FTPClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:6\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.examples.ftp.FTPClientExample.main(FTPClientExample.java:333)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1444,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test9()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          String[] stringArray0 = new String[4];
          stringArray0[0] = ""-A"";
          stringArray0[1] = ""8L"";
          // Undeclared exception!
          try { 
            FTPClientExample.main(stringArray0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""200.42.42.0:21\"" \""connect,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
             // java.net.Socket.connect(Socket.java:602)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:253)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:212)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:316)
             // org.apache.commons.net.examples.ftp.FTPClientExample.main(FTPClientExample.java:335)
             // sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1445,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test10()  throws Throwable  {
      String[] stringArray0 = new String[8];
      stringArray0[0] = ""-t"";
      stringArray0[1] = ""-T"";
      stringArray0[3] = ""-PrU"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1446,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test11()  throws Throwable  {
      String[] stringArray0 = new String[11];
      stringArray0[1] = ""DcUa:wgwG/$"";
      stringArray0[0] = ""-PrH"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // For input string: \""wgwG/$\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
1447,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test12()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = ""-z"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.examples.ftp.FTPClientExample"", e);
      }
  }"
1448,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test13()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""-w"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // null
         //
         verifyException(""java.lang.Integer"", e);
      }
  }"
1449,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test14()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-U"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1450,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test15()  throws Throwable  {
      String[] stringArray0 = new String[5];
      stringArray0[0] = ""-L"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1451,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test16()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-h"";
      stringArray0[1] = ""-k"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2
         //
         verifyException(""org.apache.commons.net.examples.ftp.FTPClientExample"", e);
      }
  }"
1452,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test17()  throws Throwable  {
      String[] stringArray0 = new String[6];
      stringArray0[0] = ""-PrP"";
      stringArray0[2] = ""-a"";
      stringArray0[3] = ""-f"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1453,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test18()  throws Throwable  {
      String[] stringArray0 = new String[11];
      stringArray0[0] = ""-e"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1454,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test19()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-d"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1455,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test20()  throws Throwable  {
      String[] stringArray0 = new String[6];
      stringArray0[0] = ""-m"";
      stringArray0[1] = ""-l"";
      stringArray0[2] = ""-Z"";
      stringArray0[4] = ""-l"";
      stringArray0[5] = ""-c"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 6
         //
         verifyException(""org.apache.commons.net.examples.ftp.FTPClientExample"", e);
      }
  }"
1456,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test21()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = ""-b"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1457,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test22()  throws Throwable  {
      String[] stringArray0 = new String[8];
      stringArray0[0] = ""-n"";
      stringArray0[1] = ""-s"";
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1458,"    public static void main(final String[] args) throws UnknownHostException
    {
        boolean storeFile = false, binaryTransfer = false, error = false, listFiles = false, listNames = false, hidden = false;
        boolean localActive = false, useEpsvWithIPv4 = false, feat = false, printHash = false;
        boolean mlst = false, mlsd = false, mdtm = false, saveUnparseable = false;
        boolean size = false;
        boolean lenient = false;
        long keepAliveTimeoutSeconds = -1;
        int controlKeepAliveReplyTimeoutMillis = -1;
        int minParams = 5; // listings require 3 params
        String protocol = null; // SSL protocol
        String doCommand = null;
        String trustmgr = null;
        String proxyHost = null;
        int proxyPort = 80;
        String proxyUser = null;
        String proxyPassword = null;
        String username = null;
        String password = null;
        String encoding = null;
        String serverTimeZoneId = null;
        String displayTimeZoneId = null;
        String serverType = null;
        String defaultDateFormat = null;
        String recentDateFormat = null;


        int base = 0;
        for (base = 0; base < args.length; base++)
        {
            if (args[base].equals(""-s"")) {
                storeFile = true;
            }
            else if (args[base].equals(""-a"")) {
                localActive = true;
            }
            else if (args[base].equals(""-A"")) {
                username = ""anonymous"";
                password = System.getProperty(""user.name"")+""@""+InetAddress.getLocalHost().getHostName();
            }
            else if (args[base].equals(""-b"")) {
                binaryTransfer = true;
            }
            else if (args[base].equals(""-c"")) {
                doCommand = args[++base];
                minParams = 3;
            }
            else if (args[base].equals(""-d"")) {
                mlsd = true;
                minParams = 3;
            }
            else if (args[base].equals(""-e"")) {
                useEpsvWithIPv4 = true;
            }
            else if (args[base].equals(""-E"")) {
                encoding = args[++base];
            }
            else if (args[base].equals(""-f"")) {
                feat = true;
                minParams = 3;
            }
            else if (args[base].equals(""-h"")) {
                hidden = true;
            }
            else if (args[base].equals(""-i"")) {
                size = true;
                minParams = 3;
            }
            else if (args[base].equals(""-k"")) {
                keepAliveTimeoutSeconds = Long.parseLong(args[++base]);
            }
            else if (args[base].equals(""-l"")) {
                listFiles = true;
                minParams = 3;
            }
            else if (args[base].equals(""-m"")) {
                mdtm = true;
                minParams = 3;
            }
            else if (args[base].equals(""-L"")) {
                lenient = true;
            }
            else if (args[base].equals(""-n"")) {
                listNames = true;
                minParams = 3;
            }
            else if (args[base].equals(""-p"")) {
                protocol = args[++base];
            }
            else if (args[base].equals(""-S"")) {
                serverType = args[++base];
            }
            else if (args[base].equals(""-t"")) {
                mlst = true;
                minParams = 3;
            }
            else if (args[base].equals(""-U"")) {
                saveUnparseable = true;
            }
            else if (args[base].equals(""-w"")) {
                controlKeepAliveReplyTimeoutMillis = Integer.parseInt(args[++base]);
            }
            else if (args[base].equals(""-T"")) {
                trustmgr = args[++base];
            }
            else if (args[base].equals(""-y"")) {
                defaultDateFormat = args[++base];
            }
            else if (args[base].equals(""-Y"")) {
                recentDateFormat = args[++base];
            }
            else if (args[base].equals(""-Z"")) {
                serverTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-z"")) {
                displayTimeZoneId = args[++base];
            }
            else if (args[base].equals(""-PrH"")) {
                proxyHost = args[++base];
                final String parts[] = proxyHost.split("":"");
                if (parts.length == 2){
                    proxyHost=parts[0];
                    proxyPort=Integer.parseInt(parts[1]);
                }
            }
            else if (args[base].equals(""-PrU"")) {
                proxyUser = args[++base];
            }
            else if (args[base].equals(""-PrP"")) {
                proxyPassword = args[++base];
            }
            else if (args[base].equals(""-#"")) {
                printHash = true;
            }
            else {
                break;
            }
        }

        final int remain = args.length - base;
        if (username != null) {
            minParams -= 2;
        }
        if (remain < minParams) // server, user, pass, remote, local [protocol]
        {
            if (args.length > 0) {
                System.err.println(""Actual Parameters: "" + Arrays.toString(args));
            }
            System.err.println(USAGE);
            System.exit(1);
        }

        String server = args[base++];
        int port = 0;
        final String parts[] = server.split("":"");
        if (parts.length == 2){
            server=parts[0];
            port=Integer.parseInt(parts[1]);
        }
        if (username == null) {
            username = args[base++];
            password = args[base++];
        }

        String remote = null;
        if (args.length - base > 0) {
            remote = args[base++];
        }

        String local = null;
        if (args.length - base > 0) {
            local = args[base++];
        }

        final FTPClient ftp;
        if (protocol == null ) {
            if(proxyHost !=null) {
                System.out.println(""Using HTTP proxy server: "" + proxyHost);
                ftp = new FTPHTTPClient(proxyHost, proxyPort, proxyUser, proxyPassword);
            }
            else {
                ftp = new FTPClient();
            }
        } else {
            final FTPSClient ftps;
            if (protocol.equals(""true"")) {
                ftps = new FTPSClient(true);
            } else if (protocol.equals(""false"")) {
                ftps = new FTPSClient(false);
            } else {
                final String prot[] = protocol.split("","");
                if (prot.length == 1) { // Just protocol
                    ftps = new FTPSClient(protocol);
                } else { // protocol,true|false
                    ftps = new FTPSClient(prot[0], Boolean.parseBoolean(prot[1]));
                }
            }
            ftp = ftps;
            if (""all"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            } else if (""valid"".equals(trustmgr)) {
                ftps.setTrustManager(TrustManagerUtils.getValidateServerCertificateTrustManager());
            } else if (""none"".equals(trustmgr)) {
                ftps.setTrustManager(null);
            }
        }

        if (printHash) {
            ftp.setCopyStreamListener(createListener());
        }
        if (keepAliveTimeoutSeconds >= 0) {
            ftp.setControlKeepAliveTimeout(keepAliveTimeoutSeconds);
        }
        if (controlKeepAliveReplyTimeoutMillis >= 0) {
            ftp.setControlKeepAliveReplyTimeout(controlKeepAliveReplyTimeoutMillis);
        }
        if (encoding != null) {
            ftp.setControlEncoding(encoding);
        }
        ftp.setListHiddenFiles(hidden);

        // suppress login details
        ftp.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));

        final FTPClientConfig config;
        if (serverType != null) {
            config = new FTPClientConfig(serverType);
        } else {
            config = new FTPClientConfig();
        }
        config.setUnparseableEntries(saveUnparseable);
        if (defaultDateFormat != null) {
            config.setDefaultDateFormatStr(defaultDateFormat);
        }
        if (recentDateFormat != null) {
            config.setRecentDateFormatStr(recentDateFormat);
        }
        ftp.configure(config);

        try
        {
            final int reply;
            if (port > 0) {
                ftp.connect(server, port);
            } else {
                ftp.connect(server);
            }
            System.out.println(""Connected to "" + server + "" on "" + (port>0 ? port : ftp.getDefaultPort()));

            // After connection attempt, you should check the reply code to verify
            // success.
            reply = ftp.getReplyCode();

            if (!FTPReply.isPositiveCompletion(reply))
            {
                ftp.disconnect();
                System.err.println(""FTP server refused connection."");
                System.exit(1);
            }
        }
        catch (final IOException e)
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
            System.err.println(""Could not connect to server."");
            e.printStackTrace();
            System.exit(1);
        }

__main:
        try
        {
            if (!ftp.login(username, password))
            {
                ftp.logout();
                error = true;
                break __main;
            }

            System.out.println(""Remote system is "" + ftp.getSystemType());

            if (binaryTransfer) {
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                // in theory this should not be necessary as servers should default to ASCII
                // but they don't all do so - see NET-500
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            }

            // Use passive mode as default because most of us are
            // behind firewalls these days.
            if (localActive) {
                ftp.enterLocalActiveMode();
            } else {
                ftp.enterLocalPassiveMode();
            }

            ftp.setUseEPSVwithIPv4(useEpsvWithIPv4);

            if (storeFile)
            {
                try (final InputStream input = new FileInputStream(local)) {
                    ftp.storeFile(remote, input);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }
            // Allow multiple list types for single invocation
            else if (listFiles || mlsd || mdtm || mlst || listNames || size)
            {
                if (mlsd) {
                    for (final FTPFile f : ftp.mlistDir(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (mdtm) {
                    final FTPFile f = ftp.mdtmFile(remote);
                    if (f != null) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    } else {
                        System.out.println(""File not found"");
                    }
                }
                if (mlst) {
                    final FTPFile f = ftp.mlistFile(remote);
                    if (f != null){
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
                if (listNames) {
                    for (final String s : ftp.listNames(remote)) {
                        System.out.println(s);
                    }
                }
                if (size) {
                    System.out.println(""Size=""+ftp.getSize(remote));
                }
                // Do this last because it changes the client
                if (listFiles) {
                    if (lenient || serverTimeZoneId != null) {
                        config.setLenientFutureDates(lenient);
                        if (serverTimeZoneId != null) {
                            config.setServerTimeZoneId(serverTimeZoneId);
                        }
                        ftp.configure(config );
                    }

                    for (final FTPFile f : ftp.listFiles(remote)) {
                        System.out.println(f.getRawListing());
                        System.out.println(f.toFormattedString(displayTimeZoneId));
                    }
                }
            }
            else if (feat)
            {
                // boolean feature check
                if (remote != null) { // See if the command is present
                    if (ftp.hasFeature(remote)) {
                        System.out.println(""Has feature: ""+remote);
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" was not detected"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }

                    // Strings feature check
                    final String []features = ftp.featureValues(remote);
                    if (features != null) {
                        for(final String f : features) {
                            System.out.println(""FEAT ""+remote+""=""+f+""."");
                        }
                    } else {
                        if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                            System.out.println(""FEAT ""+remote+"" is not present"");
                        } else {
                            System.out.println(""Command failed: ""+ftp.getReplyString());
                        }
                    }
                } else {
                    if (ftp.features()) {
//                        Command listener has already printed the output
                    } else {
                        System.out.println(""Failed: ""+ftp.getReplyString());
                    }
                }
            }
            else if (doCommand != null)
            {
                if (ftp.doCommand(doCommand, remote)) {
//                  Command listener has already printed the output
//                    for(String s : ftp.getReplyStrings()) {
//                        System.out.println(s);
//                    }
                } else {
                    System.out.println(""Failed: ""+ftp.getReplyString());
                }
            }
            else
            {
                try (final OutputStream output = new FileOutputStream(local)) {
                    ftp.retrieveFile(remote, output);
                }

                if (keepAliveTimeoutSeconds > 0) {
                    showCslStats(ftp);
                }
            }

            ftp.noop(); // check that control connection is working OK

            ftp.logout();
        }
        catch (final FTPConnectionClosedException e)
        {
            error = true;
            System.err.println(""Server closed connection."");
            e.printStackTrace();
        }
        catch (final IOException e)
        {
            error = true;
            e.printStackTrace();
        }
        finally
        {
            if (ftp.isConnected())
            {
                try
                {
                    ftp.disconnect();
                }
                catch (final IOException f)
                {
                    // do nothing
                }
            }
        }

        System.exit(error ? 1 : 0);
    }","  public void test23()  throws Throwable  {
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        FTPClientExample.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1459,,"  public void test24()  throws Throwable  {
      FTPClientExample fTPClientExample0 = new FTPClientExample();
  }"
1460,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = "",2N*V3^P&:Q7 $<.F:~"";
      stringArray0[1] = ""-Error: could not open local file for reading."";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
1461,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-s"";
      stringArray0[1] = ""Usage: tftp [options] hostname localfile remotefile\n\nhostname   - The name of the remote host [:port]\nlocalfile  - The name of the local file to send or the name to use for\n\tthe received file\nremotefile - The name of the remote file to receive or the name for\n\tthe remote server to use to name the local file being sent.\n\noptions: (The default is to assume -r -b)\n\t-t timeout in seconds (default 60s)\n\t-s Send a local file\n\t-r Receive a remote file\n\t-a Use ASCII transfer mode\n\t-b Use binary transfer mode\n\t-v Verbose (trace packets)\n"";
      stringArray0[2] = ""Connection timed out."";
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""Connection timed out."");
      FileSystemHandling.appendStringToFile(evoSuiteFile0, ""Connection timed out."");
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
1462,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test2()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-v"";
      stringArray0[1] = ""Bg8/YDD?8f{ByQ)AxT*"";
      stringArray0[2] = ""Bg8/YDD?8f{ByQ)AxT*"";
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""Bg8"");
      FileSystemHandling.appendLineToFile(evoSuiteFile0, ""A"");
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: RuntimeException"");
      } catch(RuntimeException e) {
         //
         // Error: could not open local file for writing.
         //
         verifyException(""org.apache.commons.net.examples.ftp.TFTPExample"", e);
      }
  }"
1463,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test3()  throws Throwable  {
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("" Sent: "");
      FileSystemHandling.shouldThrowIOException(evoSuiteFile0);
      String[] stringArray0 = new String[3];
      stringArray0[0] = """";
      stringArray0[1] = "" Sent: "";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
1464,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test4()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = """";
      stringArray0[1] = "" Sent: "";
      stringArray0[2] = ""lw<U].JF[\""ukg>>q"";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1465,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test5()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-s"";
      stringArray0[1] = ""Error: coul no, resolve hstate."";
      stringArray0[2] = ""-s"";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: RuntimeException"");
      } catch(RuntimeException e) {
         //
         // Error: could not open local file for reading.
         //
         verifyException(""org.apache.commons.net.examples.ftp.TFTPExample"", e);
      }
  }"
1466,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test6()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""-r"";
      stringArray0[1] = ""-t"";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // null
         //
         verifyException(""java.lang.Integer"", e);
      }
  }"
1467,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test7()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""kI7P`$iqj #+D/MK!OC"";
      stringArray0[1] = ""ijYY74yA)_o?"";
      stringArray0[2] = ""Usage: tftp [options] hostname localfile remotefile\n\nhostname   - The name of the remote host [:port]\nlocalfile  - The name of the local file to send or the name to use for\n\tthe received file\nremotefile - The name of the remote file to receive or the name for\n\tthe remote server to use to name the local file being sent.\n\noptions: (The default is to assume -r -b)\n\t-t timeout in seconds (default 60s)\n\t-s Send a local file\n\t-r Receive a remote file\n\t-a Use ASCII transfer mode\n\t-b Use binary transfer mode\n\t-v Verbose (trace packets)\n"";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
      }
  }"
1468,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test8()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""Eu:ould not o;en locl UP ockt."";
      stringArray0[1] = ""Eu:ould not o;en locl UP ockt."";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // For input string: \""ould not o;en locl UP ockt.\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
1469,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test9()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-s"";
      stringArray0[1] = ""Error: could not resolve hostname."";
      stringArray0[2] = ""Connection timed out."";
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""Connection timed out."");
      FileSystemHandling.appendStringToFile(evoSuiteFile0, ""Connection timed out."");
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
      } catch(NumberFormatException e) {
         //
         // For input string: \"" could not resolve hostname.\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
1470,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test10()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-s"";
      stringArray0[1] = ""MS{]kxdoGi=SX"";
      stringArray0[2] = ""Connection timed out."";
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""Connection timed out."");
      FileSystemHandling.appendStringToFile(evoSuiteFile0, ""Connection timed out."");
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
1471,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test11()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-a"";
      stringArray0[1] = ""Fvle write kailed."";
      stringArray0[2] = """";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1472,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test12()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-s"";
      stringArray0[1] = ""Error: could not resolve hostname."";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
      }
  }"
1473,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test13()  throws Throwable  {
      String[] stringArray0 = new String[8];
      stringArray0[0] = ""-u"";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1474,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test14()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = ""-t"";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""org.apache.commons.net.examples.ftp.TFTPExample"", e);
      }
  }"
1475,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test15()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""-r"";
      stringArray0[1] = ""-r"";
      stringArray0[2] = ""-b"";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
      } catch(System.SystemExitException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }"
1476,,"  public void test16()  throws Throwable  {
      TFTPExample tFTPExample0 = new TFTPExample();
  }"
1477,"    public static void main(final String[] args)
    {
        boolean receiveFile = true, closed;
        int transferMode = TFTP.BINARY_MODE, argc;
        String arg;
        final String hostname;
        final String localFilename;
        final String remoteFilename;
        final TFTPClient tftp;
        int timeout = 60000;
        boolean verbose = false;

        // Parse options
        for (argc = 0; argc < args.length; argc++)
        {
            arg = args[argc];
            if (arg.startsWith(""-""))
            {
                if (arg.equals(""-r"")) {
                    receiveFile = true;
                } else if (arg.equals(""-s"")) {
                    receiveFile = false;
                } else if (arg.equals(""-a"")) {
                    transferMode = TFTP.ASCII_MODE;
                } else if (arg.equals(""-b"")) {
                    transferMode = TFTP.BINARY_MODE;
                } else if (arg.equals(""-t"")) {
                    timeout = 1000*Integer.parseInt(args[++argc]);
                } else if (arg.equals(""-v"")) {
                    verbose = true;
                } else {
                    System.err.println(""Error: unrecognized option."");
                    System.err.print(USAGE);
                    System.exit(1);
                }
            } else {
                break;
            }
        }

        // Make sure there are enough arguments
        if (args.length - argc != 3)
        {
            System.err.println(""Error: invalid number of arguments."");
            System.err.print(USAGE);
            System.exit(1);
        }

        // Get host and file arguments
        hostname = args[argc];
        localFilename = args[argc + 1];
        remoteFilename = args[argc + 2];

        // Create our TFTP instance to handle the file transfer.
        if (verbose) {
            tftp = new TFTPClient() {
                @Override
                protected void trace(final String direction, final TFTPPacket packet) {
                    System.out.println(direction + "" "" + packet);
                }
            };
        } else {
            tftp = new TFTPClient();
        }

        // We want to timeout if a response takes longer than 60 seconds
        tftp.setDefaultTimeout(timeout);

        // We haven't closed the local file yet.
        closed = false;

        // If we're receiving a file, receive, otherwise send.
        if (receiveFile)
        {
            closed = receive(transferMode, hostname, localFilename, remoteFilename, tftp);
        } else {
            // We're sending a file
            closed = send(transferMode, hostname, localFilename, remoteFilename, tftp);
        }

        System.out.println(""Recd: ""+tftp.getTotalBytesReceived()+"" Sent: ""+tftp.getTotalBytesSent());

        if (!closed) {
            System.out.println(""Failed"");
            System.exit(1);
        }

        System.out.println(""OK"");
    }","  public void test17()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-v"";
      stringArray0[1] = ""Bg8/YDD?8f{ByQ)AxT*"";
      stringArray0[2] = ""Bg8/YDD?8f{ByQ)AxT*"";
      // Undeclared exception!
      try { 
        TFTPExample.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.tftp.TFTPRequestPacket"", e);
      }
  }"
1478,,"  public void test0()  throws Throwable  {
      IMAPCommand[] iMAPCommandArray0 = IMAPCommand.values();
}"
1479,,"  public void test1()  throws Throwable  {
      IMAPCommand iMAPCommand0 = IMAPCommand.valueOf(""CAPABILITY"");
}"
1480,"    public static final String getCommand(final IMAPCommand command) {
        return command.getIMAPCommand();
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        IMAPCommand.getCommand((IMAPCommand) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAPCommand"", e);
      }
  }"
1481,"    public String getIMAPCommand() {
        return imapCommand != null ? imapCommand : name();
    }","  public void test3()  throws Throwable  {
      IMAPCommand iMAPCommand0 = IMAPCommand.LIST;
      String string0 = iMAPCommand0.getIMAPCommand();
}"
1482,"    public static final String getCommand(final IMAPCommand command) {
        return command.getIMAPCommand();
    }","  public void test4()  throws Throwable  {
      IMAPCommand iMAPCommand0 = IMAPCommand.LIST;
      String string0 = IMAPCommand.getCommand(iMAPCommand0);
}"
1483,"    public static final String getCommand(final IMAPCommand command) {
        return command.getIMAPCommand();
    }","  public void test5()  throws Throwable  {
      IMAPCommand iMAPCommand0 = IMAPCommand.LIST;
      String string0 = IMAPCommand.getCommand(iMAPCommand0);
}"
1484,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test0()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      iMAP0.setChunkListener((IMAP.IMAPChunkListener) null);
}"
1485,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test1()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      MockFile mockFile0 = new MockFile(""f<)p#,x{-if;^rzz(t@"", ""\r\n"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, false, 'h');
      iMAP0.addProtocolCommandListener(printCommandListener0);
      iMAP0.fireReplyReceived(1978, ""f<)p#,x{-if;^rzz(t@"");
}"
1486,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test2()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      IMAP.IMAPState iMAP_IMAPState0 = IMAP.IMAPState.AUTH_STATE;
      iMAP0.setState(iMAP_IMAPState0);
}"
1487,"    protected String generateCommandID()
    {
        final String res = new String (initialID);
        // ""increase"" the ID for the next call
        boolean carry = true; // want to increment initially
        for (int i = initialID.length-1; carry && i>=0; i--)
        {
            if (initialID[i] == 'Z')
            {
                initialID[i] = 'A';
            }
            else
            {
                initialID[i]++;
                carry = false; // did not wrap round
            }
        }
        return res;
    }","  public void test3()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      String string0 = iMAP0.generateCommandID();
}"
1488,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test4()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      String string0 = iMAP0.generateCommandID();
}"
1489,"    public int sendData(final String command) throws IOException
    {
        return sendCommandWithID(null, command, null);
    }","  public void test5()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      try { 
        iMAP0.sendData("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Received unexpected IMAP protocol response from server: ''.
         //
         verifyException(""org.apache.commons.net.imap.IMAPReply"", e);
      }
  }"
1490,"    public int sendData(final String command) throws IOException
    {
        return sendCommandWithID(null, command, null);
    }","  public void test6()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringWriter stringWriter0 = new StringWriter(0);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      bufferedWriter0.close();
      iMAP0.__writer = bufferedWriter0;
      try { 
        iMAP0.sendData(""<"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedWriter"", e);
      }
  }"
1491,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test7()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      IMAPCommand iMAPCommand0 = IMAPCommand.RENAME;
      try { 
        iMAP0.sendCommand(iMAPCommand0, ""\"""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Received unexpected IMAP protocol response from server: ''.
         //
         verifyException(""org.apache.commons.net.imap.IMAPReply"", e);
      }
  }"
1492,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test8()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringWriter stringWriter0 = new StringWriter(0);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      bufferedWriter0.close();
      iMAP0.__writer = bufferedWriter0;
      IMAPCommand iMAPCommand0 = IMAPCommand.EXPUNGE;
      try { 
        iMAP0.sendCommand(iMAPCommand0, ""\""lr&Zt"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedWriter"", e);
      }
  }"
1493,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test9()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      bufferedReader0.readLine();
      IMAPCommand iMAPCommand0 = IMAPCommand.UNSUBSCRIBE;
      try { 
        iMAP0.sendCommand(iMAPCommand0, (String) null);
        fail(""Expecting exception: EOFException"");
      } catch(EOFException e) {
         //
         // Connection closed without indication.
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1494,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test10()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      IMAPCommand iMAPCommand0 = IMAPCommand.EXAMINE;
      try { 
        iMAP0.sendCommand(iMAPCommand0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Received unexpected IMAP protocol response from server: ''.
         //
         verifyException(""org.apache.commons.net.imap.IMAPReply"", e);
      }
  }"
1495,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test11()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      PipedWriter pipedWriter0 = new PipedWriter();
      BufferedWriter bufferedWriter0 = new BufferedWriter(pipedWriter0);
      iMAP0.__writer = bufferedWriter0;
      IMAPCommand iMAPCommand0 = IMAPCommand.FETCH;
      try { 
        iMAP0.sendCommand(iMAPCommand0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedWriter"", e);
      }
  }"
1496,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test12()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      bufferedReader0.readLine();
      IMAPCommand iMAPCommand0 = IMAPCommand.XOAUTH;
      try { 
        iMAP0.sendCommand(iMAPCommand0);
        fail(""Expecting exception: EOFException"");
      } catch(EOFException e) {
         //
         // Connection closed without indication.
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1497,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test13()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      try { 
        iMAP0.sendCommand(""\r\n"", ""NOT_AUTH_STAE"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Received unexpected IMAP protocol response from server: ''.
         //
         verifyException(""org.apache.commons.net.imap.IMAPReply"", e);
      }
  }"
1498,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test14()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      bufferedWriter0.close();
      iMAP0.__writer = bufferedWriter0;
      try { 
        iMAP0.sendCommand(""AAAA"", ""AAAA"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedWriter"", e);
      }
  }"
1499,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test15()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      bufferedReader0.readLine();
      try { 
        iMAP0.sendCommand("""", ""\""#Q^>yus&*U"");
        fail(""Expecting exception: EOFException"");
      } catch(EOFException e) {
         //
         // Connection closed without indication.
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1500,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test16()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      try { 
        iMAP0.sendCommand(""NOT_AUTH_STATE"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Received unexpected IMAP protocol response from server: ''.
         //
         verifyException(""org.apache.commons.net.imap.IMAPReply"", e);
      }
  }"
1501,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test17()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringWriter stringWriter0 = new StringWriter(0);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      bufferedWriter0.close();
      iMAP0.__writer = bufferedWriter0;
      try { 
        iMAP0.sendCommand(""NOT_AUTH_STATE"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedWriter"", e);
      }
  }"
1502,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test18()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      stringReader0.skip(143);
      iMAP0.__writer = bufferedWriter0;
      try { 
        iMAP0.sendCommand(""NOT_AUTH_STATE"");
        fail(""Expecting exception: EOFException"");
      } catch(EOFException e) {
         //
         // Connection closed without indication.
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1503,"    public boolean doCommand(final IMAPCommand command, final String args) throws IOException
    {
        return IMAPReply.isSuccess(sendCommand(command, args));
    }","  public void test19()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      IMAPCommand iMAPCommand0 = IMAPCommand.CHECK;
      try { 
        iMAP0.doCommand(iMAPCommand0, ""G8,Ct7&/b_-lZm~/}q"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Received unexpected IMAP protocol response from server: ''.
         //
         verifyException(""org.apache.commons.net.imap.IMAPReply"", e);
      }
  }"
1504,"    public boolean doCommand(final IMAPCommand command, final String args) throws IOException
    {
        return IMAPReply.isSuccess(sendCommand(command, args));
    }","  public void test20()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""\r\n"");
      FileSystemHandling.shouldThrowIOException(evoSuiteFile0);
      IMAPCommand iMAPCommand0 = IMAPCommand.XOAUTH;
      MockFileWriter mockFileWriter0 = new MockFileWriter(""\r\n"");
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockFileWriter0);
      iMAP0.__writer = bufferedWriter0;
      try { 
        iMAP0.doCommand(iMAPCommand0, ""$VLUES"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IOException
         //
         verifyException(""org.evosuite.runtime.vfs.VirtualFileSystem"", e);
      }
  }"
1505,"    public boolean doCommand(final IMAPCommand command, final String args) throws IOException
    {
        return IMAPReply.isSuccess(sendCommand(command, args));
    }","  public void test21()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      bufferedReader0.readLine();
      IMAPCommand iMAPCommand0 = IMAPCommand.XOAUTH;
      try { 
        iMAP0.doCommand(iMAPCommand0, ""AAAA"");
        fail(""Expecting exception: EOFException"");
      } catch(EOFException e) {
         //
         // Connection closed without indication.
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1506,"    public boolean doCommand(final IMAPCommand command, final String args) throws IOException
    {
        return IMAPReply.isSuccess(sendCommand(command, args));
    }","  public void test22()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      stringReader0.close();
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      IMAPCommand iMAPCommand0 = IMAPCommand.LIST;
      try { 
        iMAP0.doCommand(iMAPCommand0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.StringReader"", e);
      }
  }"
1507,"    public boolean doCommand(final IMAPCommand command, final String args) throws IOException
    {
        return IMAPReply.isSuccess(sendCommand(command, args));
    }","  public void test23()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      bufferedReader0.readLine();
      IMAPCommand iMAPCommand0 = IMAPCommand.XOAUTH;
      try { 
        iMAP0.doCommand(iMAPCommand0);
        fail(""Expecting exception: EOFException"");
      } catch(EOFException e) {
         //
         // Connection closed without indication.
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1508,"    protected void _connectAction_() throws IOException
    {
        super._connectAction_();
        _reader =
          new CRLFLineReader(new InputStreamReader(_input_,
                                                   __DEFAULT_ENCODING));
        __writer =
          new BufferedWriter(new OutputStreamWriter(_output_,
                                                    __DEFAULT_ENCODING));
        final int tmo = getSoTimeout();
        if (tmo <= 0) { // none set currently
            setSoTimeout(connectTimeout); // use connect timeout to ensure we don't block forever
        }
        getReply(false); // untagged response
        if (tmo <= 0) {
            setSoTimeout(tmo); // restore the original value
        }
        setState(IMAPState.NOT_AUTH_STATE);
    }","  public void test24()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      // Undeclared exception!
      try { 
        iMAP0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1509,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test25()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      iMAP0.getReplyString();
}"
1510,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test26()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      // Undeclared exception!
      try { 
        iMAP0.sendCommand(""AszH7)Z_*_"", """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1511,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test27()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      IMAPCommand iMAPCommand0 = IMAPCommand.RENAME;
      // Undeclared exception!
      try { 
        iMAP0.sendCommand(iMAPCommand0, ""\"""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1512,"    static String quoteMailboxName(final String input) {
        if (input == null) { // Don't throw NPE here
            return null;
        }
        if (input.isEmpty()) {
            return ""\""\""""; // return the string """"
        }
        // Length check is necessary to ensure a lone double-quote is quoted
        if (input.length() > 1 && input.startsWith(""\"""") && input.endsWith(""\"""")) {
            return input; // Assume already quoted
        }
        if (input.contains("" "")) {
            // quoted strings must escape \ and ""
            return ""\"""" + input.replaceAll(""([\\\\\""])"", ""\\\\$1"") + ""\"""";
        }
        return input;

    }","  public void test28()  throws Throwable  {
      String string0 = IMAP.quoteMailboxName(""Pattern is missing"");
}"
1513,"    static String quoteMailboxName(final String input) {
        if (input == null) { // Don't throw NPE here
            return null;
        }
        if (input.isEmpty()) {
            return ""\""\""""; // return the string """"
        }
        // Length check is necessary to ensure a lone double-quote is quoted
        if (input.length() > 1 && input.startsWith(""\"""") && input.endsWith(""\"""")) {
            return input; // Assume already quoted
        }
        if (input.contains("" "")) {
            // quoted strings must escape \ and ""
            return ""\"""" + input.replaceAll(""([\\\\\""])"", ""\\\\$1"") + ""\"""";
        }
        return input;

    }","  public void test29()  throws Throwable  {
      String string0 = IMAP.quoteMailboxName(""\""L!"");
}"
1514,"    static String quoteMailboxName(final String input) {
        if (input == null) { // Don't throw NPE here
            return null;
        }
        if (input.isEmpty()) {
            return ""\""\""""; // return the string """"
        }
        // Length check is necessary to ensure a lone double-quote is quoted
        if (input.length() > 1 && input.startsWith(""\"""") && input.endsWith(""\"""")) {
            return input; // Assume already quoted
        }
        if (input.contains("" "")) {
            // quoted strings must escape \ and ""
            return ""\"""" + input.replaceAll(""([\\\\\""])"", ""\\\\$1"") + ""\"""";
        }
        return input;

    }","  public void test30()  throws Throwable  {
      String string0 = IMAP.quoteMailboxName(""\""\"""");
}"
1515,"    static String quoteMailboxName(final String input) {
        if (input == null) { // Don't throw NPE here
            return null;
        }
        if (input.isEmpty()) {
            return ""\""\""""; // return the string """"
        }
        // Length check is necessary to ensure a lone double-quote is quoted
        if (input.length() > 1 && input.startsWith(""\"""") && input.endsWith(""\"""")) {
            return input; // Assume already quoted
        }
        if (input.contains("" "")) {
            // quoted strings must escape \ and ""
            return ""\"""" + input.replaceAll(""([\\\\\""])"", ""\\\\$1"") + ""\"""";
        }
        return input;

    }","  public void test31()  throws Throwable  {
      String string0 = IMAP.quoteMailboxName(""f"");
}"
1516,"    static String quoteMailboxName(final String input) {
        if (input == null) { // Don't throw NPE here
            return null;
        }
        if (input.isEmpty()) {
            return ""\""\""""; // return the string """"
        }
        // Length check is necessary to ensure a lone double-quote is quoted
        if (input.length() > 1 && input.startsWith(""\"""") && input.endsWith(""\"""")) {
            return input; // Assume already quoted
        }
        if (input.contains("" "")) {
            // quoted strings must escape \ and ""
            return ""\"""" + input.replaceAll(""([\\\\\""])"", ""\\\\$1"") + ""\"""";
        }
        return input;

    }","  public void test32()  throws Throwable  {
      String string0 = IMAP.quoteMailboxName((String) null);
}"
1517,"    static String quoteMailboxName(final String input) {
        if (input == null) { // Don't throw NPE here
            return null;
        }
        if (input.isEmpty()) {
            return ""\""\""""; // return the string """"
        }
        // Length check is necessary to ensure a lone double-quote is quoted
        if (input.length() > 1 && input.startsWith(""\"""") && input.endsWith(""\"""")) {
            return input; // Assume already quoted
        }
        if (input.contains("" "")) {
            // quoted strings must escape \ and ""
            return ""\"""" + input.replaceAll(""([\\\\\""])"", ""\\\\$1"") + ""\"""";
        }
        return input;

    }","  public void test33()  throws Throwable  {
      String string0 = IMAP.quoteMailboxName("""");
}"
1518,"    static String quoteMailboxName(final String input) {
        if (input == null) { // Don't throw NPE here
            return null;
        }
        if (input.isEmpty()) {
            return ""\""\""""; // return the string """"
        }
        // Length check is necessary to ensure a lone double-quote is quoted
        if (input.length() > 1 && input.startsWith(""\"""") && input.endsWith(""\"""")) {
            return input; // Assume already quoted
        }
        if (input.contains("" "")) {
            // quoted strings must escape \ and ""
            return ""\"""" + input.replaceAll(""([\\\\\""])"", ""\\\\$1"") + ""\"""";
        }
        return input;

    }","  public void test34()  throws Throwable  {
      String string0 = IMAP.quoteMailboxName("""");
}"
1519,"    protected void fireReplyReceived(final int replyCode, final String ignored) {
        if (getCommandSupport().getListenerCount() > 0) {
            getCommandSupport().fireReplyReceived(replyCode, getReplyString());
        }
    }","  public void test35()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      PrintCommandListener printCommandListener0 = new PrintCommandListener((PrintWriter) null, true, 'h');
      iMAP0.addProtocolCommandListener(printCommandListener0);
      // Undeclared exception!
      try { 
        iMAP0.fireReplyReceived(143, ""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.PrintCommandListener"", e);
      }
  }"
1520,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test36()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      iMAP0.fireReplyReceived(143, ""\r\n"");
}"
1521,"    public int sendData(final String command) throws IOException
    {
        return sendCommandWithID(null, command, null);
    }","  public void test37()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      bufferedReader0.readLine();
      try { 
        iMAP0.sendData(""\""3!\"""");
        fail(""Expecting exception: EOFException"");
      } catch(EOFException e) {
         //
         // Connection closed without indication.
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1522,"    public boolean doCommand(final IMAPCommand command, final String args) throws IOException
    {
        return IMAPReply.isSuccess(sendCommand(command, args));
    }","  public void test38()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringReader stringReader0 = new StringReader(""\r\n"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      iMAP0._reader = bufferedReader0;
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      IMAPCommand iMAPCommand0 = IMAPCommand.AUTHENTICATE;
      try { 
        iMAP0.doCommand(iMAPCommand0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Received unexpected IMAP protocol response from server: ''.
         //
         verifyException(""org.apache.commons.net.imap.IMAPReply"", e);
      }
  }"
1523,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test39()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      iMAP0.getReplyStrings();
}"
1524,"    public boolean doCommand(final IMAPCommand command, final String args) throws IOException
    {
        return IMAPReply.isSuccess(sendCommand(command, args));
    }","  public void test40()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      IMAPCommand iMAPCommand0 = IMAPCommand.UNSUBSCRIBE;
      // Undeclared exception!
      try { 
        iMAP0.doCommand(iMAPCommand0, ""DELETE"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1525,"    public int sendData(final String command) throws IOException
    {
        return sendCommandWithID(null, command, null);
    }","  public void test41()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      // Undeclared exception!
      try { 
        iMAP0.sendData(""\""3!\"""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1526,"    public boolean doCommand(final IMAPCommand command, final String args) throws IOException
    {
        return IMAPReply.isSuccess(sendCommand(command, args));
    }","  public void test42()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      IMAPCommand iMAPCommand0 = IMAPCommand.XOAUTH;
      // Undeclared exception!
      try { 
        iMAP0.doCommand(iMAPCommand0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1527,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test43()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      // Undeclared exception!
      try { 
        iMAP0.sendCommand(""NOT_AUTH_STATE"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1528,"    public int sendCommand(final String command, final String args) throws IOException
    {
        return sendCommandWithID(generateCommandID(), command, args);
    }","  public void test44()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      StringWriter stringWriter0 = new StringWriter(143);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 143);
      iMAP0.__writer = bufferedWriter0;
      IMAPCommand iMAPCommand0 = IMAPCommand.XOAUTH;
      // Undeclared exception!
      try { 
        iMAP0.sendCommand(iMAPCommand0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1529,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test45()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      iMAP0.getState();
}"
1530,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test46()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      iMAP0.disconnect();
}"
1531,"    public IMAP()
    {
        setDefaultPort(DEFAULT_PORT);
        state = IMAPState.DISCONNECTED_STATE;
        _reader = null;
        __writer = null;
        replyLines = new ArrayList<>();
        createCommandSupport();
    }","  public void test47()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      boolean boolean0 = iMAP0.TRUE_CHUNK_LISTENER.chunkReceived(iMAP0);
}"
1532,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test48()  throws Throwable  {
      IMAP iMAP0 = new IMAP();
      boolean boolean0 = iMAP0.TRUE_CHUNK_LISTENER.chunkReceived(iMAP0);
}"
1533,"    public boolean authenticate(final AuthenticatingIMAPClient.AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        return auth(method, username, password);
    }","  public void test0()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient();
      AuthenticatingIMAPClient.AUTH_METHOD authenticatingIMAPClient_AUTH_METHOD0 = AuthenticatingIMAPClient.AUTH_METHOD.LOGIN;
      // Undeclared exception!
      try { 
        authenticatingIMAPClient0.authenticate(authenticatingIMAPClient_AUTH_METHOD0, """", ""wT\""<z"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1534,"    public boolean auth(final AuthenticatingIMAPClient.AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        if (!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE, method.getAuthName())))
        {
            return false;
        }

        switch (method) {
            case PLAIN:
            {
                // the server sends an empty response (""+ ""), so we don't have to read it.
                final int result = sendData(
                    Base64.encodeBase64StringUnChunked((""\000"" + username + ""\000"" + password)
                            .getBytes(getCharset())));
                if (result == IMAPReply.OK)
                {
                    setState(IMAP.IMAPState.AUTH_STATE);
                }
                return result == IMAPReply.OK;
            }
            case CRAM_MD5:
            {
                // get the CRAM challenge (after ""+ "")
                final byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
                // get the Mac instance
                final Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
                hmac_md5.init(new SecretKeySpec(password.getBytes(getCharset()), ""HmacMD5""));
                // compute the result:
                final byte[] hmacResult = convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes(getCharset());
                // join the byte arrays to form the reply
                final byte[] usernameBytes = username.getBytes(getCharset());
                final byte[] toEncode = new byte[usernameBytes.length + 1 /* the space */ + hmacResult.length];
                System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
                toEncode[usernameBytes.length] = ' ';
                System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
                // send the reply and read the server code:
                final int result = sendData(Base64.encodeBase64StringUnChunked(toEncode));
                if (result == IMAPReply.OK)
                {
                    setState(IMAP.IMAPState.AUTH_STATE);
                }
                return result == IMAPReply.OK;
            }
            case LOGIN:
            {
                // the server sends fixed responses (base64(""Username"") and
                // base64(""Password"")), so we don't have to read them.
                if (sendData(Base64.encodeBase64StringUnChunked(username.getBytes(getCharset()))) != IMAPReply.CONT)
                {
                    return false;
                }
                final int result = sendData(Base64.encodeBase64StringUnChunked(password.getBytes(getCharset())));
                if (result == IMAPReply.OK)
                {
                    setState(IMAP.IMAPState.AUTH_STATE);
                }
                return result == IMAPReply.OK;
            }
            case XOAUTH:
            case XOAUTH2:
            {
                final int result = sendData(username);
                if (result == IMAPReply.OK)
                {
                    setState(IMAP.IMAPState.AUTH_STATE);
                }
                return result == IMAPReply.OK;
            }
        }
        return false; // safety check
    }","  public void test1()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient();
      AuthenticatingIMAPClient.AUTH_METHOD authenticatingIMAPClient_AUTH_METHOD0 = AuthenticatingIMAPClient.AUTH_METHOD.XOAUTH2;
      // Undeclared exception!
      try { 
        authenticatingIMAPClient0.auth(authenticatingIMAPClient_AUTH_METHOD0, "".(g9 8fO"", ""*"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1535,"    public AuthenticatingIMAPClient()
    {
        this(DEFAULT_PROTOCOL, false);
    }","  public void test2()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(true, sSLContext0);
}"
1536,"    public AuthenticatingIMAPClient()
    {
        this(DEFAULT_PROTOCOL, false);
    }","  public void test3()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient((String) null, true, sSLContext0);
}"
1537,,"  public void test4()  throws Throwable  {
      AuthenticatingIMAPClient.AUTH_METHOD authenticatingIMAPClient_AUTH_METHOD0 = AuthenticatingIMAPClient.AUTH_METHOD.LOGIN;
      String string0 = authenticatingIMAPClient_AUTH_METHOD0.getAuthName();
}"
1538,"    public boolean authenticate(final AuthenticatingIMAPClient.AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        return auth(method, username, password);
    }","  public void test5()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(sSLContext0);
      PipedWriter pipedWriter0 = new PipedWriter();
      BufferedWriter bufferedWriter0 = new BufferedWriter(pipedWriter0);
      authenticatingIMAPClient0.__writer = bufferedWriter0;
      AuthenticatingIMAPClient.AUTH_METHOD authenticatingIMAPClient_AUTH_METHOD0 = AuthenticatingIMAPClient.AUTH_METHOD.XOAUTH;
      try { 
        authenticatingIMAPClient0.authenticate(authenticatingIMAPClient_AUTH_METHOD0, """", """");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedWriter"", e);
      }
  }"
1539,"    public AuthenticatingIMAPClient()
    {
        this(DEFAULT_PROTOCOL, false);
    }","  public void test6()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(false);
}"
1540,"    public boolean authenticate(final AuthenticatingIMAPClient.AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        return auth(method, username, password);
    }","  public void test7()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient(""XOAUTH2"", false);
      AuthenticatingIMAPClient.AUTH_METHOD authenticatingIMAPClient_AUTH_METHOD0 = AuthenticatingIMAPClient.AUTH_METHOD.CRAM_MD5;
      // Undeclared exception!
      try { 
        authenticatingIMAPClient0.authenticate(authenticatingIMAPClient_AUTH_METHOD0, ""org.apache.commons.net.util.Base64"", ""org.apache.commons.net.util.Base64"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1541,"    public AuthenticatingIMAPClient()
    {
        this(DEFAULT_PROTOCOL, false);
    }","  public void test8()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient("""");
}"
1542,"    public boolean auth(final AuthenticatingIMAPClient.AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        if (!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE, method.getAuthName())))
        {
            return false;
        }

        switch (method) {
            case PLAIN:
            {
                // the server sends an empty response (""+ ""), so we don't have to read it.
                final int result = sendData(
                    Base64.encodeBase64StringUnChunked((""\000"" + username + ""\000"" + password)
                            .getBytes(getCharset())));
                if (result == IMAPReply.OK)
                {
                    setState(IMAP.IMAPState.AUTH_STATE);
                }
                return result == IMAPReply.OK;
            }
            case CRAM_MD5:
            {
                // get the CRAM challenge (after ""+ "")
                final byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
                // get the Mac instance
                final Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
                hmac_md5.init(new SecretKeySpec(password.getBytes(getCharset()), ""HmacMD5""));
                // compute the result:
                final byte[] hmacResult = convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes(getCharset());
                // join the byte arrays to form the reply
                final byte[] usernameBytes = username.getBytes(getCharset());
                final byte[] toEncode = new byte[usernameBytes.length + 1 /* the space */ + hmacResult.length];
                System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
                toEncode[usernameBytes.length] = ' ';
                System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
                // send the reply and read the server code:
                final int result = sendData(Base64.encodeBase64StringUnChunked(toEncode));
                if (result == IMAPReply.OK)
                {
                    setState(IMAP.IMAPState.AUTH_STATE);
                }
                return result == IMAPReply.OK;
            }
            case LOGIN:
            {
                // the server sends fixed responses (base64(""Username"") and
                // base64(""Password"")), so we don't have to read them.
                if (sendData(Base64.encodeBase64StringUnChunked(username.getBytes(getCharset()))) != IMAPReply.CONT)
                {
                    return false;
                }
                final int result = sendData(Base64.encodeBase64StringUnChunked(password.getBytes(getCharset())));
                if (result == IMAPReply.OK)
                {
                    setState(IMAP.IMAPState.AUTH_STATE);
                }
                return result == IMAPReply.OK;
            }
            case XOAUTH:
            case XOAUTH2:
            {
                final int result = sendData(username);
                if (result == IMAPReply.OK)
                {
                    setState(IMAP.IMAPState.AUTH_STATE);
                }
                return result == IMAPReply.OK;
            }
        }
        return false; // safety check
    }","  public void test9()  throws Throwable  {
      AuthenticatingIMAPClient authenticatingIMAPClient0 = new AuthenticatingIMAPClient();
      AuthenticatingIMAPClient.AUTH_METHOD authenticatingIMAPClient_AUTH_METHOD0 = AuthenticatingIMAPClient.AUTH_METHOD.XOAUTH2;
      PipedWriter pipedWriter0 = new PipedWriter();
      BufferedWriter bufferedWriter0 = new BufferedWriter(pipedWriter0, 143);
      authenticatingIMAPClient0.__writer = bufferedWriter0;
      try { 
        authenticatingIMAPClient0.auth(authenticatingIMAPClient_AUTH_METHOD0, ""=qa[/!]@XR{JC+-M,"", ""v4fM}Gx"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedWriter"", e);
      }
  }"
1543,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test0()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      iMAPSClient0.setEndpointCheckingEnabled(true);
      boolean boolean0 = iMAPSClient0.isEndpointCheckingEnabled();
}"
1544,"    public void setEnabledProtocols(final String[] protocolVersions)
    {
        protocols = protocolVersions.clone();
    }","  public void test1()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      // Undeclared exception!
      try { 
        iMAPSClient0.setEnabledProtocols((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAPSClient"", e);
      }
  }"
1545,"    public void setEnabledCipherSuites(final String[] cipherSuites)
    {
        suites = cipherSuites.clone();
    }","  public void test2()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient("""");
      // Undeclared exception!
      try { 
        iMAPSClient0.setEnabledCipherSuites((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAPSClient"", e);
      }
  }"
1546,"    public boolean execTLS() throws SSLException, IOException
    {
        if (sendCommand(IMAPCommand.getCommand(IMAPCommand.STARTTLS)) != IMAPReply.OK)
        {
            return false;
            //throw new SSLException(getReplyString());
        }
        performSSLNegotiation();
        return true;
    }","  public void test3()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient(""<"");
      // Undeclared exception!
      try { 
        iMAPSClient0.execTLS();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1547,"    public boolean execTLS() throws SSLException, IOException
    {
        if (sendCommand(IMAPCommand.getCommand(IMAPCommand.STARTTLS)) != IMAPReply.OK)
        {
            return false;
            //throw new SSLException(getReplyString());
        }
        performSSLNegotiation();
        return true;
    }","  public void test4()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      PipedWriter pipedWriter0 = new PipedWriter();
      BufferedWriter bufferedWriter0 = new BufferedWriter(pipedWriter0);
      iMAPSClient0.__writer = bufferedWriter0;
      try { 
        iMAPSClient0.execTLS();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedWriter"", e);
      }
  }"
1548,"    protected void _connectAction_() throws IOException
    {
        // Implicit mode.
        if (isImplicit) {
            performSSLNegotiation();
        }
        super._connectAction_();
        // Explicit mode - don't do anything. The user calls execTLS()
    }","  public void test5()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getInstance(""TLS"");
      IMAPSClient iMAPSClient0 = new IMAPSClient(""W:>Y5*8fm9U{0F >i2s"", true, sSLContext0);
      // Undeclared exception!
      try { 
        iMAPSClient0._connectAction_();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
      }
  }"
1549,"    protected void _connectAction_() throws IOException
    {
        // Implicit mode.
        if (isImplicit) {
            performSSLNegotiation();
        }
        super._connectAction_();
        // Explicit mode - don't do anything. The user calls execTLS()
    }","  public void test6()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient(""#J"", true);
      try { 
        iMAPSClient0._connectAction_();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not initialize SSL context
         //
         verifyException(""org.apache.commons.net.util.SSLContextUtils"", e);
      }
  }"
1550,"    public String[] getEnabledProtocols()
    {
        if (_socket_ instanceof SSLSocket)
        {
            return ((SSLSocket)_socket_).getEnabledProtocols();
        }
        return null;
    }","  public void test7()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      IMAPSClient iMAPSClient0 = new IMAPSClient("""", true, sSLContext0);
      iMAPSClient0.getEnabledProtocols();
}"
1551,"    public String[] getEnabledCipherSuites()
    {
        if (_socket_ instanceof SSLSocket)
        {
            return ((SSLSocket)_socket_).getEnabledCipherSuites();
        }
        return null;
    }","  public void test8()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      iMAPSClient0.getEnabledCipherSuites();
}"
1552,"    protected void _connectAction_() throws IOException
    {
        // Implicit mode.
        if (isImplicit) {
            performSSLNegotiation();
        }
        super._connectAction_();
        // Explicit mode - don't do anything. The user calls execTLS()
    }","  public void test9()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      IMAPSClient iMAPSClient0 = new IMAPSClient("""", true, sSLContext0);
      // Undeclared exception!
      try { 
        iMAPSClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1553,"    protected void _connectAction_() throws IOException
    {
        // Implicit mode.
        if (isImplicit) {
            performSSLNegotiation();
        }
        super._connectAction_();
        // Explicit mode - don't do anything. The user calls execTLS()
    }","  public void test10()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      // Undeclared exception!
      try { 
        iMAPSClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1554,"    public HostnameVerifier getHostnameVerifier()
    {
        return hostnameVerifier;
    }","  public void test11()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      IMAPSClient iMAPSClient0 = new IMAPSClient("""", true, sSLContext0);
      iMAPSClient0.getHostnameVerifier();
}"
1555,"    public void setKeyManager(final KeyManager newKeyManager)
    {
        keyManager = newKeyManager;
    }","  public void test12()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient(""<"");
      ExtendedAliasKeyManager extendedAliasKeyManager0 = new ExtendedAliasKeyManager((KeyManager) null, ""\r\n"");
      AliasKeyManager aliasKeyManager0 = new AliasKeyManager(extendedAliasKeyManager0, ""\r\n"");
      iMAPSClient0.setKeyManager(aliasKeyManager0);
}"
1556,"    protected void _connectAction_() throws IOException
    {
        // Implicit mode.
        if (isImplicit) {
            performSSLNegotiation();
        }
        super._connectAction_();
        // Explicit mode - don't do anything. The user calls execTLS()
    }","  public void test13()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient(true);
      // Undeclared exception!
      try { 
        iMAPSClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1557,"    public TrustManager getTrustManager()
    {
        return trustManager;
    }","  public void test14()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      iMAPSClient0.getTrustManager();
}"
1558,"    public void setTrustManager(final TrustManager newTrustManager)
    {
        trustManager = newTrustManager;
    }","  public void test15()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      iMAPSClient0.setTrustManager((TrustManager) null);
}"
1559,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test16()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      IMAPSClient iMAPSClient0 = new IMAPSClient(sSLContext0);
      iMAPSClient0.isEndpointCheckingEnabled();
}"
1560,"    public void setEnabledProtocols(final String[] protocolVersions)
    {
        protocols = protocolVersions.clone();
    }","  public void test17()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      String[] stringArray0 = iMAPSClient0.getReplyStrings();
      iMAPSClient0.setEnabledProtocols(stringArray0);
}"
1561,"    public void setEnabledCipherSuites(final String[] cipherSuites)
    {
        suites = cipherSuites.clone();
    }","  public void test18()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      String[] stringArray0 = new String[10];
      iMAPSClient0.setEnabledCipherSuites(stringArray0);
}"
1562,"    public IMAPSClient()
    {
        this(DEFAULT_PROTOCOL, false);
    }","  public void test19()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      IMAPSClient iMAPSClient0 = new IMAPSClient(false, sSLContext0);
}"
1563,"    public void setHostnameVerifier(final HostnameVerifier newHostnameVerifier)
    {
        hostnameVerifier = newHostnameVerifier;
    }","  public void test20()  throws Throwable  {
      IMAPSClient iMAPSClient0 = new IMAPSClient();
      iMAPSClient0.setHostnameVerifier((HostnameVerifier) null);
}"
1564,"    public static boolean isContinuation(final String line) {
        return line.startsWith(IMAP_CONTINUATION_PREFIX);
    }","  public void test0()  throws Throwable  {
      boolean boolean0 = IMAPReply.isContinuation(1085);
}"
1565,"    public static boolean isSuccess(final int replyCode) {
        return replyCode == OK;
    }","  public void test1()  throws Throwable  {
      boolean boolean0 = IMAPReply.isSuccess(434);
}"
1566,"    public static boolean isUntagged(final String line) {
        return line.startsWith(IMAP_UNTAGGED_PREFIX);
    }","  public void test2()  throws Throwable  {
      boolean boolean0 = IMAPReply.isUntagged(""* "");
}"
1567,"    public static boolean isUntagged(final String line) {
        return line.startsWith(IMAP_UNTAGGED_PREFIX);
    }","  public void test3()  throws Throwable  {
      boolean boolean0 = IMAPReply.isUntagged("""");
}"
1568,"    public static boolean isContinuation(final String line) {
        return line.startsWith(IMAP_CONTINUATION_PREFIX);
    }","  public void test4()  throws Throwable  {
      boolean boolean0 = IMAPReply.isContinuation(""+N|/M$^EiA"");
}"
1569,"    public static int getReplyCode(final String line) throws IOException {
        return getReplyCode(line, TAGGED_PATTERN);
    }","  public void test5()  throws Throwable  {
      int int0 = IMAPReply.getReplyCode(""+"");
}"
1570,"    public static int literalCount(final String line) {
        final Matcher m = LITERAL_PATTERN.matcher(line);
        if (m.find()) {
            return Integer.parseInt(m.group(1)); // Should always parse because we matched \d+
        }
        return -1;
    }","  public void test6()  throws Throwable  {
      // Undeclared exception!
      try { 
        IMAPReply.literalCount((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1571,"    public static boolean isContinuation(final String line) {
        return line.startsWith(IMAP_CONTINUATION_PREFIX);
    }","  public void test7()  throws Throwable  {
      // Undeclared exception!
      try { 
        IMAPReply.isContinuation((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1572,"    public static int getUntaggedReplyCode(final String line) throws IOException {
        return getReplyCode(line, UNTAGGED_PATTERN);
    }","  public void test8()  throws Throwable  {
      // Undeclared exception!
      try { 
        IMAPReply.getUntaggedReplyCode((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1573,"    public static int getReplyCode(final String line) throws IOException {
        return getReplyCode(line, TAGGED_PATTERN);
    }","  public void test9()  throws Throwable  {
      // Undeclared exception!
      try { 
        IMAPReply.getReplyCode((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1574,"    public static boolean isContinuation(final String line) {
        return line.startsWith(IMAP_CONTINUATION_PREFIX);
    }","  public void test10()  throws Throwable  {
      boolean boolean0 = IMAPReply.isContinuation(""org.apache.commons.net.MalformedServerReplyException"");
}"
1575,"    public static boolean isContinuation(final String line) {
        return line.startsWith(IMAP_CONTINUATION_PREFIX);
    }","  public void test11()  throws Throwable  {
      boolean boolean0 = IMAPReply.isContinuation(3);
}"
1576,"    public static boolean isContinuation(final String line) {
        return line.startsWith(IMAP_CONTINUATION_PREFIX);
    }","  public void test12()  throws Throwable  {
      boolean boolean0 = IMAPReply.isContinuation((-2173));
}"
1577,"    public static boolean isSuccess(final int replyCode) {
        return replyCode == OK;
    }","  public void test13()  throws Throwable  {
      boolean boolean0 = IMAPReply.isSuccess(0);
}"
1578,"    public static boolean isSuccess(final int replyCode) {
        return replyCode == OK;
    }","  public void test14()  throws Throwable  {
      boolean boolean0 = IMAPReply.isSuccess((-749));
}"
1579,"    public static int getUntaggedReplyCode(final String line) throws IOException {
        return getReplyCode(line, UNTAGGED_PATTERN);
    }","  public void test15()  throws Throwable  {
      int int0 = IMAPReply.getUntaggedReplyCode(""+"");
}"
1580,"    public static int literalCount(final String line) {
        final Matcher m = LITERAL_PATTERN.matcher(line);
        if (m.find()) {
            return Integer.parseInt(m.group(1)); // Should always parse because we matched \d+
        }
        return -1;
    }","  public void test16()  throws Throwable  {
      int int0 = IMAPReply.literalCount(""+"");
}"
1581,"    public static int getReplyCode(final String line) throws IOException {
        return getReplyCode(line, TAGGED_PATTERN);
    }","  public void test17()  throws Throwable  {
      try { 
        IMAPReply.getReplyCode(""Jc\u0000"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Received unexpected IMAP protocol response from server: 'Jc\u0000'.
         //
         verifyException(""org.apache.commons.net.imap.IMAPReply"", e);
      }
  }"
1582,"    public static int getUntaggedReplyCode(final String line) throws IOException {
        return getReplyCode(line, UNTAGGED_PATTERN);
    }","  public void test18()  throws Throwable  {
      try { 
        IMAPReply.getUntaggedReplyCode(""org.apache.commons.net.MalformedServerReplyException"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Received unexpected IMAP protocol response from server: 'org.apache.commons.net.MalformedServerReplyException'.
         //
         verifyException(""org.apache.commons.net.imap.IMAPReply"", e);
      }
  }"
1583,"    public static boolean isUntagged(final String line) {
        return line.startsWith(IMAP_UNTAGGED_PREFIX);
    }","  public void test19()  throws Throwable  {
      // Undeclared exception!
      try { 
        IMAPReply.isUntagged((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
      }
  }"
1584,"    public boolean copy(final String sequenceSet, final String mailboxName) throws IOException
    {
        return doCommand (IMAPCommand.COPY, sequenceSet + "" "" + quoteMailboxName(mailboxName));
    }","  public void test0()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.copy(""INTERNALDATE"", ""YPCsCobXok6IB}`"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1585,"    public boolean store(final String sequenceSet, final String itemNames, final String itemValues)
        throws IOException
    {
        return doCommand (IMAPCommand.STORE, sequenceSet + "" "" + itemNames + "" "" + itemValues);
    }","  public void test1()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.store(""ll4kZ"", ""ll4kZ"", ""&m*"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1586,"    public boolean store(final String sequenceSet, final String itemNames, final String itemValues)
        throws IOException
    {
        return doCommand (IMAPCommand.STORE, sequenceSet + "" "" + itemNames + "" "" + itemValues);
    }","  public void test2()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.store((String) null, ""qyr"", ""qyr"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1587,"    public boolean fetch(final String sequenceSet, final String itemNames) throws IOException
    {
        return doCommand (IMAPCommand.FETCH, sequenceSet + "" "" + itemNames);
    }","  public void test3()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.fetch(""oJ!M}R8+}1*Z7X"", ""i]RjP^%,yU%}n,L${V"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1588,"    public boolean search(final String charset, final String criteria) throws IOException
    {
        String args = """";
        if (charset != null) {
            args += ""CHARSET "" + charset;
        }
        args += criteria;
        return doCommand (IMAPCommand.SEARCH, args);
    }","  public void test4()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.search(""hSup,;go="", ""d1\""O<-Hpd&(N"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1589,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test5()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append(""w}w|j4Fl4kA >Y$E"", ""w}w|j4Fl4kA >Y$E"", ""DELETED"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1590,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test6()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append("""", ""R`TTw}I:M I`-fM"", ""R`TTw}I:M I`-fM"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1591,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test7()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append("""", """", (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1592,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test8()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append("" *******"", (String) null, ""LSUB"", ""\"""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1593,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test9()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append(""IsH38Y:T%%>"", ""`w@FF#nj$@9``!"", ""\""M"", """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1594,"    public boolean lsub(final String refName, final String mailboxName) throws IOException
    {
        return doCommand (IMAPCommand.LSUB, quoteMailboxName(refName) + "" "" + quoteMailboxName(mailboxName));
    }","  public void test10()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.lsub(""9T51T3"", """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1595,"    public boolean list(final String refName, final String mailboxName) throws IOException
    {
        return doCommand (IMAPCommand.LIST, quoteMailboxName(refName) + "" "" + quoteMailboxName(mailboxName));
    }","  public void test11()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.list("""", ""!oa 8P}b/iapMg"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1596,"    public boolean login(final String username, final String password) throws IOException
    {
        if (getState() != IMAP.IMAPState.NOT_AUTH_STATE)
        {
            return false;
        }

        if (!doCommand(IMAPCommand.LOGIN, username + "" "" + password))
        {
            return false;
        }

        setState(IMAP.IMAPState.AUTH_STATE);

        return true;
    }","  public void test12()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      IMAP.IMAPState iMAP_IMAPState0 = IMAP.IMAPState.NOT_AUTH_STATE;
      iMAPClient0.setState(iMAP_IMAPState0);
      // Undeclared exception!
      try { 
        iMAPClient0.login(""CuHT4@Zl/>a"", ""9"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1597,"    public boolean status(final String mailboxName, final String[] itemNames) throws IOException
    {
        if (itemNames == null || itemNames.length < 1) {
            throw new IllegalArgumentException(""STATUS command requires at least one data item name"");
        }

        final StringBuilder sb = new StringBuilder();
        sb.append(quoteMailboxName(mailboxName));

        sb.append("" ("");
        for ( int i = 0; i < itemNames.length; i++ )
        {
            if (i > 0) {
                sb.append("" "");
            }
            sb.append(itemNames[i]);
        }
        sb.append("")"");

        return doCommand (IMAPCommand.STATUS, sb.toString());
    }","  public void test13()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      PipedWriter pipedWriter0 = new PipedWriter();
      BufferedWriter bufferedWriter0 = new BufferedWriter(pipedWriter0);
      iMAPClient0.__writer = bufferedWriter0;
      String[] stringArray0 = new String[4];
      try { 
        iMAPClient0.status(""yg3M#"", stringArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedWriter"", e);
      }
  }"
1598,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test14()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append("""", ""UNDRAFT"", """", ""UNDRAFT"");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
1599,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test15()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append("""", """", """");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
1600,"    public boolean search(final String charset, final String criteria) throws IOException
    {
        String args = """";
        if (charset != null) {
            args += ""CHARSET "" + charset;
        }
        args += criteria;
        return doCommand (IMAPCommand.SEARCH, args);
    }","  public void test16()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.search((String) null, ""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1601,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test17()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append((String) null, (String) null, (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1602,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test18()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append(""|}uPJp"", ""|}uPJp"", ""|}uPJp"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1603,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test19()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append(""\""@f3x4`Ybq"", ""\""@f3x4`Ybq"", (String) null, ""\""@f3x4`Ybq"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1604,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test20()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append("" {"", ""\r\n"", ""\r\n"", "" {"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1605,"    public boolean status(final String mailboxName, final String[] itemNames) throws IOException
    {
        if (itemNames == null || itemNames.length < 1) {
            throw new IllegalArgumentException(""STATUS command requires at least one data item name"");
        }

        final StringBuilder sb = new StringBuilder();
        sb.append(quoteMailboxName(mailboxName));

        sb.append("" ("");
        for ( int i = 0; i < itemNames.length; i++ )
        {
            if (i > 0) {
                sb.append("" "");
            }
            sb.append(itemNames[i]);
        }
        sb.append("")"");

        return doCommand (IMAPCommand.STATUS, sb.toString());
    }","  public void test21()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        iMAPClient0.status(""\r\n"", stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // STATUS command requires at least one data item name
         //
         verifyException(""org.apache.commons.net.imap.IMAPClient"", e);
      }
  }"
1606,"    public boolean status(final String mailboxName, final String[] itemNames) throws IOException
    {
        if (itemNames == null || itemNames.length < 1) {
            throw new IllegalArgumentException(""STATUS command requires at least one data item name"");
        }

        final StringBuilder sb = new StringBuilder();
        sb.append(quoteMailboxName(mailboxName));

        sb.append("" ("");
        for ( int i = 0; i < itemNames.length; i++ )
        {
            if (i > 0) {
                sb.append("" "");
            }
            sb.append(itemNames[i]);
        }
        sb.append("")"");

        return doCommand (IMAPCommand.STATUS, sb.toString());
    }","  public void test22()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      String[] stringArray0 = new String[8];
      // Undeclared exception!
      try { 
        iMAPClient0.status("""", stringArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1607,"    public boolean status(final String mailboxName, final String[] itemNames) throws IOException
    {
        if (itemNames == null || itemNames.length < 1) {
            throw new IllegalArgumentException(""STATUS command requires at least one data item name"");
        }

        final StringBuilder sb = new StringBuilder();
        sb.append(quoteMailboxName(mailboxName));

        sb.append("" ("");
        for ( int i = 0; i < itemNames.length; i++ )
        {
            if (i > 0) {
                sb.append("" "");
            }
            sb.append(itemNames[i]);
        }
        sb.append("")"");

        return doCommand (IMAPCommand.STATUS, sb.toString());
    }","  public void test23()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.status(""yg3M#"", (String[]) null);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // STATUS command requires at least one data item name
         //
         verifyException(""org.apache.commons.net.imap.IMAPClient"", e);
      }
  }"
1608,"    public boolean login(final String username, final String password) throws IOException
    {
        if (getState() != IMAP.IMAPState.NOT_AUTH_STATE)
        {
            return false;
        }

        if (!doCommand(IMAPCommand.LOGIN, username + "" "" + password))
        {
            return false;
        }

        setState(IMAP.IMAPState.AUTH_STATE);

        return true;
    }","  public void test24()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      boolean boolean0 = iMAPClient0.login(""\r\n"", ""\r\n"");
}"
1609,"    public boolean delete(final String mailboxName) throws IOException
    {
        return doCommand (IMAPCommand.DELETE, quoteMailboxName(mailboxName));
    }","  public void test25()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.delete(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1610,"    public boolean noop() throws IOException
    {
        return doCommand (IMAPCommand.NOOP);
    }","  public void test26()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.noop();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1611,"    public boolean rename(final String oldMailboxName, final String newMailboxName) throws IOException
    {
        return doCommand (IMAPCommand.RENAME, quoteMailboxName(oldMailboxName) + "" "" + quoteMailboxName(newMailboxName));
    }","  public void test27()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.rename(""\u0003"", (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1612,"    public boolean select(final String mailboxName) throws IOException
    {
        return doCommand (IMAPCommand.SELECT, quoteMailboxName(mailboxName));
    }","  public void test28()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.select(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1613,"    public boolean logout() throws IOException
    {
        return doCommand (IMAPCommand.LOGOUT);
    }","  public void test29()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.logout();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1614,"    public boolean uid(final String command, final String commandArgs) throws IOException
    {
        return doCommand (IMAPCommand.UID, command + "" "" + commandArgs);
    }","  public void test30()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.uid(""org.apache.ftpserver.util.FileRegularFilter"", (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1615,"    public boolean capability() throws IOException
    {
        return doCommand (IMAPCommand.CAPABILITY);
    }","  public void test31()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.capability();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1616,"    public boolean create(final String mailboxName) throws IOException
    {
        return doCommand (IMAPCommand.CREATE, quoteMailboxName(mailboxName));
    }","  public void test32()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.create(""{dlR97Rj"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1617,"    public boolean unsubscribe(final String mailboxName) throws IOException
    {
        return doCommand (IMAPCommand.UNSUBSCRIBE, quoteMailboxName(mailboxName));
    }","  public void test33()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.unsubscribe(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1618,"    public boolean examine(final String mailboxName) throws IOException
    {
        return doCommand (IMAPCommand.EXAMINE, quoteMailboxName(mailboxName));
    }","  public void test34()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.examine(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1619,"    public boolean search(final String charset, final String criteria) throws IOException
    {
        String args = """";
        if (charset != null) {
            args += ""CHARSET "" + charset;
        }
        args += criteria;
        return doCommand (IMAPCommand.SEARCH, args);
    }","  public void test35()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.search(""CC"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1620,"    public boolean check() throws IOException
    {
        return doCommand (IMAPCommand.CHECK);
    }","  public void test36()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.check();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1621,"    public boolean subscribe(final String mailboxName) throws IOException
    {
        return doCommand (IMAPCommand.SUBSCRIBE, quoteMailboxName(mailboxName));
    }","  public void test37()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.subscribe(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1622,"    public boolean append(final String mailboxName, final String flags, final String datetime, final String message)
            throws IOException {
        final StringBuilder args = new StringBuilder(quoteMailboxName(mailboxName));
        if (flags != null) {
            args.append("" "").append(flags);
        }
        if (datetime != null) {
            args.append("" "");
            if (datetime.charAt(0) == DQUOTE) {
                args.append(datetime);
            } else {
                args.append(DQUOTE).append(datetime).append(DQUOTE);
            }
        }
        args.append("" "");
        // String literal (probably not used much - if at all)
        if (message.startsWith(DQUOTE_S) && message.endsWith(DQUOTE_S)) {
            args.append(message);
            return doCommand(IMAPCommand.APPEND, args.toString());
        }
        args.append('{').append(message.getBytes(IMAP.__DEFAULT_ENCODING).length).append('}'); // length of message
        final int status = sendCommand(IMAPCommand.APPEND, args.toString());
        return IMAPReply.isContinuation(status) // expecting continuation response
                && IMAPReply.isSuccess(sendData(message)); // if so, send the data
    }","  public void test38()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.append("">"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1623,"    public boolean close() throws IOException
    {
        return doCommand (IMAPCommand.CLOSE);
    }","  public void test39()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.close();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1624,"    public boolean expunge() throws IOException
    {
        return doCommand (IMAPCommand.EXPUNGE);
    }","  public void test40()  throws Throwable  {
      IMAPClient iMAPClient0 = new IMAPClient();
      // Undeclared exception!
      try { 
        iMAPClient0.expunge();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.imap.IMAP"", e);
      }
  }"
1625,"    public void rlogin(final String localUsername, final String remoteUsername,
                       final String terminalType, final int terminalSpeed)
    throws IOException
    {
        rexec(localUsername, remoteUsername, terminalType + ""/"" + terminalSpeed,
              false);
    }","  public void test0()  throws Throwable  {
      RLoginClient rLoginClient0 = new RLoginClient();
      // Undeclared exception!
      try { 
        rLoginClient0.rlogin((String) null, ""org.apache.commons.io.filefilter.TrueFileFilter"", (String) null, 1299);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.bsd.RExecClient"", e);
      }
  }"
1626,"    public void rlogin(final String localUsername, final String remoteUsername,
                       final String terminalType, final int terminalSpeed)
    throws IOException
    {
        rexec(localUsername, remoteUsername, terminalType + ""/"" + terminalSpeed,
              false);
    }","  public void test1()  throws Throwable  {
      RLoginClient rLoginClient0 = new RLoginClient();
      // Undeclared exception!
      try { 
        rLoginClient0.rlogin(""At!`LOmNJaX[="", """", ""UtwsP0TyL<,2Td[:"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.bsd.RExecClient"", e);
      }
  }"
1627,"    public void rlogin(final String localUsername, final String remoteUsername,
                       final String terminalType, final int terminalSpeed)
    throws IOException
    {
        rexec(localUsername, remoteUsername, terminalType + ""/"" + terminalSpeed,
              false);
    }","  public void test2()  throws Throwable  {
      RLoginClient rLoginClient0 = new RLoginClient();
      // Undeclared exception!
      try { 
        rLoginClient0.rlogin(""/"", ""/"", ""H}:.N}"", 513);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.bsd.RExecClient"", e);
      }
  }"
1628,"    public void rexec(final String username, final String password,
                      final String command, final boolean separateErrorStream)
    throws IOException
    {
        int ch;

        if (separateErrorStream)
        {
            _errorStream_ = createErrorStream();
        }
        else
        {
            _output_.write(NULL_CHAR);
        }

        _output_.write(username.getBytes(getCharset()));
        _output_.write(NULL_CHAR);
        _output_.write(password.getBytes(getCharset()));
        _output_.write(NULL_CHAR);
        _output_.write(command.getBytes(getCharset()));
        _output_.write(NULL_CHAR);
        _output_.flush();

        ch = _input_.read();
        if (ch > 0) {
            final StringBuilder buffer = new StringBuilder();

            while ((ch = _input_.read()) != -1 && ch != '\n') {
                buffer.append((char)ch);
            }

            throw new IOException(buffer.toString());
        } else if (ch < 0) {
            throw new IOException(""Server closed connection."");
        }
    }","  public void test0()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      // Undeclared exception!
      try { 
        rExecClient0.rexec(""zKvv+],.9'x"", ""n,Ti1'<GD5v:=q=[R"", (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.bsd.RExecClient"", e);
      }
  }"
1629,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test1()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      byte[] byteArray0 = new byte[4];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      rExecClient0._errorStream_ = (InputStream) byteArrayInputStream0;
      InputStream inputStream0 = rExecClient0.getInputStream();
}"
1630,"    public InputStream getInputStream()
    {
        return _input_;
    }","  public void test2()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      byte[] byteArray0 = new byte[4];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      rExecClient0._errorStream_ = (InputStream) byteArrayInputStream0;
      InputStream inputStream0 = rExecClient0.getInputStream();
}"
1631,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test3()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      byte[] byteArray0 = new byte[9];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 512, 512);
      rExecClient0._errorStream_ = (InputStream) byteArrayInputStream0;
      rExecClient0.getErrorStream();
}"
1632,"    InputStream createErrorStream() throws IOException
    {
        final ServerSocket server;
        final Socket socket;

        server = _serverSocketFactory_.createServerSocket(0, 1, getLocalAddress());

        _output_.write(Integer.toString(server.getLocalPort()).getBytes(StandardCharsets.UTF_8)); // $NON-NLS-1$
        _output_.write(NULL_CHAR);
        _output_.flush();

        socket = server.accept();
        server.close();

        if (remoteVerificationEnabled && !verifyRemote(socket))
        {
            socket.close();
            throw new IOException(
                ""Security violation: unexpected connection attempt by "" +
                socket.getInetAddress().getHostAddress());
        }

        return new SocketInputStream(socket, socket.getInputStream());
    }","  public void test4()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      // Undeclared exception!
      try { 
        rExecClient0.createErrorStream();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1633,"    public void rexec(final String username, final String password,
                      final String command, final boolean separateErrorStream)
    throws IOException
    {
        int ch;

        if (separateErrorStream)
        {
            _errorStream_ = createErrorStream();
        }
        else
        {
            _output_.write(NULL_CHAR);
        }

        _output_.write(username.getBytes(getCharset()));
        _output_.write(NULL_CHAR);
        _output_.write(password.getBytes(getCharset()));
        _output_.write(NULL_CHAR);
        _output_.write(command.getBytes(getCharset()));
        _output_.write(NULL_CHAR);
        _output_.flush();

        ch = _input_.read();
        if (ch > 0) {
            final StringBuilder buffer = new StringBuilder();

            while ((ch = _input_.read()) != -1 && ch != '\n') {
                buffer.append((char)ch);
            }

            throw new IOException(buffer.toString());
        } else if (ch < 0) {
            throw new IOException(""Server closed connection."");
        }
    }","  public void test5()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      // Undeclared exception!
      try { 
        rExecClient0.rexec((String) null, (String) null, (String) null, false);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.bsd.RExecClient"", e);
      }
  }"
1634,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test6()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      byte[] byteArray0 = new byte[0];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 512, 0);
      rExecClient0._errorStream_ = (InputStream) byteArrayInputStream0;
      rExecClient0.disconnect();
}"
1635,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test7()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      rExecClient0.disconnect();
}"
1636,"    public void rexec(final String username, final String password,
                      final String command, final boolean separateErrorStream)
    throws IOException
    {
        int ch;

        if (separateErrorStream)
        {
            _errorStream_ = createErrorStream();
        }
        else
        {
            _output_.write(NULL_CHAR);
        }

        _output_.write(username.getBytes(getCharset()));
        _output_.write(NULL_CHAR);
        _output_.write(password.getBytes(getCharset()));
        _output_.write(NULL_CHAR);
        _output_.write(command.getBytes(getCharset()));
        _output_.write(NULL_CHAR);
        _output_.flush();

        ch = _input_.read();
        if (ch > 0) {
            final StringBuilder buffer = new StringBuilder();

            while ((ch = _input_.read()) != -1 && ch != '\n') {
                buffer.append((char)ch);
            }

            throw new IOException(buffer.toString());
        } else if (ch < 0) {
            throw new IOException(""Server closed connection."");
        }
    }","  public void test8()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      // Undeclared exception!
      try { 
        rExecClient0.rexec(""\r\n"", ""\r\n"", ""\r\n"", true);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1637,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test9()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      rExecClient0.isRemoteVerificationEnabled();
}"
1638,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test10()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      rExecClient0.getErrorStream();
}"
1639,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test11()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      rExecClient0.getOutputStream();
}"
1640,"    public final boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test12()  throws Throwable  {
      RExecClient rExecClient0 = new RExecClient();
      rExecClient0.setRemoteVerificationEnabled(true);
      boolean boolean0 = rExecClient0.isRemoteVerificationEnabled();
}"
1641,"    public void rcommand(final String localUsername, final String remoteUsername,
                         final String command, final boolean separateErrorStream)
    throws IOException
    {
        rexec(localUsername, remoteUsername, command, separateErrorStream);
    }","  public void test0()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      // Undeclared exception!
      try { 
        rCommandClient0.rcommand(""66rW]p6AY)6%c"", """", ""66rW]p6AY)6%c"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.bsd.RExecClient"", e);
      }
  }"
1642,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
          RCommandClient rCommandClient0 = new RCommandClient();
          // Undeclared exception!
          try { 
            rCommandClient0.connect(""3So("", (-3026), inetAddress0, 733);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:733\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.Socket.bind(Socket.java:660)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:251)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:278)
             // org.apache.commons.net.bsd.RCommandClient.connect(RCommandClient.java:342)
             // sun.reflect.GeneratedMethodAccessor113.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1643,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test2()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          RCommandClient rCommandClient0 = new RCommandClient();
          InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
          // Undeclared exception!
          try { 
            rCommandClient0.connect(""m|hL'"", 1023, inetAddress0, 1023);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:1023\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.Socket.bind(Socket.java:660)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:251)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:278)
             // org.apache.commons.net.bsd.RCommandClient.connect(RCommandClient.java:342)
             // sun.reflect.GeneratedMethodAccessor113.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1644,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test3()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          InetAddress inetAddress0 = MockInetAddress.getByName(""?d,{x DtihnD,O\""{;E"");
          RCommandClient rCommandClient0 = new RCommandClient();
          InetAddress inetAddress1 = MockInetAddress.getLoopbackAddress();
          // Undeclared exception!
          try { 
            rCommandClient0.connect(inetAddress0, (-137), inetAddress1, 512);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:512\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.Socket.bind(Socket.java:660)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:251)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:236)
             // org.apache.commons.net.bsd.RCommandClient.connect(RCommandClient.java:309)
             // sun.reflect.GeneratedMethodAccessor112.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1645,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test4()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          RCommandClient rCommandClient0 = new RCommandClient();
          byte[] byteArray0 = new byte[4];
          InetAddress inetAddress0 = MockInetAddress.getByAddress(byteArray0);
          // Undeclared exception!
          try { 
            rCommandClient0.connect(inetAddress0, (int) (byte)43, inetAddress0, 1023);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:1023\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.Socket.bind(Socket.java:660)
             // org.apache.commons.net.SocketClient._connect(SocketClient.java:251)
             // org.apache.commons.net.SocketClient.connect(SocketClient.java:236)
             // org.apache.commons.net.bsd.RCommandClient.connect(RCommandClient.java:309)
             // sun.reflect.GeneratedMethodAccessor112.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
1646,"    InputStream createErrorStream() throws IOException
    {
        int localPort;
        ServerSocket server;
        final Socket socket;

        localPort = MAX_CLIENT_PORT;
        server = null; // Keep compiler from barfing

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                server = _serverSocketFactory_.createServerSocket(localPort, 1,
                         getLocalAddress());
                break; // got a socket
            }
            catch (final SocketException e)
            {
                continue;
            }
        }

        if (server == null) {
            throw new BindException(""All ports in use."");
        }

        _output_.write(Integer.toString(server.getLocalPort()).getBytes(StandardCharsets.UTF_8)); // $NON-NLS
        _output_.write(NULL_CHAR);
        _output_.flush();

        socket = server.accept();
        server.close();

        if (isRemoteVerificationEnabled() && !verifyRemote(socket))
        {
            socket.close();
            throw new IOException(
                ""Security violation: unexpected connection attempt by "" +
                socket.getInetAddress().getHostAddress());
        }

        return new SocketInputStream(socket, socket.getInputStream());
    }","  public void test5()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      // Undeclared exception!
      try { 
        rCommandClient0.createErrorStream();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1647,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test6()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      // Undeclared exception!
      try { 
        rCommandClient0.connect((InetAddress) null, (-4649), (InetAddress) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.net.Socket"", e);
      }
  }"
1648,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test7()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      byte[] byteArray0 = new byte[4];
      InetAddress inetAddress0 = MockInetAddress.getByAddress(byteArray0);
      // Undeclared exception!
      try { 
        rCommandClient0.connect(inetAddress0, (-248), inetAddress0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-248
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
1649,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test8()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      Proxy proxy0 = Proxy.NO_PROXY;
      rCommandClient0.setProxy(proxy0);
      try { 
        rCommandClient0.connect(inetAddress0, 804, inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@39d71465
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
1650,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test9()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      // Undeclared exception!
      try { 
        rCommandClient0.connect(inetAddress0, (-1719));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1719
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
1651,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test10()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      Proxy proxy0 = Proxy.NO_PROXY;
      rCommandClient0.setProxy(proxy0);
      try { 
        rCommandClient0.connect((InetAddress) null, 1769);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@73f24a9d
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
1652,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test11()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      Proxy proxy0 = Proxy.NO_PROXY;
      rCommandClient0.setProxy(proxy0);
      try { 
        rCommandClient0.connect(""\r\n"", 512, inetAddress0, 512);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@5df6efc0
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
1653,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test12()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        rCommandClient0.connect((String) null, (-338), inetAddress0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-338
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
1654,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test13()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      Proxy proxy0 = Proxy.NO_PROXY;
      rCommandClient0.setProxy(proxy0);
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      try { 
        rCommandClient0.connect(""yv-N>QeX!Y-z>e8Onn"", 0, inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@5df6b1c0
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
1655,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test14()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      // Undeclared exception!
      try { 
        rCommandClient0.connect(""\r\n"", (-2160));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-2160
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
1656,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test15()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      Proxy proxy0 = Proxy.NO_PROXY;
      rCommandClient0.setProxy(proxy0);
      try { 
        rCommandClient0.connect(""org.apache.commons.io.filefilter.iddenFileFilte"", 1023);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Remote address/port is not opened: org.evosuite.runtime.vnet.EndPointInfo@5df72da1
         //
         verifyException(""org.evosuite.runtime.vnet.VirtualNetwork"", e);
      }
  }"
1657,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test16()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      try { 
        rCommandClient0.connect(""\r\n"", 1023, (InetAddress) null, 4222);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid port number 4222
         //
         verifyException(""org.apache.commons.net.bsd.RCommandClient"", e);
      }
  }"
1658,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test17()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      try { 
        rCommandClient0.connect((String) null, (-640), inetAddress0, (-640));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid port number -640
         //
         verifyException(""org.apache.commons.net.bsd.RCommandClient"", e);
      }
  }"
1659,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test18()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      try { 
        rCommandClient0.connect((InetAddress) null, 1023, (InetAddress) null, 2215);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid port number 2215
         //
         verifyException(""org.apache.commons.net.bsd.RCommandClient"", e);
      }
  }"
1660,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test19()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      try { 
        rCommandClient0.connect(inetAddress0, (-12), inetAddress0, (-12));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid port number -12
         //
         verifyException(""org.apache.commons.net.bsd.RCommandClient"", e);
      }
  }"
1661,"    public void rcommand(final String localUsername, final String remoteUsername,
                         final String command, final boolean separateErrorStream)
    throws IOException
    {
        rexec(localUsername, remoteUsername, command, separateErrorStream);
    }","  public void test20()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      // Undeclared exception!
      try { 
        rCommandClient0.rcommand("""", ""UKQj:R.2"", ""mi"", true);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1662,"    public void rcommand(final String localUsername, final String remoteUsername,
                         final String command, final boolean separateErrorStream)
    throws IOException
    {
        rexec(localUsername, remoteUsername, command, separateErrorStream);
    }","  public void test21()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      // Undeclared exception!
      try { 
        rCommandClient0.rcommand((String) null, ""org.apache.commons.net.DefaultSocketFactory"", ""org.apache.commons.net.DefaultSocketFactory"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.bsd.RExecClient"", e);
      }
  }"
1663,"    public void connect(final InetAddress host, final int port, final InetAddress localAddr)
    throws SocketException, BindException, IOException
    {
        int localPort;

        localPort = MAX_CLIENT_PORT;

        for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort)
        {
            try
            {
                _socket_ =
                    _socketFactory_.createSocket(host, port, localAddr, localPort);
            }
            catch (final SocketException e)
            {
                continue;
            }
            break;
        }

        if (localPort < MIN_CLIENT_PORT) {
            throw new BindException(""All ports in use or insufficient permssion."");
        }

        _connectAction_();
    }","  public void test22()  throws Throwable  {
      RCommandClient rCommandClient0 = new RCommandClient();
      // Undeclared exception!
      try { 
        rCommandClient0.connect((InetAddress) null, 1769);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.net.Socket"", e);
      }
  }"
1664,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test0()  throws Throwable  {
      boolean boolean0 = NNTPReply.isNegativePermanent(600);
}"
1665,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test1()  throws Throwable  {
      boolean boolean0 = NNTPReply.isNegativePermanent(500);
}"
1666,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test2()  throws Throwable  {
      boolean boolean0 = NNTPReply.isNegativeTransient(500);
}"
1667,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test3()  throws Throwable  {
      boolean boolean0 = NNTPReply.isNegativeTransient(400);
}"
1668,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test4()  throws Throwable  {
      boolean boolean0 = NNTPReply.isPositiveIntermediate(400);
}"
1669,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test5()  throws Throwable  {
      boolean boolean0 = NNTPReply.isPositiveIntermediate(300);
}"
1670,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test6()  throws Throwable  {
      boolean boolean0 = NNTPReply.isPositiveCompletion(300);
}"
1671,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test7()  throws Throwable  {
      boolean boolean0 = NNTPReply.isPositiveCompletion(200);
}"
1672,"    public static boolean isInformational(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test8()  throws Throwable  {
      boolean boolean0 = NNTPReply.isInformational(200);
}"
1673,"    public static boolean isInformational(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test9()  throws Throwable  {
      boolean boolean0 = NNTPReply.isInformational(100);
}"
1674,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test10()  throws Throwable  {
      boolean boolean0 = NNTPReply.isNegativePermanent(836);
}"
1675,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test11()  throws Throwable  {
      boolean boolean0 = NNTPReply.isNegativePermanent((-225));
}"
1676,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test12()  throws Throwable  {
      boolean boolean0 = NNTPReply.isNegativeTransient(680);
}"
1677,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test13()  throws Throwable  {
      boolean boolean0 = NNTPReply.isNegativeTransient(0);
}"
1678,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test14()  throws Throwable  {
      boolean boolean0 = NNTPReply.isPositiveIntermediate(412);
}"
1679,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test15()  throws Throwable  {
      boolean boolean0 = NNTPReply.isPositiveIntermediate(0);
}"
1680,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test16()  throws Throwable  {
      boolean boolean0 = NNTPReply.isPositiveCompletion(2073);
}"
1681,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test17()  throws Throwable  {
      boolean boolean0 = NNTPReply.isPositiveCompletion(0);
}"
1682,"    public static boolean isInformational(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test18()  throws Throwable  {
      boolean boolean0 = NNTPReply.isInformational(320);
}"
1683,"    public static boolean isInformational(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test19()  throws Throwable  {
      boolean boolean0 = NNTPReply.isInformational(0);
}"
1684,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test0()  throws Throwable  {
      Article article0 = new Article();
}"
1685,"    public String[] messageThreadReferences() {
        return getReferences();
    }","  public void test1()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject("" "");
      Article article1 = article0.next;
      article0.setDate("" "");
      article0.simplifiedSubject();
      article0.messageThreadReferences();
  }"
1686,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test2()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""R]Ac>*>^68`p7bS2V0+"");
      article0.getArticleNumber();
      article0.simplifiedSubject();
  }"
1687,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test3()  throws Throwable  {
      Article article0 = new Article();
      article0.getArticleId();
}"
1688,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test4()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      article0.kid = article0;
      MockPrintStream mockPrintStream0 = new MockPrintStream(""org.apache.commons.io.filefilter.DirectoryFileFilter"");
      article0.setNext(article1);
      article0.kid.kid.setArticleNumber(100);
      article0.kid.next.setSubject(""org.apache.commons.io.filefilter.DirectoryFileFilter"");
      article0.getArticleId();
      long long0 = 0L;
      // Undeclared exception!
      Article.printThread(article0, (PrintStream) mockPrintStream0);
  }"
1689,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test5()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      article1.subjectIsReply();
      Object[] objectArray0 = new Object[4];
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      MockPrintStream mockPrintStream0 = new MockPrintStream(""org.apache.commons.io.filefilter.DirectoryFileFilter"");
      Article.printThread(article1, (-944), (PrintStream) mockPrintStream0);
      article0.setNext(article1);
      article0.kid.kid.setArticleNumber(1L);
      article0.kid.kid.setArticleNumber(100);
      Threadable threadable0 = article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""EOB"");
      article0.getArticleId();
      article0.kid.next.setArticleNumber((long) (-944));
      article0.kid.setChild(threadable0);
      Article.printThread(article0);
      article1.simplifiedSubject();
      article0.kid.messageThreadId();
      article1.isDummy();
      article1.getFrom();
      article0.addReference((String) null);
      threadable0.messageThreadId();
      Article.printThread(article0, 3, (PrintStream) mockPrintStream0);
  }"
1690,"    public String[] messageThreadReferences() {
        return getReferences();
    }","  public void test6()  throws Throwable  {
      Article article0 = new Article();
      article0.setArticleId(""The offset cannot be negative"");
      article0.messageThreadId();
      article0.addReference(""48H"");
      Threadable threadable0 = article0.makeDummy();
      Article.printThread(article0);
      Locale.getISOCountries();
      threadable0.messageThreadReferences();
  }"
1691,"    public String getFrom() {
        return from;
    }","  public void test7()  throws Throwable  {
      Article article0 = new Article();
      article0.toString();
      article0.getArticleId();
      article0.toString();
      article0.setSubject(""H"");
      Article.printThread(article0);
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      byteArrayOutputStream0.close();
      MockPrintStream mockPrintStream0 = new MockPrintStream(byteArrayOutputStream0, true);
      article0.setFrom(""E6;Eyq]&+`%9"");
      Article.printThread(article0, (PrintStream) mockPrintStream0);
      article0.getReferences();
      article0.isDummy();
      article0.getFrom();
  }"
1692,"    public long getArticleNumberLong() {
        return articleNumber;
    }","  public void test8()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      article1.subjectIsReply();
      Object[] objectArray0 = new Object[4];
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      article0.setNext(article1);
      article0.kid.kid.setArticleNumber(100);
      Threadable threadable0 = article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""EOB"");
      article0.getArticleId();
      article0.kid.next.setArticleNumber(0L);
      article0.kid.setChild(threadable0);
      Article.printThread(article0);
      article0.kid.toString();
      article1.simplifiedSubject();
      article0.kid.messageThreadId();
      article1.isDummy();
      article1.toString();
      article0.toString();
      article0.addReference((String) null);
      threadable0.messageThreadId();
      article1.getArticleNumberLong();
  }"
1693,"    public long getArticleNumberLong() {
        return articleNumber;
    }","  public void test9()  throws Throwable  {
      Article article0 = new Article();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(byteArrayOutputStream0);
      Locale locale0 = Locale.US;
      Object[] objectArray0 = new Object[7];
      objectArray0[0] = (Object) locale0;
      article0.setSubject("""");
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) mockPrintStream0;
      objectArray0[3] = (Object) byteArrayOutputStream0;
      objectArray0[4] = (Object) byteArrayOutputStream0;
      LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
      LinkedList<Locale> linkedList1 = new LinkedList<Locale>();
      linkedList1.add(locale0);
      Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.IGNORE_EXTENDED_RANGES;
      List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedList1, locale_FilteringMode0);
      Locale.lookup(linkedList0, list0);
      objectArray0[5] = (Object) mockPrintStream0;
      Object object0 = new Object();
      Locale.setDefault(locale0);
      objectArray0[6] = object0;
      PrintStream printStream0 = mockPrintStream0.format(locale0, """", objectArray0);
      Article.printThread(article0, 796, printStream0);
      article0.getArticleNumberLong();
      article0.makeDummy();
      article0.getFrom();
      article0.messageThreadReferences();
      article0.messageThreadId();
      article0.getFrom();
      article0.getSubject();
      article0.getReferences();
      Article.printThread(article0, 796, printStream0);
      article0.getArticleNumberLong();
  }"
1694,"    public String getFrom() {
        return from;
    }","  public void test10()  throws Throwable  {
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, ""JYIUMzQl"");
      Article article0 = new Article();
      article0.setDate(""JYIUMzQl"");
      article0.messageThreadReferences();
      article0.setFrom("""");
      article0.getFrom();
      int int0 = (-2768);
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream(""JYIUMzQl"", ""JYIUMzQl"");
        fail(""Expecting exception: UnsupportedEncodingException"");
      } catch(Throwable e) {
         //
         // JYIUMzQl
         //
         verifyException(""java.io.PrintStream"", e);
      }
  }"
1695,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test11()  throws Throwable  {
      Article article0 = new Article();
      article0.getArticleId();
      article0.setSubject(""$H"");
      Article.printThread(article0);
      article0.getReferences();
      article0.isDummy();
      article0.simplifiedSubject();
  }"
1696,"    public void addReference(final String msgId) {
        if (msgId == null || msgId.isEmpty()) {
            return;
        }
        if (references == null) {
            references = new ArrayList<>();
        }
        isReply = true;
        Collections.addAll(references, msgId.split("" ""));
    }","  public void test12()  throws Throwable  {
      Article article0 = new Article();
      article0.messageThreadReferences();
      article0.addReference(""The FilenameFilter must not be null"");
      article0.toString();
      article0.getArticleNumberLong();
      article0.addReference(""ozm;{I:nY0-mJ<#'Ec"");
  }"
1697,"    public Threadable makeDummy() {
        return new Article();
    }","  public void test13()  throws Throwable  {
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, """");
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Article article0 = new Article();
      article0.toString();
      Article.printThread(article0);
      article0.addReference(""The FilenameFilter must not be null"");
      article0.toString();
      article0.setArticleId("""");
      article0.getArticleNumberLong();
      article0.messageThreadId();
      article0.makeDummy();
  }"
1698,"    public String toString(){ // Useful for Eclipse debugging
        return articleNumber + "" "" +articleId + "" "" + subject;
    }","  public void test14()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      article1.subjectIsReply();
      Object[] objectArray0 = new Object[4];
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      article0.setNext(article1);
      Threadable threadable0 = article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""EOB"");
      article0.getArticleId();
      article0.kid.next.setArticleNumber((-13L));
      article0.kid.setChild(threadable0);
      Article.printThread(article0);
      article0.kid.toString();
      article1.simplifiedSubject();
      article0.kid.messageThreadId();
      article1.isDummy();
      article1.toString();
      article0.toString();
  }"
1699,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test15()  throws Throwable  {
      Article article0 = new Article();
      article0.getArticleId();
      article0.toString();
      article0.setSubject(""S"");
      article0.makeDummy();
      article0.setSubject(""}3."");
      Article.printThread(article0);
      article0.getReferences();
      article0.isDummy();
      article0.simplifiedSubject();
  }"
1700,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test16()  throws Throwable  {
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, """");
      Article article0 = new Article();
      article0.toString();
      byte[] byteArray0 = new byte[8];
      byteArray0[0] = (byte)104;
      byteArray0[1] = (byte)97;
      byteArray0[2] = (byte)58;
      byteArray0[3] = (byte)120;
      byteArray0[4] = (byte)33;
      byteArray0[5] = (byte)48;
      byteArray0[6] = (byte)120;
      byteArray0[7] = (byte)91;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      article0.setArticleNumber((int) (byte)48);
      article0.addReference(""The FilenameFilter must not be null"");
      article0.toString();
      article0.getArticleNumberLong();
      article0.getArticleNumber();
  }"
1701,"    public boolean subjectIsReply() {
        return isReply;
    }","  public void test17()  throws Throwable  {
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, """");
      Article article0 = new Article();
      article0.toString();
      article0.addReference(""The FilenameFilter must not be null"");
      article0.toString();
      article0.getArticleNumberLong();
      article0.subjectIsReply();
  }"
1702,"    public void addReference(final String msgId) {
        if (msgId == null || msgId.isEmpty()) {
            return;
        }
        if (references == null) {
            references = new ArrayList<>();
        }
        isReply = true;
        Collections.addAll(references, msgId.split("" ""));
    }","  public void test18()  throws Throwable  {
      Article article0 = new Article();
      String string0 = ""[L"";
      article0.setDate(""[L"");
      article0.getDate();
      article0.getReferences();
      article0.getArticleId();
      article0.addReference(""[L"");
      int int0 = (-181);
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream((OutputStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // Null output stream
         //
         verifyException(""java.io.PrintStream"", e);
      }
  }"
1703,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test19()  throws Throwable  {
      Article article0 = new Article();
      article0.getArticleId();
      article0.toString();
      article0.setSubject(""H"");
      Article.printThread(article0);
      article0.isDummy();
      article0.simplifiedSubject();
      article0.simplifiedSubject();
  }"
1704,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test20()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Object[] objectArray0 = new Object[3];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      article0.setNext(article1);
      Threadable threadable0 = article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""EOB"");
      article0.getArticleId();
      article0.kid.next.setArticleNumber(0L);
      article0.kid.setChild(threadable0);
      Article.printThread(article0);
      article0.kid.toString();
      article1.simplifiedSubject();
      article0.kid.messageThreadId();
      article1.isDummy();
      article1.toString();
      article1.getArticleNumber();
  }"
1705,"    public String getFrom() {
        return from;
    }","  public void test21()  throws Throwable  {
      Article article0 = new Article();
      article0.messageThreadId();
      article0.messageThreadId();
      article0.addReference("" F"");
      article0.setSubject(""H"");
      Article article1 = (Article)article0.makeDummy();
      article0.getReferences();
      article1.subjectIsReply();
      article0.messageThreadReferences();
      article1.getFrom();
  }"
1706,"    public void addReference(final String msgId) {
        if (msgId == null || msgId.isEmpty()) {
            return;
        }
        if (references == null) {
            references = new ArrayList<>();
        }
        isReply = true;
        Collections.addAll(references, msgId.split("" ""));
    }","  public void test22()  throws Throwable  {
      Article article0 = new Article();
      FileSystemHandling.shouldAllThrowIOExceptions();
      String string0 = """";
      article0.setDate("""");
      article0.toString();
      article0.getReferences();
      article0.getDate();
      article0.addReference(""-1 null null"");
      int int0 = (-181);
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream((OutputStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // Null output stream
         //
         verifyException(""java.io.PrintStream"", e);
      }
  }"
1707,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test23()  throws Throwable  {
      Article article0 = new Article();
      article0.getFrom();
}"
1708,"    public String toString(){ // Useful for Eclipse debugging
        return articleNumber + "" "" +articleId + "" "" + subject;
    }","  public void test24()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      article0.setNext(article1);
      Threadable threadable0 = article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""-0jqD~]cuzpX"");
      article0.getArticleId();
      article0.kid.next.setArticleNumber(0L);
      article0.kid.setChild(threadable0);
      Article.printThread(article0);
      article0.kid.toString();
      article1.simplifiedSubject();
      article0.kid.messageThreadId();
      article1.isDummy();
      article1.toString();
  }"
1709,"    public String toString(){ // Useful for Eclipse debugging
        return articleNumber + "" "" +articleId + "" "" + subject;
    }","  public void test25()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      article0.setNext(article1);
      Threadable threadable0 = article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""EOB"");
      article0.getArticleId();
      article0.kid.next.setArticleNumber(0L);
      article0.kid.setChild(threadable0);
      Article.printThread(article0);
      article0.kid.toString();
      article1.simplifiedSubject();
      article0.kid.messageThreadId();
      article1.isDummy();
      article1.toString();
  }"
1710,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test26()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      article0.setArticleId(""$=Bs "");
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      article0.setNext(article1);
      Threadable threadable0 = article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""EOB"");
      article0.getArticleId();
      article0.kid.setChild(threadable0);
      Article.printThread(article0);
      article0.kid.toString();
      article1.simplifiedSubject();
  }"
1711,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test27()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      article0.setNext(article1);
      Article article2 = (Article)article0.kid.kid.makeDummy();
      article0.kid.next.setSubject("""");
      article2.getDate();
      article0.kid.setChild(article2);
      Article.printThread(article0);
      article0.kid.toString();
      article1.simplifiedSubject();
  }"
1712,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test28()  throws Throwable  {
      Article article0 = new Article();
      Object[] objectArray0 = new Object[4];
      Article article1 = new Article();
      article0.next = article0;
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article0;
      article0.next.setArticleId("""");
      objectArray0[3] = (Object) ""-0jqD~]cuzpX"";
      article0.kid = article0;
      article0.setNext(article0);
      article0.getArticleId();
      // Undeclared exception!
      Article.printThread(article0);
  }"
1713,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test29()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      MockFile mockFile0 = new MockFile(""hzT^iWiS7"", ""-0jqD~]cuzpX"");
      File file0 = MockFile.createTempFile(""-0jqD~]cuzpX"", ""pxw_S`+m/\""VH"", (File) mockFile0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(file0);
      BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
      article1.messageThreadReferences();
      MockPrintStream mockPrintStream1 = new MockPrintStream(bufferedOutputStream0);
      Article.printThread(article1, (-78), (PrintStream) mockPrintStream1);
      article0.setNext(article1);
      Threadable threadable0 = article0.kid.kid.makeDummy();
      article0.getArticleId();
      article0.kid.setChild(threadable0);
      Article.printThread(article0);
      article0.kid.toString();
      // Undeclared exception!
      try { 
        article1.simplifiedSubject();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Article"", e);
      }
  }"
1714,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test30()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) article1;
      article0.kid = article0;
      article0.setNext(article1);
      Threadable threadable0 = article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""EOB"");
      article0.getArticleId();
      article0.kid.setChild(threadable0);
      Article.printThread(article0);
      article0.kid.toString();
      article1.simplifiedSubject();
  }"
1715,"    public long getArticleNumberLong() {
        return articleNumber;
    }","  public void test31()  throws Throwable  {
      Article article0 = new Article();
      article0.getArticleId();
      article0.toString();
      article0.setSubject(""H"");
      Article article1 = (Article)article0.makeDummy();
      Article.printThread(article0);
      article0.getReferences();
      article1.getArticleNumberLong();
  }"
1716,"    public String[] getReferences() {
        if (references == null) {
            return NetConstants.EMPTY_STRING_ARRAY;
        }
        return references.toArray(NetConstants.EMPTY_STRING_ARRAY);
    }","  public void test32()  throws Throwable  {
      Article article0 = new Article();
      article0.getArticleId();
      article0.addReference(""H"");
      article0.setSubject(""H"");
      article0.makeDummy();
      Article.printThread(article0);
      article0.getReferences();
  }"
1717,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test33()  throws Throwable  {
      Article article0 = new Article();
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[3] = (Object) """";
      article0.kid = article0;
      article0.setNext(article0);
      article0.kid.addReference("""");
      article0.kid.makeDummy();
      MockPrintStream mockPrintStream0 = new MockPrintStream(""org.apache.commons.net.nntp.Article"");
      PrintStream printStream0 = mockPrintStream0.append((CharSequence) ""-0jqD~]cuzpX"");
      // Undeclared exception!
      Article.printThread(article0, 83, printStream0);
  }"
1718,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test34()  throws Throwable  {
      Article article0 = new Article();
      article0.messageThreadReferences();
      Article article1 = new Article();
      article1.isDummy();
      article1.getDate();
      article1.subjectIsReply();
      // Undeclared exception!
      try { 
        article0.simplifiedSubject();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Article"", e);
      }
  }"
1719,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test35()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = article0.kid;
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) article0;
      objectArray0[2] = (Object) null;
      objectArray0[3] = (Object) """";
      article0.kid = article0;
      article0.setNext((Threadable) null);
      article0.getArticleId();
      // Undeclared exception!
      Article.printThread(article0);
  }"
1720,"    public void addReference(final String msgId) {
        if (msgId == null || msgId.isEmpty()) {
            return;
        }
        if (references == null) {
            references = new ArrayList<>();
        }
        isReply = true;
        Collections.addAll(references, msgId.split("" ""));
    }","  public void test36()  throws Throwable  {
      Article article0 = new Article();
      article0.messageThreadId();
      article0.setArticleId((String) null);
      article0.messageThreadReferences();
      Article article1 = new Article();
      int int0 = 1;
      article1.addReference((String) null);
      MockFileOutputStream mockFileOutputStream0 = null;
      try {
        mockFileOutputStream0 = new MockFileOutputStream((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.File"", e);
      }
  }"
1721,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test37()  throws Throwable  {
      Article article0 = new Article();
      int int0 = article0.getArticleNumber();
}"
1722,"    public String toString(){ // Useful for Eclipse debugging
        return articleNumber + "" "" +articleId + "" "" + subject;
    }","  public void test38()  throws Throwable  {
      Article article0 = new Article();
      article0.messageThreadId();
      article0.setArticleId((String) null);
      Locale locale0 = Locale.ITALIAN;
      String string0 = article0.toString();
}"
1723,"    public boolean subjectIsReply() {
        return isReply;
    }","  public void test39()  throws Throwable  {
      Article article0 = new Article();
      article0.getSubject();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, """");
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      article0.getSubject();
      article0.subjectIsReply();
      int int0 = (-2159);
      MockFileOutputStream mockFileOutputStream0 = null;
      try {
        mockFileOutputStream0 = new MockFileOutputStream("""");
        fail(""Expecting exception: FileNotFoundException"");
      } catch(Throwable e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.io.MockFileOutputStream"", e);
      }
  }"
1724,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test40()  throws Throwable  {
      Locale locale0 = Locale.SIMPLIFIED_CHINESE;
      Object[] objectArray0 = new Object[3];
      Object object0 = new Object();
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)111;
      byteArray0[1] = (byte)121;
      byteArray0[2] = (byte)3;
      byteArray0[3] = (byte)2;
      byteArray0[4] = (byte) (-76);
      byteArray0[5] = (byte)121;
      byteArray0[6] = (byte) (-97);
      byteArray0[7] = (byte)2;
      byteArray0[8] = (byte) (-97);
      objectArray0[0] = object0;
      objectArray0[2] = (Object) locale0;
      Article article0 = new Article();
      int int0 = article0.getArticleNumber();
}"
1725,"    public long getArticleNumberLong() {
        return articleNumber;
    }","  public void test41()  throws Throwable  {
      Article article0 = new Article();
      article0.setArticleNumber(1297);
      Article.printThread(article0);
      Article.printThread(article0);
      article0.setSubject("""");
      article0.getReferences();
      article0.setArticleNumber(0L);
      article0.setFrom("""");
      article0.getFrom();
      Article.printThread(article0);
      article0.getReferences();
      Article.printThread(article0);
      article0.setArticleNumber(0);
      Article.printThread(article0);
      article0.getArticleId();
}"
1726,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test42()  throws Throwable  {
      Article article0 = new Article();
      article0.setArticleNumber(1297);
      Article.printThread(article0);
      Article.printThread(article0);
      article0.setSubject("""");
      article0.getReferences();
      article0.setArticleNumber(0L);
      article0.setFrom("""");
      article0.getFrom();
      Article.printThread(article0);
      article0.getReferences();
      Article.printThread(article0);
      article0.setArticleNumber(0);
      Article.printThread(article0);
      article0.getArticleId();
      article0.simplifiedSubject();
      article0.addReference("""");
}"
1727,"    public Article() {
        articleNumber = -1; // isDummy
    }","  public void test43()  throws Throwable  {
      Article article0 = new Article();
      article0.getSubject();
      article0.setArticleId((String) null);
      article0.messageThreadReferences();
      Article article1 = new Article();
      int int0 = 1;
      MockFileOutputStream mockFileOutputStream0 = null;
      try {
        mockFileOutputStream0 = new MockFileOutputStream((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.File"", e);
      }
  }"
1728,"    public boolean isDummy() {
        return (articleNumber == -1);
    }","  public void test44()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = article0.kid;
      Article article2 = article0.next;
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) null;
      objectArray0[2] = (Object) null;
      objectArray0[3] = (Object) """";
      article0.kid = null;
      article0.setNext((Threadable) null);
      article0.getArticleId();
      Article.printThread(article0);
}"
1729,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test45()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = article0.kid;
      Article article2 = article0.next;
      Object[] objectArray0 = new Object[4];
      objectArray0[0] = (Object) article0;
      objectArray0[1] = (Object) null;
      objectArray0[2] = (Object) null;
      objectArray0[3] = (Object) """";
      article0.kid = null;
      article0.setNext((Threadable) null);
      article0.getArticleId();
      Article.printThread(article0);
}"
1730,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test46()  throws Throwable  {
      Article article0 = new Article();
      article0.makeDummy();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""U2dq{Q4z.w)#+fD"");
      article0.messageThreadId();
      article0.messageThreadReferences();
      int int0 = 1;
      OutputStream outputStream0 = null;
      boolean boolean0 = false;
      // Undeclared exception!
      try { 
        article0.simplifiedSubject();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Article"", e);
      }
  }"
1731,"    public String[] getReferences() {
        if (references == null) {
            return NetConstants.EMPTY_STRING_ARRAY;
        }
        return references.toArray(NetConstants.EMPTY_STRING_ARRAY);
    }","  public void test47()  throws Throwable  {
      Article article0 = new Article();
      article0.messageThreadId();
      article0.setArticleId((String) null);
      article0.getReferences();
      Article article1 = article0.next;
      int int0 = 1;
      MockFileOutputStream mockFileOutputStream0 = null;
      try {
        mockFileOutputStream0 = new MockFileOutputStream((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.File"", e);
      }
  }"
1732,"    public Article() {
        articleNumber = -1; // isDummy
    }","  public void test48()  throws Throwable  {
      Article article0 = new Article();
      article0.messageThreadId();
      article0.setArticleId((String) null);
      article0.messageThreadReferences();
      Article article1 = new Article();
      int int0 = 1;
      MockFileOutputStream mockFileOutputStream0 = null;
      try {
        mockFileOutputStream0 = new MockFileOutputStream((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.File"", e);
      }
  }"
1733,"    public boolean subjectIsReply() {
        return isReply;
    }","  public void test49()  throws Throwable  {
      Article article0 = new Article();
      article0.setArticleId(""h\"")?3rxKScJjAod[{"");
      article0.addReference(""h\"")?3rxKScJjAod[{"");
}"
1734,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test50()  throws Throwable  {
      Article article0 = null;
      int int0 = (-272);
      // Undeclared exception!
      try { 
        Article.printThread((Article) null, (-272));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1735,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test51()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = article0.next;
      article0.kid = null;
      // Undeclared exception!
      try { 
        Article.printThread((Article) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1736,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test52()  throws Throwable  {
      Article article0 = new Article();
      String string0 = ""QQSs|"";
      Article article1 = article0.kid;
      // Undeclared exception!
      try { 
        Article.printThread((Article) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1737,"    public long getArticleNumberLong() {
        return articleNumber;
    }","  public void test53()  throws Throwable  {
      Article article0 = new Article();
      article0.getDate();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""t0M"", true);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0, false);
      Locale locale0 = Locale.CANADA_FRENCH;
      Object[] objectArray0 = new Object[7];
      objectArray0[0] = (Object) mockFileOutputStream0;
      objectArray0[1] = (Object) null;
      objectArray0[2] = (Object) null;
      objectArray0[3] = (Object) mockFileOutputStream0;
      objectArray0[4] = (Object) article0;
      objectArray0[5] = (Object) mockFileOutputStream0;
      Object object0 = new Object();
      objectArray0[6] = object0;
      PrintStream printStream0 = mockPrintStream0.format(locale0, """", objectArray0);
      Article.printThread(article0, printStream0);
}"
1738,"    public boolean isDummy() {
        return (articleNumber == -1);
    }","  public void test54()  throws Throwable  {
      Article article0 = new Article();
      article0.getDate();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""t0M"", true);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0, false);
      Locale locale0 = Locale.CANADA_FRENCH;
      Object[] objectArray0 = new Object[7];
      objectArray0[0] = (Object) mockFileOutputStream0;
      objectArray0[1] = (Object) null;
      objectArray0[2] = (Object) null;
      objectArray0[3] = (Object) mockFileOutputStream0;
      objectArray0[4] = (Object) article0;
      objectArray0[5] = (Object) mockFileOutputStream0;
      Object object0 = new Object();
      objectArray0[6] = object0;
      PrintStream printStream0 = mockPrintStream0.format(locale0, """", objectArray0);
      Article.printThread(article0, printStream0);
}"
1739,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test55()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = article0.kid;
      // Undeclared exception!
      try { 
        Article.printThread((Article) null, (PrintStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1740,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test56()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      // Undeclared exception!
      try { 
        Article.printThread(article0, (-1), (PrintStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1741,"    public boolean isDummy() {
        return (articleNumber == -1);
    }","  public void test57()  throws Throwable  {
      Article article0 = new Article();
      boolean boolean0 = article0.isDummy();
}"
1742,"    public boolean isDummy() {
        return (articleNumber == -1);
    }","  public void test58()  throws Throwable  {
      Article article0 = new Article();
      boolean boolean0 = article0.isDummy();
      Article article1 = article0.kid;
      article0.setChild((Threadable) null);
}"
1743,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test59()  throws Throwable  {
      Article article0 = new Article();
      article0.getReferences();
      Article article1 = article0.next;
      int int0 = 715;
      PrintStream printStream0 = null;
      // Undeclared exception!
      try { 
        Article.printThread((Article) null, 715, (PrintStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
1744,"    public boolean isDummy() {
        return (articleNumber == -1);
    }","  public void test60()  throws Throwable  {
      Article article0 = new Article();
      Article.printThread(article0, (-554));
}"
1745,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test61()  throws Throwable  {
      Article article0 = new Article();
      Article.printThread(article0, (-554));
}"
1746,"    public long getArticleNumberLong() {
        return articleNumber;
    }","  public void test62()  throws Throwable  {
      Article article0 = new Article();
      article0.addHeaderField(""qg'sW]c|I<C0;5< WG("", """");
      article0.getFrom();
      article0.setDate("""");
      article0.messageThreadReferences();
}"
1747,"    public String[] messageThreadReferences() {
        return getReferences();
    }","  public void test63()  throws Throwable  {
      Article article0 = new Article();
      Threadable threadable0 = article0.makeDummy();
      article0.setChild(threadable0);
      article0.getFrom();
      article0.kid.messageThreadReferences();
      article0.kid.setSubject("""");
      article0.setDate("""");
      article0.subjectIsReply();
      article0.setChild(threadable0);
      article0.messageThreadReferences();
      int int0 = (-742);
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream((OutputStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // Null output stream
         //
         verifyException(""java.io.PrintStream"", e);
      }
  }"
1748,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test64()  throws Throwable  {
      Article article0 = new Article();
      // Undeclared exception!
      try { 
        article0.simplifiedSubject();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Article"", e);
      }
  }"
1749,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test65()  throws Throwable  {
      Article article0 = new Article();
      String string0 = ""H"";
      // Undeclared exception!
      try { 
        article0.simplifiedSubject();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Article"", e);
      }
  }"
1750,"    public long getArticleNumberLong() {
        return articleNumber;
    }","  public void test66()  throws Throwable  {
      Article article0 = new Article();
      article0.addHeaderField(""qg'sW]c|I<C0;5< WG("", ""qg'sW]c|I<C0;5< WG("");
}"
1751,"    public String toString(){ // Useful for Eclipse debugging
        return articleNumber + "" "" +articleId + "" "" + subject;
    }","  public void test67()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      article0.setArticleId(""$=Bs "");
      article0.kid = article0;
      article0.setNext(article1);
      Article article2 = (Article)article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""$=Bs "");
      article2.setArticleId(""$=Bs "");
      article0.kid.setChild(article2);
      Article.printThread(article0);
      String string0 = article0.kid.toString();
}"
1752,"    public boolean subjectIsReply() {
        return isReply;
    }","  public void test68()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      article0.setArticleId(""$=Bs "");
      article0.kid = article0;
      article0.setNext(article1);
      Article article2 = (Article)article0.kid.kid.makeDummy();
      article0.kid.next.setSubject(""$=Bs "");
      article2.setArticleId(""$=Bs "");
      article0.kid.setChild(article2);
      Article.printThread(article0);
      String string0 = article0.kid.toString();
      article2.addReference("""");
}"
1753,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test69()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject("" "");
      article0.setDate("" "");
      String string0 = article0.simplifiedSubject();
}"
1754,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test70()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject("" "");
      article0.setDate("" "");
      String string0 = article0.simplifiedSubject();
}"
1755,"    public boolean isDummy() {
        return (articleNumber == -1);
    }","  public void test71()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject("" "");
      article0.setDate("" "");
      String string0 = article0.simplifiedSubject();
      article0.messageThreadReferences();
}"
1756,"    public boolean subjectIsReply() {
        return isReply;
    }","  public void test72()  throws Throwable  {
      Article article0 = new Article();
      article0.addReference(""\t"");
      article0.addReference(""\t"");
      article0.getReferences();
}"
1757,"    public long getArticleNumberLong() {
        return articleNumber;
    }","  public void test73()  throws Throwable  {
      Article article0 = new Article();
      long long0 = article0.getArticleNumberLong();
}"
1758,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test74()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""q]Ac>*>Q68`#7bS2V+"");
      int int0 = article0.getArticleNumber();
}"
1759,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test75()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""q]Ac>*>Q68`#7bS2V+"");
      int int0 = article0.getArticleNumber();
      String string0 = article0.simplifiedSubject();
}"
1760,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test76()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""q]Ac>*>Q68`#7bS2V+"");
      int int0 = article0.getArticleNumber();
      String string0 = article0.simplifiedSubject();
}"
1761,"    public boolean isDummy() {
        return (articleNumber == -1);
    }","  public void test77()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""R]Ac>*>^68`]p7bS2V0+"");
      String string0 = article0.simplifiedSubject();
}"
1762,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test78()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""R]Ac>*>^68`]p7bS2V0+"");
      String string0 = article0.simplifiedSubject();
}"
1763,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test79()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""R]Ac>*>^68`]p7bS2V0+"");
      String string0 = article0.simplifiedSubject();
}"
1764,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test80()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""R]Ac>*>^68`p7bS2V0+"");
      String string0 = article0.simplifiedSubject();
}"
1765,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test81()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""R]Ac>*>^68`p7bS2V0+"");
      String string0 = article0.simplifiedSubject();
}"
1766,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test82()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""R]Ac>*>^68`p7bS2V0+"");
      String string0 = article0.simplifiedSubject();
}"
1767,"    public long getArticleNumberLong() {
        return articleNumber;
    }","  public void test83()  throws Throwable  {
      Article article0 = new Article();
      article0.getDate();
      article0.messageThreadId();
      article0.addReference((String) null);
}"
1768,"    public static void printThread(final Article article) {
        printThread(article, 0, System.out);
    }","  public void test84()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""\t"");
      Article.printThread(article0);
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(byteArrayOutputStream0, true);
      article0.setFrom(""\t"");
      Article.printThread(article0, (PrintStream) mockPrintStream0);
}"
1769,"    public String simplifiedSubject() {
        if(simplifiedSubject == null) {
            simplifySubject();
        }
        return simplifiedSubject;
    }","  public void test85()  throws Throwable  {
      Article article0 = new Article();
      article0.setSubject(""\t"");
      Article.printThread(article0);
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(byteArrayOutputStream0, true);
      article0.setFrom(""\t"");
      Article.printThread(article0, (PrintStream) mockPrintStream0);
      article0.isDummy();
      article0.simplifiedSubject();
      String string0 = article0.simplifiedSubject();
}"
1770,"    public int getArticleNumber() {
        return (int) articleNumber;
    }","  public void test86()  throws Throwable  {
      Article article0 = new Article();
      Article article1 = new Article();
      article1.subjectIsReply();
      article0.kid = article0;
      article0.setNext(article1);
      article0.kid.kid.setArticleNumber((-944));
      article0.kid.next.setSubject(""org.apache.commons.io.filefilter.DirectoryFileFilter"");
      article0.kid.next.setArticleNumber((long) (-944));
      article0.isDummy();
      article0.toString();
}"
1771,"    public int stat(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.STAT, messageId);
    }","  public void test0()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.stat(0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1772,"    public int xhdr(final String header, final String selectedArticles) throws IOException {
        final StringBuilder command = new StringBuilder(header);
        command.append("" "");
        command.append(selectedArticles);
        return sendCommand(NNTPCommand.XHDR, command.toString());
    }","  public void test1()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.xhdr(""PvdZZ~>r*qW@JmqT"", ""5nDSXCe;}Bv0tN"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1773,"    public int newnews(final String newsgroups, final String date, final String time, final boolean GMT,
                       final String distributions) throws IOException
    {
        final StringBuilder buffer = new StringBuilder();

        buffer.append(newsgroups);
        buffer.append(' ');
        buffer.append(date);
        buffer.append(' ');
        buffer.append(time);

        if (GMT)
        {
            buffer.append(' ');
            buffer.append(""GMT"");
        }

        if (distributions != null)
        {
            buffer.append("" <"");
            buffer.append(distributions);
            buffer.append('>');
        }

        return sendCommand(NNTPCommand.NEWNEWS, buffer.toString());
    }","  public void test2()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.newnews("""", ""2+>!$#;ZXu37vO[tiMS"", ""@\""Q}M]<"", false, ""NEWGROUPS"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1774,"    public int newgroups(final String date, final String time, final boolean GMT,
                         final String distributions) throws IOException
    {
        final StringBuilder buffer = new StringBuilder();

        buffer.append(date);
        buffer.append(' ');
        buffer.append(time);

        if (GMT)
        {
            buffer.append(' ');
            buffer.append(""GMT"");
        }

        if (distributions != null)
        {
            buffer.append("" <"");
            buffer.append(distributions);
            buffer.append('>');
        }

        return sendCommand(NNTPCommand.NEWGROUPS, buffer.toString());
    }","  public void test3()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.newgroups(""Y:S,2DE"", """", false, ""k\""8eE"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1775,"    public int head(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.HEAD, messageId);
    }","  public void test4()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      StringWriter stringWriter0 = new StringWriter(119);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0, 119);
      nNTP0._writer_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        nNTP0.head();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1776,"    public boolean isAllowedToPost()
    {
        return _isAllowedToPost;
    }","  public void test5()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
}"
1777,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test6()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0._isAllowedToPost = true;
      nNTP0.isAllowedToPost();
}"
1778,"    public int sendCommand(final String command, final String args) throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message;
        _writer_.write(message = __commandBuffer.toString());
        _writer_.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test7()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.sendCommand(16, ""g"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1779,"    public int sendCommand(final String command, final String args) throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message;
        _writer_.write(message = __commandBuffer.toString());
        _writer_.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test8()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.sendCommand(0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1780,"    public int getReply() throws IOException
    {
        replyString = _reader_.readLine();

        if (replyString == null) {
            throw new NNTPConnectionClosedException(
                    ""Connection closed without indication."");
        }

        // In case we run into an anomaly we don't want fatal index exceptions
        // to be thrown.
        if (replyString.length() < 3) {
            throw new MalformedServerReplyException(
                ""Truncated server reply: "" + replyString);
        }

        try
        {
            replyCode = Integer.parseInt(replyString.substring(0, 3));
        }
        catch (final NumberFormatException e)
        {
            throw new MalformedServerReplyException(
                ""Could not parse response code.\nServer Reply: "" + replyString);
        }

        fireReplyReceived(replyCode, replyString + SocketClient.NETASCII_EOL);

        if (replyCode == NNTPReply.SERVICE_DISCONTINUED) {
            throw new NNTPConnectionClosedException(
                ""NNTP response 400 received.  Server closed connection."");
        }
        return replyCode;
    }","  public void test9()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.getReply();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1781,"    public int getReply() throws IOException
    {
        replyString = _reader_.readLine();

        if (replyString == null) {
            throw new NNTPConnectionClosedException(
                    ""Connection closed without indication."");
        }

        // In case we run into an anomaly we don't want fatal index exceptions
        // to be thrown.
        if (replyString.length() < 3) {
            throw new MalformedServerReplyException(
                ""Truncated server reply: "" + replyString);
        }

        try
        {
            replyCode = Integer.parseInt(replyString.substring(0, 3));
        }
        catch (final NumberFormatException e)
        {
            throw new MalformedServerReplyException(
                ""Could not parse response code.\nServer Reply: "" + replyString);
        }

        fireReplyReceived(replyCode, replyString + SocketClient.NETASCII_EOL);

        if (replyCode == NNTPReply.SERVICE_DISCONTINUED) {
            throw new NNTPConnectionClosedException(
                ""NNTP response 400 received.  Server closed connection."");
        }
        return replyCode;
    }","  public void test10()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      PipedReader pipedReader0 = new PipedReader(119);
      BufferedReader bufferedReader0 = new BufferedReader(pipedReader0);
      nNTP0._reader_ = bufferedReader0;
      try { 
        nNTP0.getReply();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedReader"", e);
      }
  }"
1782,"    protected void _connectAction_() throws IOException
    {
        super._connectAction_();
        _reader_ =
            new CRLFLineReader(new InputStreamReader(_input_,
                                                     DEFAULT_ENCODING));
        _writer_ =
            new BufferedWriter(new OutputStreamWriter(_output_,
                                                      DEFAULT_ENCODING));
        getReply();

        _isAllowedToPost = replyCode == NNTPReply.SERVER_READY_POSTING_ALLOWED;
    }","  public void test11()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
1783,"    public int sendCommand(final String command, final String args) throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message;
        _writer_.write(message = __commandBuffer.toString());
        _writer_.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test12()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.sendCommand(""org.apache.commons.net.nntp.NNTP"", (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1784,"    public int sendCommand(final String command, final String args) throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message;
        _writer_.write(message = __commandBuffer.toString());
        _writer_.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test13()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.sendCommand(""V"", ""V"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1785,"    public int head(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.HEAD, messageId);
    }","  public void test14()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.head(0L);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1786,"    public int body(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.BODY, messageId);
    }","  public void test15()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.body(0L);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1787,"    public int sendCommand(final String command, final String args) throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message;
        _writer_.write(message = __commandBuffer.toString());
        _writer_.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test16()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.sendCommand(200, """");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 200
         //
         verifyException(""org.apache.commons.net.nntp.NNTPCommand"", e);
      }
  }"
1788,"    public int sendCommand(final String command, final String args) throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message;
        _writer_.write(message = __commandBuffer.toString());
        _writer_.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test17()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.sendCommand((-31));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -31
         //
         verifyException(""org.apache.commons.net.nntp.NNTPCommand"", e);
      }
  }"
1789,"    public int article(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.ARTICLE, messageId);
    }","  public void test18()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.article((-1L));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1790,"    public int newnews(final String newsgroups, final String date, final String time, final boolean GMT,
                       final String distributions) throws IOException
    {
        final StringBuilder buffer = new StringBuilder();

        buffer.append(newsgroups);
        buffer.append(' ');
        buffer.append(date);
        buffer.append(' ');
        buffer.append(time);

        if (GMT)
        {
            buffer.append(' ');
            buffer.append(""GMT"");
        }

        if (distributions != null)
        {
            buffer.append("" <"");
            buffer.append(distributions);
            buffer.append('>');
        }

        return sendCommand(NNTPCommand.NEWNEWS, buffer.toString());
    }","  public void test19()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.newnews(""wm;{\""ejgchk^o^q1[6"", ""\r\n"", ""wm;{\""ejgchk^o^q1[6"", true, ""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1791,"    public int newnews(final String newsgroups, final String date, final String time, final boolean GMT,
                       final String distributions) throws IOException
    {
        final StringBuilder buffer = new StringBuilder();

        buffer.append(newsgroups);
        buffer.append(' ');
        buffer.append(date);
        buffer.append(' ');
        buffer.append(time);

        if (GMT)
        {
            buffer.append(' ');
            buffer.append(""GMT"");
        }

        if (distributions != null)
        {
            buffer.append("" <"");
            buffer.append(distributions);
            buffer.append('>');
        }

        return sendCommand(NNTPCommand.NEWNEWS, buffer.toString());
    }","  public void test20()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.newnews(""ACTIVE "", ""ACTIVE "", ""ACTIVE "", false, (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1792,"    public int newgroups(final String date, final String time, final boolean GMT,
                         final String distributions) throws IOException
    {
        final StringBuilder buffer = new StringBuilder();

        buffer.append(date);
        buffer.append(' ');
        buffer.append(time);

        if (GMT)
        {
            buffer.append(' ');
            buffer.append(""GMT"");
        }

        if (distributions != null)
        {
            buffer.append("" <"");
            buffer.append(distributions);
            buffer.append('>');
        }

        return sendCommand(NNTPCommand.NEWGROUPS, buffer.toString());
    }","  public void test21()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.newgroups("""", ""oGg.apache.commons.net.nntp.NNTP"", true, ""oGg.apache.commons.net.nntp.NNTP"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1793,"    public int newgroups(final String date, final String time, final boolean GMT,
                         final String distributions) throws IOException
    {
        final StringBuilder buffer = new StringBuilder();

        buffer.append(date);
        buffer.append(' ');
        buffer.append(time);

        if (GMT)
        {
            buffer.append(' ');
            buffer.append(""GMT"");
        }

        if (distributions != null)
        {
            buffer.append("" <"");
            buffer.append(distributions);
            buffer.append('>');
        }

        return sendCommand(NNTPCommand.NEWGROUPS, buffer.toString());
    }","  public void test22()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.newgroups((String) null, (String) null, false, (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1794,"    public int quit() throws IOException
    {
        return sendCommand(NNTPCommand.QUIT);
    }","  public void test23()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.quit();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1795,"    public int stat(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.STAT, messageId);
    }","  public void test24()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.stat();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1796,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test25()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0.getCommandSupport();
}"
1797,"    public boolean isAllowedToPost()
    {
        return _isAllowedToPost;
    }","  public void test26()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0.getCommandSupport();
}"
1798,"    public int head(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.HEAD, messageId);
    }","  public void test27()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.head("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1799,"    public int authinfoUser(final String username) throws IOException {
        final String userParameter = ""USER "" + username;
        return sendCommand(NNTPCommand.AUTHINFO, userParameter);
    }","  public void test28()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.authinfoUser(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1800,"    public int sendCommand(final String command, final String args) throws IOException
    {
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message;
        _writer_.write(message = __commandBuffer.toString());
        _writer_.flush();

        fireCommandSent(command, message);

        return getReply();
    }","  public void test29()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.sendCommand(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1801,"    public int last() throws IOException
    {
        return sendCommand(NNTPCommand.LAST);
    }","  public void test30()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.last();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1802,"    public int ihave(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.IHAVE, messageId);
    }","  public void test31()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.ihave(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1803,"    public int body(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.BODY, messageId);
    }","  public void test32()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.body((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1804,"    public boolean isAllowedToPost()
    {
        return _isAllowedToPost;
    }","  public void test33()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      boolean boolean0 = nNTP0.isAllowedToPost();
}"
1805,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test34()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      boolean boolean0 = nNTP0.isAllowedToPost();
}"
1806,"    public int help() throws IOException
    {
        return sendCommand(NNTPCommand.HELP);
    }","  public void test35()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.help();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1807,"    public int next() throws IOException
    {
        return sendCommand(NNTPCommand.NEXT);
    }","  public void test36()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.next();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1808,"    public int stat(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.STAT, messageId);
    }","  public void test37()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.stat(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1809,"    public int article(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.ARTICLE, messageId);
    }","  public void test38()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.article(""POST"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1810,"    public int body(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.BODY, messageId);
    }","  public void test39()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.body();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1811,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test40()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      String string0 = nNTP0.getReplyString();
}"
1812,"    public String getReplyString()
    {
        return replyString;
    }","  public void test41()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      String string0 = nNTP0.getReplyString();
}"
1813,"    public boolean isAllowedToPost()
    {
        return _isAllowedToPost;
    }","  public void test42()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      String string0 = nNTP0.getReplyString();
}"
1814,"    public int group(final String newsgroup) throws IOException
    {
        return sendCommand(NNTPCommand.GROUP, newsgroup);
    }","  public void test43()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.group(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1815,"    public int listActive(final String wildmat) throws IOException {
        final StringBuilder command = new StringBuilder(""ACTIVE "");
        command.append(wildmat);
        return sendCommand(NNTPCommand.LIST, command.toString());
    }","  public void test44()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.listActive(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1816,"    public int stat(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.STAT, messageId);
    }","  public void test45()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.stat(865L);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1817,"    public int article(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.ARTICLE, messageId);
    }","  public void test46()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.article();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1818,"    public int list() throws IOException
    {
        return sendCommand(NNTPCommand.LIST);
    }","  public void test47()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.list();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1819,"    public int head(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.HEAD, messageId);
    }","  public void test48()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.head((-779));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1820,"    public int getReplyCode()
    {
        return replyCode;
    }","  public void test49()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      int int0 = nNTP0.getReplyCode();
}"
1821,"    public boolean isAllowedToPost()
    {
        return _isAllowedToPost;
    }","  public void test50()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      int int0 = nNTP0.getReplyCode();
}"
1822,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test51()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      int int0 = nNTP0.getReplyCode();
}"
1823,"    public int article(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.ARTICLE, messageId);
    }","  public void test52()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.article(94);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1824,"    public int xover(final String selectedArticles) throws IOException {
        return sendCommand(NNTPCommand.XOVER, selectedArticles);
    }","  public void test53()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.xover(""SENSITIVE"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1825,"    public int authinfoPass(final String password) throws IOException {
        final String passParameter = ""PASS "" + password;
        return sendCommand(NNTPCommand.AUTHINFO, passParameter);
    }","  public void test54()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.authinfoPass(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1826,"    public int post() throws IOException
    {
        return sendCommand(NNTPCommand.POST);
    }","  public void test55()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.post();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1827,"    public boolean isAllowedToPost()
    {
        return _isAllowedToPost;
    }","  public void test56()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0.disconnect();
}"
1828,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test57()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      nNTP0.disconnect();
}"
1829,"    public int body(final String messageId) throws IOException
    {
        return sendCommand(NNTPCommand.BODY, messageId);
    }","  public void test58()  throws Throwable  {
      NNTP nNTP0 = new NNTP();
      // Undeclared exception!
      try { 
        nNTP0.body(0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1830,"    public void remove() {
        stringIterator.remove();
    }","  public void test0()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      ArticleIterator articleIterator0 = new ArticleIterator(set0);
      articleIterator0.next();
      articleIterator0.remove();
  }"
1831,"    public Iterator<Article> iterator() {
        return this;
    }","  public void test1()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      HashSet<String> hashSet0 = new HashSet<String>(set0);
      ArticleIterator articleIterator0 = new ArticleIterator(hashSet0);
      Iterator<Article> iterator0 = articleIterator0.iterator();
}"
1832,"    public boolean hasNext() {
        return stringIterator.hasNext();
    }","  public void test2()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      HashSet<String> hashSet0 = new HashSet<String>(set0);
      ArticleIterator articleIterator0 = new ArticleIterator(hashSet0);
      boolean boolean0 = articleIterator0.hasNext();
}"
1833,"    public void remove() {
        stringIterator.remove();
    }","  public void test3()  throws Throwable  {
      Charset charset0 = Charset.defaultCharset();
      Set<String> set0 = charset0.aliases();
      ArticleIterator articleIterator0 = new ArticleIterator(set0);
      // Undeclared exception!
      try { 
        articleIterator0.remove();
        fail(""Expecting exception: UnsupportedOperationException"");
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.Collections$UnmodifiableCollection$1"", e);
      }
  }"
1834,"    public Article next() {
        final String line = stringIterator.next();
        return NNTPClient.parseArticleEntry(line);
    }","  public void test4()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      ArticleIterator articleIterator0 = new ArticleIterator(linkedList0);
      // Undeclared exception!
      try { 
        articleIterator0.next();
        fail(""Expecting exception: NoSuchElementException"");
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList$ListItr"", e);
      }
  }"
1835,"    public Article next() {
        final String line = stringIterator.next();
        return NNTPClient.parseArticleEntry(line);
    }","  public void test5()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      HashSet<String> hashSet0 = new HashSet<String>(set0);
      ArticleIterator articleIterator0 = new ArticleIterator(hashSet0);
      hashSet0.add("""");
      // Undeclared exception!
      try { 
        articleIterator0.next();
        fail(""Expecting exception: ConcurrentModificationException"");
      } catch(ConcurrentModificationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.HashMap$HashIterator"", e);
      }
  }"
1836,"    public Article next() {
        final String line = stringIterator.next();
        return NNTPClient.parseArticleEntry(line);
    }","  public void test6()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      hashSet0.add((String) null);
      ArticleIterator articleIterator0 = new ArticleIterator(hashSet0);
      // Undeclared exception!
      try { 
        articleIterator0.next();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTPClient"", e);
      }
  }"
1837,"    public ArticleIterator(final Iterable<String> iterableString) {
        stringIterator = iterableString.iterator();
    }","  public void test7()  throws Throwable  {
      ArticleIterator articleIterator0 = null;
      try {
        articleIterator0 = new ArticleIterator((Iterable<String>) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.ArticleIterator"", e);
      }
  }"
1838,"    public void remove() {
        stringIterator.remove();
    }","  public void test8()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      ArrayList<String> arrayList0 = new ArrayList<String>(vector0);
      arrayList0.add(""y6_"");
      ArticleIterator articleIterator0 = new ArticleIterator(arrayList0);
      Consumer<Article> consumer0 = (Consumer<Article>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      articleIterator0.forEach(consumer0);
      arrayList0.add(""The wildcard array must not be null"");
      // Undeclared exception!
      try { 
        articleIterator0.remove();
        fail(""Expecting exception: ConcurrentModificationException"");
      } catch(ConcurrentModificationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.ArrayList$Itr"", e);
      }
  }"
1839,"    public boolean hasNext() {
        return stringIterator.hasNext();
    }","  public void test9()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      ArrayList<String> arrayList0 = new ArrayList<String>(vector0);
      ArticleIterator articleIterator0 = new ArticleIterator(arrayList0);
      boolean boolean0 = articleIterator0.hasNext();
}"
1840,"    public void remove() {
        stringIterator.remove();
    }","  public void test10()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      ArrayList<String> arrayList0 = new ArrayList<String>(vector0);
      ArticleIterator articleIterator0 = new ArticleIterator(arrayList0);
      // Undeclared exception!
      try { 
        articleIterator0.remove();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.ArrayList$Itr"", e);
      }
  }"
1841,"    public int getPostingPermission()
    {
        return postingPermission;
    }","  public void test0()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setPostingPermission(47);
      int int0 = newsgroupInfo0.getPostingPermission();
}"
1842,"    public int getPostingPermission()
    {
        return postingPermission;
    }","  public void test1()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setPostingPermission((-2417));
      int int0 = newsgroupInfo0.getPostingPermission();
}"
1843,"    public String getNewsgroup()
    {
        return newsgroup;
    }","  public void test2()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setNewsgroup(""org.apache.commons.net.nntp.NewsgroupInfo"");
      String string0 = newsgroupInfo0.getNewsgroup();
}"
1844,"    public String getNewsgroup()
    {
        return newsgroup;
    }","  public void test3()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setNewsgroup("""");
      String string0 = newsgroupInfo0.getNewsgroup();
}"
1845,"    public long getLastArticleLong()
    {
        return lastArticle;
    }","  public void test4()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setLastArticle(3077L);
      long long0 = newsgroupInfo0.getLastArticleLong();
}"
1846,"    public long getLastArticleLong()
    {
        return lastArticle;
    }","  public void test5()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setLastArticle((-1444L));
      long long0 = newsgroupInfo0.getLastArticleLong();
}"
1847,"    public int getLastArticle() {
        return (int) lastArticle;
    }","  public void test6()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setLastArticle(3218L);
      int int0 = newsgroupInfo0.getLastArticle();
}"
1848,"    public int getLastArticle() {
        return (int) lastArticle;
    }","  public void test7()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setLastArticle((-443L));
      int int0 = newsgroupInfo0.getLastArticle();
}"
1849,"    public long getFirstArticleLong()
    {
        return firstArticle;
    }","  public void test8()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setFirstArticle(2561);
      long long0 = newsgroupInfo0.getFirstArticleLong();
}"
1850,"    public long getFirstArticleLong()
    {
        return firstArticle;
    }","  public void test9()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setFirstArticle((-230L));
      long long0 = newsgroupInfo0.getFirstArticleLong();
}"
1851,"    public int getFirstArticle() {
        return (int) firstArticle;
    }","  public void test10()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setFirstArticle(427L);
      int int0 = newsgroupInfo0.getFirstArticle();
}"
1852,"    public int getFirstArticle() {
        return (int) firstArticle;
    }","  public void test11()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setFirstArticle((-616L));
      int int0 = newsgroupInfo0.getFirstArticle();
}"
1853,"    public long getArticleCountLong()
    {
        return estimatedArticleCount;
    }","  public void test12()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setArticleCount(17L);
      long long0 = newsgroupInfo0.getArticleCountLong();
}"
1854,"    public long getArticleCountLong()
    {
        return estimatedArticleCount;
    }","  public void test13()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setArticleCount((-2527L));
      long long0 = newsgroupInfo0.getArticleCountLong();
}"
1855,"    public int getArticleCount() {
        return (int) estimatedArticleCount;
    }","  public void test14()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setArticleCount(17L);
      int int0 = newsgroupInfo0.getArticleCount();
}"
1856,"    public int getArticleCount() {
        return (int) estimatedArticleCount;
    }","  public void test15()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      newsgroupInfo0.setArticleCount((-2527L));
      int int0 = newsgroupInfo0.getArticleCount();
}"
1857,"    public String getNewsgroup()
    {
        return newsgroup;
    }","  public void test16()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      String string0 = newsgroupInfo0.getNewsgroup();
}"
1858,"    public long getFirstArticleLong()
    {
        return firstArticle;
    }","  public void test17()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      long long0 = newsgroupInfo0.getFirstArticleLong();
}"
1859,"    public int getPostingPermission()
    {
        return postingPermission;
    }","  public void test18()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      int int0 = newsgroupInfo0.getPostingPermission();
}"
1860,"    public int getLastArticle() {
        return (int) lastArticle;
    }","  public void test19()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      int int0 = newsgroupInfo0.getLastArticle();
}"
1861,"    public long getLastArticleLong()
    {
        return lastArticle;
    }","  public void test20()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      long long0 = newsgroupInfo0.getLastArticleLong();
}"
1862,"    public long getArticleCountLong()
    {
        return estimatedArticleCount;
    }","  public void test21()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      long long0 = newsgroupInfo0.getArticleCountLong();
}"
1863,"    public int getArticleCount() {
        return (int) estimatedArticleCount;
    }","  public void test22()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      int int0 = newsgroupInfo0.getArticleCount();
}"
1864,"    public int getFirstArticle() {
        return (int) firstArticle;
    }","  public void test23()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = new NewsgroupInfo();
      int int0 = newsgroupInfo0.getFirstArticle();
}"
1865,"    public ArticleInfo() {
    }","  public void test0()  throws Throwable  {
      ArticleInfo articleInfo0 = new ArticleInfo();
}"
1866,"    public BufferedReader retrieveArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.ARTICLE, articleId, pointer);

    }","  public void test0()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticle(0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1867,"    private BufferedReader retrieveArticleInfo(final String articleRange)
        throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(xover(articleRange))) {
            return null;
        }

        return new DotTerminatedMessageReader(_reader_);
    }","  public void test1()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleInfo(58);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1868,"    private BufferedReader retrieveHeader(final String header, final String articleRange)
        throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(xhdr(header, articleRange))) {
            return null;
        }

        return new DotTerminatedMessageReader(_reader_);
    }","  public void test2()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveHeader(""OVERVIEW.FMT"", 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1869,"    private BufferedReader retrieveHeader(final String header, final String articleRange)
        throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(xhdr(header, articleRange))) {
            return null;
        }

        return new DotTerminatedMessageReader(_reader_);
    }","  public void test3()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveHeader(""XOVER command failed: "", 0, 4655);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1870,"    public Iterable<Article> iterateArticleInfo(final long lowArticleNumber, final long highArticleNumber)
        throws IOException
    {
        final BufferedReader info = retrieveArticleInfo(lowArticleNumber,highArticleNumber);
        if (info == null) {
            throw new IOException(""XOVER command failed: ""+getReplyString());
        }
        // N.B. info is already DotTerminated, so don't rewrap
        return new ArticleIterator(new ReplyIterator(info, false));
    }","  public void test4()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.iterateArticleInfo((-1989L), (-2852L));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1871,"    public boolean authenticate(final String username, final String password)
        throws IOException
    {
        int replyCode = authinfoUser(username);

        if (replyCode == NNTPReply.MORE_AUTH_INFO_REQUIRED)
            {
                replyCode = authinfoPass(password);

                if (replyCode == NNTPReply.AUTHENTICATION_ACCEPTED)
                    {
                        this._isAllowedToPost = true;
                        return true;
                    }
            }
        return false;
    }","  public void test5()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.authenticate("""", ""I|3vNR`Kt/\""c"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1872,"    static NewsgroupInfo parseNewsgroupListEntry(final String entry)
    {
        final String tokens[] = entry.split("" "");
        if (tokens.length < 4) {
            return null;
        }
        final NewsgroupInfo result = new NewsgroupInfo();

        int i = 0;

        result.setNewsgroup(tokens[i++]);

        try
        {
            final long lastNum = Long.parseLong(tokens[i++]);
            final long firstNum = Long.parseLong(tokens[i++]);
            result.setFirstArticle(firstNum);
            result.setLastArticle(lastNum);
            if ((firstNum == 0) && (lastNum == 0)) {
                result.setArticleCount(0);
            } else {
                result.setArticleCount(lastNum - firstNum + 1);
            }
        } catch (final NumberFormatException e) {
            return null;
        }

        switch (tokens[i++].charAt(0))
        {
        case 'y':
        case 'Y':
            result.setPostingPermission(
                NewsgroupInfo.PERMITTED_POSTING_PERMISSION);
            break;
        case 'n':
        case 'N':
            result.setPostingPermission(
                NewsgroupInfo.PROHIBITED_POSTING_PERMISSION);
            break;
        case 'm':
        case 'M':
            result.setPostingPermission(
                NewsgroupInfo.MODERATED_POSTING_PERMISSION);
            break;
        default:
            result.setPostingPermission(
                NewsgroupInfo.UNKNOWN_POSTING_PERMISSION);
            break;
        }

        return result;
    }","  public void test6()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = NNTPClient.parseNewsgroupListEntry(""Couldtnot parsearticle pointes.\nSrver reply: "");
}"
1873,"    public boolean selectPreviousArticle(final ArticleInfo pointer)
    throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(last())) {
            return false;
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test7()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.selectPreviousArticle(articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1874,"    public boolean selectNextArticle(final ArticleInfo pointer) throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(next())) {
            return false;
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test8()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.selectNextArticle(articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1875,"    public boolean selectNewsgroup(final String newsgroup, final NewsgroupInfo info)
    throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(group(newsgroup))) {
            return false;
        }

        if (info != null) {
            parseGroupReply(getReplyString(), info);
        }

        return true;
    }","  public void test9()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.selectNewsgroup(""p"", (NewsgroupInfo) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1876,"    public boolean selectArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        if (articleId != null) {
            if (!NNTPReply.isPositiveCompletion(stat(articleId))) {
                return false;
            }
        } else {
            if (!NNTPReply.isPositiveCompletion(stat())) {
                return false;
            }
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test10()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.selectArticle(812L, articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1877,"    private BufferedReader retrieveHeader(final String header, final String articleRange)
        throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(xhdr(header, articleRange))) {
            return null;
        }

        return new DotTerminatedMessageReader(_reader_);
    }","  public void test11()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      PipedWriter pipedWriter0 = new PipedWriter();
      BufferedWriter bufferedWriter0 = new BufferedWriter(pipedWriter0);
      nNTPClient0._writer_ = bufferedWriter0;
      try { 
        nNTPClient0.retrieveHeader(""\r\n"", 0, 0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedWriter"", e);
      }
  }"
1878,"    public BufferedReader retrieveArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.ARTICLE, articleId, pointer);

    }","  public void test12()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      PipedWriter pipedWriter0 = new PipedWriter();
      BufferedWriter bufferedWriter0 = new BufferedWriter(pipedWriter0, 109);
      nNTPClient0._writer_ = bufferedWriter0;
      try { 
        nNTPClient0.retrieveArticle((-1L));
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedWriter"", e);
      }
  }"
1879,"    public Writer postArticle() throws IOException
    {
        if (!NNTPReply.isPositiveIntermediate(post())) {
            return null;
        }

        return new DotTerminatedMessageWriter(_writer_);
    }","  public void test13()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.postArticle();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1880,"    static NewsgroupInfo parseNewsgroupListEntry(final String entry)
    {
        final String tokens[] = entry.split("" "");
        if (tokens.length < 4) {
            return null;
        }
        final NewsgroupInfo result = new NewsgroupInfo();

        int i = 0;

        result.setNewsgroup(tokens[i++]);

        try
        {
            final long lastNum = Long.parseLong(tokens[i++]);
            final long firstNum = Long.parseLong(tokens[i++]);
            result.setFirstArticle(firstNum);
            result.setLastArticle(lastNum);
            if ((firstNum == 0) && (lastNum == 0)) {
                result.setArticleCount(0);
            } else {
                result.setArticleCount(lastNum - firstNum + 1);
            }
        } catch (final NumberFormatException e) {
            return null;
        }

        switch (tokens[i++].charAt(0))
        {
        case 'y':
        case 'Y':
            result.setPostingPermission(
                NewsgroupInfo.PERMITTED_POSTING_PERMISSION);
            break;
        case 'n':
        case 'N':
            result.setPostingPermission(
                NewsgroupInfo.PROHIBITED_POSTING_PERMISSION);
            break;
        case 'm':
        case 'M':
            result.setPostingPermission(
                NewsgroupInfo.MODERATED_POSTING_PERMISSION);
            break;
        default:
            result.setPostingPermission(
                NewsgroupInfo.UNKNOWN_POSTING_PERMISSION);
            break;
        }

        return result;
    }","  public void test14()  throws Throwable  {
      // Undeclared exception!
      try { 
        NNTPClient.parseNewsgroupListEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTPClient"", e);
      }
  }"
1881,"    static Article parseArticleEntry(final String line) {
        // Extract the article information
        // Mandatory format (from NNTP RFC 2980) is :
        // articleNumber\tSubject\tAuthor\tDate\tID\tReference(s)\tByte Count\tLine Count

        final Article article = new Article();
        article.setSubject(line); // in case parsing fails
        final String parts[] = line.split(""\t"");
        if (parts.length > 6) {
            int i = 0;
            try {
                article.setArticleNumber(Long.parseLong(parts[i++]));
                article.setSubject(parts[i++]);
                article.setFrom(parts[i++]);
                article.setDate(parts[i++]);
                article.setArticleId(parts[i++]);
                article.addReference(parts[i++]);
            } catch (final NumberFormatException e) {
                // ignored, already handled
            }
        }
        return article;
    }","  public void test15()  throws Throwable  {
      // Undeclared exception!
      try { 
        NNTPClient.parseArticleEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTPClient"", e);
      }
  }"
1882,"    public String[] listOverviewFmt() throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
            return null;
        }

        try (final BufferedReader reader = new DotTerminatedMessageReader(_reader_)) {
            String line;
            final ArrayList<String> list = new ArrayList<>();
            while ((line = reader.readLine()) != null) {
                list.add(line);
            }
            return list.toArray(NetConstants.EMPTY_STRING_ARRAY);
        }
    }","  public void test16()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.listOverviewFmt();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1883,"    public NewsgroupInfo[] listNewsgroups() throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(list())) {
            return null;
        }

        return readNewsgroupListing();
    }","  public void test17()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.listNewsgroups("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1884,"    public NewsgroupInfo[] listNewsgroups() throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(list())) {
            return null;
        }

        return readNewsgroupListing();
    }","  public void test18()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.listNewsgroups();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1885,"    public NewsgroupInfo[] listNewNewsgroups(final NewGroupsOrNewsQuery query)
    throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(newgroups(
                                                query.getDate(), query.getTime(),
                                                query.isGMT(), query.getDistributions())))
        {
            return null;
        }

        return readNewsgroupListing();
    }","  public void test19()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(119, 119, 0, 0, 40, 0);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      // Undeclared exception!
      try { 
        nNTPClient0.listNewNewsgroups(newGroupsOrNewsQuery0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1886,"    public String[] listNewNews(final NewGroupsOrNewsQuery query)
    throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(),
                query.isGMT(), query.getDistributions()))) {
            return null;
        }

        final Vector<String> list = new Vector<>();
        try (final BufferedReader reader = new DotTerminatedMessageReader(_reader_)) {

            String line;
            while ((line = reader.readLine()) != null) {
                list.addElement(line);
            }
        }

        final int size = list.size();
        if (size < 1) {
            return NetConstants.EMPTY_STRING_ARRAY;
        }

        final String[] result = new String[size];
        list.copyInto(result);

        return result;
    }","  public void test20()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      // Undeclared exception!
      try { 
        nNTPClient0.listNewNews(newGroupsOrNewsQuery0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1887,"    public String listHelp() throws IOException
    {
        if (!NNTPReply.isInformational(help())) {
            return null;
        }

        try (final StringWriter help = new StringWriter();
                final BufferedReader reader = new DotTerminatedMessageReader(_reader_)) {
            Util.copyReader(reader, help);
            return help.toString();
        }
    }","  public void test21()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.listHelp();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1888,"    public Iterable<String> iterateNewsgroupListing() throws IOException {
        if (NNTPReply.isPositiveCompletion(list())) {
            return new ReplyIterator(_reader_);
        }
        throw new IOException(""LIST command failed: ""+getReplyString());
    }","  public void test22()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.iterateNewsgroupListing(""[EG7D'B4"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1889,"    public Iterable<String> iterateNewsgroupListing() throws IOException {
        if (NNTPReply.isPositiveCompletion(list())) {
            return new ReplyIterator(_reader_);
        }
        throw new IOException(""LIST command failed: ""+getReplyString());
    }","  public void test23()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.iterateNewsgroupListing();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1890,"    public Iterable<String> iterateNewNewsgroupListing(final NewGroupsOrNewsQuery query) throws IOException {
        if (NNTPReply.isPositiveCompletion(newgroups(
                query.getDate(), query.getTime(),
                query.isGMT(), query.getDistributions()))) {
            return new ReplyIterator(_reader_);
        }
        throw new IOException(""NEWGROUPS command failed: ""+getReplyString());
    }","  public void test24()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      Locale locale0 = Locale.KOREA;
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      // Undeclared exception!
      try { 
        nNTPClient0.iterateNewNewsgroupListing(newGroupsOrNewsQuery0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1891,"    public Iterable<String> iterateNewNews(final NewGroupsOrNewsQuery query) throws IOException {
        if (NNTPReply.isPositiveCompletion(newnews(
                query.getNewsgroups(), query.getDate(), query.getTime(),
                query.isGMT(), query.getDistributions()))) {
            return new ReplyIterator(_reader_);
        }
        throw new IOException(""NEWNEWS command failed: ""+getReplyString());
    }","  public void test25()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      // Undeclared exception!
      try { 
        nNTPClient0.iterateNewNews(newGroupsOrNewsQuery0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1892,"    public Writer forwardArticle(final String articleId) throws IOException
    {
        if (!NNTPReply.isPositiveIntermediate(ihave(articleId))) {
            return null;
        }

        return new DotTerminatedMessageWriter(_writer_);
    }","  public void test26()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.forwardArticle(""9!"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1893,"    public boolean selectArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        if (articleId != null) {
            if (!NNTPReply.isPositiveCompletion(stat(articleId))) {
                return false;
            }
        } else {
            if (!NNTPReply.isPositiveCompletion(stat())) {
                return false;
            }
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test27()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.selectArticle((String) null, articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1894,"    public boolean selectArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        if (articleId != null) {
            if (!NNTPReply.isPositiveCompletion(stat(articleId))) {
                return false;
            }
        } else {
            if (!NNTPReply.isPositiveCompletion(stat())) {
                return false;
            }
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test28()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.selectArticle(""=:rptpBP4&"", articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1895,"    private BufferedReader retrieveHeader(final String header, final String articleRange)
        throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(xhdr(header, articleRange))) {
            return null;
        }

        return new DotTerminatedMessageReader(_reader_);
    }","  public void test29()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveHeader(""/p"", 1415L, (-473L));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1896,"    public BufferedReader retrieveArticleBody(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.BODY, articleId, pointer);

    }","  public void test30()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleBody((-238L));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1897,"    public BufferedReader retrieveArticleBody(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.BODY, articleId, pointer);

    }","  public void test31()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleBody(""*Bzpt@QQ*/J'jJE}R>)"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1898,"    public BufferedReader retrieveArticleHeader(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.HEAD, articleId, pointer);

    }","  public void test32()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleHeader((-1718L));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1899,"    public BufferedReader retrieveArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.ARTICLE, articleId, pointer);

    }","  public void test33()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticle("""", articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1900,"    private BufferedReader retrieveArticleInfo(final String articleRange)
        throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(xover(articleRange))) {
            return null;
        }

        return new DotTerminatedMessageReader(_reader_);
    }","  public void test34()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleInfo((long) (-1093), (-2886L));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1901,"    public BufferedReader retrieveArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.ARTICLE, articleId, pointer);

    }","  public void test35()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticle((-1L), articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1902,"    public BufferedReader retrieveArticleHeader(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.HEAD, articleId, pointer);

    }","  public void test36()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleHeader("""", articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1903,"    public BufferedReader retrieveArticleBody(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.BODY, articleId, pointer);

    }","  public void test37()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleBody(0L, articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1904,"    private BufferedReader retrieveHeader(final String header, final String articleRange)
        throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(xhdr(header, articleRange))) {
            return null;
        }

        return new DotTerminatedMessageReader(_reader_);
    }","  public void test38()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveHeader(""\t"", 0L);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1905,"    public BufferedReader retrieveArticleHeader(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.HEAD, articleId, pointer);

    }","  public void test39()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleHeader(1663L, articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1906,"    public boolean selectArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        if (articleId != null) {
            if (!NNTPReply.isPositiveCompletion(stat(articleId))) {
                return false;
            }
        } else {
            if (!NNTPReply.isPositiveCompletion(stat())) {
                return false;
            }
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test40()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.selectArticle(1L);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1907,"    public BufferedReader retrieveArticleBody(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.BODY, articleId, pointer);

    }","  public void test41()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleBody(""NEWGROUPS command failed: "", articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1908,"    private BufferedReader retrieveArticleInfo(final String articleRange)
        throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(xover(articleRange))) {
            return null;
        }

        return new DotTerminatedMessageReader(_reader_);
    }","  public void test42()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleInfo(0L);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1909,"    static Article parseArticleEntry(final String line) {
        // Extract the article information
        // Mandatory format (from NNTP RFC 2980) is :
        // articleNumber\tSubject\tAuthor\tDate\tID\tReference(s)\tByte Count\tLine Count

        final Article article = new Article();
        article.setSubject(line); // in case parsing fails
        final String parts[] = line.split(""\t"");
        if (parts.length > 6) {
            int i = 0;
            try {
                article.setArticleNumber(Long.parseLong(parts[i++]));
                article.setSubject(parts[i++]);
                article.setFrom(parts[i++]);
                article.setDate(parts[i++]);
                article.setArticleId(parts[i++]);
                article.addReference(parts[i++]);
            } catch (final NumberFormatException e) {
                // ignored, already handled
            }
        }
        return article;
    }","  public void test43()  throws Throwable  {
      Article article0 = NNTPClient.parseArticleEntry("" command failed: "");
}"
1910,"    static NewsgroupInfo parseNewsgroupListEntry(final String entry)
    {
        final String tokens[] = entry.split("" "");
        if (tokens.length < 4) {
            return null;
        }
        final NewsgroupInfo result = new NewsgroupInfo();

        int i = 0;

        result.setNewsgroup(tokens[i++]);

        try
        {
            final long lastNum = Long.parseLong(tokens[i++]);
            final long firstNum = Long.parseLong(tokens[i++]);
            result.setFirstArticle(firstNum);
            result.setLastArticle(lastNum);
            if ((firstNum == 0) && (lastNum == 0)) {
                result.setArticleCount(0);
            } else {
                result.setArticleCount(lastNum - firstNum + 1);
            }
        } catch (final NumberFormatException e) {
            return null;
        }

        switch (tokens[i++].charAt(0))
        {
        case 'y':
        case 'Y':
            result.setPostingPermission(
                NewsgroupInfo.PERMITTED_POSTING_PERMISSION);
            break;
        case 'n':
        case 'N':
            result.setPostingPermission(
                NewsgroupInfo.PROHIBITED_POSTING_PERMISSION);
            break;
        case 'm':
        case 'M':
            result.setPostingPermission(
                NewsgroupInfo.MODERATED_POSTING_PERMISSION);
            break;
        default:
            result.setPostingPermission(
                NewsgroupInfo.UNKNOWN_POSTING_PERMISSION);
            break;
        }

        return result;
    }","  public void test44()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = NNTPClient.parseNewsgroupListEntry("""");
}"
1911,"    static NewsgroupInfo parseNewsgroupListEntry(final String entry)
    {
        final String tokens[] = entry.split("" "");
        if (tokens.length < 4) {
            return null;
        }
        final NewsgroupInfo result = new NewsgroupInfo();

        int i = 0;

        result.setNewsgroup(tokens[i++]);

        try
        {
            final long lastNum = Long.parseLong(tokens[i++]);
            final long firstNum = Long.parseLong(tokens[i++]);
            result.setFirstArticle(firstNum);
            result.setLastArticle(lastNum);
            if ((firstNum == 0) && (lastNum == 0)) {
                result.setArticleCount(0);
            } else {
                result.setArticleCount(lastNum - firstNum + 1);
            }
        } catch (final NumberFormatException e) {
            return null;
        }

        switch (tokens[i++].charAt(0))
        {
        case 'y':
        case 'Y':
            result.setPostingPermission(
                NewsgroupInfo.PERMITTED_POSTING_PERMISSION);
            break;
        case 'n':
        case 'N':
            result.setPostingPermission(
                NewsgroupInfo.PROHIBITED_POSTING_PERMISSION);
            break;
        case 'm':
        case 'M':
            result.setPostingPermission(
                NewsgroupInfo.MODERATED_POSTING_PERMISSION);
            break;
        default:
            result.setPostingPermission(
                NewsgroupInfo.UNKNOWN_POSTING_PERMISSION);
            break;
        }

        return result;
    }","  public void test45()  throws Throwable  {
      NewsgroupInfo newsgroupInfo0 = NNTPClient.parseNewsgroupListEntry(""Couldtnot parse article pointes.\nServer reply: "");
}"
1912,"    private BufferedReader retrieveArticleInfo(final String articleRange)
        throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(xover(articleRange))) {
            return null;
        }

        return new DotTerminatedMessageReader(_reader_);
    }","  public void test46()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleInfo(15, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1913,"    public Iterable<NewsgroupInfo> iterateNewsgroups() throws IOException {
        return new NewsgroupIterator(iterateNewsgroupListing());
    }","  public void test47()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.iterateNewsgroups();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1914,"    public Iterable<NewsgroupInfo> iterateNewsgroups() throws IOException {
        return new NewsgroupIterator(iterateNewsgroupListing());
    }","  public void test48()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.iterateNewsgroups(""-nx{ r6E_ZP5oqb$E"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1915,"    public boolean selectNewsgroup(final String newsgroup, final NewsgroupInfo info)
    throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(group(newsgroup))) {
            return false;
        }

        if (info != null) {
            parseGroupReply(getReplyString(), info);
        }

        return true;
    }","  public void test49()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.selectNewsgroup(""Couldtnot parse article pointes.\nServer reply: "");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1916,"    public BufferedReader retrieveArticleHeader(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.HEAD, articleId, pointer);

    }","  public void test50()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleHeader();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1917,"    public boolean selectArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        if (articleId != null) {
            if (!NNTPReply.isPositiveCompletion(stat(articleId))) {
                return false;
            }
        } else {
            if (!NNTPReply.isPositiveCompletion(stat())) {
                return false;
            }
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test51()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.selectArticle(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1918,"    public boolean logout() throws IOException
    {
        return NNTPReply.isPositiveCompletion(quit());
    }","  public void test52()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.logout();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1919,"    public boolean selectArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        if (articleId != null) {
            if (!NNTPReply.isPositiveCompletion(stat(articleId))) {
                return false;
            }
        } else {
            if (!NNTPReply.isPositiveCompletion(stat())) {
                return false;
            }
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test53()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      ArticleInfo articleInfo0 = new ArticleInfo();
      // Undeclared exception!
      try { 
        nNTPClient0.selectArticle(articleInfo0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1920,"    public BufferedReader retrieveArticleHeader(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.HEAD, articleId, pointer);

    }","  public void test54()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleHeader(""Vu%U/HBwEgW+CpZ!"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1921,"    public boolean completePendingCommand() throws IOException
    {
        return NNTPReply.isPositiveCompletion(getReply());
    }","  public void test55()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.completePendingCommand();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1922,"    public BufferedReader retrieveArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.ARTICLE, articleId, pointer);

    }","  public void test56()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticle((-1L));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1923,"    public BufferedReader retrieveArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.ARTICLE, articleId, pointer);

    }","  public void test57()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticle();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1924,"    public boolean selectArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        if (articleId != null) {
            if (!NNTPReply.isPositiveCompletion(stat(articleId))) {
                return false;
            }
        } else {
            if (!NNTPReply.isPositiveCompletion(stat())) {
                return false;
            }
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test58()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.selectArticle(77);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1925,"    public BufferedReader retrieveArticle(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.ARTICLE, articleId, pointer);

    }","  public void test59()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticle(""NEWGROUPS command failed: "");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1926,"    public BufferedReader retrieveArticleBody(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.BODY, articleId, pointer);

    }","  public void test60()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleBody();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1927,"    public BufferedReader retrieveArticleBody(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.BODY, articleId, pointer);

    }","  public void test61()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleBody(2057);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1928,"    public boolean selectPreviousArticle(final ArticleInfo pointer)
    throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(last())) {
            return false;
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test62()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.selectPreviousArticle();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1929,"    public BufferedReader retrieveArticleHeader(final String articleId, final ArticleInfo pointer)
    throws IOException
    {
        return retrieve(NNTPCommand.HEAD, articleId, pointer);

    }","  public void test63()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.retrieveArticleHeader(2457);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1930,"    public boolean selectNextArticle(final ArticleInfo pointer) throws IOException
    {
        if (!NNTPReply.isPositiveCompletion(next())) {
            return false;
        }

        if (pointer != null) {
            parseArticlePointer(getReplyString(), pointer);
        }

        return true;
    }","  public void test64()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      // Undeclared exception!
      try { 
        nNTPClient0.selectNextArticle();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1931,"    public Iterable<NewsgroupInfo> iterateNewNewsgroups(final NewGroupsOrNewsQuery query) throws IOException {
        return new NewsgroupIterator(iterateNewNewsgroupListing(query));
    }","  public void test65()  throws Throwable  {
      NNTPClient nNTPClient0 = new NNTPClient();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      // Undeclared exception!
      try { 
        nNTPClient0.iterateNewNewsgroups(newGroupsOrNewsQuery0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTP"", e);
      }
  }"
1932,"    public String getSubject()
    {
        return subject;
    }","  public void test0()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader((String) null, (String) null);
      simpleNNTPHeader0.addHeaderField(""T\""\nEeVd7Hh"", (String) null);
}"
1933,"    public String getSubject()
    {
        return subject;
    }","  public void test1()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader((String) null, (String) null);
      String string0 = simpleNNTPHeader0.getSubject();
}"
1934,"    public String getSubject()
    {
        return subject;
    }","  public void test2()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader("""", """");
      String string0 = simpleNNTPHeader0.getSubject();
}"
1935,"    public String getNewsgroups()
    {
        return newsgroups.toString();
    }","  public void test3()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader(""VN}"", ""VN}"");
      simpleNNTPHeader0.addNewsgroup(""From: VN}\nNewsgroups: \nSubject: VN}\n\n"");
      simpleNNTPHeader0.getNewsgroups();
}"
1936,"    public String getFromAddress()
    {
        return from;
    }","  public void test4()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader((String) null, (String) null);
      String string0 = simpleNNTPHeader0.getFromAddress();
}"
1937,"    public String getSubject()
    {
        return subject;
    }","  public void test5()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader("""", ""SR#:3t$Mt4G_2w"");
      String string0 = simpleNNTPHeader0.getFromAddress();
}"
1938,"    public String getFromAddress()
    {
        return from;
    }","  public void test6()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader("""", ""SR#:3t$Mt4G_2w"");
      String string0 = simpleNNTPHeader0.getFromAddress();
}"
1939,"    public String toString()
    {
        final StringBuilder header = new StringBuilder();

        header.append(""From: "");
        header.append(from);
        header.append(""\nNewsgroups: "");
        header.append(newsgroups.toString());
        header.append(""\nSubject: "");
        header.append(subject);
        header.append('\n');
        if (headerFields.length() > 0) {
            header.append(headerFields.toString());
        }
        header.append('\n');

        return header.toString();
    }","  public void test7()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader(""VN}"", ""VN}"");
      String string0 = simpleNNTPHeader0.toString();
}"
1940,"    public String getNewsgroups()
    {
        return newsgroups.toString();
    }","  public void test8()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader(""VN}"", ""VN}"");
      simpleNNTPHeader0.addNewsgroup(""From: VN}\nNewsgroups: \nSubject: VN}\n\n"");
      simpleNNTPHeader0.addNewsgroup(""VN}"");
}"
1941,"    public String toString()
    {
        final StringBuilder header = new StringBuilder();

        header.append(""From: "");
        header.append(from);
        header.append(""\nNewsgroups: "");
        header.append(newsgroups.toString());
        header.append(""\nSubject: "");
        header.append(subject);
        header.append('\n');
        if (headerFields.length() > 0) {
            header.append(headerFields.toString());
        }
        header.append('\n');

        return header.toString();
    }","  public void test9()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader(""VN}"", ""VN}"");
      simpleNNTPHeader0.addHeaderField(""VN}"", ""VN}"");
      String string0 = simpleNNTPHeader0.toString();
}"
1942,"    public String getSubject()
    {
        return subject;
    }","  public void test10()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader(""VN}"", ""VN}"");
      String string0 = simpleNNTPHeader0.getSubject();
}"
1943,"    public String getFromAddress()
    {
        return from;
    }","  public void test11()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader(""VN}"", ""VN}"");
      String string0 = simpleNNTPHeader0.getFromAddress();
}"
1944,"    public String getNewsgroups()
    {
        return newsgroups.toString();
    }","  public void test12()  throws Throwable  {
      SimpleNNTPHeader simpleNNTPHeader0 = new SimpleNNTPHeader(""VN}"", ""VN}"");
      String string0 = simpleNNTPHeader0.getNewsgroups();
}"
1945,"    public static String getCommand(final int command)
    {
        return commands[command];
    }","  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        NNTPCommand.getCommand(3754);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 3754
         //
         verifyException(""org.apache.commons.net.nntp.NNTPCommand"", e);
      }
  }"
1946,"    public static String getCommand(final int command)
    {
        return commands[command];
    }","  public void test1()  throws Throwable  {
      String string0 = NNTPCommand.getCommand(0);
}"
1947,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test0()  throws Throwable  {
      Locale locale0 = Locale.CHINA;
      Calendar calendar0 = MockCalendar.getInstance(locale0);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(calendar0, false);
      boolean boolean0 = newGroupsOrNewsQuery0.isGMT();
}"
1948,"    public String getDate()
    {
        return date;
    }","  public void test1()  throws Throwable  {
      Locale locale0 = Locale.CHINA;
      Calendar calendar0 = MockCalendar.getInstance(locale0);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(calendar0, false);
      boolean boolean0 = newGroupsOrNewsQuery0.isGMT();
}"
1949,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test2()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(93, 93, 93, 93, 427);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      newGroupsOrNewsQuery0.addNewsgroup("""");
      newGroupsOrNewsQuery0.getNewsgroups();
}"
1950,"    public String getDate()
    {
        return date;
    }","  public void test3()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(93, 93, 93, 93, 427);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      newGroupsOrNewsQuery0.addNewsgroup("""");
      newGroupsOrNewsQuery0.getNewsgroups();
}"
1951,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test4()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 0, 0, 48, 48);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      newGroupsOrNewsQuery0.addDistribution("""");
      newGroupsOrNewsQuery0.getDistributions();
}"
1952,"    public String getDate()
    {
        return date;
    }","  public void test5()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 0, 0, 48, 48);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      newGroupsOrNewsQuery0.addDistribution("""");
      newGroupsOrNewsQuery0.getDistributions();
}"
1953,"    public NewGroupsOrNewsQuery(final Calendar date, final boolean gmt)
    {
        int num;
        String str;
        final StringBuilder buffer;

        this.distributions = null;
        this.newsgroups = null;
        this.isGMT = gmt;

        buffer = new StringBuilder();

        // Get year
        num = date.get(Calendar.YEAR);
        str = Integer.toString(num);
        num = str.length();

        if (num >= 2) {
            buffer.append(str.substring(num - 2));
        } else {
            buffer.append(""00"");
        }

        // Get month
        num = date.get(Calendar.MONTH) + 1;
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""01"");
        }

        // Get day
        num = date.get(Calendar.DAY_OF_MONTH);
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""01"");
        }

        this.date = buffer.toString();

        buffer.setLength(0);

        // Get hour
        num = date.get(Calendar.HOUR_OF_DAY);
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""00"");
        }

        // Get minutes
        num = date.get(Calendar.MINUTE);
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""00"");
        }


        // Get seconds
        num = date.get(Calendar.SECOND);
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""00"");
        }

        this.time = buffer.toString();
    }","  public void test6()  throws Throwable  {
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = null;
      try {
        newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery((Calendar) null, false);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NewGroupsOrNewsQuery"", e);
      }
  }"
1954,"    public NewGroupsOrNewsQuery(final Calendar date, final boolean gmt)
    {
        int num;
        String str;
        final StringBuilder buffer;

        this.distributions = null;
        this.newsgroups = null;
        this.isGMT = gmt;

        buffer = new StringBuilder();

        // Get year
        num = date.get(Calendar.YEAR);
        str = Integer.toString(num);
        num = str.length();

        if (num >= 2) {
            buffer.append(str.substring(num - 2));
        } else {
            buffer.append(""00"");
        }

        // Get month
        num = date.get(Calendar.MONTH) + 1;
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""01"");
        }

        // Get day
        num = date.get(Calendar.DAY_OF_MONTH);
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""01"");
        }

        this.date = buffer.toString();

        buffer.setLength(0);

        // Get hour
        num = date.get(Calendar.HOUR_OF_DAY);
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""00"");
        }

        // Get minutes
        num = date.get(Calendar.MINUTE);
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""00"");
        }


        // Get seconds
        num = date.get(Calendar.SECOND);
        str = Integer.toString(num);
        num = str.length();

        if (num == 1) {
            buffer.append('0');
            buffer.append(str);
        } else if (num == 2) {
            buffer.append(str);
        } else {
            buffer.append(""00"");
        }

        this.time = buffer.toString();
    }","  public void test7()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-3708), (-3708), (-3708));
      mockGregorianCalendar0.set(0, (-3708));
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = null;
      try {
        newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid era
         //
         verifyException(""java.util.GregorianCalendar"", e);
      }
  }"
1955,"    public String getNewsgroups()
    {
        return newsgroups == null ? null : newsgroups.toString();
    }","  public void test8()  throws Throwable  {
      Locale locale0 = new Locale(""Pattern is missing"", ""Pattern is missing"", ""Pattern is missing"");
      Calendar calendar0 = MockCalendar.getInstance(locale0);
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(calendar0, true);
      newGroupsOrNewsQuery0.omitNewsgroup(""202121"");
      newGroupsOrNewsQuery0.addNewsgroup(""202121"");
}"
1956,"    public String getDate()
    {
        return date;
    }","  public void test9()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.getNewsgroups();
}"
1957,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test10()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.getNewsgroups();
}"
1958,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test11()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.addNewsgroup((String) null);
      String string0 = newGroupsOrNewsQuery0.getNewsgroups();
}"
1959,"    public String getDate()
    {
        return date;
    }","  public void test12()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.addNewsgroup((String) null);
      String string0 = newGroupsOrNewsQuery0.getNewsgroups();
}"
1960,"    public String getNewsgroups()
    {
        return newsgroups == null ? null : newsgroups.toString();
    }","  public void test13()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.addNewsgroup((String) null);
      String string0 = newGroupsOrNewsQuery0.getNewsgroups();
}"
1961,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test14()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-2), (-2), (-2), (-2), (-2), (-2));
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      newGroupsOrNewsQuery0.getDistributions();
}"
1962,"    public String getDate()
    {
        return date;
    }","  public void test15()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-2), (-2), (-2), (-2), (-2), (-2));
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      newGroupsOrNewsQuery0.getDistributions();
}"
1963,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test16()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.addDistribution((String) null);
      String string0 = newGroupsOrNewsQuery0.getDistributions();
}"
1964,"    public String getDistributions()
    {
        return distributions == null ? null : distributions.toString();
    }","  public void test17()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.addDistribution((String) null);
      String string0 = newGroupsOrNewsQuery0.getDistributions();
}"
1965,"    public String getDate()
    {
        return date;
    }","  public void test18()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.addDistribution((String) null);
      String string0 = newGroupsOrNewsQuery0.getDistributions();
}"
1966,"    public String getDistributions()
    {
        return distributions == null ? null : distributions.toString();
    }","  public void test19()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.addDistribution((String) null);
      newGroupsOrNewsQuery0.addDistribution(""202121"");
}"
1967,"    public String getDate()
    {
        return date;
    }","  public void test20()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.getTime();
}"
1968,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test21()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      newGroupsOrNewsQuery0.getTime();
}"
1969,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test22()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      boolean boolean0 = newGroupsOrNewsQuery0.isGMT();
}"
1970,"    public String getDate()
    {
        return date;
    }","  public void test23()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, true);
      boolean boolean0 = newGroupsOrNewsQuery0.isGMT();
}"
1971,"    public boolean isGMT()
    {
        return isGMT;
    }","  public void test24()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-2), (-2), (-2), (-2), (-2), (-2));
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      String string0 = newGroupsOrNewsQuery0.getDate();
}"
1972,"    public String getDate()
    {
        return date;
    }","  public void test25()  throws Throwable  {
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-2), (-2), (-2), (-2), (-2), (-2));
      NewGroupsOrNewsQuery newGroupsOrNewsQuery0 = new NewGroupsOrNewsQuery(mockGregorianCalendar0, false);
      String string0 = newGroupsOrNewsQuery0.getDate();
}"
1973,,"  public void test0()  throws Throwable  {
      ArticlePointer articlePointer0 = new ArticlePointer();
}"
1974,"    ReplyIterator(final BufferedReader _reader, final boolean addDotReader) throws IOException {
        reader = addDotReader ? new DotTerminatedMessageReader(_reader) : _reader;
        line = reader.readLine(); // prime the iterator
        if (line == null) {
            Util.closeQuietly(reader);
        }
    }","  public void test0()  throws Throwable  {
      ReplyIterator replyIterator0 = null;
      try {
        replyIterator0 = new ReplyIterator((BufferedReader) null, false);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.ReplyIterator"", e);
      }
  }"
1975,"    ReplyIterator(final BufferedReader _reader, final boolean addDotReader) throws IOException {
        reader = addDotReader ? new DotTerminatedMessageReader(_reader) : _reader;
        line = reader.readLine(); // prime the iterator
        if (line == null) {
            Util.closeQuietly(reader);
        }
    }","  public void test1()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 1);
      stringReader0.close();
      ReplyIterator replyIterator0 = null;
      try {
        replyIterator0 = new ReplyIterator(bufferedReader0, false);
        fail(""Expecting exception: IOException"");
      } catch(Throwable e) {
         //
         // Stream closed
         //
         verifyException(""java.io.StringReader"", e);
      }
  }"
1976,"    ReplyIterator(final BufferedReader _reader, final boolean addDotReader) throws IOException {
        reader = addDotReader ? new DotTerminatedMessageReader(_reader) : _reader;
        line = reader.readLine(); // prime the iterator
        if (line == null) {
            Util.closeQuietly(reader);
        }
    }","  public void test2()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""4@2}ES!:m1ItsCdnT"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 720);
      bufferedReader0.close();
      ReplyIterator replyIterator0 = null;
      try {
        replyIterator0 = new ReplyIterator(bufferedReader0);
        fail(""Expecting exception: IOException"");
      } catch(Throwable e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedReader"", e);
      }
  }"
1977,"    public String next() throws NoSuchElementException {
        if (savedException != null){
            throw new NoSuchElementException(savedException.toString());
        }
        final String prev = line;
        if (prev == null) {
            throw new NoSuchElementException();
        }
        try {
            line = reader.readLine(); // save next line
            if (line == null) {
                Util.closeQuietly(reader);
            }
        } catch (final IOException ex) {
            savedException = ex; // if it fails, save the exception, as it does not apply to this call
            Util.closeQuietly(reader);
        }
        return prev;
    }","  public void test3()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.netio.Uil"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 640);
      ReplyIterator replyIterator0 = new ReplyIterator(bufferedReader0);
      replyIterator0.next();
      try { 
        replyIterator0.next();
        fail(""Expecting exception: NoSuchElementException"");
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.ReplyIterator"", e);
      }
  }"
1978,"    public String next() throws NoSuchElementException {
        if (savedException != null){
            throw new NoSuchElementException(savedException.toString());
        }
        final String prev = line;
        if (prev == null) {
            throw new NoSuchElementException();
        }
        try {
            line = reader.readLine(); // save next line
            if (line == null) {
                Util.closeQuietly(reader);
            }
        } catch (final IOException ex) {
            savedException = ex; // if it fails, save the exception, as it does not apply to this call
            Util.closeQuietly(reader);
        }
        return prev;
    }","  public void test4()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""jD"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 4181);
      ReplyIterator replyIterator0 = new ReplyIterator(bufferedReader0, false);
      bufferedReader0.close();
      replyIterator0.next();
      try { 
        replyIterator0.next();
        fail(""Expecting exception: NoSuchElementException"");
      } catch(NoSuchElementException e) {
         //
         // java.io.IOException: Stream closed
         //
         verifyException(""org.apache.commons.net.nntp.ReplyIterator"", e);
      }
  }"
1979,"    public boolean hasNext() {
        if (savedException != null){
            throw new NoSuchElementException(savedException.toString());
        }
        return line != null;
    }","  public void test5()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.netio.Uil"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 640);
      ReplyIterator replyIterator0 = new ReplyIterator(bufferedReader0);
      replyIterator0.next();
      boolean boolean0 = replyIterator0.hasNext();
}"
1980,"    public boolean hasNext() {
        if (savedException != null){
            throw new NoSuchElementException(savedException.toString());
        }
        return line != null;
    }","  public void test6()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""0E#,59"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 4203);
      ReplyIterator replyIterator0 = new ReplyIterator(bufferedReader0, false);
      bufferedReader0.close();
      replyIterator0.next();
      // Undeclared exception!
      try { 
        replyIterator0.hasNext();
        fail(""Expecting exception: NoSuchElementException"");
      } catch(NoSuchElementException e) {
         //
         // java.io.IOException: Stream closed
         //
         verifyException(""org.apache.commons.net.nntp.ReplyIterator"", e);
      }
  }"
1981,"    public boolean hasNext() {
        if (savedException != null){
            throw new NoSuchElementException(savedException.toString());
        }
        return line != null;
    }","  public void test7()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.netio.Uil"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 640);
      ReplyIterator replyIterator0 = new ReplyIterator(bufferedReader0);
      boolean boolean0 = replyIterator0.hasNext();
}"
1982,"    public String next() throws NoSuchElementException {
        if (savedException != null){
            throw new NoSuchElementException(savedException.toString());
        }
        final String prev = line;
        if (prev == null) {
            throw new NoSuchElementException();
        }
        try {
            line = reader.readLine(); // save next line
            if (line == null) {
                Util.closeQuietly(reader);
            }
        } catch (final IOException ex) {
            savedException = ex; // if it fails, save the exception, as it does not apply to this call
            Util.closeQuietly(reader);
        }
        return prev;
    }","  public void test8()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""..+8CCjNa|6=Y\""(*c@"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 1);
      ReplyIterator replyIterator0 = new ReplyIterator(bufferedReader0, false);
      stringReader0.reset();
      String string0 = replyIterator0.next();
}"
1983,"    public void remove() {
        throw new UnsupportedOperationException();
    }","  public void test9()  throws Throwable  {
      StringReader stringReader0 = new StringReader("""");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      ReplyIterator replyIterator0 = new ReplyIterator(bufferedReader0);
      // Undeclared exception!
      try { 
        replyIterator0.remove();
        fail(""Expecting exception: UnsupportedOperationException"");
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.ReplyIterator"", e);
      }
  }"
1984,"    public Iterator<String> iterator() {
        return this;
    }","  public void test10()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.netio.Uil"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 640);
      ReplyIterator replyIterator0 = new ReplyIterator(bufferedReader0);
      Iterator<String> iterator0 = replyIterator0.iterator();
}"
1985,"    ReplyIterator(final BufferedReader _reader, final boolean addDotReader) throws IOException {
        reader = addDotReader ? new DotTerminatedMessageReader(_reader) : _reader;
        line = reader.readLine(); // prime the iterator
        if (line == null) {
            Util.closeQuietly(reader);
        }
    }","  public void test11()  throws Throwable  {
      ReplyIterator replyIterator0 = null;
      try {
        replyIterator0 = new ReplyIterator((BufferedReader) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Reader"", e);
      }
  }"
1986,"    public void remove() {
        stringIterator.remove();
    }","  public void test0()  throws Throwable  {
      ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>(1);
      arrayDeque0.add("".?ygo%hLL=#,{"");
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(arrayDeque0);
      newsgroupIterator0.next();
      newsgroupIterator0.remove();
  }"
1987,"    public Iterator<NewsgroupInfo> iterator() {
        return this;
    }","  public void test1()  throws Throwable  {
      ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>();
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(arrayDeque0);
      Iterator<NewsgroupInfo> iterator0 = newsgroupIterator0.iterator();
}"
1988,"    public boolean hasNext() {
        return stringIterator.hasNext();
    }","  public void test2()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(set0);
      boolean boolean0 = newsgroupIterator0.hasNext();
}"
1989,"    public boolean hasNext() {
        return stringIterator.hasNext();
    }","  public void test3()  throws Throwable  {
      Class<String> class0 = String.class;
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      ServiceLoader<String> serviceLoader0 = ServiceLoader.load(class0, classLoader0);
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(serviceLoader0);
      boolean boolean0 = newsgroupIterator0.hasNext();
}"
1990,"    public void remove() {
        stringIterator.remove();
    }","  public void test4()  throws Throwable  {
      PriorityQueue<String> priorityQueue0 = new PriorityQueue<String>();
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(priorityQueue0);
      priorityQueue0.add(""3hIH-Vq 5>TsUOu(dJx"");
      // Undeclared exception!
      try { 
        newsgroupIterator0.remove();
        fail(""Expecting exception: ConcurrentModificationException"");
      } catch(ConcurrentModificationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.PriorityQueue$Itr"", e);
      }
  }"
1991,"    public NewsgroupInfo next() {
        final String line = stringIterator.next();
        return NNTPClient.parseNewsgroupListEntry(line);
    }","  public void test5()  throws Throwable  {
      PriorityQueue<String> priorityQueue0 = new PriorityQueue<String>();
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(priorityQueue0);
      priorityQueue0.add(""org.apache.commons.io.filefilter.OrFileFilter"");
      // Undeclared exception!
      try { 
        newsgroupIterator0.next();
        fail(""Expecting exception: ConcurrentModificationException"");
      } catch(ConcurrentModificationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.PriorityQueue$Itr"", e);
      }
  }"
1992,"    public NewsgroupInfo next() {
        final String line = stringIterator.next();
        return NNTPClient.parseNewsgroupListEntry(line);
    }","  public void test6()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>(vector0);
      linkedHashSet0.add((String) null);
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(linkedHashSet0);
      // Undeclared exception!
      try { 
        newsgroupIterator0.next();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NNTPClient"", e);
      }
  }"
1993,"    public NewsgroupIterator(final Iterable<String> iterableString) {
        stringIterator = iterableString.iterator();
    }","  public void test7()  throws Throwable  {
      NewsgroupIterator newsgroupIterator0 = null;
      try {
        newsgroupIterator0 = new NewsgroupIterator((Iterable<String>) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.NewsgroupIterator"", e);
      }
  }"
1994,"    public NewsgroupInfo next() {
        final String line = stringIterator.next();
        return NNTPClient.parseNewsgroupListEntry(line);
    }","  public void test8()  throws Throwable  {
      PriorityQueue<String> priorityQueue0 = new PriorityQueue<String>();
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(priorityQueue0);
      // Undeclared exception!
      try { 
        newsgroupIterator0.next();
        fail(""Expecting exception: NoSuchElementException"");
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.PriorityQueue$Itr"", e);
      }
  }"
1995,"    public void remove() {
        stringIterator.remove();
    }","  public void test9()  throws Throwable  {
      Class<String> class0 = String.class;
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      ServiceLoader<String> serviceLoader0 = ServiceLoader.load(class0, classLoader0);
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(serviceLoader0);
      // Undeclared exception!
      try { 
        newsgroupIterator0.remove();
        fail(""Expecting exception: UnsupportedOperationException"");
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.ServiceLoader$1"", e);
      }
  }"
1996,"    public void remove() {
        stringIterator.remove();
    }","  public void test10()  throws Throwable  {
      ArrayList<String> arrayList0 = new ArrayList<String>();
      HashSet<String> hashSet0 = new HashSet<String>(arrayList0);
      NewsgroupIterator newsgroupIterator0 = new NewsgroupIterator(hashSet0);
      // Undeclared exception!
      try { 
        newsgroupIterator0.remove();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.HashMap$HashIterator"", e);
      }
  }"
1997,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test0()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.setArticleNumber((-12L));
      stack0.add(article0);
      article0.setSubject(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      article0.addReference(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      Threadable threadable0 = threader0.thread((List<? extends Threadable>) stack0);
}"
1998,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test1()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.setArticleNumber((-12L));
      stack0.add(article0);
      article0.setSubject(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      article0.addReference(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      Threadable threadable0 = threader0.thread((List<? extends Threadable>) stack0);
}"
1999,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test2()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.setArticleNumber(1L);
      stack0.add(article0);
      stack0.add(article0);
      article0.setSubject(""org.apache.commons.io.fileiler.DirectoryFileFilter"");
      Threadable threadable0 = threader0.thread((List<? extends Threadable>) stack0);
}"
2000,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test3()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.setArticleNumber(1L);
      stack0.add(article0);
      stack0.add(article0);
      article0.setSubject(""org.apache.commons.io.fileiler.DirectoryFileFilter"");
      Threadable threadable0 = threader0.thread((List<? extends Threadable>) stack0);
}"
2001,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test4()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.setArticleNumber((-12L));
      stack0.add(article0);
      article0.setSubject(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      article0.addReference(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      Threadable threadable0 = threader0.thread((Iterable<? extends Threadable>) stack0);
}"
2002,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test5()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.setArticleNumber((-12L));
      stack0.add(article0);
      article0.setSubject(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      article0.addReference(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      Threadable threadable0 = threader0.thread((Iterable<? extends Threadable>) stack0);
}"
2003,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test6()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      List<Article> list0 = stack0.subList(0, 0);
      Article article0 = new Article();
      stack0.add(article0);
      // Undeclared exception!
      try { 
        threader0.thread((Iterable<? extends Threadable>) list0);
        fail(""Expecting exception: ConcurrentModificationException"");
      } catch(ConcurrentModificationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.SubList"", e);
      }
  }"
2004,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test7()  throws Throwable  {
      Threader threader0 = new Threader();
      LinkedList<Article> linkedList0 = new LinkedList<Article>();
      Article article0 = new Article();
      linkedList0.add(article0);
      Threadable threadable0 = threader0.thread((Iterable<? extends Threadable>) linkedList0);
}"
2005,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test8()  throws Throwable  {
      Threader threader0 = new Threader();
      Threadable threadable0 = threader0.thread((Threadable[]) null);
}"
2006,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test9()  throws Throwable  {
      Threader threader0 = new Threader();
      Article article0 = new Article();
      article0.setArticleNumber((-12L));
      article0.setSubject(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      article0.addReference(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      Threadable[] threadableArray0 = new Threadable[2];
      threadableArray0[0] = (Threadable) article0;
      threadableArray0[1] = (Threadable) article0;
      Article article1 = (Article)threader0.thread(threadableArray0);
}"
2007,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test10()  throws Throwable  {
      Threader threader0 = new Threader();
      Article article0 = new Article();
      article0.setArticleNumber((-12L));
      article0.setSubject(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      article0.addReference(""org.apache.commons.o.filefilter.DirectoryFieFilter"");
      Threadable[] threadableArray0 = new Threadable[2];
      threadableArray0[0] = (Threadable) article0;
      threadableArray0[1] = (Threadable) article0;
      Article article1 = (Article)threader0.thread(threadableArray0);
}"
2008,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test11()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.addReference("" "");
      article0.setArticleNumber(12L);
      stack0.add(article0);
      stack0.add(article0);
      article0.setSubject(""org.apache.commons.io.fileier.DirectoryFileFilter"");
      Threadable threadable0 = threader0.thread((Iterable<? extends Threadable>) stack0);
}"
2009,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test12()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.addReference("" "");
      article0.setArticleNumber(12L);
      stack0.add(article0);
      stack0.add(article0);
      article0.setSubject(""org.apache.commons.io.fileier.DirectoryFileFilter"");
      Threadable threadable0 = threader0.thread((Iterable<? extends Threadable>) stack0);
}"
2010,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test13()  throws Throwable  {
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.setArticleNumber((-65L));
      stack0.add(article0);
      article0.setSubject("""");
      Threader threader0 = new Threader();
      Article article1 = (Article)threader0.thread((Iterable<? extends Threadable>) stack0);
}"
2011,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test14()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.setArticleNumber((-153L));
      stack0.add(article0);
      article0.addReference(""  Qm:areKt"");
      article0.addReference(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      article0.setArticleId(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      // Undeclared exception!
      try { 
        threader0.thread((Iterable<? extends Threadable>) stack0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Article"", e);
      }
  }"
2012,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test15()  throws Throwable  {
      Threader threader0 = new Threader();
      Article article0 = new Article();
      article0.setArticleNumber((-153L));
      article0.addReference(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      article0.addReference("";$PT>"");
      article0.setArticleId(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      Threadable[] threadableArray0 = new Threadable[7];
      threadableArray0[0] = (Threadable) article0;
      threadableArray0[1] = (Threadable) article0;
      threadableArray0[2] = (Threadable) article0;
      threadableArray0[3] = (Threadable) article0;
      threadableArray0[4] = (Threadable) article0;
      threadableArray0[5] = (Threadable) article0;
      threadableArray0[6] = (Threadable) article0;
      // Undeclared exception!
      try { 
        threader0.thread(threadableArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Article"", e);
      }
  }"
2013,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test16()  throws Throwable  {
      Threader threader0 = new Threader();
      Stack<Article> stack0 = new Stack<Article>();
      Article article0 = new Article();
      article0.setArticleNumber((-153L));
      stack0.add(article0);
      article0.addReference(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      article0.addReference("";$PT>"");
      article0.setArticleId(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      // Undeclared exception!
      try { 
        threader0.thread((Iterable<? extends Threadable>) stack0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Article"", e);
      }
  }"
2014,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test17()  throws Throwable  {
      Threader threader0 = new Threader();
      Article article0 = new Article();
      article0.setArticleNumber((-49L));
      article0.addReference(""L$~y^$i8PNl,?SYe?"");
      article0.addReference(""ogapahe.commns.o.i;eUlter.DiRctoryFieFiler"");
      article0.addReference(""L$~y^$i8PNl,?SYe?"");
      article0.addReference("";w$PT>"");
      article0.setArticleId(""ogapahe.commns.o.i;eUlter.DiRctoryFieFiler"");
      Threadable[] threadableArray0 = new Threadable[1];
      threadableArray0[0] = (Threadable) article0;
      // Undeclared exception!
      try { 
        threader0.thread(threadableArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Article"", e);
      }
  }"
2015,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test18()  throws Throwable  {
      Threader threader0 = new Threader();
      Article article0 = new Article();
      article0.setArticleNumber((-153L));
      article0.setSubject(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      article0.addReference(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      article0.setArticleId(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      Threadable[] threadableArray0 = new Threadable[7];
      threadableArray0[0] = (Threadable) article0;
      threadableArray0[1] = (Threadable) article0;
      threadableArray0[2] = (Threadable) article0;
      threadableArray0[3] = (Threadable) article0;
      threadableArray0[4] = (Threadable) article0;
      threadableArray0[5] = (Threadable) article0;
      threadableArray0[6] = (Threadable) article0;
      Article article1 = (Article)threader0.thread(threadableArray0);
}"
2016,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test19()  throws Throwable  {
      Threader threader0 = new Threader();
      Article article0 = new Article();
      article0.setArticleNumber((-153L));
      article0.setSubject(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      article0.addReference(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      article0.setArticleId(""org.apahe.commns.o.fi;eilter.DiRectoryFieFilter"");
      Threadable[] threadableArray0 = new Threadable[7];
      threadableArray0[0] = (Threadable) article0;
      threadableArray0[1] = (Threadable) article0;
      threadableArray0[2] = (Threadable) article0;
      threadableArray0[3] = (Threadable) article0;
      threadableArray0[4] = (Threadable) article0;
      threadableArray0[5] = (Threadable) article0;
      threadableArray0[6] = (Threadable) article0;
      Article article1 = (Article)threader0.thread(threadableArray0);
}"
2017,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test20()  throws Throwable  {
      Threader threader0 = new Threader();
      ArrayList<Article> arrayList0 = new ArrayList<Article>();
      arrayList0.add((Article) null);
      // Undeclared exception!
      try { 
        threader0.thread((List<? extends Threadable>) arrayList0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.nntp.Threader"", e);
      }
  }"
2018,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test21()  throws Throwable  {
      Threader threader0 = new Threader();
      Threadable threadable0 = threader0.thread((Iterable<? extends Threadable>) null);
}"
2019,"    public Threadable thread(final List<? extends Threadable> messages) {
        return thread((Iterable<? extends Threadable>)messages);
    }","  public void test22()  throws Throwable  {
      Threader threader0 = new Threader();
      ArrayList<Article> arrayList0 = new ArrayList<Article>();
      Threadable threadable0 = threader0.thread((List<? extends Threadable>) arrayList0);
}"
2020,"    public NNTPConnectionClosedException()
    {
    }","  public void test0()  throws Throwable  {
      NNTPConnectionClosedException nNTPConnectionClosedException0 = new NNTPConnectionClosedException((String) null);
  }"
2021,"    public NNTPConnectionClosedException()
    {
    }","  public void test1()  throws Throwable  {
      NNTPConnectionClosedException nNTPConnectionClosedException0 = new NNTPConnectionClosedException();
  }"
2022,"    public InputStream getInputStream(final String handle) throws IOException
    {
        return getInputStream(false, handle);
    }","  public void test0()  throws Throwable  {
      WhoisClient whoisClient0 = new WhoisClient();
      // Undeclared exception!
      try { 
        whoisClient0.getInputStream("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.BufferedOutputStream"", e);
      }
  }"
2023,"    public String query(final String handle) throws IOException
    {
        return query(false, handle);
    }","  public void test1()  throws Throwable  {
      WhoisClient whoisClient0 = new WhoisClient();
      // Undeclared exception!
      try { 
        whoisClient0.query("">bWZAeD'Jb\""b"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.BufferedOutputStream"", e);
      }
  }"
2024,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test0()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0, false);
      telnetInputStream0.read();
      telnetInputStream0.available();
  }"
2025,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test1()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      TelnetClient telnetClient0 = new TelnetClient((byte)3);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0);
      telnetInputStream0.read();
      telnetInputStream0.start();
      telnetInputStream0.available();
  }"
2026,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test2()  throws Throwable  {
      byte[] byteArray0 = new byte[17];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)1, (byte)70);
      TelnetClient telnetClient0 = new TelnetClient((byte)0);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      telnetInputStream0.read(byteArray0, 4, (int) (byte)1);
  }"
2027,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test3()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      byteArray0[0] = (byte)26;
      byteArray0[1] = (byte) (-113);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient(""Queue is full! Cannot process another character."", (byte)26);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      telnetInputStream0.start();
      telnetInputStream0.read(byteArray0);
  }"
2028,"    public void run()
    {
        int ch;

        try
        {
_outerLoop:
            while (!isClosed)
            {
                try
                {
                    if ((ch = read(true)) < 0) {
                        break;
                    }
                }
                catch (final InterruptedIOException e)
                {
                    synchronized (queue)
                    {
                        ioException = e;
                        queue.notifyAll();
                        try
                        {
                            queue.wait(100);
                        }
                        catch (final InterruptedException interrupted)
                        {
                            if (isClosed) {
                                break _outerLoop;
                            }
                        }
                        continue;
                    }
                } catch(final RuntimeException re) {
                    // We treat any runtime exceptions as though the
                    // stream has been closed.  We close the
                    // underlying stream just to be sure.
                    super.close();
                    // Breaking the loop has the effect of setting
                    // the state to closed at the end of the method.
                    break _outerLoop;
                }

                // Process new character
                boolean notify = false;
                try
                {
                    notify = processChar(ch);
                }
                catch (final InterruptedException e)
                {
                    if (isClosed) {
                        break _outerLoop;
                    }
                }

                // Notify input listener if buffer was previously empty
                if (notify) {
                    client.notifyInputListener();
                }
            }
        }
        catch (final IOException ioe)
        {
            synchronized (queue)
            {
                ioException = ioe;
            }
            client.notifyInputListener();
        }

        synchronized (queue)
        {
            isClosed      = true; // Possibly redundant
            hasReachedEOF = true;
            queue.notify();
        }

        threaded = false;
    }","  public void test4()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      PipedInputStream pipedInputStream0 = new PipedInputStream(780);
      DataInputStream dataInputStream0 = new DataInputStream(pipedInputStream0);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(dataInputStream0, telnetClient0, true);
      telnetInputStream0.start();
      telnetInputStream0.run();
  }"
2029,"    void start()
    {
        if(thread == null) {
            return;
        }

        int priority;
        isClosed = false;
        // TODO remove this
        // Need to set a higher priority in case JVM does not use pre-emptive
        // threads.  This should prevent scheduler induced deadlock (rather than
        // deadlock caused by a bug in this code).
        priority = Thread.currentThread().getPriority() + 1;
        if (priority > Thread.MAX_PRIORITY) {
            priority = Thread.MAX_PRIORITY;
        }
        thread.setPriority(priority);
        thread.setDaemon(true);
        thread.start();
        threaded = true; // tell _processChar that we are running threaded
    }","  public void test5()  throws Throwable  {
      Enumeration<DataInputStream> enumeration0 = (Enumeration<DataInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      TelnetClient telnetClient0 = new TelnetClient(""spy.log"", 0);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0);
      telnetInputStream0.start();
      // Undeclared exception!
      try { 
        telnetInputStream0.start();
        fail(""Expecting exception: IllegalThreadStateException"");
      } catch(IllegalThreadStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.lang.Thread"", e);
      }
  }"
2030,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test6()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient(""Queue is full! Cannot process another character."", (byte)26);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      // Undeclared exception!
      try { 
        telnetInputStream0.read((byte[]) null, 82, 393);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetInputStream"", e);
      }
  }"
2031,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test7()  throws Throwable  {
      DataInputStream dataInputStream0 = new DataInputStream((InputStream) null);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(dataInputStream0, dataInputStream0);
      TelnetClient telnetClient0 = new TelnetClient(2094);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0);
      byte[] byteArray0 = new byte[9];
      // Undeclared exception!
      try { 
        telnetInputStream0.read(byteArray0, (-2433), 8);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.DataInputStream"", e);
      }
  }"
2032,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test8()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (-3557), 4);
      TelnetClient telnetClient0 = new TelnetClient("">="");
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0, false);
      // Undeclared exception!
      try { 
        telnetInputStream0.read(byteArray0, 137, 687);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ByteArrayInputStream"", e);
      }
  }"
2033,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test9()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream((InputStream) null, telnetClient0, false);
      byte[] byteArray0 = new byte[8];
      try { 
        telnetInputStream0.read(byteArray0, (int) (byte)1, 2254);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedInputStream"", e);
      }
  }"
2034,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test10()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream((InputStream) null, telnetClient0, false);
      // Undeclared exception!
      try { 
        telnetInputStream0.read((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetInputStream"", e);
      }
  }"
2035,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test11()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(780);
      DataInputStream dataInputStream0 = new DataInputStream((InputStream) null);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(dataInputStream0, telnetClient0, true);
      byte[] byteArray0 = new byte[2];
      // Undeclared exception!
      try { 
        telnetInputStream0.read(byteArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.DataInputStream"", e);
      }
  }"
2036,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test12()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) (-30), (byte)70);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      // Undeclared exception!
      try { 
        telnetInputStream0.read(byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ByteArrayInputStream"", e);
      }
  }"
2037,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test13()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(31);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream((InputStream) null, telnetClient0);
      byte[] byteArray0 = new byte[1];
      try { 
        telnetInputStream0.read(byteArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedInputStream"", e);
      }
  }"
2038,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test14()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(780);
      DataInputStream dataInputStream0 = new DataInputStream((InputStream) null);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(dataInputStream0, telnetClient0, true);
      // Undeclared exception!
      try { 
        telnetInputStream0.read();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.DataInputStream"", e);
      }
  }"
2039,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test15()  throws Throwable  {
      byte[] byteArray0 = new byte[2];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (-1264), 1334);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0, false);
      // Undeclared exception!
      try { 
        telnetInputStream0.read();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ByteArrayInputStream"", e);
      }
  }"
2040,"    public void close() throws IOException
    {
        // Completely disregard the fact thread may still be running.
        // We can't afford to block on this close by waiting for
        // thread to terminate because few if any JVM's will actually
        // interrupt a system read() from the interrupt() method.
        super.close();

        synchronized (queue)
        {
            hasReachedEOF = true;
            isClosed      = true;

            if (thread != null && thread.isAlive())
            {
                thread.interrupt();
            }

            queue.notifyAll();
        }

    }","  public void test16()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(780);
      DataInputStream dataInputStream0 = new DataInputStream((InputStream) null);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(dataInputStream0, telnetClient0, true);
      // Undeclared exception!
      try { 
        telnetInputStream0.close();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.FilterInputStream"", e);
      }
  }"
2041,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test17()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(780);
      DataInputStream dataInputStream0 = new DataInputStream((InputStream) null);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(dataInputStream0, telnetClient0, true);
      // Undeclared exception!
      try { 
        telnetInputStream0.available();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.FilterInputStream"", e);
      }
  }"
2042,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test18()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream((InputStream) null, telnetClient0);
      try { 
        telnetInputStream0.available();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedInputStream"", e);
      }
  }"
2043,"    TelnetInputStream(final InputStream input, final TelnetClient client,
                      final boolean readerThread)
    {
        super(input);
        this.client = client;
        this.receiveState = STATE_DATA;
        this.isClosed = true;
        this.hasReachedEOF = false;
        // Make it 2049, because when full, one slot will go unused, and we
        // want a 2048 byte buffer just to have a round number (base 2 that is)
        this.queue = new int[2049];
        this.queueHead = 0;
        this.queueTail = 0;
        this.suboption = new int[client.maxSubnegotiationLength];
        this.bytesAvailable = 0;
        this.ioException = null;
        this.readIsWaiting = false;
        this.threaded = false;
        if(readerThread) {
            this.thread = new Thread(this);
        } else {
            this.thread = null;
        }
    }","  public void test19()  throws Throwable  {
      TelnetInputStream telnetInputStream0 = null;
      try {
        telnetInputStream0 = new TelnetInputStream((InputStream) null, (TelnetClient) null, true);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetInputStream"", e);
      }
  }"
2044,"    TelnetInputStream(final InputStream input, final TelnetClient client,
                      final boolean readerThread)
    {
        super(input);
        this.client = client;
        this.receiveState = STATE_DATA;
        this.isClosed = true;
        this.hasReachedEOF = false;
        // Make it 2049, because when full, one slot will go unused, and we
        // want a 2048 byte buffer just to have a round number (base 2 that is)
        this.queue = new int[2049];
        this.queueHead = 0;
        this.queueTail = 0;
        this.suboption = new int[client.maxSubnegotiationLength];
        this.bytesAvailable = 0;
        this.ioException = null;
        this.readIsWaiting = false;
        this.threaded = false;
        if(readerThread) {
            this.thread = new Thread(this);
        } else {
            this.thread = null;
        }
    }","  public void test20()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      TelnetClient telnetClient0 = new TelnetClient((-3577));
      TelnetInputStream telnetInputStream0 = null;
      try {
        telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0, false);
        fail(""Expecting exception: NegativeArraySizeException"");
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetInputStream"", e);
      }
  }"
2045,"    TelnetInputStream(final InputStream input, final TelnetClient client,
                      final boolean readerThread)
    {
        super(input);
        this.client = client;
        this.receiveState = STATE_DATA;
        this.isClosed = true;
        this.hasReachedEOF = false;
        // Make it 2049, because when full, one slot will go unused, and we
        // want a 2048 byte buffer just to have a round number (base 2 that is)
        this.queue = new int[2049];
        this.queueHead = 0;
        this.queueTail = 0;
        this.suboption = new int[client.maxSubnegotiationLength];
        this.bytesAvailable = 0;
        this.ioException = null;
        this.readIsWaiting = false;
        this.threaded = false;
        if(readerThread) {
            this.thread = new Thread(this);
        } else {
            this.thread = null;
        }
    }","  public void test21()  throws Throwable  {
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      TelnetInputStream telnetInputStream0 = null;
      try {
        telnetInputStream0 = new TelnetInputStream(pipedInputStream0, (TelnetClient) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetInputStream"", e);
      }
  }"
2046,"    TelnetInputStream(final InputStream input, final TelnetClient client,
                      final boolean readerThread)
    {
        super(input);
        this.client = client;
        this.receiveState = STATE_DATA;
        this.isClosed = true;
        this.hasReachedEOF = false;
        // Make it 2049, because when full, one slot will go unused, and we
        // want a 2048 byte buffer just to have a round number (base 2 that is)
        this.queue = new int[2049];
        this.queueHead = 0;
        this.queueTail = 0;
        this.suboption = new int[client.maxSubnegotiationLength];
        this.bytesAvailable = 0;
        this.ioException = null;
        this.readIsWaiting = false;
        this.threaded = false;
        if(readerThread) {
            this.thread = new Thread(this);
        } else {
            this.thread = null;
        }
    }","  public void test22()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(""<nN<("", (-902));
      TelnetInputStream telnetInputStream0 = null;
      try {
        telnetInputStream0 = new TelnetInputStream((InputStream) null, telnetClient0);
        fail(""Expecting exception: NegativeArraySizeException"");
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetInputStream"", e);
      }
  }"
2047,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test23()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      TelnetClient telnetClient0 = new TelnetClient((byte)3);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0);
      telnetInputStream0.start();
      telnetInputStream0.available();
  }"
2048,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test24()  throws Throwable  {
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      TelnetClient telnetClient0 = new TelnetClient("""");
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(pipedInputStream0, telnetClient0, false);
      byte[] byteArray0 = new byte[4];
      telnetInputStream0.read(byteArray0, (-1595), (int) (byte)0);
  }"
2049,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test25()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) (-1), (-458));
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0, true);
      telnetInputStream0.read();
  }"
2050,"    public void close() throws IOException
    {
        // Completely disregard the fact thread may still be running.
        // We can't afford to block on this close by waiting for
        // thread to terminate because few if any JVM's will actually
        // interrupt a system read() from the interrupt() method.
        super.close();

        synchronized (queue)
        {
            hasReachedEOF = true;
            isClosed      = true;

            if (thread != null && thread.isAlive())
            {
                thread.interrupt();
            }

            queue.notifyAll();
        }

    }","  public void test26()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream((InputStream) null, telnetClient0, true);
      telnetInputStream0.start();
      telnetInputStream0.close();
  }"
2051,"    public void close() throws IOException
    {
        // Completely disregard the fact thread may still be running.
        // We can't afford to block on this close by waiting for
        // thread to terminate because few if any JVM's will actually
        // interrupt a system read() from the interrupt() method.
        super.close();

        synchronized (queue)
        {
            hasReachedEOF = true;
            isClosed      = true;

            if (thread != null && thread.isAlive())
            {
                thread.interrupt();
            }

            queue.notifyAll();
        }

    }","  public void test27()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream((InputStream) null, telnetClient0, true);
      telnetInputStream0.close();
  }"
2052,"    public void close() throws IOException
    {
        // Completely disregard the fact thread may still be running.
        // We can't afford to block on this close by waiting for
        // thread to terminate because few if any JVM's will actually
        // interrupt a system read() from the interrupt() method.
        super.close();

        synchronized (queue)
        {
            hasReachedEOF = true;
            isClosed      = true;

            if (thread != null && thread.isAlive())
            {
                thread.interrupt();
            }

            queue.notifyAll();
        }

    }","  public void test28()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0, false);
      telnetInputStream0.close();
  }"
2053,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test29()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0);
      telnetInputStream0.available();
  }"
2054,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test30()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0);
      TelnetClient telnetClient0 = new TelnetClient();
      pipedOutputStream0.write((-2162));
      byte[] byteArray0 = new byte[2];
      telnetClient0._registerSpyStream(pipedOutputStream0);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(pipedInputStream0, telnetClient0);
      telnetInputStream0.read();
      // Undeclared exception!
      try { 
        telnetInputStream0.read(byteArray0, (int) (byte)13, 142);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 13
         //
         verifyException(""org.apache.commons.net.telnet.TelnetInputStream"", e);
      }
  }"
2055,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test31()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient(""Queue is full! Cannot process another character."", (byte)26);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      byte[] byteArray1 = new byte[0];
      int int0 = telnetInputStream0.read(byteArray1);
}"
2056,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test32()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient(""Queue is full! Cannot process another character."", (byte)26);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      telnetInputStream0.start();
      int int0 = telnetInputStream0.read();
}"
2057,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test33()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient(""Queue is full! Cannot process another character."", (byte)26);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      telnetInputStream0.start();
      int int0 = telnetInputStream0.read();
}"
2058,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test34()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[1] = (byte) (-1);
      byteArray0[2] = (byte) (-1);
      byteArray0[3] = (byte) (-1);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      TelnetClient telnetClient0 = new TelnetClient();
      byteArrayInputStream0.read();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0);
      int int0 = telnetInputStream0.read();
}"
2059,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test35()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[1] = (byte) (-1);
      byteArray0[2] = (byte) (-1);
      byteArray0[3] = (byte) (-1);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      TelnetClient telnetClient0 = new TelnetClient();
      byteArrayInputStream0.read();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0);
      int int0 = telnetInputStream0.read();
}"
2060,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test36()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)1, (byte)0);
      TelnetClient telnetClient0 = new TelnetClient((byte)0);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      int int0 = telnetInputStream0.read(byteArray0, (int) (byte)0, (int) (byte)1);
}"
2061,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test37()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)1, (byte) (-14));
      TelnetClient telnetClient0 = new TelnetClient((byte)122);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      telnetInputStream0.start();
      int int0 = telnetInputStream0.read(byteArray0);
}"
2062,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test38()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream((InputStream) null, telnetClient0);
      telnetInputStream0.start();
      try { 
        telnetInputStream0.read();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedInputStream"", e);
      }
  }"
2063,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test39()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      byteArray0[1] = (byte)26;
      byteArray0[1] = (byte)13;
      FileSystemHandling.shouldAllThrowIOExceptions();
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      TelnetClient telnetClient0 = new TelnetClient(""Queue is full! Cannot process another character."", (byte)26);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      telnetInputStream0.start();
      telnetInputStream0.run();
}"
2064,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test40()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      byteArray0[1] = (byte)13;
      byteArray0[2] = (byte)13;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient(""g.6zJ"");
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0, true);
      // Undeclared exception!
      try { 
        telnetInputStream0.read(byteArray0, 2039, 122);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2039
         //
         verifyException(""org.apache.commons.net.telnet.TelnetInputStream"", e);
      }
  }"
2065,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test41()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      byteArray0[1] = (byte)26;
      byteArray0[1] = (byte)13;
      byteArray0[2] = (byte)0;
      FileSystemHandling.shouldAllThrowIOExceptions();
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      byteArrayInputStream0.mark((byte)13);
      TelnetClient telnetClient0 = new TelnetClient(""Queue is full! Cannot process another character."", (byte)26);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      telnetInputStream0.start();
      telnetInputStream0.run();
}"
2066,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test42()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[1] = (byte) (-1);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0);
      int int0 = telnetInputStream0.read();
}"
2067,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test43()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[1] = (byte) (-1);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(sequenceInputStream0, telnetClient0);
      int int0 = telnetInputStream0.read();
}"
2068,"    public boolean markSupported()
    {
        return false;
    }","  public void test44()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0, false);
      telnetInputStream0.start();
}"
2069,"    public int available() throws IOException
    {
        // Critical section because run() may change __bytesAvailable
        synchronized (queue)
        {
            if (threaded) { // Must not call super.available when running threaded: NET-466
                return bytesAvailable;
            }
            return bytesAvailable + super.available();
        }
    }","  public void test45()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      telnetInputStream0.start();
      telnetInputStream0.run();
      int int0 = telnetInputStream0.read(byteArray0, (int) (byte)0, 2058);
}"
2070,"    private int read(final boolean mayBlock) throws IOException
    {
        int ch;

        while (true)
        {

            // If there is no more data AND we were told not to block,
            // just return WOULD_BLOCK (-2). (More efficient than exception.)
            if(!mayBlock && super.available() == 0) {
                return WOULD_BLOCK;
            }

            // Otherwise, exit only when we reach end of stream.
            if ((ch = super.read()) < 0) {
                return EOF;
            }

            ch = ch & 0xff;

            /* Code Section added for supporting AYT (start)*/
            synchronized (client)
            {
                client.processAYTResponse();
            }
            /* Code Section added for supporting AYT (end)*/

            /* Code Section added for supporting spystreams (start)*/
            client.spyRead(ch);
            /* Code Section added for supporting spystreams (end)*/

            switch (receiveState)
            {

            case STATE_CR:
                if (ch == '\0')
                {
                    // Strip null
                    continue;
                }
                // How do we handle newline after cr?
                //  else if (ch == '\n' && _requestedDont(TelnetOption.ECHO) &&

                // Handle as normal data by falling through to _STATE_DATA case

                //$FALL-THROUGH$
            case STATE_DATA:
                if (ch == TelnetCommand.IAC)
                {
                    receiveState = STATE_IAC;
                    continue;
                }


                if (ch == '\r')
                {
                    synchronized (client)
                    {
                        if (client.requestedDont(TelnetOption.BINARY)) {
                            receiveState = STATE_CR;
                        } else {
                            receiveState = STATE_DATA;
                        }
                    }
                } else {
                    receiveState = STATE_DATA;
                }
                break;

            case STATE_IAC:
                switch (ch)
                {
                case TelnetCommand.WILL:
                    receiveState = STATE_WILL;
                    continue;
                case TelnetCommand.WONT:
                    receiveState = STATE_WONT;
                    continue;
                case TelnetCommand.DO:
                    receiveState = STATE_DO;
                    continue;
                case TelnetCommand.DONT:
                    receiveState = STATE_DONT;
                    continue;
                /* TERMINAL-TYPE option (start)*/
                case TelnetCommand.SB:
                    suboptionCount = 0;
                    receiveState = STATE_SB;
                    continue;
                /* TERMINAL-TYPE option (end)*/
                case TelnetCommand.IAC:
                    receiveState = STATE_DATA;
                    break; // exit to enclosing switch to return IAC from read
                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)
                    receiveState = STATE_DATA;
                    continue;
                default:
                    receiveState = STATE_DATA;
                    client.processCommand(ch); // Notify the user
                    continue; // move on the next char
                }
                break; // exit and return from read
            case STATE_WILL:
                synchronized (client)
                {
                    client.processWill(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_WONT:
                synchronized (client)
                {
                    client.processWont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DO:
                synchronized (client)
                {
                    client.processDo(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            case STATE_DONT:
                synchronized (client)
                {
                    client.processDont(ch);
                    client.flushOutputStream();
                }
                receiveState = STATE_DATA;
                continue;
            /* TERMINAL-TYPE option (start)*/
            case STATE_SB:
                switch (ch)
                {
                case TelnetCommand.IAC:
                    receiveState = STATE_IAC_SB;
                    continue;
                default:
                    // store suboption char
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                }
                receiveState = STATE_SB;
                continue;
            case STATE_IAC_SB: // IAC received during SB phase
                switch (ch)
                {
                case TelnetCommand.SE:
                    synchronized (client)
                    {
                        client.processSuboption(suboption, suboptionCount);
                        client.flushOutputStream();
                    }
                    receiveState = STATE_DATA;
                    continue;
                case TelnetCommand.IAC: // De-dup the duplicated IAC
                    if (suboptionCount < suboption.length) {
                        suboption[suboptionCount++] = ch;
                    }
                    break;
                default:            // unexpected byte! ignore it
                    break;
                }
                receiveState = STATE_SB;
                continue;
            /* TERMINAL-TYPE option (end)*/
            }

            break;
        }

        return ch;
    }","  public void test46()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(byteArrayInputStream0, telnetClient0);
      telnetInputStream0.start();
      telnetInputStream0.run();
      int int0 = telnetInputStream0.read(byteArray0, (int) (byte)0, 2058);
}"
2071,"    public boolean markSupported()
    {
        return false;
    }","  public void test47()  throws Throwable  {
      BufferedInputStream bufferedInputStream0 = new BufferedInputStream((InputStream) null, 8);
      TelnetClient telnetClient0 = new TelnetClient(0);
      TelnetInputStream telnetInputStream0 = new TelnetInputStream(bufferedInputStream0, telnetClient0);
      boolean boolean0 = telnetInputStream0.markSupported();
}"
2072,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test0()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      windowSizeOptionHandler0.startSubnegotiationLocal();
}"
2073,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test1()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      windowSizeOptionHandler0.startSubnegotiationLocal();
}"
2074,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test2()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      windowSizeOptionHandler0.startSubnegotiationLocal();
}"
2075,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test3()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      windowSizeOptionHandler0.startSubnegotiationLocal();
}"
2076,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test4()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      windowSizeOptionHandler0.startSubnegotiationLocal();
}"
2077,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test5()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""7d`hC_Qmb{pcm!:(5"");
      terminalTypeOptionHandler0.setWill(true);
      boolean boolean0 = terminalTypeOptionHandler0.getWill();
}"
2078,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test6()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""7d`hC_Qmb{pcm!:(5"");
      terminalTypeOptionHandler0.setWill(true);
      boolean boolean0 = terminalTypeOptionHandler0.getWill();
}"
2079,"    boolean getWill()
    {
        return willFlag;
    }","  public void test7()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""7d`hC_Qmb{pcm!:(5"");
      terminalTypeOptionHandler0.setWill(true);
      boolean boolean0 = terminalTypeOptionHandler0.getWill();
}"
2080,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test8()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""7d`hC_Qmb{pcm!:(5"");
      terminalTypeOptionHandler0.setWill(true);
      boolean boolean0 = terminalTypeOptionHandler0.getWill();
}"
2081,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test9()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""7d`hC_Qmb{pcm!:(5"");
      terminalTypeOptionHandler0.setWill(true);
      boolean boolean0 = terminalTypeOptionHandler0.getWill();
}"
2082,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test10()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""7d`hC_Qmb{pcm!:(5"");
      terminalTypeOptionHandler0.setWill(true);
      boolean boolean0 = terminalTypeOptionHandler0.getWill();
}"
2083,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test11()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(0);
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2084,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test12()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(0);
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2085,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test13()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(0);
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2086,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test14()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(0);
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2087,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test15()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(0);
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2088,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test16()  throws Throwable  {
      SuppressGAOptionHandler suppressGAOptionHandler0 = new SuppressGAOptionHandler(true, true, true, true);
      int int0 = suppressGAOptionHandler0.getOptionCode();
}"
2089,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test17()  throws Throwable  {
      SuppressGAOptionHandler suppressGAOptionHandler0 = new SuppressGAOptionHandler(true, true, true, true);
      int int0 = suppressGAOptionHandler0.getOptionCode();
}"
2090,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test18()  throws Throwable  {
      SuppressGAOptionHandler suppressGAOptionHandler0 = new SuppressGAOptionHandler(true, true, true, true);
      int int0 = suppressGAOptionHandler0.getOptionCode();
}"
2091,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test19()  throws Throwable  {
      SuppressGAOptionHandler suppressGAOptionHandler0 = new SuppressGAOptionHandler(true, true, true, true);
      int int0 = suppressGAOptionHandler0.getOptionCode();
}"
2092,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test20()  throws Throwable  {
      SuppressGAOptionHandler suppressGAOptionHandler0 = new SuppressGAOptionHandler(true, true, true, true);
      int int0 = suppressGAOptionHandler0.getOptionCode();
}"
2093,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test21()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler((-1582), (-1582));
}"
2094,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test22()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler((-1582), (-1582));
      windowSizeOptionHandler0.setInitRemote(true);
      boolean boolean0 = windowSizeOptionHandler0.getInitRemote();
}"
2095,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test23()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2174));
      simpleOptionHandler0.setDo(true);
      boolean boolean0 = simpleOptionHandler0.getDo();
}"
2096,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test24()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2174));
      simpleOptionHandler0.setDo(true);
      boolean boolean0 = simpleOptionHandler0.getDo();
}"
2097,"    boolean getDo()
    {
        return doFlag;
    }","  public void test25()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2174));
      simpleOptionHandler0.setDo(true);
      boolean boolean0 = simpleOptionHandler0.getDo();
}"
2098,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test26()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2174));
      simpleOptionHandler0.setDo(true);
      boolean boolean0 = simpleOptionHandler0.getDo();
}"
2099,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test27()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2174));
      simpleOptionHandler0.setDo(true);
      boolean boolean0 = simpleOptionHandler0.getDo();
}"
2100,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test28()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2174));
      simpleOptionHandler0.setDo(true);
      boolean boolean0 = simpleOptionHandler0.getDo();
}"
2101,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test29()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(1, false, true, false, true);
      boolean boolean0 = simpleOptionHandler0.getAcceptRemote();
}"
2102,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test30()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(1, false, true, false, true);
      boolean boolean0 = simpleOptionHandler0.getAcceptRemote();
}"
2103,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test31()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(1, false, true, false, true);
      boolean boolean0 = simpleOptionHandler0.getAcceptRemote();
}"
2104,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test32()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(1, false, true, false, true);
      boolean boolean0 = simpleOptionHandler0.getAcceptRemote();
}"
2105,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test33()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(1, false, true, false, true);
      boolean boolean0 = simpleOptionHandler0.getAcceptRemote();
}"
2106,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test34()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2174));
}"
2107,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test35()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2174));
      simpleOptionHandler0.setAcceptLocal(true);
      boolean boolean0 = simpleOptionHandler0.getAcceptLocal();
}"
2108,"    public int[] startSubnegotiationLocal() {
        return null;
    }","  public void test36()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler((-1), (-1));
      // Undeclared exception!
      try { 
        windowSizeOptionHandler0.startSubnegotiationLocal();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 5
         //
         verifyException(""org.apache.commons.net.telnet.WindowSizeOptionHandler"", e);
      }
  }"
2109,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength) {
        return null;
    }","  public void test37()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""cBDc_?l"", true, false, true, true);
      int[] intArray0 = new int[0];
      // Undeclared exception!
      try { 
        terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 256);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 0
         //
         verifyException(""org.apache.commons.net.telnet.TerminalTypeOptionHandler"", e);
      }
  }"
2110,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test38()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      boolean boolean0 = windowSizeOptionHandler0.getInitRemote();
}"
2111,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test39()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      boolean boolean0 = windowSizeOptionHandler0.getInitRemote();
}"
2112,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test40()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      boolean boolean0 = windowSizeOptionHandler0.getInitRemote();
}"
2113,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test41()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      boolean boolean0 = windowSizeOptionHandler0.getInitRemote();
}"
2114,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test42()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      boolean boolean0 = windowSizeOptionHandler0.getInitRemote();
}"
2115,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test43()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationLocal();
}"
2116,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test44()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationLocal();
}"
2117,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test45()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationLocal();
}"
2118,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test46()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationLocal();
}"
2119,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test47()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationLocal();
}"
2120,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test48()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      boolean boolean0 = windowSizeOptionHandler0.getAcceptRemote();
}"
2121,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test49()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      boolean boolean0 = windowSizeOptionHandler0.getAcceptRemote();
}"
2122,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test50()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      boolean boolean0 = windowSizeOptionHandler0.getAcceptRemote();
}"
2123,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test51()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      boolean boolean0 = windowSizeOptionHandler0.getAcceptRemote();
}"
2124,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test52()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(0, 0);
      boolean boolean0 = windowSizeOptionHandler0.getAcceptRemote();
}"
2125,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test53()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      simpleOptionHandler0.getDo();
}"
2126,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test54()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      simpleOptionHandler0.getDo();
}"
2127,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test55()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      simpleOptionHandler0.getDo();
}"
2128,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test56()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      simpleOptionHandler0.getDo();
}"
2129,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test57()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      simpleOptionHandler0.getDo();
}"
2130,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test58()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getAcceptLocal();
}"
2131,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test59()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getAcceptLocal();
}"
2132,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test60()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getAcceptLocal();
}"
2133,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test61()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getAcceptLocal();
}"
2134,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test62()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getAcceptLocal();
}"
2135,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test63()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.setAcceptRemote(false);
}"
2136,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test64()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.setAcceptRemote(false);
}"
2137,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test65()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.setAcceptRemote(false);
}"
2138,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test66()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.setAcceptRemote(false);
}"
2139,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test67()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.setAcceptRemote(false);
}"
2140,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test68()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getInitLocal();
}"
2141,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test69()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getInitLocal();
}"
2142,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test70()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getInitLocal();
}"
2143,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test71()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getInitLocal();
}"
2144,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test72()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      boolean boolean0 = simpleOptionHandler0.getInitLocal();
}"
2145,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test73()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationRemote();
}"
2146,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test74()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationRemote();
}"
2147,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test75()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationRemote();
}"
2148,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test76()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationRemote();
}"
2149,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test77()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""]NZ"");
      terminalTypeOptionHandler0.startSubnegotiationRemote();
}"
2150,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test78()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.getWill();
}"
2151,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test79()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.getWill();
}"
2152,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test80()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.getWill();
}"
2153,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test81()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.getWill();
}"
2154,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test82()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(80, 80, false, false, false, false);
      windowSizeOptionHandler0.getWill();
}"
2155,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test83()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler((-1), (-1));
      int[] intArray0 = new int[2];
      windowSizeOptionHandler0.answerSubnegotiation(intArray0, 0);
}"
2156,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test84()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler((-1), (-1));
      int[] intArray0 = new int[2];
      windowSizeOptionHandler0.answerSubnegotiation(intArray0, 0);
}"
2157,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test85()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler((-1), (-1));
      int[] intArray0 = new int[2];
      windowSizeOptionHandler0.answerSubnegotiation(intArray0, 0);
}"
2158,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test86()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler((-1), (-1));
      int[] intArray0 = new int[2];
      windowSizeOptionHandler0.answerSubnegotiation(intArray0, 0);
}"
2159,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test87()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler((-1), (-1));
      int[] intArray0 = new int[2];
      windowSizeOptionHandler0.answerSubnegotiation(intArray0, 0);
}"
2160,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test88()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
}"
2161,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test89()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-2473));
      simpleOptionHandler0.setInitLocal(true);
      boolean boolean0 = simpleOptionHandler0.getInitLocal();
}"
2162,"    public boolean getInitRemote()
    {
        return initialRemote;
    }","  public void test90()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-1254));
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2163,"    public int getOptionCode()
    {
        return optionCode;
    }","  public void test91()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-1254));
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2164,"    public boolean getInitLocal()
    {
        return initialLocal;
    }","  public void test92()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-1254));
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2165,"    public boolean getAcceptRemote()
    {
        return acceptRemote;
    }","  public void test93()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-1254));
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2166,"    public boolean getAcceptLocal()
    {
        return acceptLocal;
    }","  public void test94()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-1254));
      int int0 = simpleOptionHandler0.getOptionCode();
}"
2167,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test0()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""u_U"", false, false, true, true);
      int[] intArray0 = new int[2];
      intArray0[0] = 24;
      intArray0[1] = 1;
      int[] intArray1 = terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 24);
}"
2168,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test1()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""u_U"", false, false, true, true);
      int[] intArray0 = new int[2];
      intArray0[0] = 24;
      intArray0[1] = 1;
      int[] intArray1 = terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 24);
}"
2169,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test2()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""u_U"", false, false, true, true);
      int[] intArray0 = new int[2];
      intArray0[0] = 24;
      intArray0[1] = 1;
      int[] intArray1 = terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 24);
}"
2170,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test3()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler("" s)1xF|{L+s[-A"", false, false, false, false);
      int[] intArray0 = new int[2];
      intArray0[0] = 1376;
      int[] intArray1 = terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 1376);
}"
2171,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test4()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""_U"", false, false, false, false);
      int[] intArray0 = new int[3];
      intArray0[0] = 24;
      int[] intArray1 = terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 24);
}"
2172,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test5()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler((String) null, true, true, false, true);
      int[] intArray0 = new int[4];
      int[] intArray1 = terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 493);
}"
2173,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test6()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""_U"", false, false, false, false);
      int[] intArray0 = new int[3];
      int[] intArray1 = terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 1);
}"
2174,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test7()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""_U"", false, false, false, false);
      int[] intArray0 = new int[3];
      int[] intArray1 = terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 24);
}"
2175,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test8()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""org.apache.commons.net.telnet.TerminalTypeOptionHandler"");
      int[] intArray0 = new int[0];
      // Undeclared exception!
      try { 
        terminalTypeOptionHandler0.answerSubnegotiation(intArray0, 2);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 0
         //
         verifyException(""org.apache.commons.net.telnet.TerminalTypeOptionHandler"", e);
      }
  }"
2176,"    public int[] answerSubnegotiation(final int suboptionData[], final int suboptionLength)
    {
        if ((suboptionData != null) && (suboptionLength > 1)
            && (termType != null))
        {
            if ((suboptionData[0] == TERMINAL_TYPE)
                && (suboptionData[1] == TERMINAL_TYPE_SEND))
            {
                final int response[] = new int[termType.length() + 2];

                response[0] = TERMINAL_TYPE;
                response[1] = TERMINAL_TYPE_IS;

                for (int ii = 0; ii < termType.length(); ii++)
                {
                    response[ii + 2] = termType.charAt(ii);
                }

                return response;
            }
        }
        return null;
    }","  public void test9()  throws Throwable  {
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""HC+t/@\"":o~T"", false, true, false, false);
      int[] intArray0 = terminalTypeOptionHandler0.answerSubnegotiation((int[]) null, 0);
}"
2177,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test0()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      int[] intArray0 = new int[7];
      intArray0[0] = 247;
      telnet0.processSuboption(intArray0, 32);
}"
2178,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test1()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      int[] intArray0 = new int[4];
      telnet0.processSuboption(intArray0, 0);
}"
2179,"    void processDo(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED DO: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_DO,
                option);
        }

        boolean acceptNewState = false;


        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptLocal();
        }
        else
        {
        /* open TelnetOptionHandler functionality (end)*/
            /* TERMINAL-TYPE option (start)*/
            if (option == TERMINAL_TYPE)
            {
                if (terminalType != null && !terminalType.isEmpty())
                {
                    acceptNewState = true;
                }
            }
            /* TERMINAL-TYPE option (end)*/
        /* open TelnetOptionHandler functionality (start)*/
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (willResponse[option] > 0)
        {
            --willResponse[option];
            if (willResponse[option] > 0 && stateIsWill(option))
            {
                --willResponse[option];
            }
        }

        if (willResponse[option] == 0)
        {
            if (requestedWont(option))
            {

                switch (option)
                {

                default:
                    break;

                }


                if (acceptNewState)
                {
                    setWantWill(option);
                    sendWill(option);
                }
                else
                {
                    ++willResponse[option];
                    sendWont(option);
                }
            }
            else
            {
                // Other end has acknowledged option.

                switch (option)
                {

                default:
                    break;

                }

            }
        }

        setWill(option);
    }","  public void test2()  throws Throwable  {
      Telnet telnet0 = new Telnet(""< "");
      // Undeclared exception!
      try { 
        telnet0.processDo(2);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2180,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test3()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDo(0);
      telnet0.setWantDo(0);
}"
2181,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test4()  throws Throwable  {
      Telnet telnet0 = new Telnet("";`IfVtz[O#yCJ"");
      telnet0.setWantWill(27);
      telnet0.setWantWill(27);
}"
2182,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test5()  throws Throwable  {
      Telnet telnet0 = new Telnet(""Invalid Option Code"");
      telnet0.setDo(2);
      telnet0.setDo(2);
}"
2183,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test6()  throws Throwable  {
      Telnet telnet0 = new Telnet(""~j+\""Ymp(.@t$A3|jo"");
      telnet0.setWill(228);
      telnet0.setWill(228);
}"
2184,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test7()  throws Throwable  {
      Telnet telnet0 = new Telnet(""3"");
      telnet0.setWantWont(1);
}"
2185,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test8()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDont(0);
}"
2186,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test9()  throws Throwable  {
      Telnet telnet0 = new Telnet(""y2pBsTjEC?g"");
      telnet0.setDont(23);
}"
2187,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test10()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0._sendSubnegotiation((int[]) null);
}"
2188,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test11()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      Telnet telnet0 = new Telnet(""lq*"");
      MockFile mockFile0 = new MockFile(""\r\n"", """");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
      telnet0._registerSpyStream(mockFileOutputStream0);
      telnet0.spyWrite(2083);
}"
2189,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test12()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      MockFile mockFile0 = new MockFile(""\r\n"", ""3"");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
      mockFileOutputStream0.close();
      telnet0._registerSpyStream(mockFileOutputStream0);
      telnet0.spyRead(1);
}"
2190,"    boolean stateIsWont(final int option)
    {
        return !stateIsWill(option);
    }","  public void test13()  throws Throwable  {
      Telnet telnet0 = new Telnet(""~j+\""Ymp(.@t$A|jo"");
      boolean boolean0 = telnet0.stateIsWont(228);
}"
2191,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test14()  throws Throwable  {
      Telnet telnet0 = new Telnet(""~j+\""Ymp(.@t$A|jo"");
      boolean boolean0 = telnet0.stateIsWont(228);
}"
2192,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test15()  throws Throwable  {
      Telnet telnet0 = new Telnet(""~j+\""Ymp(.@t$A3|jo"");
      telnet0.setWill(228);
      boolean boolean0 = telnet0.stateIsWont(228);
}"
2193,"    boolean stateIsWont(final int option)
    {
        return !stateIsWill(option);
    }","  public void test16()  throws Throwable  {
      Telnet telnet0 = new Telnet(""~j+\""Ymp(.@t$A3|jo"");
      telnet0.setWill(228);
      boolean boolean0 = telnet0.stateIsWont(228);
}"
2194,"    boolean stateIsWill(final int option)
    {
        return (options[option] & WILL_MASK) != 0;
    }","  public void test17()  throws Throwable  {
      Telnet telnet0 = new Telnet(""~j+\""Ymp(.@t$A3|jo"");
      telnet0.setWill(228);
      boolean boolean0 = telnet0.stateIsWill(228);
}"
2195,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test18()  throws Throwable  {
      Telnet telnet0 = new Telnet(""~j+\""Ymp(.@t$A3|jo"");
      telnet0.setWill(228);
      boolean boolean0 = telnet0.stateIsWill(228);
}"
2196,"    boolean stateIsWill(final int option)
    {
        return (options[option] & WILL_MASK) != 0;
    }","  public void test19()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      boolean boolean0 = telnet0.stateIsWill(94);
}"
2197,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test20()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      boolean boolean0 = telnet0.stateIsWill(94);
}"
2198,"    boolean stateIsDont(final int option)
    {
        return !stateIsDo(option);
    }","  public void test21()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      boolean boolean0 = telnet0.stateIsDont(2);
}"
2199,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test22()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      boolean boolean0 = telnet0.stateIsDont(2);
}"
2200,"    boolean stateIsDont(final int option)
    {
        return !stateIsDo(option);
    }","  public void test23()  throws Throwable  {
      Telnet telnet0 = new Telnet("",h"");
      telnet0.setDo(174);
      boolean boolean0 = telnet0.stateIsDont(174);
}"
2201,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test24()  throws Throwable  {
      Telnet telnet0 = new Telnet("",h"");
      telnet0.setDo(174);
      boolean boolean0 = telnet0.stateIsDont(174);
}"
2202,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test25()  throws Throwable  {
      Telnet telnet0 = new Telnet(""_ITI"");
      telnet0.setDo(35);
      boolean boolean0 = telnet0.stateIsDo(35);
}"
2203,"    boolean stateIsDo(final int option)
    {
        return (options[option] & DO_MASK) != 0;
    }","  public void test26()  throws Throwable  {
      Telnet telnet0 = new Telnet(""_ITI"");
      telnet0.setDo(35);
      boolean boolean0 = telnet0.stateIsDo(35);
}"
2204,"    boolean stateIsDo(final int option)
    {
        return (options[option] & DO_MASK) != 0;
    }","  public void test27()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      boolean boolean0 = telnet0.stateIsDo(0);
}"
2205,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test28()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      boolean boolean0 = telnet0.stateIsDo(0);
}"
2206,"    boolean requestedWont(final int option)
    {
        return !requestedWill(option);
    }","  public void test29()  throws Throwable  {
      Telnet telnet0 = new Telnet("",h"");
      boolean boolean0 = telnet0.requestedWont(174);
}"
2207,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test30()  throws Throwable  {
      Telnet telnet0 = new Telnet("",h"");
      boolean boolean0 = telnet0.requestedWont(174);
}"
2208,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test31()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantWill(224);
      boolean boolean0 = telnet0.requestedWont(224);
}"
2209,"    boolean requestedWont(final int option)
    {
        return !requestedWill(option);
    }","  public void test32()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantWill(224);
      boolean boolean0 = telnet0.requestedWont(224);
}"
2210,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test33()  throws Throwable  {
      Telnet telnet0 = new Telnet((String) null);
      telnet0.setWantWill(226);
      boolean boolean0 = telnet0.requestedWill(226);
}"
2211,"    boolean requestedWill(final int option)
    {
        return (options[option] & REQUESTED_WILL_MASK) != 0;
    }","  public void test34()  throws Throwable  {
      Telnet telnet0 = new Telnet((String) null);
      telnet0.setWantWill(226);
      boolean boolean0 = telnet0.requestedWill(226);
}"
2212,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test35()  throws Throwable  {
      Telnet telnet0 = new Telnet("",h"");
      telnet0.requestedWill(174);
}"
2213,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test36()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      boolean boolean0 = telnet0.requestedDont(0);
}"
2214,"    boolean requestedDont(final int option)
    {
        return !requestedDo(option);
    }","  public void test37()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      boolean boolean0 = telnet0.requestedDont(0);
}"
2215,"    boolean requestedDont(final int option)
    {
        return !requestedDo(option);
    }","  public void test38()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDo(21);
      boolean boolean0 = telnet0.requestedDont(21);
}"
2216,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test39()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDo(21);
      boolean boolean0 = telnet0.requestedDont(21);
}"
2217,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test40()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDo(2);
      boolean boolean0 = telnet0.requestedDo(2);
}"
2218,"    boolean requestedDo(final int option)
    {
        return (options[option] & REQUESTED_DO_MASK) != 0;
    }","  public void test41()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDo(2);
      boolean boolean0 = telnet0.requestedDo(2);
}"
2219,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test42()  throws Throwable  {
      Telnet telnet0 = new Telnet("",zq5.TLjQCqau"");
      telnet0.requestedDo(31);
}"
2220,"    boolean stateIsWont(final int option)
    {
        return !stateIsWill(option);
    }","  public void test43()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.stateIsWont((-1323));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1323
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2221,"    boolean stateIsWill(final int option)
    {
        return (options[option] & WILL_MASK) != 0;
    }","  public void test44()  throws Throwable  {
      Telnet telnet0 = new Telnet((String) null);
      // Undeclared exception!
      try { 
        telnet0.stateIsWill((-334));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -334
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2222,"    boolean stateIsDont(final int option)
    {
        return !stateIsDo(option);
    }","  public void test45()  throws Throwable  {
      Telnet telnet0 = new Telnet(""The filter must not be null"");
      // Undeclared exception!
      try { 
        telnet0.stateIsDont(2618);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2618
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2223,"    boolean stateIsDo(final int option)
    {
        return (options[option] & DO_MASK) != 0;
    }","  public void test46()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.stateIsDo((-759));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -759
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2224,"    void setWont(final int option)
    {
        options[option] &= ~WILL_MASK;

        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            optionHandlers[option].setWill(false);
        }
        /* open TelnetOptionHandler functionality (end)*/
    }","  public void test47()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.setWont((-3435));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -3435
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2225,"    void setWill(final int option) throws IOException
    {
        options[option] |= WILL_MASK;

        /* open TelnetOptionHandler functionality (start)*/
        if (requestedWill(option))
        {
            if (optionHandlers[option] != null)
            {
                optionHandlers[option].setWill(true);

                final int[] subneg =
                    optionHandlers[option].startSubnegotiationLocal();

                if (subneg != null)
                {
                    _sendSubnegotiation(subneg);
                }
            }
        }
        /* open TelnetOptionHandler functionality (end)*/
    }","  public void test48()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.setWill(394);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 394
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2226,"    void setWantWont(final int option)
    {
        options[option] &= ~REQUESTED_WILL_MASK;
    }","  public void test49()  throws Throwable  {
      Telnet telnet0 = new Telnet(""7LH=/v:+w8=?DjE[n"");
      // Undeclared exception!
      try { 
        telnet0.setWantWont((-6));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -6
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2227,"    void setWantWill(final int option)
    {
        options[option] |= REQUESTED_WILL_MASK;
    }","  public void test50()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.setWantWill((-4217));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -4217
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2228,"    void setWantDont(final int option)
    {
        options[option] &= ~REQUESTED_DO_MASK;
    }","  public void test51()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.setWantDont((-293));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -293
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2229,"    void setWantDo(final int option)
    {
        options[option] |= REQUESTED_DO_MASK;
    }","  public void test52()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.setWantDo((-334));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -334
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2230,"    void setDont(final int option)
    {
        options[option] &= ~DO_MASK;

        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            optionHandlers[option].setDo(false);
        }
        /* open TelnetOptionHandler functionality (end)*/
    }","  public void test53()  throws Throwable  {
      Telnet telnet0 = new Telnet(""org.apache.commons.net.ProtocolCommandSupport"");
      // Undeclared exception!
      try { 
        telnet0.setDont((-819));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -819
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2231,"    void setDo(final int option) throws IOException
    {
        options[option] |= DO_MASK;

        /* open TelnetOptionHandler functionality (start)*/
        if (requestedDo(option))
        {
            if (optionHandlers[option] != null)
            {
                optionHandlers[option].setDo(true);

                final int[] subneg =
                    optionHandlers[option].startSubnegotiationRemote();

                if (subneg != null)
                {
                    _sendSubnegotiation(subneg);
                }
            }
        }
        /* open TelnetOptionHandler functionality (end)*/
    }","  public void test54()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.setDo((-680));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -680
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2232,"    final synchronized void sendWont(final int option)
    throws IOException
    {
        if (debug || debugoptions)
        {
            System.err.println(""WONT: "" + TelnetOption.getOption(option));
        }
        _output_.write(COMMAND_WONT);
        _output_.write(option);

        /* Code Section added for sending the negotiation ASAP (start)*/
        _output_.flush();
        /* Code Section added for sending the negotiation ASAP (end)*/
    }","  public void test55()  throws Throwable  {
      Telnet telnet0 = new Telnet(""oV*"");
      // Undeclared exception!
      try { 
        telnet0.sendWont((-1125));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2233,"    final synchronized void sendWill(final int option)
    throws IOException
    {
        if (debug || debugoptions)
        {
            System.err.println(""WILL: "" + TelnetOption.getOption(option));
        }
        _output_.write(COMMAND_WILL);
        _output_.write(option);

        /* Code Section added for sending the negotiation ASAP (start)*/
        _output_.flush();
        /* Code Section added for sending the negotiation ASAP (end)*/
    }","  public void test56()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.sendWill(0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2234,"    final synchronized void sendDont(final int option)
    throws IOException
    {
        if (debug || debugoptions)
        {
            System.err.println(""DONT: "" + TelnetOption.getOption(option));
        }
        _output_.write(COMMAND_DONT);
        _output_.write(option);

        /* Code Section added for sending the negotiation ASAP (start)*/
        _output_.flush();
        /* Code Section added for sending the negotiation ASAP (end)*/
    }","  public void test57()  throws Throwable  {
      Telnet telnet0 = new Telnet(""$ Mq=O"");
      // Undeclared exception!
      try { 
        telnet0.sendDont(26);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2235,"    boolean requestedWont(final int option)
    {
        return !requestedWill(option);
    }","  public void test58()  throws Throwable  {
      Telnet telnet0 = new Telnet(""~j+\""Ymp(.@t$A3|jo"");
      // Undeclared exception!
      try { 
        telnet0.requestedWont((-1361));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1361
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2236,"    boolean requestedWill(final int option)
    {
        return (options[option] & REQUESTED_WILL_MASK) != 0;
    }","  public void test59()  throws Throwable  {
      Telnet telnet0 = new Telnet(""\"""");
      // Undeclared exception!
      try { 
        telnet0.requestedWill((-342));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -342
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2237,"    boolean requestedDont(final int option)
    {
        return !requestedDo(option);
    }","  public void test60()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.requestedDont(1790);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1790
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2238,"    boolean requestedDo(final int option)
    {
        return (options[option] & REQUESTED_DO_MASK) != 0;
    }","  public void test61()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.requestedDo((-2624));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -2624
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2239,"    final synchronized void requestWont(final int option)
    throws IOException
    {
        if (willResponse[option] == 0 && stateIsWont(option)
            || requestedWont(option))
        {
            return ;
        }
        setWantWont(option);
        ++doResponse[option];
        sendWont(option);
    }","  public void test62()  throws Throwable  {
      Telnet telnet0 = new Telnet(""_ITI"");
      // Undeclared exception!
      try { 
        telnet0.requestWont((-921));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -921
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2240,"    final synchronized void requestWill(final int option)
    throws IOException
    {
        if (willResponse[option] == 0 && stateIsWill(option)
            || requestedWill(option))
        {
            return ;
        }
        setWantWill(option);
        ++doResponse[option];
        sendWill(option);
    }","  public void test63()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.requestWill(2354);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2354
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2241,"    final synchronized void requestDont(final int option)
    throws IOException
    {
        if (doResponse[option] == 0 && stateIsDont(option)
            || requestedDont(option))
        {
            return ;
        }
        setWantDont(option);
        ++doResponse[option];
        sendDont(option);
    }","  public void test64()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.requestDont(2116);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2116
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2242,"    final synchronized void requestDo(final int option)
    throws IOException
    {
        if (doResponse[option] == 0 && stateIsDo(option)
            || requestedDo(option))
        {
            return ;
        }
        setWantDo(option);
        ++doResponse[option];
        sendDo(option);
    }","  public void test65()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.requestDo(2278);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2278
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2243,"    void processWont(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED WONT: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_WONT,
                option);
        }

        if (doResponse[option] > 0)
        {
            --doResponse[option];
            if (doResponse[option] > 0 && stateIsDont(option))
            {
                --doResponse[option];
            }
        }

        if (doResponse[option] == 0 && requestedDo(option))
        {

            switch (option)
            {

            default:
                break;

            }

            /* FIX for a BUG in the negotiation (start)*/
            if (stateIsDo(option) || requestedDo(option))
            {
                sendDont(option);
            }

            setWantDont(option);
            /* FIX for a BUG in the negotiation (end)*/
        }

        setDont(option);
    }","  public void test66()  throws Throwable  {
      Telnet telnet0 = new Telnet(""AYT response:"");
      // Undeclared exception!
      try { 
        telnet0.processWont((-693));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -693
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2244,"    void processWill(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED WILL: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_WILL,
                option);
        }

        boolean acceptNewState = false;

        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptRemote();
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (doResponse[option] > 0)
        {
            --doResponse[option];
            if (doResponse[option] > 0 && stateIsDo(option))
            {
                --doResponse[option];
            }
        }

        if (doResponse[option] == 0 && requestedDont(option))
        {

            switch (option)
            {

            default:
                break;

            }


            if (acceptNewState)
            {
                setWantDo(option);
                sendDo(option);
            }
            else
            {
                ++doResponse[option];
                sendDont(option);
            }
        }

        setDo(option);
    }","  public void test67()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.processWill((-559));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -559
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2245,"    void processSuboption(final int[] suboption, final int suboptionLength)
    throws IOException
    {
        if (debug)
        {
            System.err.println(""PROCESS SUBOPTION."");
        }

        /* open TelnetOptionHandler functionality (start)*/
        if (suboptionLength > 0)
        {
            if (optionHandlers[suboption[0]] != null)
            {
                final int[] responseSuboption =
                  optionHandlers[suboption[0]].answerSubnegotiation(suboption,
                  suboptionLength);
                _sendSubnegotiation(responseSuboption);
            }
            else
            {
                if (suboptionLength > 1)
                {
                    if (debug)
                    {
                        for (int ii = 0; ii < suboptionLength; ii++)
                        {
                            System.err.println(""SUB["" + ii + ""]: ""
                                + suboption[ii]);
                        }
                    }
                    if (suboption[0] == TERMINAL_TYPE
                        && suboption[1] == TERMINAL_TYPE_SEND)
                    {
                        sendTerminalType();
                    }
                }
            }
        }
        /* open TelnetOptionHandler functionality (end)*/
    }","  public void test68()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.processSuboption((int[]) null, 246);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2246,"    void processSuboption(final int[] suboption, final int suboptionLength)
    throws IOException
    {
        if (debug)
        {
            System.err.println(""PROCESS SUBOPTION."");
        }

        /* open TelnetOptionHandler functionality (start)*/
        if (suboptionLength > 0)
        {
            if (optionHandlers[suboption[0]] != null)
            {
                final int[] responseSuboption =
                  optionHandlers[suboption[0]].answerSubnegotiation(suboption,
                  suboptionLength);
                _sendSubnegotiation(responseSuboption);
            }
            else
            {
                if (suboptionLength > 1)
                {
                    if (debug)
                    {
                        for (int ii = 0; ii < suboptionLength; ii++)
                        {
                            System.err.println(""SUB["" + ii + ""]: ""
                                + suboption[ii]);
                        }
                    }
                    if (suboption[0] == TERMINAL_TYPE
                        && suboption[1] == TERMINAL_TYPE_SEND)
                    {
                        sendTerminalType();
                    }
                }
            }
        }
        /* open TelnetOptionHandler functionality (end)*/
    }","  public void test69()  throws Throwable  {
      Telnet telnet0 = new Telnet(""Bb.@guJux;$FP"");
      int[] intArray0 = new int[2];
      intArray0[0] = (-1306);
      // Undeclared exception!
      try { 
        telnet0.processSuboption(intArray0, 63);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1306
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2247,"    void processDont(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED DONT: ""
                + TelnetOption.getOption(option));
        }
        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_DONT,
                option);
        }
        if (willResponse[option] > 0)
        {
            --willResponse[option];
            if (willResponse[option] > 0 && stateIsWont(option))
            {
                --willResponse[option];
            }
        }

        if (willResponse[option] == 0 && requestedWill(option))
        {

            switch (option)
            {

            default:
                break;

            }

            /* FIX for a BUG in the negotiation (start)*/
            if (stateIsWill(option) || requestedWill(option))
            {
                sendWont(option);
            }

            setWantWont(option);
            /* FIX for a BUG in the negotiation (end)*/
        }

        setWont(option);
    }","  public void test70()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.processDont(3733);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 3733
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2248,"    void processDo(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED DO: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_DO,
                option);
        }

        boolean acceptNewState = false;


        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptLocal();
        }
        else
        {
        /* open TelnetOptionHandler functionality (end)*/
            /* TERMINAL-TYPE option (start)*/
            if (option == TERMINAL_TYPE)
            {
                if (terminalType != null && !terminalType.isEmpty())
                {
                    acceptNewState = true;
                }
            }
            /* TERMINAL-TYPE option (end)*/
        /* open TelnetOptionHandler functionality (start)*/
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (willResponse[option] > 0)
        {
            --willResponse[option];
            if (willResponse[option] > 0 && stateIsWill(option))
            {
                --willResponse[option];
            }
        }

        if (willResponse[option] == 0)
        {
            if (requestedWont(option))
            {

                switch (option)
                {

                default:
                    break;

                }


                if (acceptNewState)
                {
                    setWantWill(option);
                    sendWill(option);
                }
                else
                {
                    ++willResponse[option];
                    sendWont(option);
                }
            }
            else
            {
                // Other end has acknowledged option.

                switch (option)
                {

                default:
                    break;

                }

            }
        }

        setWill(option);
    }","  public void test71()  throws Throwable  {
      Telnet telnet0 = new Telnet(""x?S.H*7A)"");
      // Undeclared exception!
      try { 
        telnet0.processDo((-296));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -296
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2249,"    void deleteOptionHandler(final int optcode)
    throws InvalidTelnetOptionException, IOException
    {
        if (TelnetOption.isValidOption(optcode))
        {
            if (optionHandlers[optcode] == null)
            {
                throw new InvalidTelnetOptionException(
                    ""Unregistered option"", optcode);
            }
            final TelnetOptionHandler opthand = optionHandlers[optcode];
            optionHandlers[optcode] = null;

            if (opthand.getWill())
            {
                requestWont(optcode);
            }

            if (opthand.getDo())
            {
                requestDont(optcode);
            }
        }
        else
        {
            throw new InvalidTelnetOptionException(
                ""Invalid Option Code"", optcode);
        }
    }","  public void test72()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.deleteOptionHandler((-1395));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1395
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2250,"    void addOptionHandler(final TelnetOptionHandler opthand)
    throws InvalidTelnetOptionException, IOException
    {
        final int optcode = opthand.getOptionCode();
        if (TelnetOption.isValidOption(optcode))
        {
            if (optionHandlers[optcode] == null)
            {
                optionHandlers[optcode] = opthand;
                if (isConnected())
                {
                    if (opthand.getInitLocal())
                    {
                        requestWill(optcode);
                    }

                    if (opthand.getInitRemote())
                    {
                        requestDo(optcode);
                    }
                }
            }
            else
            {
                throw new InvalidTelnetOptionException(
                    ""Already registered option"", optcode);
            }
        }
        else
        {
            throw new InvalidTelnetOptionException(
                ""Invalid Option Code"", optcode);
        }
    }","  public void test73()  throws Throwable  {
      Telnet telnet0 = new Telnet(""PPy&7}5P2^p|?@>"");
      // Undeclared exception!
      try { 
        telnet0.addOptionHandler((TelnetOptionHandler) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2251,"    void addOptionHandler(final TelnetOptionHandler opthand)
    throws InvalidTelnetOptionException, IOException
    {
        final int optcode = opthand.getOptionCode();
        if (TelnetOption.isValidOption(optcode))
        {
            if (optionHandlers[optcode] == null)
            {
                optionHandlers[optcode] = opthand;
                if (isConnected())
                {
                    if (opthand.getInitLocal())
                    {
                        requestWill(optcode);
                    }

                    if (opthand.getInitRemote())
                    {
                        requestDo(optcode);
                    }
                }
            }
            else
            {
                throw new InvalidTelnetOptionException(
                    ""Already registered option"", optcode);
            }
        }
        else
        {
            throw new InvalidTelnetOptionException(
                ""Invalid Option Code"", optcode);
        }
    }","  public void test74()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-1), false, false, false, false);
      // Undeclared exception!
      try { 
        telnet0.addOptionHandler(simpleOptionHandler0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2252,"    final boolean _sendAYT(final long timeout)
    throws IOException, IllegalArgumentException, InterruptedException
    {
        boolean retValue = false;
        synchronized (aytMonitor)
        {
            synchronized (this)
            {
                aytFlag = false;
                _output_.write(COMMAND_AYT);
                _output_.flush();
            }
            aytMonitor.wait(timeout);
            if (aytFlag == false)
            {
                retValue = false;
                aytFlag = true;
            }
            else
            {
                retValue = true;
            }
        }

        return retValue;
    }","  public void test75()  throws Throwable  {
      Telnet telnet0 = new Telnet(""_ITI"");
      // Undeclared exception!
      try { 
        telnet0._sendAYT(0L);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2253,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test76()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(232);
      MockPrintStream mockPrintStream0 = new MockPrintStream(byteArrayOutputStream0, true);
      telnet0._registerSpyStream(mockPrintStream0);
      telnet0.spyRead(232);
}"
2254,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test77()  throws Throwable  {
      Telnet telnet0 = new Telnet((String) null);
      telnet0.spyRead(249);
}"
2255,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test78()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(44, true, true, true, true);
      simpleOptionHandler0.setDo(true);
      telnet0.addOptionHandler(simpleOptionHandler0);
      telnet0.deleteOptionHandler(44);
}"
2256,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test79()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(44, true, true, true, true);
      telnet0.addOptionHandler(simpleOptionHandler0);
      telnet0.deleteOptionHandler(44);
}"
2257,"    void deleteOptionHandler(final int optcode)
    throws InvalidTelnetOptionException, IOException
    {
        if (TelnetOption.isValidOption(optcode))
        {
            if (optionHandlers[optcode] == null)
            {
                throw new InvalidTelnetOptionException(
                    ""Unregistered option"", optcode);
            }
            final TelnetOptionHandler opthand = optionHandlers[optcode];
            optionHandlers[optcode] = null;

            if (opthand.getWill())
            {
                requestWont(optcode);
            }

            if (opthand.getDo())
            {
                requestDont(optcode);
            }
        }
        else
        {
            throw new InvalidTelnetOptionException(
                ""Invalid Option Code"", optcode);
        }
    }","  public void test80()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      try { 
        telnet0.deleteOptionHandler(44);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Unregistered option: 44
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2258,"    void deleteOptionHandler(final int optcode)
    throws InvalidTelnetOptionException, IOException
    {
        if (TelnetOption.isValidOption(optcode))
        {
            if (optionHandlers[optcode] == null)
            {
                throw new InvalidTelnetOptionException(
                    ""Unregistered option"", optcode);
            }
            final TelnetOptionHandler opthand = optionHandlers[optcode];
            optionHandlers[optcode] = null;

            if (opthand.getWill())
            {
                requestWont(optcode);
            }

            if (opthand.getDo())
            {
                requestDont(optcode);
            }
        }
        else
        {
            throw new InvalidTelnetOptionException(
                ""Invalid Option Code"", optcode);
        }
    }","  public void test81()  throws Throwable  {
      Telnet telnet0 = new Telnet(""Invalid Option CWoe"");
      try { 
        telnet0.deleteOptionHandler(1024);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Invalid Option Code: 1024
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2259,"    void addOptionHandler(final TelnetOptionHandler opthand)
    throws InvalidTelnetOptionException, IOException
    {
        final int optcode = opthand.getOptionCode();
        if (TelnetOption.isValidOption(optcode))
        {
            if (optionHandlers[optcode] == null)
            {
                optionHandlers[optcode] = opthand;
                if (isConnected())
                {
                    if (opthand.getInitLocal())
                    {
                        requestWill(optcode);
                    }

                    if (opthand.getInitRemote())
                    {
                        requestDo(optcode);
                    }
                }
            }
            else
            {
                throw new InvalidTelnetOptionException(
                    ""Already registered option"", optcode);
            }
        }
        else
        {
            throw new InvalidTelnetOptionException(
                ""Invalid Option Code"", optcode);
        }
    }","  public void test82()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(2, (-2624));
      telnet0.addOptionHandler(windowSizeOptionHandler0);
      try { 
        telnet0.addOptionHandler(windowSizeOptionHandler0);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Already registered option: 31
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2260,"    void addOptionHandler(final TelnetOptionHandler opthand)
    throws InvalidTelnetOptionException, IOException
    {
        final int optcode = opthand.getOptionCode();
        if (TelnetOption.isValidOption(optcode))
        {
            if (optionHandlers[optcode] == null)
            {
                optionHandlers[optcode] = opthand;
                if (isConnected())
                {
                    if (opthand.getInitLocal())
                    {
                        requestWill(optcode);
                    }

                    if (opthand.getInitRemote())
                    {
                        requestDo(optcode);
                    }
                }
            }
            else
            {
                throw new InvalidTelnetOptionException(
                    ""Already registered option"", optcode);
            }
        }
        else
        {
            throw new InvalidTelnetOptionException(
                ""Invalid Option Code"", optcode);
        }
    }","  public void test83()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(1094, true, true, true, true);
      try { 
        telnet0.addOptionHandler(simpleOptionHandler0);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Invalid Option Code: 1094
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2261,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test84()  throws Throwable  {
      Telnet telnet0 = new Telnet(""_ITI"");
      telnet0.setWill(35);
      telnet0.requestWont(35);
}"
2262,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test85()  throws Throwable  {
      Telnet telnet0 = new Telnet((String) null);
      telnet0.setWantWill(249);
      telnet0.requestWill(249);
}"
2263,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test86()  throws Throwable  {
      Telnet telnet0 = new Telnet("".`"");
      telnet0.setWill(0);
      telnet0.requestWill(0);
}"
2264,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test87()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDo(21);
      telnet0.requestDo(21);
}"
2265,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test88()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setDo(121);
      telnet0.requestDo(121);
}"
2266,"    final synchronized void requestDo(final int option)
    throws IOException
    {
        if (doResponse[option] == 0 && stateIsDo(option)
            || requestedDo(option))
        {
            return ;
        }
        setWantDo(option);
        ++doResponse[option];
        sendDo(option);
    }","  public void test89()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.requestDo(44);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2267,"    protected void _connectAction_() throws IOException
    {
        /* (start). BUGFIX: clean the option info for each connection*/
        for (int ii = 0; ii < TelnetOption.MAX_OPTION_VALUE + 1; ii++)
        {
            doResponse[ii] = 0;
            willResponse[ii] = 0;
            options[ii] = 0;
            if (optionHandlers[ii] != null)
            {
                optionHandlers[ii].setDo(false);
                optionHandlers[ii].setWill(false);
            }
        }
        /* (end). BUGFIX: clean the option info for each connection*/

        super._connectAction_();
        _input_ = new BufferedInputStream(_input_);
        _output_ = new BufferedOutputStream(_output_);

        /* open TelnetOptionHandler functionality (start)*/
        for (int ii = 0; ii < TelnetOption.MAX_OPTION_VALUE + 1; ii++)
        {
            if (optionHandlers[ii] != null)
            {
                if (optionHandlers[ii].getInitLocal())
                {
                    requestWill(optionHandlers[ii].getOptionCode());
                }

                if (optionHandlers[ii].getInitRemote())
                {
                    requestDo(optionHandlers[ii].getOptionCode());
                }
            }
        }
        /* open TelnetOptionHandler functionality (end)*/
    }","  public void test90()  throws Throwable  {
      Telnet telnet0 = new Telnet(""~j+\""Ymp(.@t$A3|jo"");
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(228, (-3737), true, true, true, true);
      telnet0.addOptionHandler(windowSizeOptionHandler0);
      // Undeclared exception!
      try { 
        telnet0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2268,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test91()  throws Throwable  {
      Telnet telnet0 = new Telnet("",h"");
      telnet0.processAYTResponse();
}"
2269,"    final synchronized void _sendSubnegotiation(final int[] subn)
    throws IOException
    {
        if (debug)
        {
            System.err.println(""SEND SUBNEGOTIATION: "");
            if (subn != null)
            {
                System.err.println(Arrays.toString(subn));
            }
        }
        if (subn != null)
        {
            _output_.write(COMMAND_SB);
            // Note _output_ is buffered, so might as well simplify by writing single bytes
            for (final int element : subn)
            {
                final byte b = (byte) element;
                if (b == (byte) TelnetCommand.IAC) { // cast is necessary because IAC is outside the signed byte range
                    _output_.write(b); // double any IAC bytes
                }
                _output_.write(b);
            }
            _output_.write(COMMAND_SE);

            /* Code Section added for sending the negotiation ASAP (start)*/
            _output_.flush();
            /* Code Section added for sending the negotiation ASAP (end)*/
        }
    }","  public void test92()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      int[] intArray0 = new int[6];
      // Undeclared exception!
      try { 
        telnet0._sendSubnegotiation(intArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2270,"    final synchronized void sendTerminalType()
    throws IOException
    {
        if (debug)
        {
            System.err.println(""SEND TERMINAL-TYPE: "" + terminalType);
        }
        if (terminalType != null)
        {
            _output_.write(COMMAND_SB);
            _output_.write(COMMAND_IS);
            _output_.write(terminalType.getBytes(getCharset()));
            _output_.write(COMMAND_SE);
            _output_.flush();
        }
    }","  public void test93()  throws Throwable  {
      Telnet telnet0 = new Telnet(""Error registering option: "");
      // Undeclared exception!
      try { 
        telnet0.sendTerminalType();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2271,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test94()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.sendTerminalType();
}"
2272,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test95()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      int[] intArray0 = new int[3];
      intArray0[0] = 24;
      telnet0.processSuboption(intArray0, 24);
}"
2273,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test96()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      int[] intArray0 = new int[16];
      telnet0.processSuboption(intArray0, 1);
}"
2274,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test97()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      int[] intArray0 = new int[3];
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(44, true, true, true, true);
      telnet0.addOptionHandler(simpleOptionHandler0);
      intArray0[0] = 44;
      telnet0.processSuboption(intArray0, 44);
}"
2275,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test98()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      int[] intArray0 = new int[3];
      telnet0.processSuboption(intArray0, 24);
}"
2276,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test99()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      int[] intArray0 = new int[3];
      telnet0.processSuboption(intArray0, (-9));
}"
2277,"    void processWont(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED WONT: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_WONT,
                option);
        }

        if (doResponse[option] > 0)
        {
            --doResponse[option];
            if (doResponse[option] > 0 && stateIsDont(option))
            {
                --doResponse[option];
            }
        }

        if (doResponse[option] == 0 && requestedDo(option))
        {

            switch (option)
            {

            default:
                break;

            }

            /* FIX for a BUG in the negotiation (start)*/
            if (stateIsDo(option) || requestedDo(option))
            {
                sendDont(option);
            }

            setWantDont(option);
            /* FIX for a BUG in the negotiation (end)*/
        }

        setDont(option);
    }","  public void test100()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDo(21);
      telnet0.setDo(21);
      // Undeclared exception!
      try { 
        telnet0.processWont(21);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2278,"    void processWont(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED WONT: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_WONT,
                option);
        }

        if (doResponse[option] > 0)
        {
            --doResponse[option];
            if (doResponse[option] > 0 && stateIsDont(option))
            {
                --doResponse[option];
            }
        }

        if (doResponse[option] == 0 && requestedDo(option))
        {

            switch (option)
            {

            default:
                break;

            }

            /* FIX for a BUG in the negotiation (start)*/
            if (stateIsDo(option) || requestedDo(option))
            {
                sendDont(option);
            }

            setWantDont(option);
            /* FIX for a BUG in the negotiation (end)*/
        }

        setDont(option);
    }","  public void test101()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDo(21);
      // Undeclared exception!
      try { 
        telnet0.processWont(21);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2279,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test102()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnet0.registerNotifHandler(telnetClientExample0);
      telnet0.processWont(24);
}"
2280,"    void processWill(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED WILL: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_WILL,
                option);
        }

        boolean acceptNewState = false;

        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptRemote();
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (doResponse[option] > 0)
        {
            --doResponse[option];
            if (doResponse[option] > 0 && stateIsDo(option))
            {
                --doResponse[option];
            }
        }

        if (doResponse[option] == 0 && requestedDont(option))
        {

            switch (option)
            {

            default:
                break;

            }


            if (acceptNewState)
            {
                setWantDo(option);
                sendDo(option);
            }
            else
            {
                ++doResponse[option];
                sendDont(option);
            }
        }

        setDo(option);
    }","  public void test103()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(3);
      simpleOptionHandler0.setAcceptRemote(true);
      telnet0.addOptionHandler(simpleOptionHandler0);
      // Undeclared exception!
      try { 
        telnet0.processWill(3);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2281,"    void processWill(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED WILL: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_WILL,
                option);
        }

        boolean acceptNewState = false;

        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptRemote();
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (doResponse[option] > 0)
        {
            --doResponse[option];
            if (doResponse[option] > 0 && stateIsDo(option))
            {
                --doResponse[option];
            }
        }

        if (doResponse[option] == 0 && requestedDont(option))
        {

            switch (option)
            {

            default:
                break;

            }


            if (acceptNewState)
            {
                setWantDo(option);
                sendDo(option);
            }
            else
            {
                ++doResponse[option];
                sendDont(option);
            }
        }

        setDo(option);
    }","  public void test104()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(3);
      telnet0.addOptionHandler(simpleOptionHandler0);
      // Undeclared exception!
      try { 
        telnet0.processWill(3);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2282,"    void processWill(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED WILL: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_WILL,
                option);
        }

        boolean acceptNewState = false;

        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptRemote();
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (doResponse[option] > 0)
        {
            --doResponse[option];
            if (doResponse[option] > 0 && stateIsDo(option))
            {
                --doResponse[option];
            }
        }

        if (doResponse[option] == 0 && requestedDont(option))
        {

            switch (option)
            {

            default:
                break;

            }


            if (acceptNewState)
            {
                setWantDo(option);
                sendDo(option);
            }
            else
            {
                ++doResponse[option];
                sendDont(option);
            }
        }

        setDo(option);
    }","  public void test105()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnet0.registerNotifHandler(telnetClientExample0);
      // Undeclared exception!
      try { 
        telnet0.processWill(241);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2283,"    void processDont(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED DONT: ""
                + TelnetOption.getOption(option));
        }
        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_DONT,
                option);
        }
        if (willResponse[option] > 0)
        {
            --willResponse[option];
            if (willResponse[option] > 0 && stateIsWont(option))
            {
                --willResponse[option];
            }
        }

        if (willResponse[option] == 0 && requestedWill(option))
        {

            switch (option)
            {

            default:
                break;

            }

            /* FIX for a BUG in the negotiation (start)*/
            if (stateIsWill(option) || requestedWill(option))
            {
                sendWont(option);
            }

            setWantWont(option);
            /* FIX for a BUG in the negotiation (end)*/
        }

        setWont(option);
    }","  public void test106()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantWill(249);
      telnet0.processDo(249);
      // Undeclared exception!
      try { 
        telnet0.processDont(249);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2284,"    void processDont(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED DONT: ""
                + TelnetOption.getOption(option));
        }
        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_DONT,
                option);
        }
        if (willResponse[option] > 0)
        {
            --willResponse[option];
            if (willResponse[option] > 0 && stateIsWont(option))
            {
                --willResponse[option];
            }
        }

        if (willResponse[option] == 0 && requestedWill(option))
        {

            switch (option)
            {

            default:
                break;

            }

            /* FIX for a BUG in the negotiation (start)*/
            if (stateIsWill(option) || requestedWill(option))
            {
                sendWont(option);
            }

            setWantWont(option);
            /* FIX for a BUG in the negotiation (end)*/
        }

        setWont(option);
    }","  public void test107()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantWill(249);
      // Undeclared exception!
      try { 
        telnet0.processDont(249);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2285,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test108()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnet0.registerNotifHandler(telnetClientExample0);
      telnet0.processDont(247);
}"
2286,"    void processDo(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED DO: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_DO,
                option);
        }

        boolean acceptNewState = false;


        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptLocal();
        }
        else
        {
        /* open TelnetOptionHandler functionality (end)*/
            /* TERMINAL-TYPE option (start)*/
            if (option == TERMINAL_TYPE)
            {
                if (terminalType != null && !terminalType.isEmpty())
                {
                    acceptNewState = true;
                }
            }
            /* TERMINAL-TYPE option (end)*/
        /* open TelnetOptionHandler functionality (start)*/
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (willResponse[option] > 0)
        {
            --willResponse[option];
            if (willResponse[option] > 0 && stateIsWill(option))
            {
                --willResponse[option];
            }
        }

        if (willResponse[option] == 0)
        {
            if (requestedWont(option))
            {

                switch (option)
                {

                default:
                    break;

                }


                if (acceptNewState)
                {
                    setWantWill(option);
                    sendWill(option);
                }
                else
                {
                    ++willResponse[option];
                    sendWont(option);
                }
            }
            else
            {
                // Other end has acknowledged option.

                switch (option)
                {

                default:
                    break;

                }

            }
        }

        setWill(option);
    }","  public void test109()  throws Throwable  {
      Telnet telnet0 = new Telnet("""");
      // Undeclared exception!
      try { 
        telnet0.processDo(24);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2287,"    void processDo(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED DO: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_DO,
                option);
        }

        boolean acceptNewState = false;


        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptLocal();
        }
        else
        {
        /* open TelnetOptionHandler functionality (end)*/
            /* TERMINAL-TYPE option (start)*/
            if (option == TERMINAL_TYPE)
            {
                if (terminalType != null && !terminalType.isEmpty())
                {
                    acceptNewState = true;
                }
            }
            /* TERMINAL-TYPE option (end)*/
        /* open TelnetOptionHandler functionality (start)*/
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (willResponse[option] > 0)
        {
            --willResponse[option];
            if (willResponse[option] > 0 && stateIsWill(option))
            {
                --willResponse[option];
            }
        }

        if (willResponse[option] == 0)
        {
            if (requestedWont(option))
            {

                switch (option)
                {

                default:
                    break;

                }


                if (acceptNewState)
                {
                    setWantWill(option);
                    sendWill(option);
                }
                else
                {
                    ++willResponse[option];
                    sendWont(option);
                }
            }
            else
            {
                // Other end has acknowledged option.

                switch (option)
                {

                default:
                    break;

                }

            }
        }

        setWill(option);
    }","  public void test110()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      TerminalTypeOptionHandler terminalTypeOptionHandler0 = new TerminalTypeOptionHandler(""\r\n"");
      telnet0.addOptionHandler(terminalTypeOptionHandler0);
      // Undeclared exception!
      try { 
        telnet0.processDo(24);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2288,"    void processDo(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED DO: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_DO,
                option);
        }

        boolean acceptNewState = false;


        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptLocal();
        }
        else
        {
        /* open TelnetOptionHandler functionality (end)*/
            /* TERMINAL-TYPE option (start)*/
            if (option == TERMINAL_TYPE)
            {
                if (terminalType != null && !terminalType.isEmpty())
                {
                    acceptNewState = true;
                }
            }
            /* TERMINAL-TYPE option (end)*/
        /* open TelnetOptionHandler functionality (start)*/
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (willResponse[option] > 0)
        {
            --willResponse[option];
            if (willResponse[option] > 0 && stateIsWill(option))
            {
                --willResponse[option];
            }
        }

        if (willResponse[option] == 0)
        {
            if (requestedWont(option))
            {

                switch (option)
                {

                default:
                    break;

                }


                if (acceptNewState)
                {
                    setWantWill(option);
                    sendWill(option);
                }
                else
                {
                    ++willResponse[option];
                    sendWont(option);
                }
            }
            else
            {
                // Other end has acknowledged option.

                switch (option)
                {

                default:
                    break;

                }

            }
        }

        setWill(option);
    }","  public void test111()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnet0.registerNotifHandler(telnetClientExample0);
      // Undeclared exception!
      try { 
        telnet0.processDo(24);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2289,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test112()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.processCommand(244);
}"
2290,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test113()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(44, true, true, true, true);
      telnet0.addOptionHandler(simpleOptionHandler0);
      telnet0.processWont(44);
}"
2291,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test114()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(44, true, true, true, true);
      telnet0.addOptionHandler(simpleOptionHandler0);
      telnet0.setWont(44);
}"
2292,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test115()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setDo(249);
      telnet0.requestDont(249);
}"
2293,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test116()  throws Throwable  {
      Telnet telnet0 = new Telnet(""lq*"");
      telnet0.spyWrite(2083);
}"
2294,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test117()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.requestWont(232);
}"
2295,"    final synchronized void requestWill(final int option)
    throws IOException
    {
        if (willResponse[option] == 0 && stateIsWill(option)
            || requestedWill(option))
        {
            return ;
        }
        setWantWill(option);
        ++doResponse[option];
        sendWill(option);
    }","  public void test118()  throws Throwable  {
      Telnet telnet0 = new Telnet(""org.apache.commons.net.telet.SuppressGAOptionHandqer"");
      // Undeclared exception!
      try { 
        telnet0.requestWill(161);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2296,"    final synchronized void sendByte(final int b)
    throws IOException
    {
        _output_.write(b);

        /* Code Section added for supporting spystreams (start)*/
        spyWrite(b);
        /* Code Section added for supporting spystreams (end)*/

    }","  public void test119()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0.sendByte(232);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2297,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test120()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.unregisterNotifHandler();
}"
2298,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test121()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      MockFile mockFile0 = new MockFile(""\r\n"", """");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
      telnet0._registerSpyStream(mockFileOutputStream0);
      telnet0.spyWrite(2083);
}"
2299,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test122()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnet0.registerNotifHandler(telnetClientExample0);
      telnet0.processCommand(241);
}"
2300,"    final synchronized void requestWont(final int option)
    throws IOException
    {
        if (willResponse[option] == 0 && stateIsWont(option)
            || requestedWont(option))
        {
            return ;
        }
        setWantWont(option);
        ++doResponse[option];
        sendWont(option);
    }","  public void test123()  throws Throwable  {
      Telnet telnet0 = new Telnet(""P`IUVtzO#yJ"");
      telnet0.setWill(50);
      telnet0.setWantWill(50);
      // Undeclared exception!
      try { 
        telnet0.requestWont(50);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2301,"    void processDo(final int option) throws IOException
    {
        if (debugoptions)
        {
            System.err.println(""RECEIVED DO: ""
                + TelnetOption.getOption(option));
        }

        if (notifhand != null)
        {
            notifhand.receivedNegotiation(
                TelnetNotificationHandler.RECEIVED_DO,
                option);
        }

        boolean acceptNewState = false;


        /* open TelnetOptionHandler functionality (start)*/
        if (optionHandlers[option] != null)
        {
            acceptNewState = optionHandlers[option].getAcceptLocal();
        }
        else
        {
        /* open TelnetOptionHandler functionality (end)*/
            /* TERMINAL-TYPE option (start)*/
            if (option == TERMINAL_TYPE)
            {
                if (terminalType != null && !terminalType.isEmpty())
                {
                    acceptNewState = true;
                }
            }
            /* TERMINAL-TYPE option (end)*/
        /* open TelnetOptionHandler functionality (start)*/
        }
        /* open TelnetOptionHandler functionality (end)*/

        if (willResponse[option] > 0)
        {
            --willResponse[option];
            if (willResponse[option] > 0 && stateIsWill(option))
            {
                --willResponse[option];
            }
        }

        if (willResponse[option] == 0)
        {
            if (requestedWont(option))
            {

                switch (option)
                {

                default:
                    break;

                }


                if (acceptNewState)
                {
                    setWantWill(option);
                    sendWill(option);
                }
                else
                {
                    ++willResponse[option];
                    sendWont(option);
                }
            }
            else
            {
                // Other end has acknowledged option.

                switch (option)
                {

                default:
                    break;

                }

            }
        }

        setWill(option);
    }","  public void test124()  throws Throwable  {
      Telnet telnet0 = new Telnet(""oRnyI"");
      // Undeclared exception!
      try { 
        telnet0.processDo(24);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2302,"    final synchronized void sendDo(final int option)
    throws IOException
    {
        if (debug || debugoptions)
        {
            System.err.println(""DO: "" + TelnetOption.getOption(option));
        }
        _output_.write(COMMAND_DO);
        _output_.write(option);

        /* Code Section added for sending the negotiation ASAP (start)*/
        _output_.flush();
        /* Code Section added for sending the negotiation ASAP (end)*/
    }","  public void test125()  throws Throwable  {
      Telnet telnet0 = new Telnet(""$Z@fH (.J"");
      // Undeclared exception!
      try { 
        telnet0.sendDo((-320));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2303,"    final synchronized void requestDont(final int option)
    throws IOException
    {
        if (doResponse[option] == 0 && stateIsDont(option)
            || requestedDont(option))
        {
            return ;
        }
        setWantDont(option);
        ++doResponse[option];
        sendDont(option);
    }","  public void test126()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0.setWantDo(236);
      telnet0.processWill(236);
      // Undeclared exception!
      try { 
        telnet0.requestDont(236);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2304,"    final synchronized void _sendCommand(final byte cmd) throws IOException
    {
            _output_.write(TelnetCommand.IAC);
            _output_.write(cmd);
            _output_.flush();
    }","  public void test127()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      // Undeclared exception!
      try { 
        telnet0._sendCommand((byte) (-69));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2305,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test128()  throws Throwable  {
      Telnet telnet0 = new Telnet();
      telnet0._stopSpyStream();
}"
2306,"    public SimpleOptionHandler(final int optcode,
                                final boolean initlocal,
                                final boolean initremote,
                                final boolean acceptlocal,
                                final boolean acceptremote)
    {
        super(optcode, initlocal, initremote,
                                      acceptlocal, acceptremote);
    }","  public void test0()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(1813);
}"
2307,"    public SimpleOptionHandler(final int optcode,
                                final boolean initlocal,
                                final boolean initremote,
                                final boolean acceptlocal,
                                final boolean acceptremote)
    {
        super(optcode, initlocal, initremote,
                                      acceptlocal, acceptremote);
    }","  public void test1()  throws Throwable  {
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(1813, false, false, true, false);
}"
2308,"    public static boolean isValidCommand(final int code)
    {
        return code <= FIRST_COMMAND && code >= LAST_COMMAND;
    }","  public void test0()  throws Throwable  {
      boolean boolean0 = TelnetCommand.isValidCommand(236);
}"
2309,"    public static String getCommand(final int code)
    {
        return commandString[FIRST_COMMAND - code];
    }","  public void test1()  throws Throwable  {
      String string0 = TelnetCommand.getCommand(251);
}"
2310,"    public static boolean isValidCommand(final int code)
    {
        return code <= FIRST_COMMAND && code >= LAST_COMMAND;
    }","  public void test2()  throws Throwable  {
      boolean boolean0 = TelnetCommand.isValidCommand(0);
}"
2311,"    public static boolean isValidCommand(final int code)
    {
        return code <= FIRST_COMMAND && code >= LAST_COMMAND;
    }","  public void test3()  throws Throwable  {
      boolean boolean0 = TelnetCommand.isValidCommand(255);
}"
2312,"    public static boolean isValidCommand(final int code)
    {
        return code <= FIRST_COMMAND && code >= LAST_COMMAND;
    }","  public void test4()  throws Throwable  {
      boolean boolean0 = TelnetCommand.isValidCommand(1501);
}"
2313,"    public static String getCommand(final int code)
    {
        return commandString[FIRST_COMMAND - code];
    }","  public void test5()  throws Throwable  {
      // Undeclared exception!
      try { 
        TelnetCommand.getCommand(1501);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1246
         //
         verifyException(""org.apache.commons.net.telnet.TelnetCommand"", e);
      }
  }"
2314,"    public String getMessage()
    {
        return msg + "": "" + optionCode;
    }","  public void test0()  throws Throwable  {
      InvalidTelnetOptionException invalidTelnetOptionException0 = new InvalidTelnetOptionException("""", 809);
      String string0 = invalidTelnetOptionException0.getMessage();
}"
2315,"    public int[] startSubnegotiationLocal()
    {
        final int nCompoundWindowSize = width * 0x10000 + height;
        int nResponseSize = 5;
        int nIndex;
        int nShift;
        int nTurnedOnBits;

        if (width % 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (width / 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (height % 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (height / 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        //
        // allocate response array
        //
        final int response[] = new int[nResponseSize];

        //
        // Build response array.
        // ---------------------
        // 1. put option name.
        // 2. loop through Window size and fill the values,
        // 3.    duplicate 'ff' if needed.
        //

        response[0] = WINDOW_SIZE;                          // 1 //

        for (                                               // 2 //
            nIndex=1, nShift = 24;
            nIndex < nResponseSize;
            nIndex++, nShift -=8
        ) {
            nTurnedOnBits = 0xFF;
            nTurnedOnBits <<= nShift;
            response[nIndex] = (nCompoundWindowSize & nTurnedOnBits) >>> nShift;

            if (response[nIndex] == 0xff) {                 // 3 //
                nIndex++;
                response[nIndex] = 0xff;
            }
        }

        return response;
    }","  public void test0()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(65536, 65536, false, false, true, false);
      int[] intArray0 = windowSizeOptionHandler0.startSubnegotiationLocal();
}"
2316,"    public int[] startSubnegotiationLocal()
    {
        final int nCompoundWindowSize = width * 0x10000 + height;
        int nResponseSize = 5;
        int nIndex;
        int nShift;
        int nTurnedOnBits;

        if (width % 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (width / 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (height % 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (height / 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        //
        // allocate response array
        //
        final int response[] = new int[nResponseSize];

        //
        // Build response array.
        // ---------------------
        // 1. put option name.
        // 2. loop through Window size and fill the values,
        // 3.    duplicate 'ff' if needed.
        //

        response[0] = WINDOW_SIZE;                          // 1 //

        for (                                               // 2 //
            nIndex=1, nShift = 24;
            nIndex < nResponseSize;
            nIndex++, nShift -=8
        ) {
            nTurnedOnBits = 0xFF;
            nTurnedOnBits <<= nShift;
            response[nIndex] = (nCompoundWindowSize & nTurnedOnBits) >>> nShift;

            if (response[nIndex] == 0xff) {                 // 3 //
                nIndex++;
                response[nIndex] = 0xff;
            }
        }

        return response;
    }","  public void test1()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(65511, 65511, true, false, false, false);
      int[] intArray0 = windowSizeOptionHandler0.startSubnegotiationLocal();
}"
2317,"    public int[] startSubnegotiationLocal()
    {
        final int nCompoundWindowSize = width * 0x10000 + height;
        int nResponseSize = 5;
        int nIndex;
        int nShift;
        int nTurnedOnBits;

        if (width % 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (width / 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (height % 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (height / 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        //
        // allocate response array
        //
        final int response[] = new int[nResponseSize];

        //
        // Build response array.
        // ---------------------
        // 1. put option name.
        // 2. loop through Window size and fill the values,
        // 3.    duplicate 'ff' if needed.
        //

        response[0] = WINDOW_SIZE;                          // 1 //

        for (                                               // 2 //
            nIndex=1, nShift = 24;
            nIndex < nResponseSize;
            nIndex++, nShift -=8
        ) {
            nTurnedOnBits = 0xFF;
            nTurnedOnBits <<= nShift;
            response[nIndex] = (nCompoundWindowSize & nTurnedOnBits) >>> nShift;

            if (response[nIndex] == 0xff) {                 // 3 //
                nIndex++;
                response[nIndex] = 0xff;
            }
        }

        return response;
    }","  public void test2()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler(255, 255);
      int[] intArray0 = windowSizeOptionHandler0.startSubnegotiationLocal();
}"
2318,"    public int[] startSubnegotiationLocal()
    {
        final int nCompoundWindowSize = width * 0x10000 + height;
        int nResponseSize = 5;
        int nIndex;
        int nShift;
        int nTurnedOnBits;

        if (width % 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (width / 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (height % 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        if (height / 0x100 == 0xFF) {
            nResponseSize += 1;
        }

        //
        // allocate response array
        //
        final int response[] = new int[nResponseSize];

        //
        // Build response array.
        // ---------------------
        // 1. put option name.
        // 2. loop through Window size and fill the values,
        // 3.    duplicate 'ff' if needed.
        //

        response[0] = WINDOW_SIZE;                          // 1 //

        for (                                               // 2 //
            nIndex=1, nShift = 24;
            nIndex < nResponseSize;
            nIndex++, nShift -=8
        ) {
            nTurnedOnBits = 0xFF;
            nTurnedOnBits <<= nShift;
            response[nIndex] = (nCompoundWindowSize & nTurnedOnBits) >>> nShift;

            if (response[nIndex] == 0xff) {                 // 3 //
                nIndex++;
                response[nIndex] = 0xff;
            }
        }

        return response;
    }","  public void test3()  throws Throwable  {
      WindowSizeOptionHandler windowSizeOptionHandler0 = new WindowSizeOptionHandler((-1), (-1));
      // Undeclared exception!
      try { 
        windowSizeOptionHandler0.startSubnegotiationLocal();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 5
         //
         verifyException(""org.apache.commons.net.telnet.WindowSizeOptionHandler"", e);
      }
  }"
2319,"    public static final boolean isValidOption(final int code)
    {
        return code <= LAST_OPTION;
    }","  public void test0()  throws Throwable  {
      boolean boolean0 = TelnetOption.isValidOption(255);
}"
2320,"    public static final String getOption(final int code)
    {
        if(optionString[code].isEmpty())
        {
            return ""UNASSIGNED"";
        }
        return optionString[code];
    }","  public void test1()  throws Throwable  {
      String string0 = TelnetOption.getOption(7);
}"
2321,"    public static final String getOption(final int code)
    {
        if(optionString[code].isEmpty())
        {
            return ""UNASSIGNED"";
        }
        return optionString[code];
    }","  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        TelnetOption.getOption(825);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 825
         //
         verifyException(""org.apache.commons.net.telnet.TelnetOption"", e);
      }
  }"
2322,"    public static final boolean isValidOption(final int code)
    {
        return code <= LAST_OPTION;
    }","  public void test3()  throws Throwable  {
      boolean boolean0 = TelnetOption.isValidOption(2);
}"
2323,"    public static final boolean isValidOption(final int code)
    {
        return code <= LAST_OPTION;
    }","  public void test4()  throws Throwable  {
      boolean boolean0 = TelnetOption.isValidOption(1953);
}"
2324,"    public static final String getOption(final int code)
    {
        if(optionString[code].isEmpty())
        {
            return ""UNASSIGNED"";
        }
        return optionString[code];
    }","  public void test5()  throws Throwable  {
      String string0 = TelnetOption.getOption(203);
}"
2325,"    public static final String getOption(final int code)
    {
        if(optionString[code].isEmpty())
        {
            return ""UNASSIGNED"";
        }
        return optionString[code];
    }","  public void test6()  throws Throwable  {
      String string0 = TelnetOption.getOption(2);
}"
2326,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test0()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      byte[] byteArray0 = new byte[1];
      telnetOutputStream0.write(byteArray0, (int) (byte) (-91), (-449));
}"
2327,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test1()  throws Throwable  {
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream((TelnetClient) null);
      // Undeclared exception!
      try { 
        telnetOutputStream0.write((byte[]) null, 240, 240);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetOutputStream"", e);
      }
  }"
2328,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test2()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      byte[] byteArray0 = new byte[8];
      // Undeclared exception!
      try { 
        telnetOutputStream0.write(byteArray0, 8, 31);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 8
         //
         verifyException(""org.apache.commons.net.telnet.TelnetOutputStream"", e);
      }
  }"
2329,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test3()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      // Undeclared exception!
      try { 
        telnetOutputStream0.write((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetOutputStream"", e);
      }
  }"
2330,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test4()  throws Throwable  {
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream((TelnetClient) null);
      // Undeclared exception!
      try { 
        telnetOutputStream0.write(255);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetOutputStream"", e);
      }
  }"
2331,"    public void flush() throws IOException
    {
        client.flushOutputStream();
    }","  public void test5()  throws Throwable  {
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream((TelnetClient) null);
      // Undeclared exception!
      try { 
        telnetOutputStream0.flush();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetOutputStream"", e);
      }
  }"
2332,"    public void close() throws IOException
    {
        client.closeOutputStream();
    }","  public void test6()  throws Throwable  {
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream((TelnetClient) null);
      // Undeclared exception!
      try { 
        telnetOutputStream0.close();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.TelnetOutputStream"", e);
      }
  }"
2333,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test7()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(""~q>oW$i{/hct\""Iw*3d"");
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      byte[] byteArray0 = new byte[3];
      // Undeclared exception!
      try { 
        telnetOutputStream0.write(byteArray0, 0, 24);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2334,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test8()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      byte[] byteArray0 = new byte[0];
      telnetOutputStream0.write(byteArray0, 0, 0);
}"
2335,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test9()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient((-147));
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      // Undeclared exception!
      try { 
        telnetOutputStream0.write((-1915));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2336,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test10()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient((String) null, 817);
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      byte[] byteArray0 = new byte[0];
      telnetOutputStream0.write(byteArray0);
}"
2337,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test11()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient((-1));
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      // Undeclared exception!
      try { 
        telnetOutputStream0.write((-1));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2338,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test12()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      // Undeclared exception!
      try { 
        telnetOutputStream0.write(13);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2339,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test13()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      // Undeclared exception!
      try { 
        telnetOutputStream0.write(10);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2340,"    public void write(int ch) throws IOException
    {

        synchronized (client)
        {
            ch &= 0xff;

            if (client.requestedWont(TelnetOption.BINARY)) // i.e. ASCII
            {
                if (lastWasCR)
                {
                    if (convertCRtoCRLF)
                    {
                        client.sendByte('\n');
                        if (ch == '\n') // i.e. was CRLF anyway
                        {
                            lastWasCR = false;
                            return ;
                        }
                    } // __convertCRtoCRLF
                    else if (ch != '\n')
                     {
                        client.sendByte('\0'); // RFC854 requires CR NUL for bare CR
                    }
                }

                switch (ch)
                {
                case '\r':
                    client.sendByte('\r');
                    lastWasCR = true;
                    break;
                case '\n':
                    if (!lastWasCR) { // convert LF to CRLF
                        client.sendByte('\r');
                    }
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                case TelnetCommand.IAC:
                    client.sendByte(TelnetCommand.IAC);
                    client.sendByte(TelnetCommand.IAC);
                    lastWasCR = false;
                    break;
                default:
                    client.sendByte(ch);
                    lastWasCR = false;
                    break;
                }
            } // end ASCII
            else if (ch == TelnetCommand.IAC)
            {
                client.sendByte(ch);
                client.sendByte(TelnetCommand.IAC);
            } else {
                client.sendByte(ch);
            }
        }
    }","  public void test14()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(3663);
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      byte[] byteArray0 = new byte[4];
      // Undeclared exception!
      try { 
        telnetOutputStream0.write(byteArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2341,"    public void close() throws IOException
    {
        client.closeOutputStream();
    }","  public void test15()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      telnetOutputStream0.close();
  }"
2342,"    public void flush() throws IOException
    {
        client.flushOutputStream();
    }","  public void test16()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(""5kZJej?#%dOs)e"", 0);
      TelnetOutputStream telnetOutputStream0 = new TelnetOutputStream(telnetClient0);
      try { 
        telnetOutputStream0.flush();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""org.apache.commons.net.telnet.TelnetClient"", e);
      }
  }"
2343,"    public EchoOptionHandler(final boolean initlocal, final boolean initremote,
                                final boolean acceptlocal, final boolean acceptremote)
    {
        super(TelnetOption.ECHO, initlocal, initremote,
                                      acceptlocal, acceptremote);
    }","  public void test0()  throws Throwable  {
      EchoOptionHandler echoOptionHandler0 = new EchoOptionHandler(false, false, false, true);
}"
2344,"    public EchoOptionHandler(final boolean initlocal, final boolean initremote,
                                final boolean acceptlocal, final boolean acceptremote)
    {
        super(TelnetOption.ECHO, initlocal, initremote,
                                      acceptlocal, acceptremote);
    }","  public void test1()  throws Throwable  {
      EchoOptionHandler echoOptionHandler0 = new EchoOptionHandler();
}"
2345,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test0()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.setDo(70);
      boolean boolean0 = telnetClient0.getRemoteOptionState(70);
}"
2346,"    public boolean getRemoteOptionState(final int option)
    {
        /* BUG (option active when not already acknowledged) (start)*/
        return stateIsDo(option) && requestedDo(option);
        /* BUG (option active when not already acknowledged) (end)*/
    }","  public void test1()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.setDo(70);
      boolean boolean0 = telnetClient0.getRemoteOptionState(70);
}"
2347,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test2()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient("""");
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(81);
      telnetClient0.addOptionHandler(simpleOptionHandler0);
      telnetClient0.deleteOptionHandler(81);
}"
2348,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test3()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
}"
2349,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test4()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.setReaderThread(false);
      boolean boolean0 = telnetClient0.getReaderThread();
}"
2350,"    public boolean getRemoteOptionState(final int option)
    {
        /* BUG (option active when not already acknowledged) (start)*/
        return stateIsDo(option) && requestedDo(option);
        /* BUG (option active when not already acknowledged) (end)*/
    }","  public void test5()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient((-1397));
      // Undeclared exception!
      try { 
        telnetClient0.getRemoteOptionState((-1397));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1397
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2351,"    public boolean getLocalOptionState(final int option)
    {
        /* BUG (option active when not already acknowledged) (start)*/
        return stateIsWill(option) && requestedWill(option);
        /* BUG (option active when not already acknowledged) (end)*/
    }","  public void test6()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(2635);
      // Undeclared exception!
      try { 
        telnetClient0.getLocalOptionState(2635);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2635
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2352,"    public void deleteOptionHandler(final int optcode)
    throws InvalidTelnetOptionException, IOException
    {
        super.deleteOptionHandler(optcode);
    }","  public void test7()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      // Undeclared exception!
      try { 
        telnetClient0.deleteOptionHandler((-1));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2353,"    public void addOptionHandler(final TelnetOptionHandler opthand)
    throws InvalidTelnetOptionException, IOException
    {
        super.addOptionHandler(opthand);
    }","  public void test8()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(""j YK'Fk3+%\""D7@' "");
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler(1438);
      try { 
        telnetClient0.addOptionHandler(simpleOptionHandler0);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Invalid Option Code: 1438
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2354,"    public void addOptionHandler(final TelnetOptionHandler opthand)
    throws InvalidTelnetOptionException, IOException
    {
        super.addOptionHandler(opthand);
    }","  public void test9()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(""~H_.b"", 0);
      // Undeclared exception!
      try { 
        telnetClient0.addOptionHandler((TelnetOptionHandler) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2355,"    public void addOptionHandler(final TelnetOptionHandler opthand)
    throws InvalidTelnetOptionException, IOException
    {
        super.addOptionHandler(opthand);
    }","  public void test10()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(""V_sU17TrlY~?)K(1"");
      SimpleOptionHandler simpleOptionHandler0 = new SimpleOptionHandler((-1));
      // Undeclared exception!
      try { 
        telnetClient0.addOptionHandler(simpleOptionHandler0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2356,"    protected void _connectAction_() throws IOException
    {
        super._connectAction_();
        final TelnetInputStream tmp = new TelnetInputStream(_input_, this, readerThread);
        if(readerThread)
        {
            tmp.start();
        }
        // __input CANNOT refer to the TelnetInputStream.  We run into
        // blocking problems when some classes use TelnetInputStream, so
        // we wrap it with a BufferedInputStream which we know is safe.
        // This blocking behavior requires further investigation, but right
        // now it looks like classes like InputStreamReader are not implemented
        // in a safe manner.
        input = new BufferedInputStream(tmp);
        output = new TelnetOutputStream(this);
    }","  public void test11()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(""5NVDqH&2l\"",8l-"");
      // Undeclared exception!
      try { 
        telnetClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2357,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test12()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetInputListener telnetInputListener0 = mock(TelnetInputListener.class, new ViolatedAssumptionAnswer());
      telnetClient0.registerInputListener(telnetInputListener0);
      telnetClient0.notifyInputListener();
}"
2358,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test13()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(0);
      telnetClient0.notifyInputListener();
}"
2359,"    public void sendSubnegotiation(final int[] message)
    throws IOException, IllegalArgumentException
    {
        if (message.length < 1) {
            throw new IllegalArgumentException(""zero length message"");
        }
        _sendSubnegotiation(message);
    }","  public void test14()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      int[] intArray0 = new int[0];
      try { 
        telnetClient0.sendSubnegotiation(intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // zero length message
         //
         verifyException(""org.apache.commons.net.telnet.TelnetClient"", e);
      }
  }"
2360,"    public void sendSubnegotiation(final int[] message)
    throws IOException, IllegalArgumentException
    {
        if (message.length < 1) {
            throw new IllegalArgumentException(""zero length message"");
        }
        _sendSubnegotiation(message);
    }","  public void test15()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(243);
      int[] intArray0 = new int[9];
      // Undeclared exception!
      try { 
        telnetClient0.sendSubnegotiation(intArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2361,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test16()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      boolean boolean0 = telnetClient0.getRemoteOptionState(0);
}"
2362,"    public boolean getRemoteOptionState(final int option)
    {
        /* BUG (option active when not already acknowledged) (start)*/
        return stateIsDo(option) && requestedDo(option);
        /* BUG (option active when not already acknowledged) (end)*/
    }","  public void test17()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      boolean boolean0 = telnetClient0.getRemoteOptionState(0);
}"
2363,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test18()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.setWill(38);
      boolean boolean0 = telnetClient0.getLocalOptionState(38);
}"
2364,"    public boolean getLocalOptionState(final int option)
    {
        /* BUG (option active when not already acknowledged) (start)*/
        return stateIsWill(option) && requestedWill(option);
        /* BUG (option active when not already acknowledged) (end)*/
    }","  public void test19()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.setWill(38);
      boolean boolean0 = telnetClient0.getLocalOptionState(38);
}"
2365,"    public boolean getLocalOptionState(final int option)
    {
        /* BUG (option active when not already acknowledged) (start)*/
        return stateIsWill(option) && requestedWill(option);
        /* BUG (option active when not already acknowledged) (end)*/
    }","  public void test20()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      boolean boolean0 = telnetClient0.getLocalOptionState(3);
}"
2366,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test21()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      boolean boolean0 = telnetClient0.getLocalOptionState(3);
}"
2367,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test22()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.disconnect();
}"
2368,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test23()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.closeOutputStream();
}"
2369,"    void flushOutputStream() throws IOException
    {
        if (_output_ == null) {
            throw new IOException(""Stream closed"");
        }
        _output_.flush();
    }","  public void test24()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      try { 
        telnetClient0.flushOutputStream();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""org.apache.commons.net.telnet.TelnetClient"", e);
      }
  }"
2370,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test25()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      TelnetClientExample telnetClientExample0 = new TelnetClientExample();
      telnetClient0.registerNotifHandler(telnetClientExample0);
}"
2371,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test26()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      boolean boolean0 = telnetClient0.getReaderThread();
}"
2372,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test27()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.setReaderThread(true);
}"
2373,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test28()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.getOutputStream();
}"
2374,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test29()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.unregisterNotifHandler();
}"
2375,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test30()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.unregisterInputListener();
}"
2376,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test31()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.getInputStream();
}"
2377,"    public boolean sendAYT(final long timeout)
    throws IOException, IllegalArgumentException, InterruptedException
    {
        return _sendAYT(timeout);
    }","  public void test32()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      // Undeclared exception!
      try { 
        telnetClient0.sendAYT(58);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2378,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test33()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.registerSpyStream((OutputStream) null);
}"
2379,"    public void deleteOptionHandler(final int optcode)
    throws InvalidTelnetOptionException, IOException
    {
        super.deleteOptionHandler(optcode);
    }","  public void test34()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(""org.apache.commons.io.filefilter.SizeFileFilter"");
      try { 
        telnetClient0.deleteOptionHandler(0);
        fail(""Expecting exception: Exception"");
      } catch(Exception e) {
         //
         // Unregistered option: 0
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2380,"    public boolean getReaderThread()
    {
        return readerThread;
    }","  public void test35()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient();
      telnetClient0.stopSpyStream();
}"
2381,"    public void sendCommand(final byte command)
    throws IOException, IllegalArgumentException
    {
        _sendCommand(command);
    }","  public void test36()  throws Throwable  {
      TelnetClient telnetClient0 = new TelnetClient(0);
      // Undeclared exception!
      try { 
        telnetClient0.sendCommand((byte) (-49));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.telnet.Telnet"", e);
      }
  }"
2382,"    public SuppressGAOptionHandler(final boolean initlocal, final boolean initremote,
                                final boolean acceptlocal, final boolean acceptremote)
    {
        super(TelnetOption.SUPPRESS_GO_AHEAD, initlocal, initremote,
                                      acceptlocal, acceptremote);
    }","  public void test0()  throws Throwable  {
      SuppressGAOptionHandler suppressGAOptionHandler0 = new SuppressGAOptionHandler();
}"
2383,"    public SuppressGAOptionHandler(final boolean initlocal, final boolean initremote,
                                final boolean acceptlocal, final boolean acceptremote)
    {
        super(TelnetOption.SUPPRESS_GO_AHEAD, initlocal, initremote,
                                      acceptlocal, acceptremote);
    }","  public void test1()  throws Throwable  {
      SuppressGAOptionHandler suppressGAOptionHandler0 = new SuppressGAOptionHandler(true, false, false, true);
}"
2384,"    public long getTime(final InetAddress host, final int port) throws IOException
    {
        long time;
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        time = 0L;
        time |= (((timeData[0] & 0xff) << 24) & 0xffffffffL);
        time |= (((timeData[1] & 0xff) << 16) & 0xffffffffL);
        time |= (((timeData[2] & 0xff) << 8) & 0xffffffffL);
        time |= ((timeData[3] & 0xff) & 0xffffffffL);

        return time;
    }","  public void test0()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 37);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, (byte[]) null);
      timeUDPClient0.open(0, (InetAddress) null);
      InetAddress inetAddress0 = timeUDPClient0.getLocalAddress();
      long long0 = timeUDPClient0.getTime(inetAddress0, 0);
}"
2385,"    public long getTime(final InetAddress host, final int port) throws IOException
    {
        long time;
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        time = 0L;
        time |= (((timeData[0] & 0xff) << 24) & 0xffffffffL);
        time |= (((timeData[1] & 0xff) << 16) & 0xffffffffL);
        time |= (((timeData[2] & 0xff) << 8) & 0xffffffffL);
        time |= ((timeData[3] & 0xff) & 0xffffffffL);

        return time;
    }","  public void test1()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 37);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, (byte[]) null);
      timeUDPClient0.open(0, (InetAddress) null);
      InetAddress inetAddress0 = timeUDPClient0.getLocalAddress();
      long long0 = timeUDPClient0.getTime(inetAddress0);
}"
2386,"    public Date getDate(final InetAddress host, final int port) throws IOException
    {
        return new Date((getTime(host, port) - SECONDS_1900_TO_1970)*1000L);
    }","  public void test2()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 37);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, (byte[]) null);
      timeUDPClient0.open(0, (InetAddress) null);
      InetAddress inetAddress0 = timeUDPClient0.getLocalAddress();
      Date date0 = timeUDPClient0.getDate(inetAddress0, 0);
}"
2387,"    public Date getDate(final InetAddress host, final int port) throws IOException
    {
        return new Date((getTime(host, port) - SECONDS_1900_TO_1970)*1000L);
    }","  public void test3()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""192.168.1.42"", 37);
      timeUDPClient0.open();
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, (byte[]) null);
      InetAddress inetAddress0 = timeUDPClient0.getLocalAddress();
      Date date0 = timeUDPClient0.getDate(inetAddress0);
}"
2388,"    public long getTime(final InetAddress host, final int port) throws IOException
    {
        long time;
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        time = 0L;
        time |= (((timeData[0] & 0xff) << 24) & 0xffffffffL);
        time |= (((timeData[1] & 0xff) << 16) & 0xffffffffL);
        time |= (((timeData[2] & 0xff) << 8) & 0xffffffffL);
        time |= ((timeData[3] & 0xff) & 0xffffffffL);

        return time;
    }","  public void test4()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        timeUDPClient0.getTime(inetAddress0, (-1604));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-1604
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
2389,"    public long getTime(final InetAddress host, final int port) throws IOException
    {
        long time;
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        time = 0L;
        time |= (((timeData[0] & 0xff) << 24) & 0xffffffffL);
        time |= (((timeData[1] & 0xff) << 16) & 0xffffffffL);
        time |= (((timeData[2] & 0xff) << 8) & 0xffffffffL);
        time |= ((timeData[3] & 0xff) & 0xffffffffL);

        return time;
    }","  public void test5()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      timeUDPClient0.open();
      try { 
        timeUDPClient0.getTime(inetAddress0, 153);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
2390,"    public long getTime(final InetAddress host, final int port) throws IOException
    {
        long time;
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        time = 0L;
        time |= (((timeData[0] & 0xff) << 24) & 0xffffffffL);
        time |= (((timeData[1] & 0xff) << 16) & 0xffffffffL);
        time |= (((timeData[2] & 0xff) << 8) & 0xffffffffL);
        time |= ((timeData[3] & 0xff) & 0xffffffffL);

        return time;
    }","  public void test6()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        timeUDPClient0.getTime(inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.time.TimeUDPClient"", e);
      }
  }"
2391,"    public Date getDate(final InetAddress host, final int port) throws IOException
    {
        return new Date((getTime(host, port) - SECONDS_1900_TO_1970)*1000L);
    }","  public void test7()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        timeUDPClient0.getDate(inetAddress0, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.time.TimeUDPClient"", e);
      }
  }"
2392,"    public Date getDate(final InetAddress host, final int port) throws IOException
    {
        return new Date((getTime(host, port) - SECONDS_1900_TO_1970)*1000L);
    }","  public void test8()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        timeUDPClient0.getDate(inetAddress0, (-300));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port out of range:-300
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
2393,"    public Date getDate(final InetAddress host, final int port) throws IOException
    {
        return new Date((getTime(host, port) - SECONDS_1900_TO_1970)*1000L);
    }","  public void test9()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      // Undeclared exception!
      try { 
        timeUDPClient0.getDate(inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.time.TimeUDPClient"", e);
      }
  }"
2394,"    public long getTime(final InetAddress host, final int port) throws IOException
    {
        long time;
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        time = 0L;
        time |= (((timeData[0] & 0xff) << 24) & 0xffffffffL);
        time |= (((timeData[1] & 0xff) << 16) & 0xffffffffL);
        time |= (((timeData[2] & 0xff) << 8) & 0xffffffffL);
        time |= ((timeData[3] & 0xff) & 0xffffffffL);

        return time;
    }","  public void test10()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        timeUDPClient0.getTime(inetAddress0, 868);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.time.TimeUDPClient"", e);
      }
  }"
2395,"    public Date getDate(final InetAddress host, final int port) throws IOException
    {
        return new Date((getTime(host, port) - SECONDS_1900_TO_1970)*1000L);
    }","  public void test11()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      timeUDPClient0.open();
      InetAddress inetAddress0 = timeUDPClient0.getLocalAddress();
      try { 
        timeUDPClient0.getDate(inetAddress0, 37);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
2396,"    public long getTime(final InetAddress host, final int port) throws IOException
    {
        long time;
        final DatagramPacket sendPacket;
        final DatagramPacket receivePacket;

        sendPacket =
            new DatagramPacket(dummyData, dummyData.length, host, port);
        receivePacket = new DatagramPacket(timeData, timeData.length);

        _socket_.send(sendPacket);
        _socket_.receive(receivePacket);

        time = 0L;
        time |= (((timeData[0] & 0xff) << 24) & 0xffffffffL);
        time |= (((timeData[1] & 0xff) << 16) & 0xffffffffL);
        time |= (((timeData[2] & 0xff) << 8) & 0xffffffffL);
        time |= ((timeData[3] & 0xff) & 0xffffffffL);

        return time;
    }","  public void test12()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      timeUDPClient0.open();
      InetAddress inetAddress0 = timeUDPClient0.getLocalAddress();
      try { 
        timeUDPClient0.getTime(inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
2397,"    public Date getDate(final InetAddress host, final int port) throws IOException
    {
        return new Date((getTime(host, port) - SECONDS_1900_TO_1970)*1000L);
    }","  public void test13()  throws Throwable  {
      TimeUDPClient timeUDPClient0 = new TimeUDPClient();
      timeUDPClient0.open();
      InetAddress inetAddress0 = timeUDPClient0.getLocalAddress();
      try { 
        timeUDPClient0.getDate(inetAddress0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
2398,"    public long getTime() throws IOException
    {
        final DataInputStream input;
        input = new DataInputStream(_input_);
        return input.readInt() & 0xffffffffL;
    }","  public void test0()  throws Throwable  {
      TimeTCPClient timeTCPClient0 = new TimeTCPClient();
      // Undeclared exception!
      try { 
        timeTCPClient0.getTime();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
2399,"    public Date getDate() throws IOException
    {
        return new Date((getTime() - SECONDS_1900_TO_1970)*1000L);
    }","  public void test1()  throws Throwable  {
      TimeTCPClient timeTCPClient0 = new TimeTCPClient();
      // Undeclared exception!
      try { 
        timeTCPClient0.getDate();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
2400,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test0()  throws Throwable  {
      EchoTCPClient echoTCPClient0 = new EchoTCPClient();
      echoTCPClient0.getInputStream();
}"
2401,"    public void send(final byte[] data, final int length, final InetAddress host)
    throws IOException
    {
        send(data, length, host, DEFAULT_PORT);
    }","  public void test0()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      byte[] byteArray0 = new byte[1];
      echoUDPClient0.open();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      echoUDPClient0.send(byteArray0, inetAddress0);
}"
2402,"    public void send(final byte[] data, final int length, final InetAddress host)
    throws IOException
    {
        send(data, length, host, DEFAULT_PORT);
    }","  public void test1()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      byte[] byteArray0 = new byte[8];
      echoUDPClient0.open(1636);
      InetAddress inetAddress0 = echoUDPClient0.getLocalAddress();
      echoUDPClient0.send(byteArray0, 0, inetAddress0);
}"
2403,"    public int receive(final byte[] data, final int length) throws IOException
    {
        receivePacket.setData(data);
        receivePacket.setLength(length);
        _socket_.receive(receivePacket);
        return receivePacket.getLength();
    }","  public void test2()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.open();
      byte[] byteArray0 = new byte[8];
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""192.168.1.42"", 40000);
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress("""", 1);
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, evoSuiteRemoteAddress0, byteArray0);
      int int0 = echoUDPClient0.receive(byteArray0, 0);
}"
2404,"    public int receive(final byte[] data, final int length) throws IOException
    {
        receivePacket.setData(data);
        receivePacket.setLength(length);
        _socket_.receive(receivePacket);
        return receivePacket.getLength();
    }","  public void test3()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getByName(""p/Y\""1CyDdA#B(A?amg"");
      EvoSuiteLocalAddress evoSuiteLocalAddress0 = new EvoSuiteLocalAddress(""200.42.42.0"", 1927);
      byte[] byteArray0 = new byte[2];
      NetworkHandling.sendUdpPacket(evoSuiteLocalAddress0, byteArray0);
      echoUDPClient0.open(1927, inetAddress0);
      int int0 = echoUDPClient0.receive(byteArray0);
}"
2405,"    public void send(final byte[] data, final int length, final InetAddress host)
    throws IOException
    {
        send(data, length, host, DEFAULT_PORT);
    }","  public void test4()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      byte[] byteArray0 = new byte[5];
      // Undeclared exception!
      try { 
        echoUDPClient0.send(byteArray0, 826, (InetAddress) null);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // illegal length
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
2406,"    public int receive(final byte[] data, final int length) throws IOException
    {
        receivePacket.setData(data);
        receivePacket.setLength(length);
        _socket_.receive(receivePacket);
        return receivePacket.getLength();
    }","  public void test5()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      byte[] byteArray0 = new byte[6];
      // Undeclared exception!
      try { 
        echoUDPClient0.receive(byteArray0, (int) (byte)0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.echo.EchoUDPClient"", e);
      }
  }"
2407,"    public int receive(final byte[] data, final int length) throws IOException
    {
        receivePacket.setData(data);
        receivePacket.setLength(length);
        _socket_.receive(receivePacket);
        return receivePacket.getLength();
    }","  public void test6()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      echoUDPClient0.open();
      byte[] byteArray0 = new byte[8];
      try { 
        echoUDPClient0.receive(byteArray0, 0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
2408,"    public int receive(final byte[] data, final int length) throws IOException
    {
        receivePacket.setData(data);
        receivePacket.setLength(length);
        _socket_.receive(receivePacket);
        return receivePacket.getLength();
    }","  public void test7()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      byte[] byteArray0 = new byte[8];
      echoUDPClient0.open(1636);
      try { 
        echoUDPClient0.receive(byteArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Simulated IO exception
         //
         verifyException(""org.evosuite.runtime.mock.java.net.EvoDatagramSocketImpl"", e);
      }
  }"
2409,"    public int receive(final byte[] data, final int length) throws IOException
    {
        receivePacket.setData(data);
        receivePacket.setLength(length);
        _socket_.receive(receivePacket);
        return receivePacket.getLength();
    }","  public void test8()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      byte[] byteArray0 = new byte[4];
      // Undeclared exception!
      try { 
        echoUDPClient0.receive(byteArray0, (int) (byte)16);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // illegal length
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
2410,"    public void send(final byte[] data, final int length, final InetAddress host)
    throws IOException
    {
        send(data, length, host, DEFAULT_PORT);
    }","  public void test9()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      byte[] byteArray0 = new byte[5];
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      // Undeclared exception!
      try { 
        echoUDPClient0.send(byteArray0, inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.discard.DiscardUDPClient"", e);
      }
  }"
2411,"    public int receive(final byte[] data, final int length) throws IOException
    {
        receivePacket.setData(data);
        receivePacket.setLength(length);
        _socket_.receive(receivePacket);
        return receivePacket.getLength();
    }","  public void test10()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      byte[] byteArray0 = new byte[4];
      // Undeclared exception!
      try { 
        echoUDPClient0.receive(byteArray0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.echo.EchoUDPClient"", e);
      }
  }"
2412,"    public void send(final byte[] data, final int length, final InetAddress host)
    throws IOException
    {
        send(data, length, host, DEFAULT_PORT);
    }","  public void test11()  throws Throwable  {
      EchoUDPClient echoUDPClient0 = new EchoUDPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      // Undeclared exception!
      try { 
        echoUDPClient0.send((byte[]) null, 7, inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // null packet buffer
         //
         verifyException(""java.net.DatagramPacket"", e);
      }
  }"
2413,"    public int type(final int fileType, final int formatOrByteSize) throws IOException
    {
        final StringBuilder arg = new StringBuilder();

        arg.append(modes.charAt(fileType));
        arg.append(' ');
        if (fileType == LOCAL_FILE_TYPE) {
            arg.append(formatOrByteSize);
        } else {
            arg.append(modes.charAt(formatOrByteSize));
        }

        return sendCommand(FTPCmd.TYPE, arg.toString());
    }","  public void test0()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.type(2, 2);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2414,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test1()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.getCommandSupport();
}"
2415,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test2()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.getCommandSupport();
}"
2416,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test3()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.getCommandSupport();
}"
2417,"    public int type(final int fileType, final int formatOrByteSize) throws IOException
    {
        final StringBuilder arg = new StringBuilder();

        arg.append(modes.charAt(fileType));
        arg.append(' ');
        if (fileType == LOCAL_FILE_TYPE) {
            arg.append(formatOrByteSize);
        } else {
            arg.append(modes.charAt(formatOrByteSize));
        }

        return sendCommand(FTPCmd.TYPE, arg.toString());
    }","  public void test4()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.type(1540, 3246);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2418,"    public int type(final int fileType, final int formatOrByteSize) throws IOException
    {
        final StringBuilder arg = new StringBuilder();

        arg.append(modes.charAt(fileType));
        arg.append(' ');
        if (fileType == LOCAL_FILE_TYPE) {
            arg.append(formatOrByteSize);
        } else {
            arg.append(modes.charAt(formatOrByteSize));
        }

        return sendCommand(FTPCmd.TYPE, arg.toString());
    }","  public void test5()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.type(0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2419,"    public int stru(final int structure) throws IOException
    {
        return sendCommand(FTPCmd.STRU,
                           modes.substring(structure, structure + 1));
    }","  public void test6()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.stru(11);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2420,"    public int stou() throws IOException
    {
        return sendCommand(FTPCmd.STOU);
    }","  public void test7()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.stou("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2421,"    public int size(final String parameters) throws IOException
    {
        return sendCommand(FTPCmd.SIZE, parameters);
    }","  public void test8()  throws Throwable  {
      FTP fTP0 = new FTP();
      CharArrayWriter charArrayWriter0 = new CharArrayWriter(12);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(charArrayWriter0, false);
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
      fTP0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTP0.size("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2422,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (_controlOutput_ == null) {
            throw new IOException(""Connection is not open"");
        }

        final String message = buildMessage(command, args);

        send(message);

        fireCommandSent(command, message);

        return getReply();
    }","  public void test9()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.sendCommand(5, """");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2423,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (_controlOutput_ == null) {
            throw new IOException(""Connection is not open"");
        }

        final String message = buildMessage(command, args);

        send(message);

        fireCommandSent(command, message);

        return getReply();
    }","  public void test10()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.sendCommand((-2843));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -2843
         //
         verifyException(""org.apache.commons.net.ftp.FTPCommand"", e);
      }
  }"
2424,"    public int rest(final String marker) throws IOException
    {
        return sendCommand(FTPCmd.REST, marker);
    }","  public void test11()  throws Throwable  {
      FTP fTP0 = new FTP();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter("" $ _B~9y2p4d"");
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
      fTP0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTP0.rest(""W>F4^CN2A"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2425,"    public int port(final InetAddress host, final int port) throws IOException
    {
        int num;
        final StringBuilder info = new StringBuilder(24);

        info.append(host.getHostAddress().replace('.', ','));
        num = port >>> 8;
        info.append(',');
        info.append(num);
        info.append(',');
        num = port & 0xff;
        info.append(num);

        return sendCommand(FTPCmd.PORT, info.toString());
    }","  public void test12()  throws Throwable  {
      FTP fTP0 = new FTP();
      InetAddress inetAddress0 = InetAddress.getLoopbackAddress();
      try { 
        fTP0.port(inetAddress0, (-12));
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2426,"    public int mode(final int mode) throws IOException
    {
        return sendCommand(FTPCmd.MODE,
                           modes.substring(mode, mode + 1));
    }","  public void test13()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.mode((-4546));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2427,"    public int mlst() throws IOException
    {
        return sendCommand(FTPCmd.MLST);
    }","  public void test14()  throws Throwable  {
      FTP fTP0 = new FTP();
      MockFileWriter mockFileWriter0 = new MockFileWriter(""\r\n"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, true);
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
      fTP0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTP0.mlst((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2428,"    String getReplyString(final int index)
    {
        return _replyLines.get(index);
    }","  public void test15()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.getReplyString(65);
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 65, Size: 0
         //
         verifyException(""java.util.ArrayList"", e);
      }
  }"
2429,"    public int eprt(final InetAddress host, final int port) throws IOException
    {
        final int num;
        final StringBuilder info = new StringBuilder();
        String h;

        // If IPv6, trim the zone index
        h = host.getHostAddress();
        num = h.indexOf('%');
        if (num > 0) {
            h = h.substring(0, num);
        }

        info.append(""|"");

        if (host instanceof Inet4Address) {
            info.append(""1"");
        } else if (host instanceof Inet6Address) {
            info.append(""2"");
        }
        info.append(""|"");
        info.append(h);
        info.append(""|"");
        info.append(port);
        info.append(""|"");

        return sendCommand(FTPCmd.EPRT, info.toString());
    }","  public void test16()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.eprt((InetAddress) null, (-844));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockInetAddress"", e);
      }
  }"
2430,"    public int cdup() throws IOException
    {
        return sendCommand(FTPCmd.CDUP);
    }","  public void test17()  throws Throwable  {
      FTP fTP0 = new FTP();
      CharArrayWriter charArrayWriter0 = new CharArrayWriter(12);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(charArrayWriter0, false);
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
      fTP0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTP0.cdup();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2431,"    public int acct(final String account) throws IOException
    {
        return sendCommand(FTPCmd.ACCT, account);
    }","  public void test18()  throws Throwable  {
      FTP fTP0 = new FTP();
      CharArrayWriter charArrayWriter0 = new CharArrayWriter(12);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(charArrayWriter0, false);
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
      fTP0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTP0.acct(""$.CUcSfnSD!6aQ"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2432,"    public int abor() throws IOException
    {
        return sendCommand(FTPCmd.ABOR);
    }","  public void test19()  throws Throwable  {
      FTP fTP0 = new FTP();
      CharArrayWriter charArrayWriter0 = new CharArrayWriter(12);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(charArrayWriter0, false);
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
      fTP0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTP0.abor();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2433,"    protected void _connectAction_() throws IOException
    {
        _connectAction_(null);
    }","  public void test20()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0._connectAction_((Reader) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2434,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (_controlOutput_ == null) {
            throw new IOException(""Connection is not open"");
        }

        final String message = buildMessage(command, args);

        send(message);

        fireCommandSent(command, message);

        return getReply();
    }","  public void test21()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.sendCommand(""q7u3"", ""q7u3"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2435,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (_controlOutput_ == null) {
            throw new IOException(""Connection is not open"");
        }

        final String message = buildMessage(command, args);

        send(message);

        fireCommandSent(command, message);

        return getReply();
    }","  public void test22()  throws Throwable  {
      FTP fTP0 = new FTP();
      FTPCmd fTPCmd0 = FTPCmd.MLSD;
      try { 
        fTP0.sendCommand(fTPCmd0, """");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2436,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (_controlOutput_ == null) {
            throw new IOException(""Connection is not open"");
        }

        final String message = buildMessage(command, args);

        send(message);

        fireCommandSent(command, message);

        return getReply();
    }","  public void test23()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.sendCommand((-998), ""m?[{g$ogMMl"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -998
         //
         verifyException(""org.apache.commons.net.ftp.FTPCommand"", e);
      }
  }"
2437,"    private int getReply(final boolean reportReply) throws IOException
    {
        final int length;

        _newReplyString = true;
        _replyLines.clear();

        String line = _controlInput_.readLine();

        if (line == null) {
            throw new FTPConnectionClosedException(
                    ""Connection closed without indication."");
        }

        // In case we run into an anomaly we don't want fatal index exceptions
        // to be thrown.
        length = line.length();
        if (length < REPLY_CODE_LEN) {
            throw new MalformedServerReplyException(
                ""Truncated server reply: "" + line);
        }

        String code = null;
        try
        {
            code = line.substring(0, REPLY_CODE_LEN);
            _replyCode = Integer.parseInt(code);
        }
        catch (final NumberFormatException e)
        {
            throw new MalformedServerReplyException(
                ""Could not parse response code.\nServer Reply: "" + line);
        }

        _replyLines.add(line);

        // Check the server reply type
        if (length > REPLY_CODE_LEN) {
            final char sep = line.charAt(REPLY_CODE_LEN);
            // Get extra lines if message continues.
            if (sep == '-') {
                do
                {
                    line = _controlInput_.readLine();

                    if (line == null) {
                        throw new FTPConnectionClosedException(
                            ""Connection closed without indication."");
                    }

                    _replyLines.add(line);

                    // The length() check handles problems that could arise from readLine()
                    // returning too soon after encountering a naked CR or some other
                    // anomaly.
                }
                while ( isStrictMultilineParsing() ? strictCheck(line, code) : lenientCheck(line));

            } else if (isStrictReplyParsing()) {
                if (length == REPLY_CODE_LEN + 1) { // expecting some text
                    throw new MalformedServerReplyException(""Truncated server reply: '"" + line +""'"");
                } else if (sep != ' ') {
                    throw new MalformedServerReplyException(""Invalid server reply: '"" + line +""'"");
                }
            }
        } else if (isStrictReplyParsing()) {
            throw new MalformedServerReplyException(""Truncated server reply: '"" + line +""'"");
        }

        if (reportReply) {
            fireReplyReceived(_replyCode, getReplyString());
        }

        if (_replyCode == FTPReply.SERVICE_NOT_AVAILABLE) {
            throw new FTPConnectionClosedException(""FTP response 421 received.  Server closed connection."");
        }
        return _replyCode;
    }","  public void test24()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.getReply();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2438,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (_controlOutput_ == null) {
            throw new IOException(""Connection is not open"");
        }

        final String message = buildMessage(command, args);

        send(message);

        fireCommandSent(command, message);

        return getReply();
    }","  public void test25()  throws Throwable  {
      FTP fTP0 = new FTP();
      FTPCmd fTPCmd0 = FTPCmd.MKD;
      try { 
        fTP0.sendCommand(fTPCmd0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2439,"    public int type(final int fileType, final int formatOrByteSize) throws IOException
    {
        final StringBuilder arg = new StringBuilder();

        arg.append(modes.charAt(fileType));
        arg.append(' ');
        if (fileType == LOCAL_FILE_TYPE) {
            arg.append(formatOrByteSize);
        } else {
            arg.append(modes.charAt(formatOrByteSize));
        }

        return sendCommand(FTPCmd.TYPE, arg.toString());
    }","  public void test26()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.type(3, 3);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2440,"    public int type(final int fileType, final int formatOrByteSize) throws IOException
    {
        final StringBuilder arg = new StringBuilder();

        arg.append(modes.charAt(fileType));
        arg.append(' ');
        if (fileType == LOCAL_FILE_TYPE) {
            arg.append(formatOrByteSize);
        } else {
            arg.append(modes.charAt(formatOrByteSize));
        }

        return sendCommand(FTPCmd.TYPE, arg.toString());
    }","  public void test27()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.type(6, 6);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2441,"    public int eprt(final InetAddress host, final int port) throws IOException
    {
        final int num;
        final StringBuilder info = new StringBuilder();
        String h;

        // If IPv6, trim the zone index
        h = host.getHostAddress();
        num = h.indexOf('%');
        if (num > 0) {
            h = h.substring(0, num);
        }

        info.append(""|"");

        if (host instanceof Inet4Address) {
            info.append(""1"");
        } else if (host instanceof Inet6Address) {
            info.append(""2"");
        }
        info.append(""|"");
        info.append(h);
        info.append(""|"");
        info.append(port);
        info.append(""|"");

        return sendCommand(FTPCmd.EPRT, info.toString());
    }","  public void test28()  throws Throwable  {
      FTP fTP0 = new FTP();
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      try { 
        fTP0.eprt(inetAddress0, 25);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2442,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test29()  throws Throwable  {
      FTP fTP0 = new FTP();
      String string0 = fTP0.getReplyString();
}"
2443,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test30()  throws Throwable  {
      FTP fTP0 = new FTP();
      String string0 = fTP0.getReplyString();
}"
2444,"    String getReplyString(final int index)
    {
        return _replyLines.get(index);
    }","  public void test31()  throws Throwable  {
      FTP fTP0 = new FTP();
      String string0 = fTP0.getReplyString();
}"
2445,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test32()  throws Throwable  {
      FTP fTP0 = new FTP();
      String string0 = fTP0.getReplyString();
}"
2446,"    public int mdtm(final String file) throws IOException
    {
        return sendCommand(FTPCmd.MDTM, file);
    }","  public void test33()  throws Throwable  {
      FTP fTP0 = new FTP();
      CharArrayWriter charArrayWriter0 = new CharArrayWriter(12);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(charArrayWriter0, false);
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
      fTP0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTP0.mdtm(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2447,"    public int epsv() throws IOException
    {
        return sendCommand(FTPCmd.EPSV);
    }","  public void test34()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.epsv();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2448,"    public int nlst() throws IOException
    {
        return sendCommand(FTPCmd.NLST);
    }","  public void test35()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.nlst("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2449,"    public int help() throws IOException
    {
        return sendCommand(FTPCmd.HELP);
    }","  public void test36()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.help(""ISO-8859-1"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2450,"    public int appe(final String pathname) throws IOException
    {
        return sendCommand(FTPCmd.APPE, pathname);
    }","  public void test37()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.appe(""mMN"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2451,"    public int mlsd() throws IOException
    {
        return sendCommand(FTPCmd.MLSD);
    }","  public void test38()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.mlsd(""Truncated server reply: "");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2452,"    public int user(final String username) throws IOException
    {
        return sendCommand(FTPCmd.USER, username);
    }","  public void test39()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.user(""\r\n"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2453,"    public int cwd(final String directory) throws IOException
    {
        return sendCommand(FTPCmd.CWD, directory);
    }","  public void test40()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.cwd(""ABORT"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2454,"    public int rnfr(final String pathname) throws IOException
    {
        return sendCommand(FTPCmd.RNFR, pathname);
    }","  public void test41()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.rnfr("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2455,"    public int abor() throws IOException
    {
        return sendCommand(FTPCmd.ABOR);
    }","  public void test42()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.abor();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2456,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test43()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.getReplyStrings();
}"
2457,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test44()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.getReplyStrings();
}"
2458,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test45()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.getReplyStrings();
}"
2459,"    public int allo(final int bytes) throws IOException
    {
        return sendCommand(FTPCmd.ALLO, Integer.toString(bytes));
    }","  public void test46()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.allo(3430L);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2460,"    public int stor(final String pathname) throws IOException
    {
        return sendCommand(FTPCmd.STOR, pathname);
    }","  public void test47()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.stor("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2461,"    public int pass(final String password) throws IOException
    {
        return sendCommand(FTPCmd.PASS, password);
    }","  public void test48()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.pass(""P#%_6l<?9"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2462,"    public int list() throws IOException
    {
        return sendCommand(FTPCmd.LIST);
    }","  public void test49()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.list(""The wildcard must not be null"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2463,"    public int smnt(final String dir) throws IOException
    {
        return sendCommand(FTPCmd.SMNT, dir);
    }","  public void test50()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.smnt(""org.apache.commons.net.ftp.FTP"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2464,"    public int stru(final int structure) throws IOException
    {
        return sendCommand(FTPCmd.STRU,
                           modes.substring(structure, structure + 1));
    }","  public void test51()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.stru(16);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2465,"    public int site(final String parameters) throws IOException
    {
        return sendCommand(FTPCmd.SITE, parameters);
    }","  public void test52()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.site(""NMELIT"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2466,"    protected void _connectAction_() throws IOException
    {
        _connectAction_(null);
    }","  public void test53()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2467,"    public int stat() throws IOException
    {
        return sendCommand(FTPCmd.STAT);
    }","  public void test54()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.stat();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2468,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test55()  throws Throwable  {
      FTP fTP0 = new FTP();
      String string0 = fTP0.getControlEncoding();
}"
2469,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test56()  throws Throwable  {
      FTP fTP0 = new FTP();
      String string0 = fTP0.getControlEncoding();
}"
2470,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test57()  throws Throwable  {
      FTP fTP0 = new FTP();
      String string0 = fTP0.getControlEncoding();
}"
2471,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test58()  throws Throwable  {
      FTP fTP0 = new FTP();
      String string0 = fTP0.getControlEncoding();
}"
2472,"    public int noop() throws IOException
    {
        return sendCommand(FTPCmd.NOOP);
    }","  public void test59()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.noop();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2473,"    public int rest(final String marker) throws IOException
    {
        return sendCommand(FTPCmd.REST, marker);
    }","  public void test60()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.rest(""W>F4^CN2A"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2474,"    public int nlst() throws IOException
    {
        return sendCommand(FTPCmd.NLST);
    }","  public void test61()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.nlst();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2475,"    public int pwd() throws IOException
    {
        return sendCommand(FTPCmd.PWD);
    }","  public void test62()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.pwd();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2476,"    public int mfmt(final String pathname, final String timeval) throws IOException
    {
        return sendCommand(FTPCmd.MFMT, timeval + "" "" + pathname);
    }","  public void test63()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.mfmt(""ISO-8859-1"", ""ISO-8859-1"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2477,"    public int mlst() throws IOException
    {
        return sendCommand(FTPCmd.MLST);
    }","  public void test64()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.mlst((String) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2478,"    protected void __noop() throws IOException {
        final String msg = buildMessage(FTPCmd.NOOP.getCommand(), null);
        send(msg);
        __getReplyNoReport(); // This may timeout
    }","  public void test65()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.__noop();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2479,"    public int acct(final String account) throws IOException
    {
        return sendCommand(FTPCmd.ACCT, account);
    }","  public void test66()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.acct(""$.CUcSfnSD!6aQ"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2480,"    public int list() throws IOException
    {
        return sendCommand(FTPCmd.LIST);
    }","  public void test67()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.list();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2481,"    public int feat() throws IOException
    {
        return sendCommand(FTPCmd.FEAT);
    }","  public void test68()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.feat();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2482,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test69()  throws Throwable  {
      FTP fTP0 = new FTP();
      boolean boolean0 = fTP0.isStrictReplyParsing();
}"
2483,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test70()  throws Throwable  {
      FTP fTP0 = new FTP();
      boolean boolean0 = fTP0.isStrictReplyParsing();
}"
2484,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test71()  throws Throwable  {
      FTP fTP0 = new FTP();
      boolean boolean0 = fTP0.isStrictReplyParsing();
}"
2485,"    public int mdtm(final String file) throws IOException
    {
        return sendCommand(FTPCmd.MDTM, file);
    }","  public void test72()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.mdtm(""\r\n"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2486,"    String getReplyString(final int index)
    {
        return _replyLines.get(index);
    }","  public void test73()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.getReplyString((-853));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
2487,"    public int rnto(final String pathname) throws IOException
    {
        return sendCommand(FTPCmd.RNTO, pathname);
    }","  public void test74()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.rnto((String) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2488,"    public int pasv() throws IOException
    {
        return sendCommand(FTPCmd.PASV);
    }","  public void test75()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.pasv();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2489,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test76()  throws Throwable  {
      FTP fTP0 = new FTP();
      int int0 = fTP0.getReplyCode();
}"
2490,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test77()  throws Throwable  {
      FTP fTP0 = new FTP();
      int int0 = fTP0.getReplyCode();
}"
2491,"    public int getReplyCode()
    {
        return _replyCode;
    }","  public void test78()  throws Throwable  {
      FTP fTP0 = new FTP();
      int int0 = fTP0.getReplyCode();
}"
2492,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test79()  throws Throwable  {
      FTP fTP0 = new FTP();
      int int0 = fTP0.getReplyCode();
}"
2493,"    public int help() throws IOException
    {
        return sendCommand(FTPCmd.HELP);
    }","  public void test80()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.help();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2494,"    public int mlsd() throws IOException
    {
        return sendCommand(FTPCmd.MLSD);
    }","  public void test81()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.mlsd();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2495,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test82()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.disconnect();
}"
2496,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test83()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.disconnect();
}"
2497,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test84()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.disconnect();
}"
2498,"    public int allo(final int bytes) throws IOException
    {
        return sendCommand(FTPCmd.ALLO, Integer.toString(bytes));
    }","  public void test85()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.allo((long) 21, 3);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2499,"    public int retr(final String pathname) throws IOException
    {
        return sendCommand(FTPCmd.RETR, pathname);
    }","  public void test86()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.retr(""}"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2500,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test87()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.isStrictMultilineParsing();
}"
2501,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test88()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.isStrictMultilineParsing();
}"
2502,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test89()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.isStrictMultilineParsing();
}"
2503,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test90()  throws Throwable  {
      FTP fTP0 = new FTP();
}"
2504,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test91()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.setStrictReplyParsing(false);
}"
2505,"    public int mlst() throws IOException
    {
        return sendCommand(FTPCmd.MLST);
    }","  public void test92()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.mlst();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2506,"    public int allo(final int bytes) throws IOException
    {
        return sendCommand(FTPCmd.ALLO, Integer.toString(bytes));
    }","  public void test93()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.allo(0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2507,"    protected void __getReplyNoReport()  throws IOException
    {
        getReply(false);
    }","  public void test94()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.__getReplyNoReport();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2508,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (_controlOutput_ == null) {
            throw new IOException(""Connection is not open"");
        }

        final String message = buildMessage(command, args);

        send(message);

        fireCommandSent(command, message);

        return getReply();
    }","  public void test95()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.sendCommand(12);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2509,"    public int syst() throws IOException
    {
        return sendCommand(FTPCmd.SYST);
    }","  public void test96()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.syst();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2510,"    public int stou() throws IOException
    {
        return sendCommand(FTPCmd.STOU);
    }","  public void test97()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.stou();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2511,"    public boolean isStrictMultilineParsing() {
        return strictMultilineParsing;
    }","  public void test98()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.setStrictMultilineParsing(false);
}"
2512,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test99()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.setStrictMultilineParsing(false);
}"
2513,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test100()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.setStrictMultilineParsing(false);
}"
2514,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test101()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.setStrictMultilineParsing(false);
}"
2515,"    public int cdup() throws IOException
    {
        return sendCommand(FTPCmd.CDUP);
    }","  public void test102()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.cdup();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2516,"    public int rmd(final String pathname) throws IOException
    {
        return sendCommand(FTPCmd.RMD, pathname);
    }","  public void test103()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.rmd(""ISO-8859-1"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2517,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (_controlOutput_ == null) {
            throw new IOException(""Connection is not open"");
        }

        final String message = buildMessage(command, args);

        send(message);

        fireCommandSent(command, message);

        return getReply();
    }","  public void test104()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.sendCommand(""ISO-8859-1"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2518,"    public String getControlEncoding() {
        return _controlEncoding;
    }","  public void test105()  throws Throwable  {
      FTP fTP0 = new FTP();
}"
2519,"    public boolean isStrictReplyParsing() {
        return strictReplyParsing;
    }","  public void test106()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.setControlEncoding((String) null);
}"
2520,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test107()  throws Throwable  {
      FTP fTP0 = new FTP();
      fTP0.setControlEncoding((String) null);
}"
2521,"    public int stat() throws IOException
    {
        return sendCommand(FTPCmd.STAT);
    }","  public void test108()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.stat(""m>4TB#FYU!1}O!"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2522,"    public int rein() throws IOException
    {
        return sendCommand(FTPCmd.REIN);
    }","  public void test109()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.rein();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2523,"    public int allo(final int bytes) throws IOException
    {
        return sendCommand(FTPCmd.ALLO, Integer.toString(bytes));
    }","  public void test110()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.allo((-1397), 16);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2524,"    public int size(final String parameters) throws IOException
    {
        return sendCommand(FTPCmd.SIZE, parameters);
    }","  public void test111()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.size("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2525,"    public int type(final int fileType, final int formatOrByteSize) throws IOException
    {
        final StringBuilder arg = new StringBuilder();

        arg.append(modes.charAt(fileType));
        arg.append(' ');
        if (fileType == LOCAL_FILE_TYPE) {
            arg.append(formatOrByteSize);
        } else {
            arg.append(modes.charAt(formatOrByteSize));
        }

        return sendCommand(FTPCmd.TYPE, arg.toString());
    }","  public void test112()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.type((-2334));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2526,"    public int port(final InetAddress host, final int port) throws IOException
    {
        int num;
        final StringBuilder info = new StringBuilder(24);

        info.append(host.getHostAddress().replace('.', ','));
        num = port >>> 8;
        info.append(',');
        info.append(num);
        info.append(',');
        num = port & 0xff;
        info.append(num);

        return sendCommand(FTPCmd.PORT, info.toString());
    }","  public void test113()  throws Throwable  {
      FTP fTP0 = new FTP();
      // Undeclared exception!
      try { 
        fTP0.port((InetAddress) null, (-2145));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockInetAddress"", e);
      }
  }"
2527,"    public int mkd(final String pathname) throws IOException
    {
        return sendCommand(FTPCmd.MKD, pathname);
    }","  public void test114()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.mkd(""Connction s not open"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2528,"    public int dele(final String pathname) throws IOException
    {
        return sendCommand(FTPCmd.DELE, pathname);
    }","  public void test115()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.dele(""FTP response 421 received.  Server closed connection."");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2529,"    public int quit() throws IOException
    {
        return sendCommand(FTPCmd.QUIT);
    }","  public void test116()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.quit();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2530,"    public int stou() throws IOException
    {
        return sendCommand(FTPCmd.STOU);
    }","  public void test117()  throws Throwable  {
      FTP fTP0 = new FTP();
      StringWriter stringWriter0 = new StringWriter(504);
      BufferedWriter bufferedWriter0 = new BufferedWriter(stringWriter0);
      fTP0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTP0.stou((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2531,"    public int mode(final int mode) throws IOException
    {
        return sendCommand(FTPCmd.MODE,
                           modes.substring(mode, mode + 1));
    }","  public void test118()  throws Throwable  {
      FTP fTP0 = new FTP();
      try { 
        fTP0.mode(11);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2532,,"  public void test0()  throws Throwable  {
      FTPFileFilters fTPFileFilters0 = new FTPFileFilters();
  }"
2533,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test0()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""TYPE: L8"", ""TYPE: L8"", (String) null, ""TYPE: L8"", ""_L"", true, false);
}"
2534,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test1()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""TYPE: L8"", ""TYPE: L8"", (String) null, ""TYPE: L8"", ""_L"", true, false);
}"
2535,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test2()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""TYPE: L8"", ""TYPE: L8"", (String) null, ""TYPE: L8"", ""_L"", true, false);
}"
2536,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test3()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""TYPE: L8"", ""TYPE: L8"", (String) null, ""TYPE: L8"", ""_L"", true, false);
}"
2537,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test4()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""TYPE: L8"", ""TYPE: L8"", (String) null, ""TYPE: L8"", ""_L"", true, false);
}"
2538,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test5()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""TYPE: L8"", ""TYPE: L8"", (String) null, ""TYPE: L8"", ""_L"", true, false);
}"
2539,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test6()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""P*D_Aq"", (String) null, ""D{2B+Xf^y *"", ""?&VD'p"", ""P*D_Aq"");
}"
2540,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test7()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""P*D_Aq"", (String) null, ""D{2B+Xf^y *"", ""?&VD'p"", ""P*D_Aq"");
}"
2541,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test8()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""P*D_Aq"", (String) null, ""D{2B+Xf^y *"", ""?&VD'p"", ""P*D_Aq"");
}"
2542,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test9()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""P*D_Aq"", (String) null, ""D{2B+Xf^y *"", ""?&VD'p"", ""P*D_Aq"");
}"
2543,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test10()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""P*D_Aq"", (String) null, ""D{2B+Xf^y *"", ""?&VD'p"", ""P*D_Aq"");
}"
2544,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test11()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2545,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test12()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2546,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test13()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2547,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test14()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2548,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test15()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2549,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test16()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2550,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test17()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2551,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test18()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2552,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test19()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2553,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test20()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2554,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test21()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2555,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test22()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2556,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test23()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2557,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test24()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2558,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test25()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2559,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test26()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""~,P0"", ""^PX=-=aC7pi+>B)`"", ""~,P0"", ""i>fJcT`Zz79T"", """", ""~,P0"", false, false);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2560,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test27()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2561,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test28()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2562,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test29()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2563,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test30()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2564,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test31()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2565,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test32()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""0t%$/"", ""0t%$/"");
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2566,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test33()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""0t%$/"", ""0t%$/"");
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2567,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test34()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""0t%$/"", ""0t%$/"");
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2568,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test35()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""0t%$/"", ""0t%$/"");
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2569,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test36()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""0t%$/"", ""0t%$/"");
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2570,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test37()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setServerTimeZoneId("""");
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2571,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test38()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setServerTimeZoneId("""");
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2572,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test39()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setServerTimeZoneId("""");
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2573,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test40()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, """", """", """", ""!//AhfOwYC"", (String) null, false, false);
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2574,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test41()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, """", """", """", ""!//AhfOwYC"", (String) null, false, false);
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2575,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test42()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, """", """", """", ""!//AhfOwYC"", (String) null, false, false);
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2576,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test43()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, """", """", """", ""!//AhfOwYC"", (String) null, false, false);
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2577,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test44()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, """", """", """", ""!//AhfOwYC"", (String) null, false, false);
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2578,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test45()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, """", """", """", ""!//AhfOwYC"", (String) null, false, false);
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2579,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test46()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, """", """", """", ""!//AhfOwYC"", (String) null, false, false);
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2580,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test47()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2581,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test48()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2582,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test49()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2583,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test50()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2584,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test51()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D+V#"", """", ""3/*)Ouow|*q%rq!s"");
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2585,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test52()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", """", ""no"", """", false, false);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2586,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test53()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", """", ""no"", """", false, false);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2587,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test54()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", """", ""no"", """", false, false);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2588,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test55()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", """", ""no"", """", false, false);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2589,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test56()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", """", ""no"", """", false, false);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2590,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test57()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", """", ""no"", """", false, false);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2591,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test58()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", """", ""no"", """", false, false);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2592,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test59()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", """", ""no"", """", false, false);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2593,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test60()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""0t%$/"", ""0t%$/"");
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2594,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test61()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""0t%$/"", ""0t%$/"");
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2595,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test62()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""0t%$/"", ""0t%$/"");
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2596,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test63()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""0t%$/"", ""0t%$/"");
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2597,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test64()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setRecentDateFormatStr("""");
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2598,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test65()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setRecentDateFormatStr("""");
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2599,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test66()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setRecentDateFormatStr("""");
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2600,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test67()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""@?4svNhfh6B/x7*)RZ"");
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2601,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test68()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""@?4svNhfh6B/x7*)RZ"");
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2602,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test69()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""@?4svNhfh6B/x7*)RZ"");
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2603,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test70()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setDefaultDateFormatStr("""");
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2604,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test71()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setDefaultDateFormatStr("""");
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2605,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test72()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setDefaultDateFormatStr("""");
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2606,"    public static DateFormatSymbols getDateFormatSymbols(final String shortmonths)
    {
        final String[] months = splitShortMonthString(shortmonths);
        final DateFormatSymbols dfs = new DateFormatSymbols(Locale.US);
        dfs.setShortMonths(months);
        return dfs;
    }","  public void test73()  throws Throwable  {
      DateFormatSymbols dateFormatSymbols0 = FTPClientConfig.getDateFormatSymbols(""jan|f\u00E9v|mar|avr|mai|jun|jui|ao\u00FB|sep|oct|nov|d\u00E9c"");
}"
2607,"    public static DateFormatSymbols lookupDateFormatSymbols(final String languageCode)
    {
        final Object lang = LANGUAGE_CODE_MAP.get(languageCode);
        if (lang != null) {
            if (lang instanceof Locale) {
                return new DateFormatSymbols((Locale) lang);
            } else if (lang instanceof String){
                return getDateFormatSymbols((String) lang);
            }
        }
        return new DateFormatSymbols(Locale.US);
    }","  public void test74()  throws Throwable  {
      // Undeclared exception!
      try { 
        FTPClientConfig.lookupDateFormatSymbols((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.TreeMap"", e);
      }
  }"
2608,"    public static DateFormatSymbols getDateFormatSymbols(final String shortmonths)
    {
        final String[] months = splitShortMonthString(shortmonths);
        final DateFormatSymbols dfs = new DateFormatSymbols(Locale.US);
        dfs.setShortMonths(months);
        return dfs;
    }","  public void test75()  throws Throwable  {
      // Undeclared exception!
      try { 
        FTPClientConfig.getDateFormatSymbols((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.StringTokenizer"", e);
      }
  }"
2609,"    public FTPClientConfig(final String systemKey) {
        this.serverSystemKey = systemKey;
    }","  public void test76()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = null;
      try {
        fTPClientConfig0 = new FTPClientConfig((FTPClientConfig) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
2610,"    public FTPClientConfig(final String systemKey) {
        this.serverSystemKey = systemKey;
    }","  public void test77()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = null;
      try {
        fTPClientConfig0 = new FTPClientConfig(""HA:w1TUBAwn&G`i8)W"", (FTPClientConfig) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
2611,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test78()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2612,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test79()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2613,"    public static DateFormatSymbols getDateFormatSymbols(final String shortmonths)
    {
        final String[] months = splitShortMonthString(shortmonths);
        final DateFormatSymbols dfs = new DateFormatSymbols(Locale.US);
        dfs.setShortMonths(months);
        return dfs;
    }","  public void test80()  throws Throwable  {
      // Undeclared exception!
      try { 
        FTPClientConfig.getDateFormatSymbols(""NETWARE"");
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
2614,"    public static DateFormatSymbols lookupDateFormatSymbols(final String languageCode)
    {
        final Object lang = LANGUAGE_CODE_MAP.get(languageCode);
        if (lang != null) {
            if (lang instanceof Locale) {
                return new DateFormatSymbols((Locale) lang);
            } else if (lang instanceof String){
                return getDateFormatSymbols((String) lang);
            }
        }
        return new DateFormatSymbols(Locale.US);
    }","  public void test81()  throws Throwable  {
      DateFormatSymbols dateFormatSymbols0 = FTPClientConfig.lookupDateFormatSymbols(""en"");
}"
2615,"    public static DateFormatSymbols lookupDateFormatSymbols(final String languageCode)
    {
        final Object lang = LANGUAGE_CODE_MAP.get(languageCode);
        if (lang != null) {
            if (lang instanceof Locale) {
                return new DateFormatSymbols((Locale) lang);
            } else if (lang instanceof String){
                return getDateFormatSymbols((String) lang);
            }
        }
        return new DateFormatSymbols(Locale.US);
    }","  public void test82()  throws Throwable  {
      DateFormatSymbols dateFormatSymbols0 = FTPClientConfig.lookupDateFormatSymbols(""TYPE: L8"");
}"
2616,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test83()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2617,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test84()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2618,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test85()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2619,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test86()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2620,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test87()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2621,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test88()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2622,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test89()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2623,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test90()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerTimeZoneId();
}"
2624,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test91()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2625,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test92()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2626,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test93()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2627,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test94()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2628,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test95()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2629,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test96()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2630,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test97()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2631,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test98()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2632,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test99()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2633,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test100()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2634,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test101()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2635,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test102()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2636,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test103()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2637,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test104()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2638,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test105()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2639,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test106()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getDefaultDateFormatStr();
}"
2640,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test107()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPClientConfig0.setShortMonthNames("""");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2641,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test108()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPClientConfig0.setShortMonthNames("""");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2642,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test109()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPClientConfig0.setShortMonthNames("""");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2643,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test110()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPClientConfig0.setShortMonthNames("""");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2644,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test111()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPClientConfig0.setShortMonthNames("""");
      String string0 = fTPClientConfig0.getShortMonthNames();
}"
2645,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test112()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2646,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test113()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2647,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test114()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      String string0 = fTPClientConfig0.getRecentDateFormatStr();
}"
2648,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test115()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setServerLanguageCode(""org.apache.commons.net.ftp.FTPClientConfig"");
}"
2649,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test116()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setServerLanguageCode(""org.apache.commons.net.ftp.FTPClientConfig"");
}"
2650,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test117()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setServerLanguageCode(""org.apache.commons.net.ftp.FTPClientConfig"");
}"
2651,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test118()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setServerLanguageCode(""org.apache.commons.net.ftp.FTPClientConfig"");
}"
2652,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test119()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setServerLanguageCode(""org.apache.commons.net.ftp.FTPClientConfig"");
}"
2653,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test120()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setServerLanguageCode(""org.apache.commons.net.ftp.FTPClientConfig"");
}"
2654,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test121()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setServerLanguageCode(""org.apache.commons.net.ftp.FTPClientConfig"");
}"
2655,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test122()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setServerLanguageCode(""org.apache.commons.net.ftp.FTPClientConfig"");
}"
2656,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test123()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, (String) null, ""WINDOWS"", ""WINDOWS"", (String) null, """");
      fTPClientConfig0.setUnparseableEntries(false);
}"
2657,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test124()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, (String) null, ""WINDOWS"", ""WINDOWS"", (String) null, """");
      fTPClientConfig0.setUnparseableEntries(false);
}"
2658,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test125()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, (String) null, ""WINDOWS"", ""WINDOWS"", (String) null, """");
      fTPClientConfig0.setUnparseableEntries(false);
}"
2659,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test126()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, (String) null, ""WINDOWS"", ""WINDOWS"", (String) null, """");
      fTPClientConfig0.setUnparseableEntries(false);
}"
2660,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test127()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, (String) null, ""WINDOWS"", ""WINDOWS"", (String) null, """");
      fTPClientConfig0.setUnparseableEntries(false);
}"
2661,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test128()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2662,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test129()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2663,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test130()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2664,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test131()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2665,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test132()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2666,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test133()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2667,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test134()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2668,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test135()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      boolean boolean0 = fTPClientConfig0.getUnparseableEntries();
}"
2669,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test136()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2670,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test137()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      String string0 = fTPClientConfig0.getServerSystemKey();
}"
2671,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test138()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setLenientFutureDates(true);
}"
2672,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test139()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setLenientFutureDates(true);
}"
2673,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test140()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setLenientFutureDates(true);
}"
2674,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test141()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setLenientFutureDates(true);
}"
2675,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test142()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setLenientFutureDates(true);
}"
2676,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test143()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setLenientFutureDates(true);
}"
2677,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test144()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setLenientFutureDates(true);
}"
2678,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test145()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      fTPClientConfig0.setLenientFutureDates(true);
}"
2679,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test146()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2680,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test147()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      boolean boolean0 = fTPClientConfig0.isLenientFutureDates();
}"
2681,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test148()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(""UNIX"", fTPClientConfig0);
}"
2682,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test149()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(""UNIX"", fTPClientConfig0);
}"
2683,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test150()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(""UNIX"", fTPClientConfig0);
}"
2684,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test151()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(""UNIX"", fTPClientConfig0);
}"
2685,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test152()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(""UNIX"", fTPClientConfig0);
}"
2686,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test153()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(""UNIX"", fTPClientConfig0);
}"
2687,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test154()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(""UNIX"", fTPClientConfig0);
}"
2688,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test155()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(""UNIX"", fTPClientConfig0);
}"
2689,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test156()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(""UNIX"", fTPClientConfig0);
}"
2690,"    public String getServerTimeZoneId() {
        return serverTimeZoneId;
    }","  public void test157()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2691,"    public String getDefaultDateFormatStr() {
        return defaultDateFormatStr;
    }","  public void test158()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2692,"    public boolean getUnparseableEntries() {
        return this.saveUnparseableEntries;
    }","  public void test159()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2693,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test160()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2694,"    public String getShortMonthNames() {
        return shortMonthNames;
    }","  public void test161()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2695,"    public String getRecentDateFormatStr() {
        return recentDateFormatStr;
    }","  public void test162()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2696,"    public String getServerLanguageCode() {
        return serverLanguageCode;
    }","  public void test163()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2697,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test164()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", ""org.apache.commons.net.ftp.FTPClientConfig"", true, true);
      String string0 = fTPClientConfig0.getServerLanguageCode();
}"
2698,"    public static Collection<String> getSupportedLanguageCodes() {
        return LANGUAGE_CODE_MAP.keySet();
    }","  public void test165()  throws Throwable  {
      Collection<String> collection0 = FTPClientConfig.getSupportedLanguageCodes();
}"
2699,"    public static DateFormatSymbols lookupDateFormatSymbols(final String languageCode)
    {
        final Object lang = LANGUAGE_CODE_MAP.get(languageCode);
        if (lang != null) {
            if (lang instanceof Locale) {
                return new DateFormatSymbols((Locale) lang);
            } else if (lang instanceof String){
                return getDateFormatSymbols((String) lang);
            }
        }
        return new DateFormatSymbols(Locale.US);
    }","  public void test166()  throws Throwable  {
      DateFormatSymbols dateFormatSymbols0 = FTPClientConfig.lookupDateFormatSymbols(""fr"");
}"
2700,"    public boolean isLenientFutureDates() {
        return lenientFutureDates;
    }","  public void test167()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(fTPClientConfig0);
}"
2701,"    public String getServerSystemKey() {
        return serverSystemKey;
    }","  public void test168()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      FTPClientConfig fTPClientConfig1 = new FTPClientConfig(fTPClientConfig0);
}"
2702,"    public static String getCommand(final int command)
    {
        return _commands[command];
    }","  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        FTPCommand.getCommand(858);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 858
         //
         verifyException(""org.apache.commons.net.ftp.FTPCommand"", e);
      }
  }"
2703,"    static void checkArray(){
        final int expectedLength = LAST+1;
        if (_commands.length != expectedLength) {
            throw new RuntimeException(""Incorrect _commands array. Should have length ""
                    +expectedLength+"" found ""+_commands.length);
        }
    }","  public void test1()  throws Throwable  {
      FTPCommand.checkArray();
  }"
2704,"    public static String getCommand(final int command)
    {
        return _commands[command];
    }","  public void test2()  throws Throwable  {
      String string0 = FTPCommand.getCommand(0);
}"
2705,"    public ServerSocket createServerSocket() throws IOException {
        return init(getServerSocketFactory().createServerSocket());
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          SSLContext sSLContext0 = SSLContext.getDefault();
          FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory(sSLContext0);
          InetAddress inetAddress0 = MockInetAddress.getByName("""");
          // Undeclared exception!
          try { 
            fTPSServerSocketFactory0.createServerSocket(93, 0, inetAddress0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:93\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.ServerSocket.bind(ServerSocket.java:389)
             // java.net.ServerSocket.<init>(ServerSocket.java:252)
             // javax.net.ssl.SSLServerSocket.<init>(SSLServerSocket.java:181)
             // sun.security.ssl.SSLServerSocketImpl.<init>(SSLServerSocketImpl.java:78)
             // sun.security.ssl.SSLServerSocketFactoryImpl.createServerSocket(SSLServerSocketFactoryImpl.java:87)
             // org.apache.commons.net.ftp.FTPSServerSocketFactory.createServerSocket(FTPSServerSocketFactory.java:70)
             // sun.reflect.GeneratedMethodAccessor67.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
2706,"    public ServerSocket createServerSocket() throws IOException {
        return init(getServerSocketFactory().createServerSocket());
    }","  public void test1()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          SSLContext sSLContext0 = SSLContext.getDefault();
          FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory(sSLContext0);
          // Undeclared exception!
          try { 
            fTPSServerSocketFactory0.createServerSocket(0, (-1492));
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:0\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.ServerSocket.bind(ServerSocket.java:389)
             // java.net.ServerSocket.<init>(ServerSocket.java:252)
             // java.net.ServerSocket.<init>(ServerSocket.java:196)
             // javax.net.ssl.SSLServerSocket.<init>(SSLServerSocket.java:136)
             // sun.security.ssl.SSLServerSocketImpl.<init>(SSLServerSocketImpl.java:70)
             // sun.security.ssl.SSLServerSocketFactoryImpl.createServerSocket(SSLServerSocketFactoryImpl.java:80)
             // org.apache.commons.net.ftp.FTPSServerSocketFactory.createServerSocket(FTPSServerSocketFactory.java:63)
             // sun.reflect.GeneratedMethodAccessor54.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
2707,"    public ServerSocket init(final ServerSocket socket) {
        ((SSLServerSocket) socket).setUseClientMode(true);
        return socket;
    }","  public void test2()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory(sSLContext0);
      InetAddress inetAddress0 = MockInetAddress.getByName(""org.apache.commons.io.filefilter.AgeFileFilter"");
      MockServerSocket mockServerSocket0 = new MockServerSocket(0, 0, inetAddress0);
      // Undeclared exception!
      try { 
        fTPSServerSocketFactory0.init(mockServerSocket0);
        fail(""Expecting exception: ClassCastException"");
      } catch(ClassCastException e) {
         //
         // org.evosuite.runtime.mock.java.net.MockServerSocket cannot be cast to javax.net.ssl.SSLServerSocket
         //
         verifyException(""org.apache.commons.net.ftp.FTPSServerSocketFactory"", e);
      }
  }"
2708,"    public ServerSocket createServerSocket() throws IOException {
        return init(getServerSocketFactory().createServerSocket());
    }","  public void test3()  throws Throwable  {
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory((SSLContext) null);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        fTPSServerSocketFactory0.createServerSocket(1, 1, inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSServerSocketFactory"", e);
      }
  }"
2709,"    public ServerSocket createServerSocket() throws IOException {
        return init(getServerSocketFactory().createServerSocket());
    }","  public void test4()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory(sSLContext0);
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      // Undeclared exception!
      try { 
        fTPSServerSocketFactory0.createServerSocket((-2286), (-2286), inetAddress0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port value out of range: -2286
         //
         verifyException(""java.net.ServerSocket"", e);
      }
  }"
2710,"    public ServerSocket createServerSocket() throws IOException {
        return init(getServerSocketFactory().createServerSocket());
    }","  public void test5()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory(sSLContext0);
      // Undeclared exception!
      try { 
        fTPSServerSocketFactory0.createServerSocket((-2686), (-2686));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port value out of range: -2686
         //
         verifyException(""java.net.ServerSocket"", e);
      }
  }"
2711,"    public ServerSocket createServerSocket() throws IOException {
        return init(getServerSocketFactory().createServerSocket());
    }","  public void test6()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory(sSLContext0);
      // Undeclared exception!
      try { 
        fTPSServerSocketFactory0.createServerSocket((-4));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port value out of range: -4
         //
         verifyException(""java.net.ServerSocket"", e);
      }
  }"
2712,"    public ServerSocket init(final ServerSocket socket) {
        ((SSLServerSocket) socket).setUseClientMode(true);
        return socket;
    }","  public void test7()  throws Throwable  {
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSServerSocketFactory0.init((ServerSocket) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSServerSocketFactory"", e);
      }
  }"
2713,"    public ServerSocket createServerSocket() throws IOException {
        return init(getServerSocketFactory().createServerSocket());
    }","  public void test8()  throws Throwable  {
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSServerSocketFactory0.createServerSocket(0, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSServerSocketFactory"", e);
      }
  }"
2714,"    public ServerSocket init(final ServerSocket socket) {
        ((SSLServerSocket) socket).setUseClientMode(true);
        return socket;
    }","  public void test9()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory(sSLContext0);
      ServerSocket serverSocket0 = fTPSServerSocketFactory0.createServerSocket();
      ServerSocket serverSocket1 = fTPSServerSocketFactory0.init(serverSocket0);
}"
2715,"    public ServerSocket createServerSocket() throws IOException {
        return init(getServerSocketFactory().createServerSocket());
    }","  public void test10()  throws Throwable  {
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSServerSocketFactory0.createServerSocket();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSServerSocketFactory"", e);
      }
  }"
2716,"    public ServerSocket createServerSocket() throws IOException {
        return init(getServerSocketFactory().createServerSocket());
    }","  public void test11()  throws Throwable  {
      FTPSServerSocketFactory fTPSServerSocketFactory0 = new FTPSServerSocketFactory((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSServerSocketFactory0.createServerSocket(0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSServerSocketFactory"", e);
      }
  }"
2717,"    public void checkServerTrusted(final X509Certificate[] certificates, final String authType) throws CertificateException
    {
        for (final X509Certificate certificate : certificates)
        {
            certificate.checkValidity();
        }
    }","  public void test0()  throws Throwable  {
      FTPSTrustManager fTPSTrustManager0 = new FTPSTrustManager();
      // Undeclared exception!
      try { 
        fTPSTrustManager0.checkServerTrusted((X509Certificate[]) null, (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSTrustManager"", e);
      }
  }"
2718,"    public void checkServerTrusted(final X509Certificate[] certificates, final String authType) throws CertificateException
    {
        for (final X509Certificate certificate : certificates)
        {
            certificate.checkValidity();
        }
    }","  public void test1()  throws Throwable  {
      FTPSTrustManager fTPSTrustManager0 = new FTPSTrustManager();
      X509Certificate[] x509CertificateArray0 = new X509Certificate[1];
      X509Certificate x509Certificate0 = mock(X509Certificate.class, new ViolatedAssumptionAnswer());
      x509CertificateArray0[0] = x509Certificate0;
      fTPSTrustManager0.checkServerTrusted(x509CertificateArray0, ""HLuV:"");
}"
2719,"    public X509Certificate[] getAcceptedIssuers()
    {
        return NetConstants.EMPTY_X509_CERTIFICATE_ARRAY;
    }","  public void test2()  throws Throwable  {
      FTPSTrustManager fTPSTrustManager0 = new FTPSTrustManager();
      X509Certificate[] x509CertificateArray0 = fTPSTrustManager0.getAcceptedIssuers();
}"
2720,"    public void checkClientTrusted(final X509Certificate[] certificates, final String authType)
    {
    }","  public void test3()  throws Throwable  {
      FTPSTrustManager fTPSTrustManager0 = new FTPSTrustManager();
      X509Certificate[] x509CertificateArray0 = new X509Certificate[1];
      fTPSTrustManager0.checkClientTrusted(x509CertificateArray0, ""HLuV:"");
}"
2721,"    public static boolean isProtectedReplyCode(final int reply)
    {
        // actually, only 3 protected reply codes are
        // defined in RFC 2228: 631, 632 and 633.
        return reply >= 600 && reply < 700;
    }","  public void test0()  throws Throwable  {
      boolean boolean0 = FTPReply.isProtectedReplyCode(700);
}"
2722,"    public static boolean isProtectedReplyCode(final int reply)
    {
        // actually, only 3 protected reply codes are
        // defined in RFC 2228: 631, 632 and 633.
        return reply >= 600 && reply < 700;
    }","  public void test1()  throws Throwable  {
      boolean boolean0 = FTPReply.isProtectedReplyCode(600);
}"
2723,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test2()  throws Throwable  {
      boolean boolean0 = FTPReply.isNegativePermanent(600);
}"
2724,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test3()  throws Throwable  {
      boolean boolean0 = FTPReply.isNegativePermanent(500);
}"
2725,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test4()  throws Throwable  {
      boolean boolean0 = FTPReply.isNegativeTransient(500);
}"
2726,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test5()  throws Throwable  {
      boolean boolean0 = FTPReply.isNegativeTransient(400);
}"
2727,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test6()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositiveIntermediate(400);
}"
2728,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test7()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositiveIntermediate(300);
}"
2729,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test8()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositiveCompletion(300);
}"
2730,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test9()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositiveCompletion(200);
}"
2731,"    public static boolean isPositivePreliminary(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test10()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositivePreliminary(200);
}"
2732,"    public static boolean isProtectedReplyCode(final int reply)
    {
        // actually, only 3 protected reply codes are
        // defined in RFC 2228: 631, 632 and 633.
        return reply >= 600 && reply < 700;
    }","  public void test11()  throws Throwable  {
      boolean boolean0 = FTPReply.isProtectedReplyCode(1210);
}"
2733,"    public static boolean isProtectedReplyCode(final int reply)
    {
        // actually, only 3 protected reply codes are
        // defined in RFC 2228: 631, 632 and 633.
        return reply >= 600 && reply < 700;
    }","  public void test12()  throws Throwable  {
      boolean boolean0 = FTPReply.isProtectedReplyCode(287);
}"
2734,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test13()  throws Throwable  {
      boolean boolean0 = FTPReply.isNegativePermanent(622);
}"
2735,"    public static boolean isNegativePermanent(final int reply)
    {
        return reply >= 500 && reply < 600;
    }","  public void test14()  throws Throwable  {
      boolean boolean0 = FTPReply.isNegativePermanent(197);
}"
2736,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test15()  throws Throwable  {
      boolean boolean0 = FTPReply.isNegativeTransient(553);
}"
2737,"    public static boolean isNegativeTransient(final int reply)
    {
        return reply >= 400 && reply < 500;
    }","  public void test16()  throws Throwable  {
      boolean boolean0 = FTPReply.isNegativeTransient((-1));
}"
2738,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test17()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositiveIntermediate(409);
}"
2739,"    public static boolean isPositiveIntermediate(final int reply)
    {
        return reply >= 300 && reply < 400;
    }","  public void test18()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositiveIntermediate((-1));
}"
2740,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test19()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositiveCompletion(409);
}"
2741,"    public static boolean isPositiveCompletion(final int reply)
    {
        return reply >= 200 && reply < 300;
    }","  public void test20()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositiveCompletion((-1));
}"
2742,"    public static boolean isPositivePreliminary(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test21()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositivePreliminary(553);
}"
2743,"    public static boolean isPositivePreliminary(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test22()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositivePreliminary(100);
}"
2744,"    public static boolean isPositivePreliminary(final int reply)
    {
        return reply >= 100 && reply < 200;
    }","  public void test23()  throws Throwable  {
      boolean boolean0 = FTPReply.isPositivePreliminary(0);
}"
2745,,"  public void test0()  throws Throwable  {
      FTPCmd[] fTPCmdArray0 = FTPCmd.values();
}"
2746,,"  public void test1()  throws Throwable  {
      FTPCmd fTPCmd0 = FTPCmd.valueOf(""DELE"");
}"
2747,"    public final String getCommand()
    {
        return this.name();
    }","  public void test2()  throws Throwable  {
      FTPCmd fTPCmd0 = FTPCmd.REST;
      String string0 = fTPCmd0.getCommand();
}"
2748,"    public void connect(final String host, final int port) throws SocketException, IOException {

        _socket_ = _socketFactory_.createSocket(proxyHost, proxyPort);
        _input_ = _socket_.getInputStream();
        _output_ = _socket_.getOutputStream();
        final Reader socketIsReader;
        try {
            socketIsReader = tunnelHandshake(host, port, _input_, _output_);
        }
        catch (final Exception e) {
            final IOException ioe = new IOException(""Could not connect to "" + host + "" using port "" + port);
            ioe.initCause(e);
            throw ioe;
        }
        super._connectAction_(socketIsReader);
    }","  public void test0()  throws Throwable  {
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient(""[source="", 13);
      // Undeclared exception!
      try { 
        fTPHTTPClient0.connect(""[source="", 13);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // invalid host/port: [source=:13
         //
         verifyException(""java.net.SocketPermission"", e);
      }
  }"
2749,"    protected Socket _openDataConnection_(final int command, final String arg)
    throws IOException {
        return super._openDataConnection_(command, arg);
    }","  public void test1()  throws Throwable  {
      Charset charset0 = Charset.defaultCharset();
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient(""PO-E"", 4, charset0);
      fTPHTTPClient0.enterLocalPassiveMode();
      // Undeclared exception!
      try { 
        fTPHTTPClient0._openDataConnection_(""q"", ""\""?zwtD)~:=pp:"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2750,"    protected Socket _openDataConnection_(final int command, final String arg)
    throws IOException {
        return super._openDataConnection_(command, arg);
    }","  public void test2()  throws Throwable  {
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient("""", 3);
      // Undeclared exception!
      try { 
        fTPHTTPClient0._openDataConnection_("""", """");
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Only passive connection mode supported
         //
         verifyException(""org.apache.commons.net.ftp.FTPHTTPClient"", e);
      }
  }"
2751,"    protected Socket _openDataConnection_(final int command, final String arg)
    throws IOException {
        return super._openDataConnection_(command, arg);
    }","  public void test3()  throws Throwable  {
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient((String) null, 0, (String) null, (String) null);
      // Undeclared exception!
      try { 
        fTPHTTPClient0._openDataConnection_(1606, (String) null);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1606
         //
         verifyException(""org.apache.commons.net.ftp.FTPCommand"", e);
      }
  }"
2752,"    public FTPHTTPClient(final String proxyHost, final int proxyPort, final String proxyUser, final String proxyPass,
            final Charset encoding) {
        this.proxyHost = proxyHost;
        this.proxyPort = proxyPort;
        this.proxyUsername = proxyUser;
        this.proxyPassword = proxyPass;
        this.tunnelHost = null;
        this.charset = encoding;
    }","  public void test4()  throws Throwable  {
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient(""j1IQn/"", (-1441), ""j1IQn/"", ""j1IQn/"", (Charset) null);
}"
2753,"    public void connect(final String host, final int port) throws SocketException, IOException {

        _socket_ = _socketFactory_.createSocket(proxyHost, proxyPort);
        _input_ = _socket_.getInputStream();
        _output_ = _socket_.getOutputStream();
        final Reader socketIsReader;
        try {
            socketIsReader = tunnelHandshake(host, port, _input_, _output_);
        }
        catch (final Exception e) {
            final IOException ioe = new IOException(""Could not connect to "" + host + "" using port "" + port);
            ioe.initCause(e);
            throw ioe;
        }
        super._connectAction_(socketIsReader);
    }","  public void test5()  throws Throwable  {
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 3393);
      NetworkHandling.openRemoteTcpServer(evoSuiteRemoteAddress0);
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient(""e+"", 3393, ""e+"", (String) null);
      fTPHTTPClient0.setProxy((Proxy) null);
      try { 
        fTPHTTPClient0.connect(""org.apache.commons.net.ftp.systemType"", 3393);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not connect to org.apache.commons.net.ftp.systemType using port 3393
         //
         verifyException(""org.apache.commons.net.ftp.FTPHTTPClient"", e);
      }
  }"
2754,"    public void connect(final String host, final int port) throws SocketException, IOException {

        _socket_ = _socketFactory_.createSocket(proxyHost, proxyPort);
        _input_ = _socket_.getInputStream();
        _output_ = _socket_.getOutputStream();
        final Reader socketIsReader;
        try {
            socketIsReader = tunnelHandshake(host, port, _input_, _output_);
        }
        catch (final Exception e) {
            final IOException ioe = new IOException(""Could not connect to "" + host + "" using port "" + port);
            ioe.initCause(e);
            throw ioe;
        }
        super._connectAction_(socketIsReader);
    }","  public void test6()  throws Throwable  {
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 3393);
      NetworkHandling.openRemoteTcpServer(evoSuiteRemoteAddress0);
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient(""e+"", 3393, ""e+"", ""e+"");
      fTPHTTPClient0.setProxy((Proxy) null);
      try { 
        fTPHTTPClient0.connect(""org.apache.commons.net.ftp.systemType.default"", 3393);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not connect to org.apache.commons.net.ftp.systemType.default using port 3393
         //
         verifyException(""org.apache.commons.net.ftp.FTPHTTPClient"", e);
      }
  }"
2755,"    public void connect(final String host, final int port) throws SocketException, IOException {

        _socket_ = _socketFactory_.createSocket(proxyHost, proxyPort);
        _input_ = _socket_.getInputStream();
        _output_ = _socket_.getOutputStream();
        final Reader socketIsReader;
        try {
            socketIsReader = tunnelHandshake(host, port, _input_, _output_);
        }
        catch (final Exception e) {
            final IOException ioe = new IOException(""Could not connect to "" + host + "" using port "" + port);
            ioe.initCause(e);
            throw ioe;
        }
        super._connectAction_(socketIsReader);
    }","  public void test7()  throws Throwable  {
      EvoSuiteRemoteAddress evoSuiteRemoteAddress0 = new EvoSuiteRemoteAddress(""200.42.42.0"", 3393);
      NetworkHandling.openRemoteTcpServer(evoSuiteRemoteAddress0);
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient(""+"", 3393);
      fTPHTTPClient0.setProxy((Proxy) null);
      try { 
        fTPHTTPClient0.connect(""org.apache.commons.net.ftp.systemType.default"", 3393);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not connect to org.apache.commons.net.ftp.systemType.default using port 3393
         //
         verifyException(""org.apache.commons.net.ftp.FTPHTTPClient"", e);
      }
  }"
2756,"    protected Socket _openDataConnection_(final int command, final String arg)
    throws IOException {
        return super._openDataConnection_(command, arg);
    }","  public void test8()  throws Throwable  {
      Charset charset0 = Charset.defaultCharset();
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient("""", 450, charset0);
      fTPHTTPClient0.enterLocalPassiveMode();
      // Undeclared exception!
      try { 
        fTPHTTPClient0._openDataConnection_(0, ""org.apache.commons.net.ftp.systemType.default"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2757,"    protected Socket _openDataConnection_(final int command, final String arg)
    throws IOException {
        return super._openDataConnection_(command, arg);
    }","  public void test9()  throws Throwable  {
      Charset charset0 = Charset.defaultCharset();
      FTPHTTPClient fTPHTTPClient0 = new FTPHTTPClient("""", 450, charset0);
      // Undeclared exception!
      try { 
        fTPHTTPClient0._openDataConnection_(0, ""org.apache.commons.net.ftp.systemType.default"");
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Only passive connection mode supported
         //
         verifyException(""org.apache.commons.net.ftp.FTPHTTPClient"", e);
      }
  }"
2758,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test0()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
}"
2759,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test1()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset(0L);
}"
2760,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test2()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset(0L);
}"
2761,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test3()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset(0L);
}"
2762,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test4()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset(0L);
}"
2763,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test5()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset(0L);
}"
2764,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test6()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset(0L);
}"
2765,"    protected void _parseExtendedPassiveModeReply(String reply) throws MalformedServerReplyException {
        reply = reply.substring(reply.indexOf('(') + 1, reply.indexOf(')')).trim();

        final char delim1 = reply.charAt(0);
        final char delim2 = reply.charAt(1);
        final char delim3 = reply.charAt(2);
        final char delim4 = reply.charAt(reply.length() - 1);

        if ((delim1 != delim2) || (delim2 != delim3) || (delim3 != delim4)) {
            throw new MalformedServerReplyException(
                ""Could not parse extended passive host information.\nServer Reply: "" + reply);
        }

        final int port;
        try {
            port = Integer.parseInt(reply.substring(3, reply.length() - 1));
        } catch (final NumberFormatException e) {
            throw new MalformedServerReplyException(
                ""Could not parse extended passive host information.\nServer Reply: "" + reply);
        }

        // in EPSV mode, the passive host address is implicit
        this.passiveHost = getRemoteAddress().getHostAddress();
        this.passivePort = port;
    }","  public void test7()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0._parseExtendedPassiveModeReply(""pcyj'&)q]QR#"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not parse extended passive host information.
         // Server Reply: pcyj'&
         //
         verifyException(""org.apache.commons.net.ftp.FTPClient"", e);
      }
  }"
2766,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test8()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve("""");
}"
2767,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test9()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve("""");
}"
2768,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test10()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve("""");
}"
2769,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test11()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve("""");
}"
2770,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test12()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve("""");
}"
2771,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test13()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve("""");
}"
2772,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test14()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve("""");
}"
2773,"    static String parsePathname(final String reply)
    {
        final String param = reply.substring(REPLY_CODE_LEN + 1);
        if (param.startsWith(""\"""")) {
            final StringBuilder sb = new StringBuilder();
            boolean quoteSeen = false;
            // start after initial quote
            for(int i=1; i < param.length(); i++) {
                final char ch = param.charAt(i);
                if (ch=='""') {
                    if (quoteSeen) {
                        sb.append(ch);
                        quoteSeen=false;
                    } else {
                        // don't output yet, in case doubled
                        quoteSeen=true;
                    }
                } else {
                    if (quoteSeen) { // found lone trailing quote within string
                        return sb.toString();
                    }
                    sb.append(ch); // just another character
                }
            }
            if (quoteSeen) { // found lone trailing quote at end of string
                return sb.toString();
            }
        }
        // malformed reply, return all after reply code and space
        return param;
    }","  public void test15()  throws Throwable  {
      String string0 = FTPClient.parsePathname(""USER"");
}"
2774,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test16()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments((String) null);
}"
2775,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test17()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments((String) null);
}"
2776,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test18()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments((String) null);
}"
2777,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test19()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments((String) null);
}"
2778,"    protected String getListArguments(final String pathname) {
        if (getListHiddenFiles())
        {
            if (pathname != null)
            {
                final StringBuilder sb = new StringBuilder(pathname.length() + 3);
                sb.append(""-a "");
                sb.append(pathname);
                return sb.toString();
            }
            return ""-a"";
        }

        return pathname;
    }","  public void test20()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments((String) null);
}"
2779,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test21()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments((String) null);
}"
2780,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test22()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments((String) null);
}"
2781,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test23()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments("""");
}"
2782,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test24()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments("""");
}"
2783,"    protected String getListArguments(final String pathname) {
        if (getListHiddenFiles())
        {
            if (pathname != null)
            {
                final StringBuilder sb = new StringBuilder(pathname.length() + 3);
                sb.append(""-a "");
                sb.append(pathname);
                return sb.toString();
            }
            return ""-a"";
        }

        return pathname;
    }","  public void test25()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments("""");
}"
2784,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test26()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments("""");
}"
2785,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test27()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments("""");
}"
2786,"    protected String getListArguments(final String pathname) {
        if (getListHiddenFiles())
        {
            if (pathname != null)
            {
                final StringBuilder sb = new StringBuilder(pathname.length() + 3);
                sb.append(""-a "");
                sb.append(pathname);
                return sb.toString();
            }
            return ""-a"";
        }

        return pathname;
    }","  public void test28()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments("""");
}"
2787,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test29()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments("""");
}"
2788,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test30()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments("""");
}"
2789,"    public boolean setFileType(final int fileType) throws IOException
    {
        if (FTPReply.isPositiveCompletion(type(fileType)))
        {
            this.fileType = fileType;
            this.fileFormat = FTP.NON_PRINT_TEXT_FORMAT;
            return true;
        }
        return false;
    }","  public void test31()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.setFileType(229, 2526);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2790,"    public boolean setFileType(final int fileType) throws IOException
    {
        if (FTPReply.isPositiveCompletion(type(fileType)))
        {
            this.fileType = fileType;
            this.fileFormat = FTP.NON_PRINT_TEXT_FORMAT;
            return true;
        }
        return false;
    }","  public void test32()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.setFileType(0, 0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2791,"    public boolean setFileType(final int fileType) throws IOException
    {
        if (FTPReply.isPositiveCompletion(type(fileType)))
        {
            this.fileType = fileType;
            this.fileFormat = FTP.NON_PRINT_TEXT_FORMAT;
            return true;
        }
        return false;
    }","  public void test33()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.setFileType((-61));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2792,"    public boolean setFileType(final int fileType) throws IOException
    {
        if (FTPReply.isPositiveCompletion(type(fileType)))
        {
            this.fileType = fileType;
            this.fileFormat = FTP.NON_PRINT_TEXT_FORMAT;
            return true;
        }
        return false;
    }","  public void test34()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.setFileType(12);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2793,"    public boolean setFileTransferMode(final int mode) throws IOException
    {
        if (FTPReply.isPositiveCompletion(mode(mode)))
        {
            fileTransferMode = mode;
            return true;
        }
        return false;
    }","  public void test35()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.setFileTransferMode(119);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2794,"    public boolean setFileTransferMode(final int mode) throws IOException
    {
        if (FTPReply.isPositiveCompletion(mode(mode)))
        {
            fileTransferMode = mode;
            return true;
        }
        return false;
    }","  public void test36()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.setFileTransferMode(2);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2795,"    public boolean setFileStructure(final int structure) throws IOException
    {
        if (FTPReply.isPositiveCompletion(stru(structure)))
        {
            fileStructure = structure;
            return true;
        }
        return false;
    }","  public void test37()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.setFileStructure(1411);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2796,"    public boolean setFileStructure(final int structure) throws IOException
    {
        if (FTPReply.isPositiveCompletion(stru(structure)))
        {
            fileStructure = structure;
            return true;
        }
        return false;
    }","  public void test38()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.setFileStructure(3);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2797,"    public boolean sendSiteCommand(final String arguments) throws IOException
    {
        return FTPReply.isPositiveCompletion(site(arguments));
    }","  public void test39()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      StringWriter stringWriter0 = new StringWriter(5);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(stringWriter0, false);
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
      fTPClient0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTPClient0.sendSiteCommand(""e.~+Ec& *Wj9WX-]$m5"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2798,"    public boolean rename(final String from, final String to) throws IOException
    {
        if (!FTPReply.isPositiveIntermediate(rnfr(from))) {
            return false;
        }

        return FTPReply.isPositiveCompletion(rnto(to));
    }","  public void test40()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.rename(""CHANGE_WORKING_DIRECTORY"", ""(P*1^]HP3<LmWv+WB8^"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2799,"    public boolean reinitialize() throws IOException
    {
        rein();

        if (FTPReply.isPositiveCompletion(_replyCode) ||
                (FTPReply.isPositivePreliminary(_replyCode) &&
                        FTPReply.isPositiveCompletion(getReply())))
        {

            initDefaults();

            return true;
        }

        return false;
    }","  public void test41()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.reinitialize();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2800,"    public String printWorkingDirectory() throws IOException
    {
        if (pwd() != FTPReply.PATHNAME_CREATED) {
            return null;
        }

        return parsePathname(_replyLines.get( _replyLines.size() - 1));
    }","  public void test42()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.printWorkingDirectory();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2801,"    static String parsePathname(final String reply)
    {
        final String param = reply.substring(REPLY_CODE_LEN + 1);
        if (param.startsWith(""\"""")) {
            final StringBuilder sb = new StringBuilder();
            boolean quoteSeen = false;
            // start after initial quote
            for(int i=1; i < param.length(); i++) {
                final char ch = param.charAt(i);
                if (ch=='""') {
                    if (quoteSeen) {
                        sb.append(ch);
                        quoteSeen=false;
                    } else {
                        // don't output yet, in case doubled
                        quoteSeen=true;
                    }
                } else {
                    if (quoteSeen) { // found lone trailing quote within string
                        return sb.toString();
                    }
                    sb.append(ch); // just another character
                }
            }
            if (quoteSeen) { // found lone trailing quote at end of string
                return sb.toString();
            }
        }
        // malformed reply, return all after reply code and space
        return param;
    }","  public void test43()  throws Throwable  {
      // Undeclared exception!
      try { 
        FTPClient.parsePathname(""\"""");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2802,"    static String parsePathname(final String reply)
    {
        final String param = reply.substring(REPLY_CODE_LEN + 1);
        if (param.startsWith(""\"""")) {
            final StringBuilder sb = new StringBuilder();
            boolean quoteSeen = false;
            // start after initial quote
            for(int i=1; i < param.length(); i++) {
                final char ch = param.charAt(i);
                if (ch=='""') {
                    if (quoteSeen) {
                        sb.append(ch);
                        quoteSeen=false;
                    } else {
                        // don't output yet, in case doubled
                        quoteSeen=true;
                    }
                } else {
                    if (quoteSeen) { // found lone trailing quote within string
                        return sb.toString();
                    }
                    sb.append(ch); // just another character
                }
            }
            if (quoteSeen) { // found lone trailing quote at end of string
                return sb.toString();
            }
        }
        // malformed reply, return all after reply code and space
        return param;
    }","  public void test44()  throws Throwable  {
      // Undeclared exception!
      try { 
        FTPClient.parsePathname((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPClient"", e);
      }
  }"
2803,"    public FTPFile mlistFile(final String pathname) throws IOException
    {
        final boolean success = FTPReply.isPositiveCompletion(sendCommand(FTPCmd.MLST, pathname));
        if (success){
            String reply = getReplyString(1);
            // some FTP server reply not contains space before fact(s)
            if(reply.charAt(0) != ' ') { reply = "" "" + reply; }
            /* check the response makes sense.
             * Must have space before fact(s) and between fact(s) and file name
             * Fact(s) can be absent, so at least 3 chars are needed.
             */
            if (reply.length() < 3) {
                throw new MalformedServerReplyException(""Invalid server reply (MLST): '"" + reply + ""'"");
            }
            // some FTP server reply contains more than one space before fact(s)
            final String entry = reply.replaceAll(""^\\s+"", """"); // skip leading space for parser
            return MLSxEntryParser.parseEntry(entry);
        }
        return null;
    }","  public void test45()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.mlistFile("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2804,"    public FTPFile mdtmFile(final String pathname) throws IOException {
        final String modificationTime = getModificationTime(pathname);
        if (modificationTime != null) {
            final FTPFile file = new FTPFile();
            file.setName(pathname);
            file.setRawListing(modificationTime);
            file.setTimestamp(MLSxEntryParser.parseGMTdateTime(modificationTime));
            return file;
        }
        return null;
    }","  public void test46()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.mdtmFile(""org.apache.commons.net.ftp.systemType"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2805,"    public Calendar mdtmCalendar(final String pathname) throws IOException {
        final String modificationTime = getModificationTime(pathname);
        if (modificationTime != null) {
            return MLSxEntryParser.parseGMTdateTime(modificationTime);
        }
        return null;
    }","  public void test47()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.mdtmCalendar(""da"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2806,"    public boolean login(final String username, final String password) throws IOException
    {

        user(username);

        if (FTPReply.isPositiveCompletion(_replyCode)) {
            return true;
        }

        // If we get here, we either have an error code, or an intermmediate
        // reply requesting password.
        if (!FTPReply.isPositiveIntermediate(_replyCode)) {
            return false;
        }

        return FTPReply.isPositiveCompletion(pass(password));
    }","  public void test48()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.login(""%654"", ""org.apache.commons.net.ftp.systemType.default"", ""%654"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2807,"    public boolean login(final String username, final String password) throws IOException
    {

        user(username);

        if (FTPReply.isPositiveCompletion(_replyCode)) {
            return true;
        }

        // If we get here, we either have an error code, or an intermmediate
        // reply requesting password.
        if (!FTPReply.isPositiveIntermediate(_replyCode)) {
            return false;
        }

        return FTPReply.isPositiveCompletion(pass(password));
    }","  public void test49()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.login((String) null, (String) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2808,"    public String[] listNames() throws IOException
    {
        return listNames(null);
    }","  public void test50()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.listNames(""T#K`5`.9*Mm"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2809,"    public String listHelp() throws IOException {
        return FTPReply.isPositiveCompletion(help()) ? getReplyString() : null;
    }","  public void test51()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      MockFileWriter mockFileWriter0 = new MockFileWriter(""k"", false);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, false);
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
      fTPClient0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTPClient0.listHelp(""SMNT"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2810,"    public String listHelp() throws IOException {
        return FTPReply.isPositiveCompletion(help()) ? getReplyString() : null;
    }","  public void test52()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.listHelp(""u6!"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2811,"    public String listHelp() throws IOException {
        return FTPReply.isPositiveCompletion(help()) ? getReplyString() : null;
    }","  public void test53()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.listHelp();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2812,"    public FTPListParseEngine initiateMListParsing() throws IOException
    {
        return initiateMListParsing(null);
    }","  public void test54()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.initiateMListParsing((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2813,"    public FTPListParseEngine initiateListParsing()
    throws IOException
    {
        return initiateListParsing((String) null);
    }","  public void test55()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setParserFactory((FTPFileEntryParserFactory) null);
      // Undeclared exception!
      try { 
        fTPClient0.initiateListParsing("" %1$tY-%1$tm-%1$td"", "" %1$tY-%1$tm-%1$td"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPClient"", e);
      }
  }"
2814,"    public FTPListParseEngine initiateListParsing()
    throws IOException
    {
        return initiateListParsing((String) null);
    }","  public void test56()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.initiateListParsing((String) null, (String) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2815,"    public boolean hasFeature(final FTPCmd feature) throws IOException {
        return hasFeature(feature.name());
    }","  public void test57()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.hasFeature((FTPCmd) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPClient"", e);
      }
  }"
2816,"    public boolean hasFeature(final FTPCmd feature) throws IOException {
        return hasFeature(feature.name());
    }","  public void test58()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.hasFeature("""", """");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2817,"    public boolean hasFeature(final FTPCmd feature) throws IOException {
        return hasFeature(feature.name());
    }","  public void test59()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.hasFeature(""vUY|Q'X1Mh"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2818,"    public String getStatus() throws IOException
    {
        if (FTPReply.isPositiveCompletion(stat())) {
            return getReplyString();
        }
        return null;
    }","  public void test60()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.getStatus("";6~Q"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2819,"    public String getStatus() throws IOException
    {
        if (FTPReply.isPositiveCompletion(stat())) {
            return getReplyString();
        }
        return null;
    }","  public void test61()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.getStatus();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2820,"    public String getSize(final String pathname) throws IOException
    {
        if (FTPReply.isPositiveCompletion(size(pathname))) {
            return getReplyString(0).substring(4); // skip the return code (e.g. 213) and the space
        }
        return null;
    }","  public void test62()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.getSize(""2hat0O"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2821,"    public String getModificationTime(final String pathname) throws IOException {
        if (FTPReply.isPositiveCompletion(mdtm(pathname))) {
            // skip the return code (e.g. 213) and the space
            return getReplyString(0).substring(4);
        }
        return null;
    }","  public void test63()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.getModificationTime((String) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2822,"    public String[] featureValues(final String feature) throws IOException {
        if (!initFeatureMap()) {
            return null;
        }
        final Set<String> entries = featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
        if (entries != null) {
            return entries.toArray(NetConstants.EMPTY_STRING_ARRAY);
        }
        return null;
    }","  public void test64()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.featureValues(""-r{|\""H]i&asz{>"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2823,"    public String featureValue(final String feature) throws IOException {
        final String [] values = featureValues(feature);
        if (values != null) {
            return values[0];
        }
        return null;
    }","  public void test65()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.featureValue("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2824,"    public boolean enterRemotePassiveMode() throws IOException
    {
        if (pasv() != FTPReply.ENTERING_PASSIVE_MODE) {
            return false;
        }

        dataConnectionMode = PASSIVE_REMOTE_DATA_CONNECTION_MODE;
        _parsePassiveModeReply(_replyLines.get(0));

        return true;
    }","  public void test66()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      MockFileWriter mockFileWriter0 = new MockFileWriter(""\r\n"", true);
      BufferedWriter bufferedWriter0 = new BufferedWriter(mockFileWriter0);
      fTPClient0._controlOutput_ = bufferedWriter0;
      // Undeclared exception!
      try { 
        fTPClient0.enterRemotePassiveMode();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2825,"    public boolean enterRemotePassiveMode() throws IOException
    {
        if (pasv() != FTPReply.ENTERING_PASSIVE_MODE) {
            return false;
        }

        dataConnectionMode = PASSIVE_REMOTE_DATA_CONNECTION_MODE;
        _parsePassiveModeReply(_replyLines.get(0));

        return true;
    }","  public void test67()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.enterRemotePassiveMode();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2826,"    public boolean enterRemoteActiveMode(final InetAddress host, final int port)
    throws IOException
    {
        if (FTPReply.isPositiveCompletion(port(host, port)))
        {
            dataConnectionMode = ACTIVE_REMOTE_DATA_CONNECTION_MODE;
            passiveHost = null;
            passivePort = -1;
            return true;
        }
        return false;
    }","  public void test68()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.enterRemoteActiveMode((InetAddress) null, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.mock.java.net.MockInetAddress"", e);
      }
  }"
2827,"    public boolean enterRemoteActiveMode(final InetAddress host, final int port)
    throws IOException
    {
        if (FTPReply.isPositiveCompletion(port(host, port)))
        {
            dataConnectionMode = ACTIVE_REMOTE_DATA_CONNECTION_MODE;
            passiveHost = null;
            passivePort = -1;
            return true;
        }
        return false;
    }","  public void test69()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      InetAddress inetAddress0 = InetAddress.getLoopbackAddress();
      try { 
        fTPClient0.enterRemoteActiveMode(inetAddress0, (-2032));
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2828,"    public String[] doCommandAsStrings(final String command, final String params) throws IOException
    {
        final boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
        if (success){
            return getReplyStrings();
        }
        return null;
    }","  public void test70()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.doCommandAsStrings(""8:1S^-43!j33l"", ""-a "");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2829,"    void createParser(final String parserKey) throws IOException {
        // We cache the value to avoid creation of a new object every
        // time a file listing is generated.
        // Note: we don't check against a null parserKey (NET-544)
        if(entryParser == null ||  (parserKey != null && ! entryParserKey.equals(parserKey))) {
            if (null != parserKey) {
                // if a parser key was supplied in the parameters,
                // use that to create the parser
                entryParser =
                    parserFactory.createFileEntryParser(parserKey);
                entryParserKey = parserKey;

            } else {
                // if no parserKey was supplied, check for a configuration
                // in the params, and if it has a non-empty system type, use that.
                if (null != configuration && configuration.getServerSystemKey().length() > 0) {
                    entryParser =
                        parserFactory.createFileEntryParser(configuration);
                    entryParserKey = configuration.getServerSystemKey();
                } else {
                    // if a parserKey hasn't been supplied, and a configuration
                    // hasn't been supplied, and the override property is not set
                    // then autodetect by calling
                    // the SYST command and use that to choose the parser.
                    String systemType = System.getProperty(FTP_SYSTEM_TYPE);
                    if (systemType == null) {
                        systemType = getSystemType(); // cannot be null
                        final Properties override = getOverrideProperties();
                        if (override != null) {
                            final String newType = override.getProperty(systemType);
                            if (newType != null) {
                                systemType = newType;
                            }
                        }
                    }
                    if (null != configuration) { // system type must have been empty above
                        entryParser = parserFactory.createFileEntryParser(new FTPClientConfig(systemType, configuration));
                    } else {
                        entryParser = parserFactory.createFileEntryParser(systemType);
                    }
                    entryParserKey = systemType;
                }
            }
        }
    }","  public void test71()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.createParser((String) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2830,"    protected OutputStream _storeFileStream(final String command, final String remote)
    throws IOException
    {
        final Socket socket = _openDataConnection_(command, remote);

        if (socket == null) {
            return null;
        }

        final OutputStream output;
        if (fileType == ASCII_FILE_TYPE) {
            // We buffer ascii transfers because the buffering has to
            // be interposed between ToNetASCIIOutputSream and the underlying
            // socket output stream.  We don't buffer binary transfers
            // because we don't want to impose a buffering policy on the
            // programmer if possible.  Programmers can decide on their
            // own if they want to wrap the SocketOutputStream we return
            // for file types other than ASCII.
            output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
        } else {
            output = socket.getOutputStream();
        }
        return new SocketOutputStream(socket, output);
    }","  public void test72()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0._storeFileStream(""P5uz>F:}Rrqz1/5%!"", ""|+l3r^P* `pv=Sq-.(s"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2831,"    protected boolean _storeFile(final String command, final String remote, final InputStream local)
    throws IOException
    {
        final Socket socket = _openDataConnection_(command, remote);

        if (socket == null) {
            return false;
        }

        final OutputStream output;

        if (fileType == ASCII_FILE_TYPE) {
            output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
        } else {
            output = getBufferedOutputStream(socket.getOutputStream());
        }

        CSL csl = null;
        if (controlKeepAliveTimeoutMillis > 0) {
            csl = new CSL(this, controlKeepAliveTimeoutMillis, controlKeepAliveReplyTimeoutMillis);
        }

        // Treat everything else as binary for now
        try
        {
            Util.copyStream(local, output, getBufferSize(),
                    CopyStreamEvent.UNKNOWN_STREAM_SIZE, mergeListeners(csl),
                    false);
            output.close(); // ensure the file is fully written
            socket.close(); // done writing the file

            // Get the transfer response
            return completePendingCommand();
        }
        catch (final IOException e)
        {
            Util.closeQuietly(output); // ignore close errors here
            Util.closeQuietly(socket); // ignore close errors here
            throw e;
        } finally {
            if (csl != null) {
                cslDebug = csl.cleanUp(); // fetch any outstanding keepalive replies
            }
        }
    }","  public void test73()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      // Undeclared exception!
      try { 
        fTPClient0._storeFile(""Invalid server reply (MLST): '"", """", sequenceInputStream0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2832,"    protected InputStream _retrieveFileStream(final String command, final String remote)
    throws IOException
    {
        final Socket socket = _openDataConnection_(command, remote);

        if (socket == null) {
            return null;
        }

        final InputStream input;
        if (fileType == ASCII_FILE_TYPE) {
            // We buffer ascii transfers because the buffering has to
            // be interposed between FromNetASCIIOutputSream and the underlying
            // socket input stream.  We don't buffer binary transfers
            // because we don't want to impose a buffering policy on the
            // programmer if possible.  Programmers can decide on their
            // own if they want to wrap the SocketInputStream we return
            // for file types other than ASCII.
            input = new FromNetASCIIInputStream(getBufferedInputStream(socket.getInputStream()));
        } else {
            input = socket.getInputStream();
        }
        return new org.apache.commons.net.io.SocketInputStream(socket, input);
    }","  public void test74()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0._retrieveFileStream(""=A/{p~"", ""=A/{p~"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2833,"    protected boolean _retrieveFile(final String command, final String remote, final OutputStream local)
    throws IOException
    {
        final Socket socket = _openDataConnection_(command, remote);

        if (socket == null) {
            return false;
        }

        InputStream input = null;
        CSL csl = null;
        try {
            try {
                if (fileType == ASCII_FILE_TYPE) {
                    input = new FromNetASCIIInputStream(getBufferedInputStream(socket.getInputStream()));
                } else {
                    input = getBufferedInputStream(socket.getInputStream());
                }

                if (controlKeepAliveTimeoutMillis > 0) {
                    csl = new CSL(this, controlKeepAliveTimeoutMillis, controlKeepAliveReplyTimeoutMillis);
                }

                // Treat everything else as binary for now
                Util.copyStream(input, local, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, mergeListeners(csl),
                    false);
            } finally {
                Util.closeQuietly(input);
            }
            // Get the transfer response
            return completePendingCommand();
        } finally {
            Util.closeQuietly(socket);
            if (csl != null) {
                cslDebug = csl.cleanUp(); // fetch any outstanding keepalive replies
            }
        }
    }","  public void test75()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      File file0 = MockFile.createTempFile(""[Replacing PASV mode reply address "", """");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(file0, true);
      // Undeclared exception!
      try { 
        fTPClient0._retrieveFile(""UTF8"", ""UTF8"", mockFileOutputStream0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2834,"    protected void _parsePassiveModeReply(final String reply) throws MalformedServerReplyException {
        final Matcher m = PARMS_PAT.matcher(reply);
        if (!m.find()) {
            throw new MalformedServerReplyException(
                ""Could not parse passive host information.\nServer Reply: "" + reply);
        }

        this.passiveHost = ""0,0,0,0"".equals(m.group(1)) ? _socket_.getInetAddress().getHostAddress()
            : m.group(1).replace(',', '.'); // Fix up to look like IP address

        try {
            final int oct1 = Integer.parseInt(m.group(2));
            final int oct2 = Integer.parseInt(m.group(3));
            passivePort = (oct1 << 8) | oct2;
        } catch (final NumberFormatException e) {
            throw new MalformedServerReplyException(
                ""Could not parse passive port information.\nServer Reply: "" + reply);
        }

        if (passiveNatWorkaroundStrategy != null) {
            try {
                final String newPassiveHost = passiveNatWorkaroundStrategy.resolve(this.passiveHost);
                if (!this.passiveHost.equals(newPassiveHost)) {
                    fireReplyReceived(0,
                        ""[Replacing PASV mode reply address "" + this.passiveHost + "" with "" + newPassiveHost + ""]\n"");
                    this.passiveHost = newPassiveHost;
                }
            } catch (final UnknownHostException e) { // Should not happen as we are passing in an IP address
                throw new MalformedServerReplyException(
                    ""Could not parse passive host information.\nServer Reply: "" + reply);
            }
        }
    }","  public void test76()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0._parsePassiveModeReply((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
2835,"    protected void _parseExtendedPassiveModeReply(String reply) throws MalformedServerReplyException {
        reply = reply.substring(reply.indexOf('(') + 1, reply.indexOf(')')).trim();

        final char delim1 = reply.charAt(0);
        final char delim2 = reply.charAt(1);
        final char delim3 = reply.charAt(2);
        final char delim4 = reply.charAt(reply.length() - 1);

        if ((delim1 != delim2) || (delim2 != delim3) || (delim3 != delim4)) {
            throw new MalformedServerReplyException(
                ""Could not parse extended passive host information.\nServer Reply: "" + reply);
        }

        final int port;
        try {
            port = Integer.parseInt(reply.substring(3, reply.length() - 1));
        } catch (final NumberFormatException e) {
            throw new MalformedServerReplyException(
                ""Could not parse extended passive host information.\nServer Reply: "" + reply);
        }

        // in EPSV mode, the passive host address is implicit
        this.passiveHost = getRemoteAddress().getHostAddress();
        this.passivePort = port;
    }","  public void test77()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0._parseExtendedPassiveModeReply(""\""W Br("");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
2836,"    protected void _parseExtendedPassiveModeReply(String reply) throws MalformedServerReplyException {
        reply = reply.substring(reply.indexOf('(') + 1, reply.indexOf(')')).trim();

        final char delim1 = reply.charAt(0);
        final char delim2 = reply.charAt(1);
        final char delim3 = reply.charAt(2);
        final char delim4 = reply.charAt(reply.length() - 1);

        if ((delim1 != delim2) || (delim2 != delim3) || (delim3 != delim4)) {
            throw new MalformedServerReplyException(
                ""Could not parse extended passive host information.\nServer Reply: "" + reply);
        }

        final int port;
        try {
            port = Integer.parseInt(reply.substring(3, reply.length() - 1));
        } catch (final NumberFormatException e) {
            throw new MalformedServerReplyException(
                ""Could not parse extended passive host information.\nServer Reply: "" + reply);
        }

        // in EPSV mode, the passive host address is implicit
        this.passiveHost = getRemoteAddress().getHostAddress();
        this.passivePort = port;
    }","  public void test78()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0._parseExtendedPassiveModeReply((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPClient"", e);
      }
  }"
2837,"    protected Socket _openDataConnection_(final FTPCmd command, final String arg)
    throws IOException
    {
        return _openDataConnection_(command.getCommand(), arg);
    }","  public void test79()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPCmd fTPCmd0 = FTPCmd.PORT;
      // Undeclared exception!
      try { 
        fTPClient0._openDataConnection_(fTPCmd0, "">w,;^8e"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2838,"    protected Socket _openDataConnection_(final FTPCmd command, final String arg)
    throws IOException
    {
        return _openDataConnection_(command.getCommand(), arg);
    }","  public void test80()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0._openDataConnection_(1389, "":v tNLiwwXXG/"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1389
         //
         verifyException(""org.apache.commons.net.ftp.FTPCommand"", e);
      }
  }"
2839,"    protected void _connectAction_() throws IOException {
        _connectAction_(null);
    }","  public void test81()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      PipedReader pipedReader0 = new PipedReader();
      // Undeclared exception!
      try { 
        fTPClient0._connectAction_(pipedReader0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
2840,"    public String getSystemType() throws IOException
    {
        //if (syst() == FTPReply.NAME_SYSTEM_TYPE)
        // Technically, we should expect a NAME_SYSTEM_TYPE response, but
        // in practice FTP servers deviate, so we soften the condition to
        // a positive completion.
        if (systemName == null){
            if (FTPReply.isPositiveCompletion(syst())) {
                // Assume that response is not empty here (cannot be null)
                systemName = _replyLines.get(_replyLines.size() - 1).substring(4);
            } else {
                // Check if the user has provided a default for when the SYST command fails
                final String systDefault = System.getProperty(FTP_SYSTEM_TYPE_DEFAULT);
                if (systDefault != null) {
                    systemName = systDefault;
                } else {
                    throw new IOException(""Unable to determine system type - response: "" + getReplyString());
                }
            }
        }
        return systemName;
    }","  public void test82()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.getSystemType();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2841,"    public FTPFile[] listDirectories() throws IOException {
        return listDirectories((String) null);
    }","  public void test83()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.listDirectories(""~GY~2[~oU29bt9u"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2842,"    public FTPFile[] listFiles()
    throws IOException
    {
        return listFiles((String) null);
    }","  public void test84()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPFileFilter fTPFileFilter0 = mock(FTPFileFilter.class, new ViolatedAssumptionAnswer());
      try { 
        fTPClient0.listFiles(""6!|?f#kuuoAXL4=#"", fTPFileFilter0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2843,"    public FTPListParseEngine initiateListParsing()
    throws IOException
    {
        return initiateListParsing((String) null);
    }","  public void test85()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.initiateListParsing("" %1$tY-%1$tm-%1$td"", "" %1$tY-%1$tm-%1$td"");
        fail(""Expecting exception: RuntimeException"");
      } catch(RuntimeException e) {
         //
         // Unknown parser type:  %1$tY-%1$tm-%1$td
         //
         verifyException(""org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory"", e);
      }
  }"
2844,"    public FTPListParseEngine initiateListParsing()
    throws IOException
    {
        return initiateListParsing((String) null);
    }","  public void test86()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.initiateListParsing(""V8b-hsn"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2845,"    public FTPFile[] listFiles()
    throws IOException
    {
        return listFiles((String) null);
    }","  public void test87()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.listFiles("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2846,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test88()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getListHiddenFiles();
}"
2847,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test89()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getListHiddenFiles();
}"
2848,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test90()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getListHiddenFiles();
}"
2849,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test91()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getListHiddenFiles();
}"
2850,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test92()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getListHiddenFiles();
}"
2851,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test93()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getListHiddenFiles();
}"
2852,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test94()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getListHiddenFiles();
}"
2853,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test95()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset(9);
}"
2854,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test96()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset((-5141L));
}"
2855,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test97()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset((-5141L));
}"
2856,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test98()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset((-5141L));
}"
2857,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test99()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset((-5141L));
}"
2858,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test100()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset((-5141L));
}"
2859,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test101()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset((-5141L));
}"
2860,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test102()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRestartOffset((-5141L));
}"
2861,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test103()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(true);
}"
2862,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test104()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(true);
}"
2863,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test105()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(true);
}"
2864,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test106()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(true);
}"
2865,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test107()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(true);
}"
2866,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test108()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(true);
}"
2867,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test109()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(true);
}"
2868,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test110()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(false);
}"
2869,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test111()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(false);
}"
2870,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test112()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(false);
}"
2871,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test113()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(false);
}"
2872,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test114()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(false);
}"
2873,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test115()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(false);
}"
2874,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test116()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveNatWorkaround(false);
}"
2875,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test117()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique(""\""apache.commons.net.ftp.systemType"");
}"
2876,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test118()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique(""\""apache.commons.net.ftp.systemType"");
}"
2877,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test119()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique(""\""apache.commons.net.ftp.systemType"");
}"
2878,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test120()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique(""\""apache.commons.net.ftp.systemType"");
}"
2879,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test121()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique(""\""apache.commons.net.ftp.systemType"");
}"
2880,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test122()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique(""\""apache.commons.net.ftp.systemType"");
}"
2881,"    public boolean remoteStoreUnique() throws IOException
    {
        if (dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||
                dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
            return FTPReply.isPositivePreliminary(stou());
        }
        return false;
    }","  public void test123()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique(""\""apache.commons.net.ftp.systemType"");
}"
2882,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test124()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique(""\""apache.commons.net.ftp.systemType"");
}"
2883,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test125()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique();
}"
2884,"    public boolean remoteStoreUnique() throws IOException
    {
        if (dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||
                dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
            return FTPReply.isPositivePreliminary(stou());
        }
        return false;
    }","  public void test126()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique();
}"
2885,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test127()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique();
}"
2886,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test128()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique();
}"
2887,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test129()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique();
}"
2888,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test130()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique();
}"
2889,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test131()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique();
}"
2890,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test132()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStoreUnique();
}"
2891,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test133()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStore((String) null);
}"
2892,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test134()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStore((String) null);
}"
2893,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test135()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStore((String) null);
}"
2894,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test136()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStore((String) null);
}"
2895,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test137()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStore((String) null);
}"
2896,"    public boolean remoteStore(final String fileName) throws IOException
    {
        if (dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||
                dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
            return FTPReply.isPositivePreliminary(stor(fileName));
        }
        return false;
    }","  public void test138()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStore((String) null);
}"
2897,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test139()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStore((String) null);
}"
2898,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test140()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteStore((String) null);
}"
2899,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test141()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteRetrieve(""org.apache.commons.net.ftp.systemType"");
}"
2900,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test142()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteRetrieve(""org.apache.commons.net.ftp.systemType"");
}"
2901,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test143()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteRetrieve(""org.apache.commons.net.ftp.systemType"");
}"
2902,"    public boolean remoteRetrieve(final String fileName) throws IOException
    {
        if (dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||
                dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
            return FTPReply.isPositivePreliminary(retr(fileName));
        }
        return false;
    }","  public void test144()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteRetrieve(""org.apache.commons.net.ftp.systemType"");
}"
2903,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test145()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteRetrieve(""org.apache.commons.net.ftp.systemType"");
}"
2904,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test146()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteRetrieve(""org.apache.commons.net.ftp.systemType"");
}"
2905,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test147()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteRetrieve(""org.apache.commons.net.ftp.systemType"");
}"
2906,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test148()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteRetrieve(""org.apache.commons.net.ftp.systemType"");
}"
2907,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test149()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
}"
2908,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test150()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteAppend(""org.apache.commons.net.ftp.systemType.default"");
}"
2909,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test151()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteAppend(""org.apache.commons.net.ftp.systemType.default"");
}"
2910,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test152()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteAppend(""org.apache.commons.net.ftp.systemType.default"");
}"
2911,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test153()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteAppend(""org.apache.commons.net.ftp.systemType.default"");
}"
2912,"    public boolean remoteAppend(final String fileName) throws IOException
    {
        if (dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||
                dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
            return FTPReply.isPositivePreliminary(appe(fileName));
        }
        return false;
    }","  public void test154()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteAppend(""org.apache.commons.net.ftp.systemType.default"");
}"
2913,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test155()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteAppend(""org.apache.commons.net.ftp.systemType.default"");
}"
2914,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test156()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteAppend(""org.apache.commons.net.ftp.systemType.default"");
}"
2915,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test157()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.remoteAppend(""org.apache.commons.net.ftp.systemType.default"");
}"
2916,"    public String getSystemName() throws IOException
    {
        if (systemName == null && FTPReply.isPositiveCompletion(syst())) {
            systemName = _replyLines.get(_replyLines.size() - 1).substring(4);
        }
        return systemName;
    }","  public void test158()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.getSystemName();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2917,"    void createParser(final String parserKey) throws IOException {
        // We cache the value to avoid creation of a new object every
        // time a file listing is generated.
        // Note: we don't check against a null parserKey (NET-544)
        if(entryParser == null ||  (parserKey != null && ! entryParserKey.equals(parserKey))) {
            if (null != parserKey) {
                // if a parser key was supplied in the parameters,
                // use that to create the parser
                entryParser =
                    parserFactory.createFileEntryParser(parserKey);
                entryParserKey = parserKey;

            } else {
                // if no parserKey was supplied, check for a configuration
                // in the params, and if it has a non-empty system type, use that.
                if (null != configuration && configuration.getServerSystemKey().length() > 0) {
                    entryParser =
                        parserFactory.createFileEntryParser(configuration);
                    entryParserKey = configuration.getServerSystemKey();
                } else {
                    // if a parserKey hasn't been supplied, and a configuration
                    // hasn't been supplied, and the override property is not set
                    // then autodetect by calling
                    // the SYST command and use that to choose the parser.
                    String systemType = System.getProperty(FTP_SYSTEM_TYPE);
                    if (systemType == null) {
                        systemType = getSystemType(); // cannot be null
                        final Properties override = getOverrideProperties();
                        if (override != null) {
                            final String newType = override.getProperty(systemType);
                            if (newType != null) {
                                systemType = newType;
                            }
                        }
                    }
                    if (null != configuration) { // system type must have been empty above
                        entryParser = parserFactory.createFileEntryParser(new FTPClientConfig(systemType, configuration));
                    } else {
                        entryParser = parserFactory.createFileEntryParser(systemType);
                    }
                    entryParserKey = systemType;
                }
            }
        }
    }","  public void test159()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.createParser(""org.apache.commons.net.ftp.systemType"");
        fail(""Expecting exception: RuntimeException"");
      } catch(RuntimeException e) {
         //
         // Unknown parser type: org.apache.commons.net.ftp.systemType
         //
         verifyException(""org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory"", e);
      }
  }"
2918,"    protected void _parsePassiveModeReply(final String reply) throws MalformedServerReplyException {
        final Matcher m = PARMS_PAT.matcher(reply);
        if (!m.find()) {
            throw new MalformedServerReplyException(
                ""Could not parse passive host information.\nServer Reply: "" + reply);
        }

        this.passiveHost = ""0,0,0,0"".equals(m.group(1)) ? _socket_.getInetAddress().getHostAddress()
            : m.group(1).replace(',', '.'); // Fix up to look like IP address

        try {
            final int oct1 = Integer.parseInt(m.group(2));
            final int oct2 = Integer.parseInt(m.group(3));
            passivePort = (oct1 << 8) | oct2;
        } catch (final NumberFormatException e) {
            throw new MalformedServerReplyException(
                ""Could not parse passive port information.\nServer Reply: "" + reply);
        }

        if (passiveNatWorkaroundStrategy != null) {
            try {
                final String newPassiveHost = passiveNatWorkaroundStrategy.resolve(this.passiveHost);
                if (!this.passiveHost.equals(newPassiveHost)) {
                    fireReplyReceived(0,
                        ""[Replacing PASV mode reply address "" + this.passiveHost + "" with "" + newPassiveHost + ""]\n"");
                    this.passiveHost = newPassiveHost;
                }
            } catch (final UnknownHostException e) { // Should not happen as we are passing in an IP address
                throw new MalformedServerReplyException(
                    ""Could not parse passive host information.\nServer Reply: "" + reply);
            }
        }
    }","  public void test160()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0._parsePassiveModeReply(""JOBNAME"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not parse passive host information.
         // Server Reply: JOBNAME
         //
         verifyException(""org.apache.commons.net.ftp.FTPClient"", e);
      }
  }"
2919,"    protected void _parseExtendedPassiveModeReply(String reply) throws MalformedServerReplyException {
        reply = reply.substring(reply.indexOf('(') + 1, reply.indexOf(')')).trim();

        final char delim1 = reply.charAt(0);
        final char delim2 = reply.charAt(1);
        final char delim3 = reply.charAt(2);
        final char delim4 = reply.charAt(reply.length() - 1);

        if ((delim1 != delim2) || (delim2 != delim3) || (delim3 != delim4)) {
            throw new MalformedServerReplyException(
                ""Could not parse extended passive host information.\nServer Reply: "" + reply);
        }

        final int port;
        try {
            port = Integer.parseInt(reply.substring(3, reply.length() - 1));
        } catch (final NumberFormatException e) {
            throw new MalformedServerReplyException(
                ""Could not parse extended passive host information.\nServer Reply: "" + reply);
        }

        // in EPSV mode, the passive host address is implicit
        this.passiveHost = getRemoteAddress().getHostAddress();
        this.passivePort = port;
    }","  public void test161()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0._parseExtendedPassiveModeReply(""Zpcsyj'&)qQR#"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not parse extended passive host information.
         // Server Reply: Zpcsyj'&
         //
         verifyException(""org.apache.commons.net.ftp.FTPClient"", e);
      }
  }"
2920,"    static String parsePathname(final String reply)
    {
        final String param = reply.substring(REPLY_CODE_LEN + 1);
        if (param.startsWith(""\"""")) {
            final StringBuilder sb = new StringBuilder();
            boolean quoteSeen = false;
            // start after initial quote
            for(int i=1; i < param.length(); i++) {
                final char ch = param.charAt(i);
                if (ch=='""') {
                    if (quoteSeen) {
                        sb.append(ch);
                        quoteSeen=false;
                    } else {
                        // don't output yet, in case doubled
                        quoteSeen=true;
                    }
                } else {
                    if (quoteSeen) { // found lone trailing quote within string
                        return sb.toString();
                    }
                    sb.append(ch); // just another character
                }
            }
            if (quoteSeen) { // found lone trailing quote at end of string
                return sb.toString();
            }
        }
        // malformed reply, return all after reply code and space
        return param;
    }","  public void test162()  throws Throwable  {
      String string0 = FTPClient.parsePathname(""ISO-8859-1"");
}"
2921,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test163()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve(""\""apache.commons.net.ftp.systemType"");
}"
2922,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test164()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve(""\""apache.commons.net.ftp.systemType"");
}"
2923,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test165()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve(""\""apache.commons.net.ftp.systemType"");
}"
2924,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test166()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve(""\""apache.commons.net.ftp.systemType"");
}"
2925,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test167()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve(""\""apache.commons.net.ftp.systemType"");
}"
2926,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test168()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve(""\""apache.commons.net.ftp.systemType"");
}"
2927,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test169()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve(""\""apache.commons.net.ftp.systemType"");
}"
2928,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test170()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient_NatServerResolverImpl0.resolve(""\""apache.commons.net.ftp.systemType"");
}"
2929,"    public boolean logout() throws IOException
    {
        return FTPReply.isPositiveCompletion(quit());
    }","  public void test171()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.logout();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2930,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test172()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      fTPClient0.setPassiveLocalIPAddress(inetAddress0);
}"
2931,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test173()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      fTPClient0.setPassiveLocalIPAddress(inetAddress0);
}"
2932,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test174()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      fTPClient0.setPassiveLocalIPAddress(inetAddress0);
}"
2933,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test175()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      fTPClient0.setPassiveLocalIPAddress(inetAddress0);
}"
2934,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test176()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      fTPClient0.setPassiveLocalIPAddress(inetAddress0);
}"
2935,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test177()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      fTPClient0.setPassiveLocalIPAddress(inetAddress0);
}"
2936,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test178()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      fTPClient0.setPassiveLocalIPAddress(inetAddress0);
}"
2937,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test179()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      fTPClient0.setPassiveLocalIPAddress(inetAddress0);
}"
2938,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test180()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getControlKeepAliveReplyTimeout();
}"
2939,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test181()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getControlKeepAliveReplyTimeout();
}"
2940,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test182()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getControlKeepAliveReplyTimeout();
}"
2941,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test183()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getControlKeepAliveReplyTimeout();
}"
2942,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test184()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getControlKeepAliveReplyTimeout();
}"
2943,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test185()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getControlKeepAliveReplyTimeout();
}"
2944,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test186()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getControlKeepAliveReplyTimeout();
}"
2945,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test187()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getControlKeepAliveReplyTimeout();
}"
2946,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test188()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
}"
2947,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test189()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setControlKeepAliveReplyTimeout(0);
}"
2948,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test190()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActiveExternalIPAddress("" %1$tY-%1$tm-%1$td"");
}"
2949,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test191()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActiveExternalIPAddress("" %1$tY-%1$tm-%1$td"");
}"
2950,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test192()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActiveExternalIPAddress("" %1$tY-%1$tm-%1$td"");
}"
2951,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test193()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActiveExternalIPAddress("" %1$tY-%1$tm-%1$td"");
}"
2952,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test194()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActiveExternalIPAddress("" %1$tY-%1$tm-%1$td"");
}"
2953,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test195()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActiveExternalIPAddress("" %1$tY-%1$tm-%1$td"");
}"
2954,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test196()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActiveExternalIPAddress("" %1$tY-%1$tm-%1$td"");
}"
2955,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test197()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActiveExternalIPAddress("" %1$tY-%1$tm-%1$td"");
}"
2956,"    protected boolean restart(final long offset) throws IOException
    {
        restartOffset = 0;
        return FTPReply.isPositiveIntermediate(rest(Long.toString(offset)));
    }","  public void test198()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.restart((-404L));
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2957,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test199()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isUseEPSVwithIPv4();
}"
2958,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test200()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isUseEPSVwithIPv4();
}"
2959,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test201()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isUseEPSVwithIPv4();
}"
2960,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test202()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isUseEPSVwithIPv4();
}"
2961,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test203()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isUseEPSVwithIPv4();
}"
2962,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test204()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isUseEPSVwithIPv4();
}"
2963,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test205()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isUseEPSVwithIPv4();
}"
2964,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test206()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isUseEPSVwithIPv4();
}"
2965,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test207()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setCopyStreamListener((CopyStreamListener) null);
}"
2966,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test208()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setCopyStreamListener((CopyStreamListener) null);
}"
2967,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test209()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setCopyStreamListener((CopyStreamListener) null);
}"
2968,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test210()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setCopyStreamListener((CopyStreamListener) null);
}"
2969,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test211()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setCopyStreamListener((CopyStreamListener) null);
}"
2970,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test212()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setCopyStreamListener((CopyStreamListener) null);
}"
2971,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test213()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setCopyStreamListener((CopyStreamListener) null);
}"
2972,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test214()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setCopyStreamListener((CopyStreamListener) null);
}"
2973,"    public boolean hasFeature(final FTPCmd feature) throws IOException {
        return hasFeature(feature.name());
    }","  public void test215()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPCmd fTPCmd0 = FTPCmd.PASS;
      try { 
        fTPClient0.hasFeature(fTPCmd0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2974,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test216()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isRemoteVerificationEnabled();
}"
2975,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test217()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isRemoteVerificationEnabled();
}"
2976,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test218()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isRemoteVerificationEnabled();
}"
2977,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test219()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isRemoteVerificationEnabled();
}"
2978,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test220()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isRemoteVerificationEnabled();
}"
2979,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test221()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isRemoteVerificationEnabled();
}"
2980,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test222()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isRemoteVerificationEnabled();
}"
2981,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test223()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.isRemoteVerificationEnabled();
}"
2982,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test224()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getControlKeepAliveTimeout();
}"
2983,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test225()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getControlKeepAliveTimeout();
}"
2984,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test226()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getControlKeepAliveTimeout();
}"
2985,"    public long getControlKeepAliveTimeout() {
        return controlKeepAliveTimeoutMillis / 1000;
    }","  public void test227()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getControlKeepAliveTimeout();
}"
2986,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test228()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getControlKeepAliveTimeout();
}"
2987,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test229()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getControlKeepAliveTimeout();
}"
2988,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test230()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getControlKeepAliveTimeout();
}"
2989,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test231()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getControlKeepAliveTimeout();
}"
2990,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test232()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getControlKeepAliveTimeout();
}"
2991,"    public boolean changeToParentDirectory() throws IOException
    {
        return FTPReply.isPositiveCompletion(cdup());
    }","  public void test233()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.changeToParentDirectory();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
2992,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test234()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getDataConnectionMode();
}"
2993,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test235()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getDataConnectionMode();
}"
2994,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test236()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getDataConnectionMode();
}"
2995,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test237()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getDataConnectionMode();
}"
2996,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test238()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getDataConnectionMode();
}"
2997,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test239()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getDataConnectionMode();
}"
2998,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test240()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getDataConnectionMode();
}"
2999,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test241()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getDataConnectionMode();
}"
3000,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test242()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setAutodetectUTF8(false);
}"
3001,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test243()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setAutodetectUTF8(false);
}"
3002,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test244()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setAutodetectUTF8(false);
}"
3003,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test245()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setAutodetectUTF8(false);
}"
3004,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test246()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setAutodetectUTF8(false);
}"
3005,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test247()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setAutodetectUTF8(false);
}"
3006,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test248()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setAutodetectUTF8(false);
}"
3007,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test249()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setAutodetectUTF8(false);
}"
3008,"    public boolean completePendingCommand() throws IOException
    {
        return FTPReply.isPositiveCompletion(getReply());
    }","  public void test250()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.completePendingCommand();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3009,"    private OutputStream storeFileStream(final FTPCmd command, final String remote)
    throws IOException
    {
        return _storeFileStream(command.getCommand(), remote);
    }","  public void test251()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.storeFileStream("":umM.<V!!hU\fW"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3010,"    public boolean retrieveFile(final String remote, final OutputStream local)
    throws IOException
    {
        return _retrieveFile(FTPCmd.RETR.getCommand(), remote, local);
    }","  public void test252()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      MockFile mockFile0 = new MockFile(""\""~DA%(*@-YY+"", """");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0, false);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      // Undeclared exception!
      try { 
        fTPClient0.retrieveFile(""<8b"", mockPrintStream0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3011,"    public FTPFile[] mlistDir() throws IOException
    {
        return mlistDir(null);
    }","  public void test253()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.mlistDir();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3012,"    public OutputStream appendFileStream(final String remote) throws IOException
    {
        return storeFileStream(FTPCmd.APPE, remote);
    }","  public void test254()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.appendFileStream(""ISO-8859-1"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3013,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test255()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
}"
3014,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test256()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setUseEPSVwithIPv4(true);
}"
3015,"    public boolean sendSiteCommand(final String arguments) throws IOException
    {
        return FTPReply.isPositiveCompletion(site(arguments));
    }","  public void test257()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.sendSiteCommand(""e.~+Ec& *Wj9WX-]$m5"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3016,"    public boolean abort() throws IOException
    {
        return FTPReply.isPositiveCompletion(abor());
    }","  public void test258()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.abort();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3017,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test259()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient0.setPassiveNatWorkaroundStrategy(fTPClient_NatServerResolverImpl0);
}"
3018,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test260()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient0.setPassiveNatWorkaroundStrategy(fTPClient_NatServerResolverImpl0);
}"
3019,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test261()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient0.setPassiveNatWorkaroundStrategy(fTPClient_NatServerResolverImpl0);
}"
3020,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test262()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient0.setPassiveNatWorkaroundStrategy(fTPClient_NatServerResolverImpl0);
}"
3021,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test263()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient0.setPassiveNatWorkaroundStrategy(fTPClient_NatServerResolverImpl0);
}"
3022,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test264()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient0.setPassiveNatWorkaroundStrategy(fTPClient_NatServerResolverImpl0);
}"
3023,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test265()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient0.setPassiveNatWorkaroundStrategy(fTPClient_NatServerResolverImpl0);
}"
3024,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test266()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPClient.NatServerResolverImpl fTPClient_NatServerResolverImpl0 = new FTPClient.NatServerResolverImpl(fTPClient0);
      fTPClient0.setPassiveNatWorkaroundStrategy(fTPClient_NatServerResolverImpl0);
}"
3025,"    public boolean changeWorkingDirectory(final String pathname) throws IOException
    {
        return FTPReply.isPositiveCompletion(cwd(pathname));
    }","  public void test267()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.changeWorkingDirectory(""\r\n"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3026,"    private boolean storeFile(final FTPCmd command, final String remote, final InputStream local)
    throws IOException
    {
        return _storeFile(command.getCommand(), remote, local);
    }","  public void test268()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      byte[] byteArray0 = new byte[3];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      // Undeclared exception!
      try { 
        fTPClient0.storeFile(""?5&jXM\""8~"", byteArrayInputStream0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3027,"    protected Socket _openDataConnection_(final FTPCmd command, final String arg)
    throws IOException
    {
        return _openDataConnection_(command.getCommand(), arg);
    }","  public void test269()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.enterLocalPassiveMode();
      // Undeclared exception!
      try { 
        fTPClient0._openDataConnection_(""org.apache.commons.net.ftp.systemType"", ""org.apache.commons.net.ftp.systemType"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3028,"    public FTPFile[] listFiles()
    throws IOException
    {
        return listFiles((String) null);
    }","  public void test270()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.listFiles();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3029,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test271()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCopyStreamListener();
}"
3030,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test272()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCopyStreamListener();
}"
3031,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test273()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCopyStreamListener();
}"
3032,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test274()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCopyStreamListener();
}"
3033,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test275()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCopyStreamListener();
}"
3034,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test276()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCopyStreamListener();
}"
3035,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test277()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCopyStreamListener();
}"
3036,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test278()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCopyStreamListener();
}"
3037,"    public int getReceiveDataSocketBufferSize() {
        return receiveDataSocketBufferSize;
    }","  public void test279()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
}"
3038,"    public int getReceiveDataSocketBufferSize() {
        return receiveDataSocketBufferSize;
    }","  public void test280()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setReceieveDataSocketBufferSize(4);
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3039,"    public boolean deleteFile(final String pathname) throws IOException
    {
        return FTPReply.isPositiveCompletion(dele(pathname));
    }","  public void test281()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.deleteFile("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3040,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test282()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3041,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test283()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3042,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test284()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3043,"    public int getReceiveDataSocketBufferSize() {
        return receiveDataSocketBufferSize;
    }","  public void test285()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3044,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test286()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3045,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test287()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3046,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test288()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3047,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test289()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3048,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test290()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getReceiveDataSocketBufferSize();
}"
3049,"    public boolean allocate(final int bytes) throws IOException
    {
        return FTPReply.isPositiveCompletion(allo(bytes));
    }","  public void test291()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.allocate(1343);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3050,"    public int getBufferSize() {
        return bufferSize;
    }","  public void test292()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setBufferSize(69);
}"
3051,"    public boolean sendNoOp() throws IOException
    {
        return FTPReply.isPositiveCompletion(noop());
    }","  public void test293()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.sendNoOp();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3052,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test294()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setListHiddenFiles(false);
}"
3053,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test295()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setListHiddenFiles(false);
}"
3054,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test296()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setListHiddenFiles(false);
}"
3055,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test297()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setListHiddenFiles(false);
}"
3056,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test298()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setListHiddenFiles(false);
}"
3057,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test299()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setListHiddenFiles(false);
}"
3058,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test300()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setListHiddenFiles(false);
}"
3059,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test301()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setListHiddenFiles(false);
}"
3060,"    public boolean removeDirectory(final String pathname) throws IOException
    {
        return FTPReply.isPositiveCompletion(rmd(pathname));
    }","  public void test302()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.removeDirectory(""Fh_m=I}_I_'f_ 6KO"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3061,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test303()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getEntryParser();
}"
3062,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test304()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getEntryParser();
}"
3063,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test305()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getEntryParser();
}"
3064,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test306()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getEntryParser();
}"
3065,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test307()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getEntryParser();
}"
3066,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test308()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getEntryParser();
}"
3067,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test309()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getEntryParser();
}"
3068,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test310()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getEntryParser();
}"
3069,"    public boolean allocate(final int bytes) throws IOException
    {
        return FTPReply.isPositiveCompletion(allo(bytes));
    }","  public void test311()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.allocate(1785L, (-1433));
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3070,"    public FTPFile[] mlistDir() throws IOException
    {
        return mlistDir(null);
    }","  public void test312()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      FTPFileFilter fTPFileFilter0 = mock(FTPFileFilter.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        fTPClient0.mlistDir((String) null, fTPFileFilter0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3071,"    public boolean structureMount(final String pathname) throws IOException
    {
        return FTPReply.isPositiveCompletion(smnt(pathname));
    }","  public void test313()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.structureMount(""YRcHHsP#"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3072,"    public String[] listNames() throws IOException
    {
        return listNames(null);
    }","  public void test314()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.listNames();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3073,"    public FTPFile[] mlistDir() throws IOException
    {
        return mlistDir(null);
    }","  public void test315()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.mlistDir("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3074,"    protected void _connectAction_() throws IOException {
        _connectAction_(null);
    }","  public void test316()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3075,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test317()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRemoteVerificationEnabled(true);
}"
3076,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test318()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRemoteVerificationEnabled(true);
}"
3077,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test319()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRemoteVerificationEnabled(true);
}"
3078,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test320()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRemoteVerificationEnabled(true);
}"
3079,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test321()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRemoteVerificationEnabled(true);
}"
3080,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test322()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRemoteVerificationEnabled(true);
}"
3081,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test323()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRemoteVerificationEnabled(true);
}"
3082,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test324()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setRemoteVerificationEnabled(true);
}"
3083,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test325()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveLocalIPAddress((String) null);
}"
3084,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test326()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveLocalIPAddress((String) null);
}"
3085,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test327()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveLocalIPAddress((String) null);
}"
3086,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test328()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveLocalIPAddress((String) null);
}"
3087,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test329()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveLocalIPAddress((String) null);
}"
3088,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test330()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveLocalIPAddress((String) null);
}"
3089,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test331()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveLocalIPAddress((String) null);
}"
3090,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test332()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setPassiveLocalIPAddress((String) null);
}"
3091,"    public FTPListParseEngine initiateMListParsing() throws IOException
    {
        return initiateMListParsing(null);
    }","  public void test333()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.initiateMListParsing();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3092,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test334()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getPassiveHost();
}"
3093,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test335()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getPassiveHost();
}"
3094,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test336()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getPassiveHost();
}"
3095,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test337()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getPassiveHost();
}"
3096,"    public String getPassiveHost()
    {
        return passiveHost;
    }","  public void test338()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getPassiveHost();
}"
3097,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test339()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getPassiveHost();
}"
3098,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test340()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getPassiveHost();
}"
3099,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test341()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getPassiveHost();
}"
3100,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test342()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getPassiveHost();
}"
3101,"    public OutputStream storeUniqueFileStream() throws IOException
    {
        return storeFileStream(FTPCmd.STOU, null);
    }","  public void test343()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.storeUniqueFileStream(""-Yf\u0007c95"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3102,"    public int getSendDataSocketBufferSize() {
        return sendDataSocketBufferSize;
    }","  public void test344()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setSendDataSocketBufferSize((-626));
}"
3103,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test345()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setReportActiveExternalIPAddress(""org.apache.commons.net.ftp.systemType.default"");
}"
3104,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test346()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setReportActiveExternalIPAddress(""org.apache.commons.net.ftp.systemType.default"");
}"
3105,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test347()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setReportActiveExternalIPAddress(""org.apache.commons.net.ftp.systemType.default"");
}"
3106,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test348()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setReportActiveExternalIPAddress(""org.apache.commons.net.ftp.systemType.default"");
}"
3107,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test349()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setReportActiveExternalIPAddress(""org.apache.commons.net.ftp.systemType.default"");
}"
3108,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test350()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setReportActiveExternalIPAddress(""org.apache.commons.net.ftp.systemType.default"");
}"
3109,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test351()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setReportActiveExternalIPAddress(""org.apache.commons.net.ftp.systemType.default"");
}"
3110,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test352()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setReportActiveExternalIPAddress(""org.apache.commons.net.ftp.systemType.default"");
}"
3111,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test353()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.enterLocalActiveMode();
}"
3112,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test354()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.enterLocalActiveMode();
}"
3113,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test355()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.enterLocalActiveMode();
}"
3114,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test356()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.enterLocalActiveMode();
}"
3115,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test357()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.enterLocalActiveMode();
}"
3116,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test358()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.enterLocalActiveMode();
}"
3117,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test359()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.enterLocalActiveMode();
}"
3118,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test360()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.enterLocalActiveMode();
}"
3119,"    public boolean setModificationTime(final String pathname, final String timeval) throws IOException {
        return (FTPReply.isPositiveCompletion(mfmt(pathname, timeval)));
    }","  public void test361()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.setModificationTime(""{xVo}:+"", ""-a"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3120,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test362()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.configure((FTPClientConfig) null);
}"
3121,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test363()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.configure((FTPClientConfig) null);
}"
3122,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test364()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.configure((FTPClientConfig) null);
}"
3123,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test365()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.configure((FTPClientConfig) null);
}"
3124,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test366()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.configure((FTPClientConfig) null);
}"
3125,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test367()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.configure((FTPClientConfig) null);
}"
3126,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test368()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.configure((FTPClientConfig) null);
}"
3127,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test369()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.configure((FTPClientConfig) null);
}"
3128,"    public OutputStream storeUniqueFileStream() throws IOException
    {
        return storeFileStream(FTPCmd.STOU, null);
    }","  public void test370()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.storeUniqueFileStream();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3129,"    public InputStream retrieveFileStream(final String remote) throws IOException
    {
        return _retrieveFileStream(FTPCmd.RETR.getCommand(), remote);
    }","  public void test371()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0.retrieveFileStream("";"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3130,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test372()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.disconnect();
}"
3131,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test373()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.disconnect();
}"
3132,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test374()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.disconnect();
}"
3133,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test375()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.disconnect();
}"
3134,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test376()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.disconnect();
}"
3135,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test377()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.disconnect();
}"
3136,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test378()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.disconnect();
}"
3137,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test379()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.disconnect();
}"
3138,"    protected Socket _openDataConnection_(final FTPCmd command, final String arg)
    throws IOException
    {
        return _openDataConnection_(command.getCommand(), arg);
    }","  public void test380()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      // Undeclared exception!
      try { 
        fTPClient0._openDataConnection_(11, ""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3139,"    public boolean storeUniqueFile(final InputStream local) throws IOException
    {
        return storeFile(FTPCmd.STOU, null, local);
    }","  public void test381()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0);
      // Undeclared exception!
      try { 
        fTPClient0.storeUniqueFile("":%1$tM"", (InputStream) pipedInputStream0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3140,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test382()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setDataTimeout(3);
}"
3141,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test383()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setDataTimeout(3);
}"
3142,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test384()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setDataTimeout(3);
}"
3143,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test385()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setDataTimeout(3);
}"
3144,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test386()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setDataTimeout(3);
}"
3145,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test387()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setDataTimeout(3);
}"
3146,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test388()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setDataTimeout(3);
}"
3147,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test389()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setDataTimeout(3);
}"
3148,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test390()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActivePortRange((-1433), (-1433));
}"
3149,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test391()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActivePortRange((-1433), (-1433));
}"
3150,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test392()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActivePortRange((-1433), (-1433));
}"
3151,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test393()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActivePortRange((-1433), (-1433));
}"
3152,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test394()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActivePortRange((-1433), (-1433));
}"
3153,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test395()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActivePortRange((-1433), (-1433));
}"
3154,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test396()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActivePortRange((-1433), (-1433));
}"
3155,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test397()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setActivePortRange((-1433), (-1433));
}"
3156,"    public boolean allocate(final int bytes) throws IOException
    {
        return FTPReply.isPositiveCompletion(allo(bytes));
    }","  public void test398()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.allocate(44, 3);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3157,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test399()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments(""org.apache.commons.net.ftp.systemType.default"");
}"
3158,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test400()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments(""org.apache.commons.net.ftp.systemType.default"");
}"
3159,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test401()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments(""org.apache.commons.net.ftp.systemType.default"");
}"
3160,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test402()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments(""org.apache.commons.net.ftp.systemType.default"");
}"
3161,"    protected String getListArguments(final String pathname) {
        if (getListHiddenFiles())
        {
            if (pathname != null)
            {
                final StringBuilder sb = new StringBuilder(pathname.length() + 3);
                sb.append(""-a "");
                sb.append(pathname);
                return sb.toString();
            }
            return ""-a"";
        }

        return pathname;
    }","  public void test403()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments(""org.apache.commons.net.ftp.systemType.default"");
}"
3162,"    protected String getListArguments(final String pathname) {
        if (getListHiddenFiles())
        {
            if (pathname != null)
            {
                final StringBuilder sb = new StringBuilder(pathname.length() + 3);
                sb.append(""-a "");
                sb.append(pathname);
                return sb.toString();
            }
            return ""-a"";
        }

        return pathname;
    }","  public void test404()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments(""org.apache.commons.net.ftp.systemType.default"");
}"
3163,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test405()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments(""org.apache.commons.net.ftp.systemType.default"");
}"
3164,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test406()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments(""org.apache.commons.net.ftp.systemType.default"");
}"
3165,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test407()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      String string0 = fTPClient0.getListArguments(""org.apache.commons.net.ftp.systemType.default"");
}"
3166,"    public boolean appendFile(final String remote, final InputStream local)
    throws IOException
    {
        return storeFile(FTPCmd.APPE, remote, local);
    }","  public void test408()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      byte[] byteArray0 = new byte[8];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 11, 1);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      // Undeclared exception!
      try { 
        fTPClient0.appendFile((String) null, sequenceInputStream0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3167,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test409()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getRestartOffset();
}"
3168,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test410()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getRestartOffset();
}"
3169,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test411()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getRestartOffset();
}"
3170,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test412()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getRestartOffset();
}"
3171,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test413()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getRestartOffset();
}"
3172,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test414()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getRestartOffset();
}"
3173,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test415()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getRestartOffset();
}"
3174,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test416()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      long long0 = fTPClient0.getRestartOffset();
}"
3175,"    public boolean doCommand(final String command, final String params) throws IOException
    {
        return FTPReply.isPositiveCompletion(sendCommand(command, params));
    }","  public void test417()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.doCommand(""org.apache.commons.net.ftp.systemType.default"", ""\r\n"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3176,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test418()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getPassivePort();
}"
3177,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test419()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getPassivePort();
}"
3178,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test420()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getPassivePort();
}"
3179,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test421()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getPassivePort();
}"
3180,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test422()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getPassivePort();
}"
3181,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test423()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getPassivePort();
}"
3182,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test424()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getPassivePort();
}"
3183,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test425()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getPassivePort();
}"
3184,"    public boolean features() throws IOException {
        return FTPReply.isPositiveCompletion(feat());
    }","  public void test426()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.features();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3185,"    public boolean makeDirectory(final String pathname) throws IOException
    {
        return FTPReply.isPositiveCompletion(mkd(pathname));
    }","  public void test427()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.makeDirectory(""qzS Y@"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3186,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test428()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getAutodetectUTF8();
}"
3187,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test429()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getAutodetectUTF8();
}"
3188,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test430()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getAutodetectUTF8();
}"
3189,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test431()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getAutodetectUTF8();
}"
3190,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test432()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getAutodetectUTF8();
}"
3191,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test433()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getAutodetectUTF8();
}"
3192,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test434()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getAutodetectUTF8();
}"
3193,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test435()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      boolean boolean0 = fTPClient0.getAutodetectUTF8();
}"
3194,"    public long getControlKeepAliveTimeout() {
        return controlKeepAliveTimeoutMillis / 1000;
    }","  public void test436()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.setControlKeepAliveTimeout((-2966L));
}"
3195,"    public FTPListParseEngine initiateListParsing()
    throws IOException
    {
        return initiateListParsing((String) null);
    }","  public void test437()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.initiateListParsing();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3196,"    public boolean storeUniqueFile(final InputStream local) throws IOException
    {
        return storeFile(FTPCmd.STOU, null, local);
    }","  public void test438()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      // Undeclared exception!
      try { 
        fTPClient0.storeUniqueFile((InputStream) sequenceInputStream0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3197,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test439()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getSendDataSocketBufferSize();
}"
3198,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test440()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getSendDataSocketBufferSize();
}"
3199,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test441()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getSendDataSocketBufferSize();
}"
3200,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test442()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getSendDataSocketBufferSize();
}"
3201,"    public int getSendDataSocketBufferSize() {
        return sendDataSocketBufferSize;
    }","  public void test443()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getSendDataSocketBufferSize();
}"
3202,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test444()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getSendDataSocketBufferSize();
}"
3203,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test445()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getSendDataSocketBufferSize();
}"
3204,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test446()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getSendDataSocketBufferSize();
}"
3205,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test447()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getSendDataSocketBufferSize();
}"
3206,"    public boolean allocate(final int bytes) throws IOException
    {
        return FTPReply.isPositiveCompletion(allo(bytes));
    }","  public void test448()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.allocate((long) (-584));
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3207,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test449()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCslDebug();
}"
3208,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test450()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCslDebug();
}"
3209,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test451()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCslDebug();
}"
3210,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test452()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCslDebug();
}"
3211,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test453()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCslDebug();
}"
3212,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test454()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCslDebug();
}"
3213,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test455()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCslDebug();
}"
3214,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test456()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getCslDebug();
}"
3215,"    public int getBufferSize() {
        return bufferSize;
    }","  public void test457()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getBufferSize();
}"
3216,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test458()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getBufferSize();
}"
3217,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test459()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getBufferSize();
}"
3218,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test460()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getBufferSize();
}"
3219,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test461()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getBufferSize();
}"
3220,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test462()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getBufferSize();
}"
3221,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test463()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getBufferSize();
}"
3222,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test464()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getBufferSize();
}"
3223,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test465()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      int int0 = fTPClient0.getBufferSize();
}"
3224,"    public boolean getAutodetectUTF8()
    {
        return autodetectEncoding;
    }","  public void test466()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getPassiveLocalIPAddress();
}"
3225,"    public int getPassivePort()
    {
        return passivePort;
    }","  public void test467()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getPassiveLocalIPAddress();
}"
3226,"    public boolean getListHiddenFiles() {
        return this.listHiddenFiles;
    }","  public void test468()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getPassiveLocalIPAddress();
}"
3227,"    public int getControlKeepAliveReplyTimeout() {
        return controlKeepAliveReplyTimeoutMillis;
    }","  public void test469()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getPassiveLocalIPAddress();
}"
3228,"    public int getDataConnectionMode()
    {
        return dataConnectionMode;
    }","  public void test470()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getPassiveLocalIPAddress();
}"
3229,"    public long getRestartOffset()
    {
        return restartOffset;
    }","  public void test471()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getPassiveLocalIPAddress();
}"
3230,"    public boolean isUseEPSVwithIPv4() {
        return useEPSVwithIPv4;
    }","  public void test472()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getPassiveLocalIPAddress();
}"
3231,"    public boolean isRemoteVerificationEnabled()
    {
        return remoteVerificationEnabled;
    }","  public void test473()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      fTPClient0.getPassiveLocalIPAddress();
}"
3232,"    public FTPFile[] listDirectories() throws IOException {
        return listDirectories((String) null);
    }","  public void test474()  throws Throwable  {
      FTPClient fTPClient0 = new FTPClient();
      try { 
        fTPClient0.listDirectories();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3233,"    public int getType() {
        return type;
    }","  public void test0()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(1458);
      boolean boolean0 = fTPFile0.isUnknown();
}"
3234,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test1()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(1458);
      boolean boolean0 = fTPFile0.isUnknown();
}"
3235,"    public boolean isFile() {
        return type == FILE_TYPE;
    }","  public void test2()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
}"
3236,"    public int getType() {
        return type;
    }","  public void test3()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
      fTPFile0.setType(0);
      boolean boolean0 = fTPFile0.isSymbolicLink();
}"
3237,"    public boolean isSymbolicLink() {
        return type == SYMBOLIC_LINK_TYPE;
    }","  public void test4()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
      fTPFile0.setType(0);
      boolean boolean0 = fTPFile0.isSymbolicLink();
}"
3238,"    public int getType() {
        return type;
    }","  public void test5()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""E/J4.|+"");
      fTPFile0.setType((-1047));
      boolean boolean0 = fTPFile0.isFile();
}"
3239,"    public boolean isFile() {
        return type == FILE_TYPE;
    }","  public void test6()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""E/J4.|+"");
      fTPFile0.setType((-1047));
      boolean boolean0 = fTPFile0.isFile();
}"
3240,"    public long getSize() {
        return size;
    }","  public void test7()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""{exJN*|i^{`O"");
      fTPFile0.toString();
}"
3241,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test8()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""{exJN*|i^{`O"");
      fTPFile0.toString();
}"
3242,"    public long getSize() {
        return size;
    }","  public void test9()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.toString();
}"
3243,"    public int getType() {
        return type;
    }","  public void test10()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.toString();
}"
3244,"    public int getType() {
        return type;
    }","  public void test11()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setPermission(0, 0, true);
      boolean boolean0 = fTPFile0.hasPermission(0, 0);
}"
3245,"    public long getSize() {
        return size;
    }","  public void test12()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setPermission(0, 0, true);
      boolean boolean0 = fTPFile0.hasPermission(0, 0);
}"
3246,"    public boolean hasPermission(final int access, final int permission) {
        if (permissions == null) {
            return false;
        }
        return permissions[access][permission];
    }","  public void test13()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setPermission(0, 0, true);
      boolean boolean0 = fTPFile0.hasPermission(0, 0);
}"
3247,"    public int getType() {
        return type;
    }","  public void test14()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
      fTPFile0.setUser("" %1$tY-%1$tm-%1$td"");
      fTPFile0.getUser();
}"
3248,"    public long getSize() {
        return size;
    }","  public void test15()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
      fTPFile0.setUser("" %1$tY-%1$tm-%1$td"");
      fTPFile0.getUser();
}"
3249,"    public boolean isFile() {
        return type == FILE_TYPE;
    }","  public void test16()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""E/J4.|+"");
}"
3250,"    public boolean isFile() {
        return type == FILE_TYPE;
    }","  public void test17()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""E/J4.|+"");
      fTPFile0.setType(0);
      int int0 = fTPFile0.getType();
}"
3251,"    public int getType() {
        return type;
    }","  public void test18()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""E/J4.|+"");
      fTPFile0.setType(0);
      int int0 = fTPFile0.getType();
}"
3252,"    public int getType() {
        return type;
    }","  public void test19()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType((-1835));
      int int0 = fTPFile0.getType();
}"
3253,"    public long getSize() {
        return size;
    }","  public void test20()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      TimeZone timeZone0 = TimeZone.getTimeZone(""?Sa[ .M`/`\u0004:R3l"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      mockGregorianCalendar0.setLenient(false);
      fTPFile0.getTimestamp();
}"
3254,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test21()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      TimeZone timeZone0 = TimeZone.getTimeZone(""?Sa[ .M`/`\u0004:R3l"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      mockGregorianCalendar0.setLenient(false);
      fTPFile0.getTimestamp();
}"
3255,"    public long getSize() {
        return size;
    }","  public void test22()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(3689, 3, 114, 0, (-1673));
      mockGregorianCalendar0.setMinimalDaysInFirstWeek(0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      fTPFile0.getTimestamp();
}"
3256,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test23()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(3689, 3, 114, 0, (-1673));
      mockGregorianCalendar0.setMinimalDaysInFirstWeek(0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      fTPFile0.getTimestamp();
}"
3257,"    public long getSize() {
        return size;
    }","  public void test24()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 2, 0, 2, 3);
      mockGregorianCalendar0.setMinimalDaysInFirstWeek((-175));
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      fTPFile0.getTimestamp();
}"
3258,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test25()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 2, 0, 2, 3);
      mockGregorianCalendar0.setMinimalDaysInFirstWeek((-175));
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      fTPFile0.getTimestamp();
}"
3259,"    public long getSize() {
        return size;
    }","  public void test26()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2, """");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
      mockGregorianCalendar0.setFirstDayOfWeek(0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      fTPFile0.getTimestamp();
}"
3260,"    public int getType() {
        return type;
    }","  public void test27()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2, """");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
      mockGregorianCalendar0.setFirstDayOfWeek(0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      fTPFile0.getTimestamp();
}"
3261,"    public int getType() {
        return type;
    }","  public void test28()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      Calendar calendar0 = MockCalendar.getInstance();
      calendar0.setFirstDayOfWeek((-1));
      fTPFile0.setTimestamp(calendar0);
      fTPFile0.getTimestamp();
}"
3262,"    public long getSize() {
        return size;
    }","  public void test29()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      Calendar calendar0 = MockCalendar.getInstance();
      calendar0.setFirstDayOfWeek((-1));
      fTPFile0.setTimestamp(calendar0);
      fTPFile0.getTimestamp();
}"
3263,"    public long getSize() {
        return size;
    }","  public void test30()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""QW@|HE~"");
}"
3264,"    public boolean isSymbolicLink() {
        return type == SYMBOLIC_LINK_TYPE;
    }","  public void test31()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""QW@|HE~"");
      fTPFile0.setSize(0);
      fTPFile0.getSize();
}"
3265,"    public long getSize() {
        return size;
    }","  public void test32()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.setSize(1786L);
      long long0 = fTPFile0.getSize();
}"
3266,"    public long getSize() {
        return size;
    }","  public void test33()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getRawListing();
}"
3267,"    public int getType() {
        return type;
    }","  public void test34()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getRawListing();
}"
3268,"    public int getType() {
        return type;
    }","  public void test35()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""L>|RIXyK58"");
      fTPFile0.getRawListing();
}"
3269,"    public long getSize() {
        return size;
    }","  public void test36()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""L>|RIXyK58"");
      fTPFile0.getRawListing();
}"
3270,"    public long getSize() {
        return size;
    }","  public void test37()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.setName(""*CQ*G4AoN)7nhs/G"");
      fTPFile0.getName();
}"
3271,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test38()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.setName(""*CQ*G4AoN)7nhs/G"");
      fTPFile0.getName();
}"
3272,"    public int getType() {
        return type;
    }","  public void test39()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.setName("""");
      fTPFile0.getName();
}"
3273,"    public long getSize() {
        return size;
    }","  public void test40()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.setName("""");
      fTPFile0.getName();
}"
3274,"    public int getType() {
        return type;
    }","  public void test41()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""Unl1/Z"");
      fTPFile0.setLink("";uPF /ZLQ"");
      fTPFile0.getLink();
}"
3275,"    public long getSize() {
        return size;
    }","  public void test42()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""Unl1/Z"");
      fTPFile0.setLink("";uPF /ZLQ"");
      fTPFile0.getLink();
}"
3276,"    public int getType() {
        return type;
    }","  public void test43()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""org.apache.commons.io.filefilter.HiddenFileFilter"");
      fTPFile0.setLink("""");
      fTPFile0.getLink();
}"
3277,"    public long getSize() {
        return size;
    }","  public void test44()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""org.apache.commons.io.filefilter.HiddenFileFilter"");
      fTPFile0.setLink("""");
      fTPFile0.getLink();
}"
3278,"    public int getHardLinkCount() {
        return hardLinkCount;
    }","  public void test45()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""9"");
}"
3279,"    public int getHardLinkCount() {
        return hardLinkCount;
    }","  public void test46()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""9"");
      fTPFile0.setHardLinkCount(3);
      int int0 = fTPFile0.getHardLinkCount();
}"
3280,"    public int getHardLinkCount() {
        return hardLinkCount;
    }","  public void test47()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile((String) null);
      fTPFile0.setHardLinkCount((-2343));
      int int0 = fTPFile0.getHardLinkCount();
}"
3281,"    public long getSize() {
        return size;
    }","  public void test48()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile((String) null);
      fTPFile0.setGroup((String) null);
      fTPFile0.getGroup();
}"
3282,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test49()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile((String) null);
      fTPFile0.setGroup((String) null);
      fTPFile0.getGroup();
}"
3283,"    public long getSize() {
        return size;
    }","  public void test50()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.setGroup(""7=QiBpFwYqu"");
      fTPFile0.getGroup();
}"
3284,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test51()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.setGroup(""7=QiBpFwYqu"");
      fTPFile0.getGroup();
}"
3285,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test52()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      mockGregorianCalendar0.set(0, (-128));
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      // Undeclared exception!
      try { 
        fTPFile0.toFormattedString(""flXl7E{VCDKh+NOs_"");
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid era
         //
         verifyException(""java.util.GregorianCalendar"", e);
      }
  }"
3286,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test53()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-214), 2, (-214), 120, 0);
      mockGregorianCalendar0.set(0, (-478));
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      // Undeclared exception!
      try { 
        fTPFile0.toFormattedString();
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Invalid era
         //
         verifyException(""java.util.GregorianCalendar"", e);
      }
  }"
3287,"    public void setPermission(final int access, final int permission, final boolean value) {
        permissions[access][permission] = value;
    }","  public void test54()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      // Undeclared exception!
      try { 
        fTPFile0.setPermission(63, 63, false);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 63
         //
         verifyException(""org.apache.commons.net.ftp.FTPFile"", e);
      }
  }"
3288,"    public boolean hasPermission(final int access, final int permission) {
        if (permissions == null) {
            return false;
        }
        return permissions[access][permission];
    }","  public void test55()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      // Undeclared exception!
      try { 
        fTPFile0.hasPermission((-1548), (-196));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3289,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test56()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(1, 0, 0);
      mockGregorianCalendar0.setTimeZone((TimeZone) null);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      // Undeclared exception!
      try { 
        fTPFile0.toFormattedString((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3290,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test57()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      TimeZone timeZone0 = TimeZone.getTimeZone(""?Sa[ .M`/`\u0004:R3l"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      mockGregorianCalendar0.clear();
      String string0 = fTPFile0.toFormattedString("""");
}"
3291,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test58()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      TimeZone timeZone0 = TimeZone.getTimeZone(""?Sa[ .M`/`\u0004:R3l"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      mockGregorianCalendar0.clear();
      String string0 = fTPFile0.toFormattedString("""");
}"
3292,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test59()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      Calendar calendar0 = MockCalendar.getInstance();
      fTPFile0.setTimestamp(calendar0);
      String string0 = fTPFile0.toFormattedString((String) null);
}"
3293,"    public int getType() {
        return type;
    }","  public void test60()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      Calendar calendar0 = MockCalendar.getInstance();
      fTPFile0.setTimestamp(calendar0);
      String string0 = fTPFile0.toFormattedString((String) null);
}"
3294,"    public int getType() {
        return type;
    }","  public void test61()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isValid();
}"
3295,"    public long getSize() {
        return size;
    }","  public void test62()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isValid();
}"
3296,"    public boolean isValid() {
        return permissions != null;
    }","  public void test63()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isValid();
}"
3297,"    public int getType() {
        return type;
    }","  public void test64()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
      boolean boolean0 = fTPFile0.isValid();
}"
3298,"    public long getSize() {
        return size;
    }","  public void test65()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
      boolean boolean0 = fTPFile0.isValid();
}"
3299,"    public boolean isValid() {
        return permissions != null;
    }","  public void test66()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
      boolean boolean0 = fTPFile0.isValid();
}"
3300,"    public long getSize() {
        return size;
    }","  public void test67()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.hasPermission(0, 0);
}"
3301,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test68()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.hasPermission(0, 0);
}"
3302,"    public long getSize() {
        return size;
    }","  public void test69()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      long long0 = fTPFile0.getSize();
}"
3303,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test70()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      long long0 = fTPFile0.getSize();
}"
3304,"    public int getType() {
        return type;
    }","  public void test71()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
      fTPFile0.getUser();
}"
3305,"    public long getSize() {
        return size;
    }","  public void test72()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("" %1$tY-%1$tm-%1$td"");
      fTPFile0.getUser();
}"
3306,"    public long getSize() {
        return size;
    }","  public void test73()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.getRawListing();
}"
3307,"    public int getType() {
        return type;
    }","  public void test74()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      fTPFile0.getRawListing();
}"
3308,"    public int getHardLinkCount() {
        return hardLinkCount;
    }","  public void test75()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      int int0 = fTPFile0.getHardLinkCount();
}"
3309,"    public long getSize() {
        return size;
    }","  public void test76()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      int int0 = fTPFile0.getHardLinkCount();
}"
3310,"    public int getType() {
        return type;
    }","  public void test77()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      int int0 = fTPFile0.getHardLinkCount();
}"
3311,"    public long getSize() {
        return size;
    }","  public void test78()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getGroup();
}"
3312,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test79()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getGroup();
}"
3313,"    public long getSize() {
        return size;
    }","  public void test80()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getTimestamp();
}"
3314,"    public int getType() {
        return type;
    }","  public void test81()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getTimestamp();
}"
3315,"    public long getSize() {
        return size;
    }","  public void test82()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getName();
}"
3316,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test83()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getName();
}"
3317,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test84()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(2, 2, 1);
      mockGregorianCalendar0.setTimeZone((TimeZone) null);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      // Undeclared exception!
      try { 
        fTPFile0.toFormattedString();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3318,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test85()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(3, 1892, 187, 0, 0, 4892);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      String string0 = fTPFile0.toFormattedString(""rz\""&?}"");
}"
3319,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test86()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(3, 1892, 187, 0, 0, 4892);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      String string0 = fTPFile0.toFormattedString(""rz\""&?}"");
}"
3320,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test87()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      TimeZone timeZone0 = TimeZone.getTimeZone(""?Sa[ .M`/`\u0004:R3l"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      mockGregorianCalendar0.clear();
      mockGregorianCalendar0.set(0, 3, (-1246), 3106, 1442);
      String string0 = fTPFile0.toFormattedString("""");
}"
3321,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test88()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      TimeZone timeZone0 = TimeZone.getTimeZone(""?Sa[ .M`/`\u0004:R3l"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      mockGregorianCalendar0.clear();
      mockGregorianCalendar0.set(0, 3, (-1246), 3106, 1442);
      String string0 = fTPFile0.toFormattedString("""");
}"
3322,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test89()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(3, 0, 0, 2, 0, 2);
      mockGregorianCalendar0.clear(12);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      String string0 = fTPFile0.toFormattedString("":%1$tS"");
}"
3323,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test90()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(3, 0, 0, 2, 0, 2);
      mockGregorianCalendar0.clear(12);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      String string0 = fTPFile0.toFormattedString("":%1$tS"");
}"
3324,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test91()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      TimeZone timeZone0 = TimeZone.getTimeZone(""?Sa[ .M`/`\u0004:R3l"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      mockGregorianCalendar0.clear();
      String string0 = fTPFile0.toFormattedString();
}"
3325,"    public int getType() {
        return type;
    }","  public void test92()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      TimeZone timeZone0 = TimeZone.getTimeZone(""?Sa[ .M`/`\u0004:R3l"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      mockGregorianCalendar0.clear();
      String string0 = fTPFile0.toFormattedString();
}"
3326,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test93()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, "" %1tY-%1Ntm-1$d"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      String string0 = fTPFile0.toFormattedString("" %1tY-%1Ntm-1$d"");
}"
3327,"    public int getType() {
        return type;
    }","  public void test94()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, "" %1tY-%1Ntm-1$d"");
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
      fTPFile0.setTimestamp(mockGregorianCalendar0);
      String string0 = fTPFile0.toFormattedString("" %1tY-%1Ntm-1$d"");
}"
3328,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test95()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setPermission(2, 2, true);
      String string0 = fTPFile0.toFormattedString(""The filters must not be null"");
}"
3329,"    public int getType() {
        return type;
    }","  public void test96()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setPermission(2, 2, true);
      String string0 = fTPFile0.toFormattedString(""The filters must not be null"");
}"
3330,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test97()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setPermission(0, 1, true);
      String string0 = fTPFile0.toFormattedString();
}"
3331,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test98()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setPermission(0, 1, true);
      String string0 = fTPFile0.toFormattedString();
}"
3332,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test99()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setPermission(0, 0, true);
      String string0 = fTPFile0.toFormattedString(""The filters must not be null"");
}"
3333,"    public long getSize() {
        return size;
    }","  public void test100()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      String string0 = fTPFile0.toFormattedString(""lI2mb!"");
}"
3334,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test101()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      String string0 = fTPFile0.toFormattedString(""lI2mb!"");
}"
3335,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test102()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile("""");
      String string0 = fTPFile0.toFormattedString(""lI2mb!"");
}"
3336,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test103()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isUnknown();
}"
3337,"    public long getSize() {
        return size;
    }","  public void test104()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isUnknown();
}"
3338,"    public boolean isFile() {
        return type == FILE_TYPE;
    }","  public void test105()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
}"
3339,"    public int getType() {
        return type;
    }","  public void test106()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(0);
      boolean boolean0 = fTPFile0.isUnknown();
}"
3340,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test107()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(0);
      boolean boolean0 = fTPFile0.isUnknown();
}"
3341,"    public boolean isSymbolicLink() {
        return type == SYMBOLIC_LINK_TYPE;
    }","  public void test108()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
}"
3342,"    public int getType() {
        return type;
    }","  public void test109()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(2);
      boolean boolean0 = fTPFile0.isSymbolicLink();
}"
3343,"    public boolean isSymbolicLink() {
        return type == SYMBOLIC_LINK_TYPE;
    }","  public void test110()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(2);
      boolean boolean0 = fTPFile0.isSymbolicLink();
}"
3344,"    public boolean isSymbolicLink() {
        return type == SYMBOLIC_LINK_TYPE;
    }","  public void test111()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isSymbolicLink();
}"
3345,"    public int getType() {
        return type;
    }","  public void test112()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isSymbolicLink();
}"
3346,"    public long getSize() {
        return size;
    }","  public void test113()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isSymbolicLink();
}"
3347,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test114()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
}"
3348,"    public int getType() {
        return type;
    }","  public void test115()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(0);
      boolean boolean0 = fTPFile0.isFile();
}"
3349,"    public boolean isFile() {
        return type == FILE_TYPE;
    }","  public void test116()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(0);
      boolean boolean0 = fTPFile0.isFile();
}"
3350,"    public boolean isFile() {
        return type == FILE_TYPE;
    }","  public void test117()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isFile();
}"
3351,"    public long getSize() {
        return size;
    }","  public void test118()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isFile();
}"
3352,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test119()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isFile();
}"
3353,"    public int getType() {
        return type;
    }","  public void test120()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
}"
3354,"    public int getType() {
        return type;
    }","  public void test121()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(1);
      boolean boolean0 = fTPFile0.isDirectory();
}"
3355,"    public boolean isDirectory() {
        return type == DIRECTORY_TYPE;
    }","  public void test122()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(1);
      boolean boolean0 = fTPFile0.isDirectory();
}"
3356,"    public boolean isDirectory() {
        return type == DIRECTORY_TYPE;
    }","  public void test123()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isDirectory();
}"
3357,"    public int getType() {
        return type;
    }","  public void test124()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isDirectory();
}"
3358,"    public long getSize() {
        return size;
    }","  public void test125()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      boolean boolean0 = fTPFile0.isDirectory();
}"
3359,"    public boolean hasPermission(final int access, final int permission) {
        if (permissions == null) {
            return false;
        }
        return permissions[access][permission];
    }","  public void test126()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""!c"");
      boolean boolean0 = fTPFile0.hasPermission(0, 1);
}"
3360,"    public long getSize() {
        return size;
    }","  public void test127()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""!c"");
      boolean boolean0 = fTPFile0.hasPermission(0, 1);
}"
3361,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test128()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""!c"");
      boolean boolean0 = fTPFile0.hasPermission(0, 1);
}"
3362,"    public boolean isSymbolicLink() {
        return type == SYMBOLIC_LINK_TYPE;
    }","  public void test129()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(2);
      fTPFile0.toFormattedString();
}"
3363,"    public int getType() {
        return type;
    }","  public void test130()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
}"
3364,"    public String toFormattedString() {
        return toFormattedString(null);
    }","  public void test131()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(1);
      String string0 = fTPFile0.toFormattedString();
}"
3365,"    public long getSize() {
        return size;
    }","  public void test132()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setRawListing((String) null);
}"
3366,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test133()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setRawListing((String) null);
}"
3367,"    public long getSize() {
        return size;
    }","  public void test134()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      int int0 = fTPFile0.getType();
}"
3368,"    public int getType() {
        return type;
    }","  public void test135()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      int int0 = fTPFile0.getType();
}"
3369,"    public long getSize() {
        return size;
    }","  public void test136()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getLink();
}"
3370,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test137()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.getLink();
}"
3371,"    public long getSize() {
        return size;
    }","  public void test138()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.toString();
}"
3372,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test139()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.toString();
}"
3373,"    public long getSize() {
        return size;
    }","  public void test140()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setUser((String) null);
      fTPFile0.getUser();
}"
3374,"    public boolean isUnknown() {
        return type == UNKNOWN_TYPE;
    }","  public void test141()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setUser((String) null);
      fTPFile0.getUser();
}"
3375,"    public boolean isFile() {
        return type == FILE_TYPE;
    }","  public void test142()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile();
      fTPFile0.setType(0);
      fTPFile0.toFormattedString(""{6<"");
}"
3376,"    public void setPermission(final int access, final int permission, final boolean value) {
        permissions[access][permission] = value;
    }","  public void test143()  throws Throwable  {
      FTPFile fTPFile0 = new FTPFile(""QW@|HE~"");
      // Undeclared exception!
      try { 
        fTPFile0.setPermission(42, 0, false);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPFile"", e);
      }
  }"
3377,"    public FTPConnectionClosedException()
    {
    }","  public void test0()  throws Throwable  {
      FTPConnectionClosedException fTPConnectionClosedException0 = new FTPConnectionClosedException("""");
  }"
3378,"    public FTPConnectionClosedException()
    {
    }","  public void test1()  throws Throwable  {
      FTPConnectionClosedException fTPConnectionClosedException0 = new FTPConnectionClosedException();
  }"
3379,"    public java.net.ServerSocket createServerSocket(final int port) throws IOException {
        return this.init(this.context.getServerSocketFactory().createServerSocket(port));
    }","  public void test0()  throws Throwable  {
    Future<?> future = executor.submit(new Runnable(){ 
            @Override public void run() { 
        try {
          SSLContext sSLContext0 = SSLContext.getDefault();
          FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
          // Undeclared exception!
          try { 
            fTPSSocketFactory0.createServerSocket(1463, 0);
            fail(""Expecting exception: SecurityException"");
          } catch(SecurityException e) {
             //
             // Security manager blocks (\""java.net.SocketPermission\"" \""localhost:1463\"" \""listen,resolve\"")
             // java.lang.Thread.getStackTrace(Thread.java:1559)
             // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
             // java.lang.SecurityManager.checkListen(SecurityManager.java:1131)
             // java.net.ServerSocket.bind(ServerSocket.java:389)
             // java.net.ServerSocket.<init>(ServerSocket.java:252)
             // java.net.ServerSocket.<init>(ServerSocket.java:196)
             // javax.net.ssl.SSLServerSocket.<init>(SSLServerSocket.java:136)
             // sun.security.ssl.SSLServerSocketImpl.<init>(SSLServerSocketImpl.java:70)
             // sun.security.ssl.SSLServerSocketFactoryImpl.createServerSocket(SSLServerSocketFactoryImpl.java:80)
             // org.apache.commons.net.ftp.FTPSSocketFactory.createServerSocket(FTPSSocketFactory.java:88)
             // sun.reflect.GeneratedMethodAccessor90.invoke(Unknown Source)
             // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
             // java.lang.reflect.Method.invoke(Method.java:498)
             // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
             // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
             // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
             // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
             // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
             // java.util.concurrent.FutureTask.run(FutureTask.java:266)
             // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
             // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
             // java.lang.Thread.run(Thread.java:748)
             //
             verifyException(""org.evosuite.runtime.sandbox.MSecurityManager"", e);
          }
        } catch(Throwable t) {
            // Need to catch declared exceptions
        }
      } 
    });
    future.get(4000, TimeUnit.MILLISECONDS);
  }"
3380,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test1()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket((InetAddress) null, (-1), (InetAddress) null, (-1200));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1200
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
3381,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test2()  throws Throwable  {
      InetAddress inetAddress0 = MockInetAddress.getByName(""~'ilU<R5#7WbVH@@"");
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      InetAddress inetAddress1 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket(inetAddress1, (-1280), inetAddress0, (-1280));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1280
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
3382,"    public java.net.ServerSocket init(final java.net.ServerSocket socket) throws IOException {
        ((javax.net.ssl.SSLServerSocket) socket).setUseClientMode(true);
        return socket;
    }","  public void test3()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.init((ServerSocket) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3383,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test4()  throws Throwable  {
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory((SSLContext) null);
      InetAddress inetAddress0 = MockInetAddress.anyLocalAddress();
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket(inetAddress0, (-1543), inetAddress0, (-1543));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3384,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test5()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      InetAddress inetAddress0 = MockInetAddress.getLoopbackAddress();
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket(inetAddress0, (-490));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-490
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
3385,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test6()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket("""", 0, inetAddress0, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
3386,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test7()  throws Throwable  {
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket("">3'^Q"", (-1023));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3387,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test8()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket("""", (-1));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // port out of range:-1
         //
         verifyException(""java.net.InetSocketAddress"", e);
      }
  }"
3388,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test9()  throws Throwable  {
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3389,"    public java.net.ServerSocket createServerSocket(final int port) throws IOException {
        return this.init(this.context.getServerSocketFactory().createServerSocket(port));
    }","  public void test10()  throws Throwable  {
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory((SSLContext) null);
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createServerSocket(0, 63, inetAddress0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3390,"    public java.net.ServerSocket createServerSocket(final int port) throws IOException {
        return this.init(this.context.getServerSocketFactory().createServerSocket(port));
    }","  public void test11()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      InetAddress inetAddress0 = MockInetAddress.getByName("""");
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createServerSocket((-3594), (-1089), inetAddress0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port value out of range: -3594
         //
         verifyException(""java.net.ServerSocket"", e);
      }
  }"
3391,"    public java.net.ServerSocket createServerSocket(final int port) throws IOException {
        return this.init(this.context.getServerSocketFactory().createServerSocket(port));
    }","  public void test12()  throws Throwable  {
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createServerSocket(0, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3392,"    public java.net.ServerSocket createServerSocket(final int port) throws IOException {
        return this.init(this.context.getServerSocketFactory().createServerSocket(port));
    }","  public void test13()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createServerSocket((-1), (-1));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port value out of range: -1
         //
         verifyException(""java.net.ServerSocket"", e);
      }
  }"
3393,"    public java.net.ServerSocket createServerSocket(final int port) throws IOException {
        return this.init(this.context.getServerSocketFactory().createServerSocket(port));
    }","  public void test14()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createServerSocket((-3));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Port value out of range: -3
         //
         verifyException(""java.net.ServerSocket"", e);
      }
  }"
3394,"    public java.net.ServerSocket createServerSocket(final int port) throws IOException {
        return this.init(this.context.getServerSocketFactory().createServerSocket(port));
    }","  public void test15()  throws Throwable  {
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createServerSocket(91);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3395,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test16()  throws Throwable  {
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory((SSLContext) null);
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket(""The wildcard array must not be null"", 0, inetAddress0, 0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3396,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test17()  throws Throwable  {
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.createSocket((InetAddress) null, 2546);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3397,"    public Socket createSocket() throws IOException{
        return this.context.getSocketFactory().createSocket();
    }","  public void test18()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory(sSLContext0);
      Socket socket0 = fTPSSocketFactory0.createSocket();
}"
3398,"    public java.net.ServerSocket init(final java.net.ServerSocket socket) throws IOException {
        ((javax.net.ssl.SSLServerSocket) socket).setUseClientMode(true);
        return socket;
    }","  public void test19()  throws Throwable  {
      FTPSSocketFactory fTPSSocketFactory0 = new FTPSSocketFactory((SSLContext) null);
      InetAddress inetAddress0 = MockInetAddress.getLocalHost();
      MockServerSocket mockServerSocket0 = new MockServerSocket(1, 1, inetAddress0);
      // Undeclared exception!
      try { 
        fTPSSocketFactory0.init(mockServerSocket0);
        fail(""Expecting exception: ClassCastException"");
      } catch(ClassCastException e) {
         //
         // org.evosuite.runtime.mock.java.net.MockServerSocket cannot be cast to javax.net.ssl.SSLServerSocket
         //
         verifyException(""org.apache.commons.net.ftp.FTPSSocketFactory"", e);
      }
  }"
3399,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        return reader.readLine();
    }","  public void test0()  throws Throwable  {
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser();
      StringReader stringReader0 = new StringReader("""");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 16);
      String string0 = unixFTPEntryParser0.readNextEntry(bufferedReader0);
}"
3400,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        return reader.readLine();
    }","  public void test1()  throws Throwable  {
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser();
      StringReader stringReader0 = new StringReader(""gdNm9"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      String string0 = macOsPeterFTPEntryParser0.readNextEntry(bufferedReader0);
}"
3401,"    public List<String> preParse(final List<String> original) {
         return original;
     }","  public void test2()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      List<String> list0 = mVSFTPEntryParser0.preParse(linkedList0);
}"
3402,"    public List<String> preParse(final List<String> original) {
         return original;
     }","  public void test3()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser(fTPClientConfig0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.offerLast(""UNIX_LTRIM"");
      List<String> list0 = oS2FTPEntryParser0.preParse(linkedList0);
}"
3403,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        return reader.readLine();
    }","  public void test4()  throws Throwable  {
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser();
      StringReader stringReader0 = new StringReader(""~M"");
      stringReader0.close();
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 3425);
      try { 
        macOsPeterFTPEntryParser0.readNextEntry(bufferedReader0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.StringReader"", e);
      }
  }"
3404,"    public List<String> preParse(final List<String> original) {
         return original;
     }","  public void test5()  throws Throwable  {
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser((FTPClientConfig) null, true);
      // Undeclared exception!
      try { 
        unixFTPEntryParser0.preParse((List<String>) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.parser.UnixFTPEntryParser"", e);
      }
  }"
3405,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        return reader.readLine();
    }","  public void test6()  throws Throwable  {
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser((FTPClientConfig) null);
      // Undeclared exception!
      try { 
        netwareFTPEntryParser0.readNextEntry((BufferedReader) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPFileEntryParserImpl"", e);
      }
  }"
3406,"    public List<String> preParse(final List<String> original) {
         return original;
     }","  public void test7()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      List<String> list0 = vMSFTPEntryParser0.preParse((List<String>) null);
}"
3407,"    public byte[] parseADATReply(final String reply)
    {
        if (reply == null) {
            return null;
        }
        return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
    }","  public void test0()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      byte[] byteArray0 = fTPSClient0.parseADATReply("")ADAT="");
}"
3408,"    public byte[] parseADATReply(final String reply)
    {
        if (reply == null) {
            return null;
        }
        return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
    }","  public void test1()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      byte[] byteArray0 = fTPSClient0.parseADATReply("")ADAT="");
}"
3409,"    public String getAuthValue() {
        return this.auth;
    }","  public void test2()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      byte[] byteArray0 = fTPSClient0.parseADATReply("")ADAT="");
}"
3410,"    public byte[] parseADATReply(final String reply)
    {
        if (reply == null) {
            return null;
        }
        return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
    }","  public void test3()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      byte[] byteArray0 = fTPSClient0.parseADATReply("")ADAT="");
}"
3411,"    protected void execAUTH() throws SSLException, IOException {
        final int replyCode = sendCommand(CMD_AUTH, auth);
        if (FTPReply.SECURITY_MECHANISM_IS_OK == replyCode) {
            // replyCode = 334
            // I carry out an ADAT command.
        } else if (FTPReply.SECURITY_DATA_EXCHANGE_COMPLETE != replyCode) {
            throw new SSLException(getReplyString());
        }
    }","  public void test4()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""", true);
      try { 
        fTPSClient0.execAUTH("""");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3412,"    protected Socket _openDataConnection_(final int command, final String arg)
            throws IOException {
        return _openDataConnection_(FTPCommand.getCommand(command), arg);
    }","  public void test5()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(true);
      // Undeclared exception!
      try { 
        fTPSClient0._openDataConnection_(0, """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3413,"    public long parsePBSZ(final long pbsz) throws SSLException, IOException {
        execPBSZ(pbsz);
        long minvalue = pbsz;
        final String remainder = extractPrefixedData(""PBSZ="", getReplyString());
        if (remainder != null) {
            final long replysz = Long.parseLong(remainder);
            if (replysz < minvalue) {
                minvalue = replysz;
            }
        }
        return minvalue;
    }","  public void test6()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      try { 
        fTPSClient0.parsePBSZ(4294967295L);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3414,"    public String getAuthValue() {
        return this.auth;
    }","  public void test7()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""XGs[%2+|o%|/nmg+"", true);
      fTPSClient0.setWantClientAuth(true);
}"
3415,"    public void setWantClientAuth(final boolean isWantClientAuth) {
        this.isWantClientAuth = isWantClientAuth;
    }","  public void test8()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""XGs[%2+|o%|/nmg+"", true);
      fTPSClient0.setWantClientAuth(true);
}"
3416,"    public void setNeedClientAuth(final boolean isNeedClientAuth) {
        this.isNeedClientAuth = isNeedClientAuth;
    }","  public void test9()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(true);
      fTPSClient0.setNeedClientAuth(true);
}"
3417,"    public String getAuthValue() {
        return this.auth;
    }","  public void test10()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(true);
      fTPSClient0.setNeedClientAuth(true);
}"
3418,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test11()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""E"", true);
      fTPSClient0.setEndpointCheckingEnabled(true);
      boolean boolean0 = fTPSClient0.isEndpointCheckingEnabled();
}"
3419,"    public void setEnabledProtocols(final String[] protocolVersions) {
        protocols = protocolVersions.clone();
    }","  public void test12()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(true, (SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSClient0.setEnabledProtocols((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSClient"", e);
      }
  }"
3420,"    public void setEnabledCipherSuites(final String[] cipherSuites) {
        suites = cipherSuites.clone();
    }","  public void test13()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((SSLContext) null);
      // Undeclared exception!
      try { 
        fTPSClient0.setEnabledCipherSuites((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSClient"", e);
      }
  }"
3421,"    public int sendCommand(final String command, final String args) throws IOException {
        final int repCode = super.sendCommand(command, args);
        /* If CCC is issued, restore socket i/o streams to unsecured versions */
        if (CMD_CCC.equals(command)) {
            if (FTPReply.COMMAND_OK == repCode) {
                _socket_.close();
                _socket_ = plainSocket;
                _controlInput_ = new BufferedReader(
                    new InputStreamReader(
                        _socket_ .getInputStream(), getControlEncoding()));
                _controlOutput_ = new BufferedWriter(
                    new OutputStreamWriter(
                        _socket_.getOutputStream(), getControlEncoding()));
            } else {
                throw new SSLException(getReplyString());
            }
        }
        return repCode;
    }","  public void test14()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null, true);
      try { 
        fTPSClient0.sendCommand(""y0)-'Vgy+4[Iz;( ("", ""eZNs+f/8ck"");
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3422,"    public long parsePBSZ(final long pbsz) throws SSLException, IOException {
        execPBSZ(pbsz);
        long minvalue = pbsz;
        final String remainder = extractPrefixedData(""PBSZ="", getReplyString());
        if (remainder != null) {
            final long replysz = Long.parseLong(remainder);
            if (replysz < minvalue) {
                minvalue = replysz;
            }
        }
        return minvalue;
    }","  public void test15()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null);
      try { 
        fTPSClient0.parsePBSZ(0L);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3423,"    protected void execAUTH() throws SSLException, IOException {
        final int replyCode = sendCommand(CMD_AUTH, auth);
        if (FTPReply.SECURITY_MECHANISM_IS_OK == replyCode) {
            // replyCode = 334
            // I carry out an ADAT command.
        } else if (FTPReply.SECURITY_DATA_EXCHANGE_COMPLETE != replyCode) {
            throw new SSLException(getReplyString());
        }
    }","  public void test16()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""A3|Qf:>lNmhRS47J>"");
      try { 
        fTPSClient0.execAUTH();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3424,"    protected Socket _openDataConnection_(final int command, final String arg)
            throws IOException {
        return _openDataConnection_(FTPCommand.getCommand(command), arg);
    }","  public void test17()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""E"", true);
      // Undeclared exception!
      try { 
        fTPSClient0._openDataConnection_(""\r\n"", ""E"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3425,"    protected Socket _openDataConnection_(final int command, final String arg)
            throws IOException {
        return _openDataConnection_(FTPCommand.getCommand(command), arg);
    }","  public void test18()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""C"", false);
      // Undeclared exception!
      try { 
        fTPSClient0._openDataConnection_(119, """");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 119
         //
         verifyException(""org.apache.commons.net.ftp.FTPCommand"", e);
      }
  }"
3426,"    public void execPBSZ(final long pbsz) throws SSLException, IOException {
        if (pbsz < 0 || 4294967295L < pbsz) { // 32-bit unsigned number
            throw new IllegalArgumentException();
        }
        final int status = sendCommand(CMD_PBSZ, String.valueOf(pbsz));
        if (FTPReply.COMMAND_OK != status) {
            throw new SSLException(getReplyString());
        }
    }","  public void test19()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSClient fTPSClient0 = new FTPSClient(false, sSLContext0);
      // Undeclared exception!
      try { 
        fTPSClient0.execPBSZ((-1126L));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSClient"", e);
      }
  }"
3427,"    public byte[] parseADATReply(final String reply)
    {
        if (reply == null) {
            return null;
        }
        return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
    }","  public void test20()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""LpE"", false);
      // Undeclared exception!
      try { 
        fTPSClient0.parseADATReply(""\r\n"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.util.Base64"", e);
      }
  }"
3428,"    public String getAuthValue() {
        return this.auth;
    }","  public void test21()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""p"");
      fTPSClient0.parseADATReply((String) null);
}"
3429,"    public byte[] parseADATReply(final String reply)
    {
        if (reply == null) {
            return null;
        }
        return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
    }","  public void test22()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""p"");
      fTPSClient0.parseADATReply((String) null);
}"
3430,"    public byte[] parseADATReply(final String reply)
    {
        if (reply == null) {
            return null;
        }
        return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
    }","  public void test23()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      byte[] byteArray0 = fTPSClient0.parseADATReply(""ADAT="");
}"
3431,"    public byte[] parseADATReply(final String reply)
    {
        if (reply == null) {
            return null;
        }
        return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
    }","  public void test24()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      byte[] byteArray0 = fTPSClient0.parseADATReply(""ADAT="");
}"
3432,"    public String getAuthValue() {
        return this.auth;
    }","  public void test25()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      byte[] byteArray0 = fTPSClient0.parseADATReply(""ADAT="");
}"
3433,"    public byte[] parseADATReply(final String reply)
    {
        if (reply == null) {
            return null;
        }
        return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
    }","  public void test26()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      byte[] byteArray0 = fTPSClient0.parseADATReply(""ADAT="");
}"
3434,"    public int execENC(final byte[] data) throws IOException
    {
        if (data != null)
        {
            return sendCommand(CMD_ENC, Base64.encodeBase64StringUnChunked(data));
        }
        return sendCommand(CMD_ENC, """"); // perhaps ""="" or just sendCommand(String)?
    }","  public void test27()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""xjn4-h\""V`638U>g'3"");
      byte[] byteArray0 = new byte[3];
      try { 
        fTPSClient0.execENC(byteArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3435,"    public int execENC(final byte[] data) throws IOException
    {
        if (data != null)
        {
            return sendCommand(CMD_ENC, Base64.encodeBase64StringUnChunked(data));
        }
        return sendCommand(CMD_ENC, """"); // perhaps ""="" or just sendCommand(String)?
    }","  public void test28()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      try { 
        fTPSClient0.execENC((byte[]) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3436,"    public int execCONF(final byte[] data) throws IOException
    {
        if (data != null)
        {
            return sendCommand(CMD_CONF, Base64.encodeBase64StringUnChunked(data));
        }
        return sendCommand(CMD_CONF, """"); // perhaps ""="" or just sendCommand(String)?
    }","  public void test29()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      byte[] byteArray0 = new byte[9];
      try { 
        fTPSClient0.execCONF(byteArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3437,"    public int execCONF(final byte[] data) throws IOException
    {
        if (data != null)
        {
            return sendCommand(CMD_CONF, Base64.encodeBase64StringUnChunked(data));
        }
        return sendCommand(CMD_CONF, """"); // perhaps ""="" or just sendCommand(String)?
    }","  public void test30()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(false);
      try { 
        fTPSClient0.execCONF((byte[]) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3438,"    public int execMIC(final byte[] data) throws IOException
    {
        if (data != null)
        {
            return sendCommand(CMD_MIC, Base64.encodeBase64StringUnChunked(data));
        }
        return sendCommand(CMD_MIC, """"); // perhaps ""="" or just sendCommand(String)?
    }","  public void test31()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""", true);
      byte[] byteArray0 = new byte[6];
      try { 
        fTPSClient0.execMIC(byteArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3439,"    public int execMIC(final byte[] data) throws IOException
    {
        if (data != null)
        {
            return sendCommand(CMD_MIC, Base64.encodeBase64StringUnChunked(data));
        }
        return sendCommand(CMD_MIC, """"); // perhaps ""="" or just sendCommand(String)?
    }","  public void test32()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((SSLContext) null);
      try { 
        fTPSClient0.execMIC((byte[]) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3440,"    public int execADAT(final byte[] data) throws IOException
    {
        if (data != null)
        {
            return sendCommand(CMD_ADAT, Base64.encodeBase64StringUnChunked(data));
        }
        return sendCommand(CMD_ADAT);
    }","  public void test33()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""$VALUES"");
      byte[] byteArray0 = new byte[7];
      try { 
        fTPSClient0.execADAT(byteArray0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3441,"    public int execADAT(final byte[] data) throws IOException
    {
        if (data != null)
        {
            return sendCommand(CMD_ADAT, Base64.encodeBase64StringUnChunked(data));
        }
        return sendCommand(CMD_ADAT);
    }","  public void test34()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      try { 
        fTPSClient0.execADAT((byte[]) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3442,"    public String getAuthValue() {
        return this.auth;
    }","  public void test35()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.disconnect();
}"
3443,"    public void disconnect() throws IOException
    {
        super.disconnect();
        if (plainSocket != null) {
            plainSocket.close();
        }
        setSocketFactory(null);
        setServerSocketFactory(null);
    }","  public void test36()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.disconnect();
}"
3444,"    public void execPROT(String prot) throws SSLException, IOException {
        if (prot == null) {
            prot = DEFAULT_PROT;
        }
        if (!checkPROTValue(prot)) {
            throw new IllegalArgumentException();
        }
        if (FTPReply.COMMAND_OK != sendCommand(CMD_PROT, prot)) {
            throw new SSLException(getReplyString());
        }
        if (DEFAULT_PROT.equals(prot)) {
            setSocketFactory(null);
            setServerSocketFactory(null);
        } else {
            setSocketFactory(new FTPSSocketFactory(context));
            setServerSocketFactory(new FTPSServerSocketFactory(context));
            initSslContext();
        }
    }","  public void test37()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(true);
      // Undeclared exception!
      try { 
        fTPSClient0.execPROT(""T"");
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSClient"", e);
      }
  }"
3445,"    public void execPBSZ(final long pbsz) throws SSLException, IOException {
        if (pbsz < 0 || 4294967295L < pbsz) { // 32-bit unsigned number
            throw new IllegalArgumentException();
        }
        final int status = sendCommand(CMD_PBSZ, String.valueOf(pbsz));
        if (FTPReply.COMMAND_OK != status) {
            throw new SSLException(getReplyString());
        }
    }","  public void test38()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("")M_3i-G9mz "");
      // Undeclared exception!
      try { 
        fTPSClient0.execPBSZ(4294967315L);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSClient"", e);
      }
  }"
3446,"    public void execPBSZ(final long pbsz) throws SSLException, IOException {
        if (pbsz < 0 || 4294967295L < pbsz) { // 32-bit unsigned number
            throw new IllegalArgumentException();
        }
        final int status = sendCommand(CMD_PBSZ, String.valueOf(pbsz));
        if (FTPReply.COMMAND_OK != status) {
            throw new SSLException(getReplyString());
        }
    }","  public void test39()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      try { 
        fTPSClient0.execPBSZ(9L);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3447,"    public long parsePBSZ(final long pbsz) throws SSLException, IOException {
        execPBSZ(pbsz);
        long minvalue = pbsz;
        final String remainder = extractPrefixedData(""PBSZ="", getReplyString());
        if (remainder != null) {
            final long replysz = Long.parseLong(remainder);
            if (replysz < minvalue) {
                minvalue = replysz;
            }
        }
        return minvalue;
    }","  public void test40()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      // Undeclared exception!
      try { 
        fTPSClient0.parsePBSZ((byte) (-70));
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSClient"", e);
      }
  }"
3448,"    public String[] getEnabledProtocols() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getEnabledProtocols();
        }
        return null;
    }","  public void test41()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null, false);
      fTPSClient0.getEnabledProtocols();
}"
3449,"    public String getAuthValue() {
        return this.auth;
    }","  public void test42()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null, false);
      fTPSClient0.getEnabledProtocols();
}"
3450,"    public String[] getEnabledCipherSuites() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getEnabledCipherSuites();
        }
        return null;
    }","  public void test43()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""");
      fTPSClient0.getEnabledCipherSuites();
}"
3451,"    public String getAuthValue() {
        return this.auth;
    }","  public void test44()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""");
      fTPSClient0.getEnabledCipherSuites();
}"
3452,"    public boolean getUseClientMode() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getUseClientMode();
        }
        return false;
    }","  public void test45()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null, false);
      boolean boolean0 = fTPSClient0.getUseClientMode();
}"
3453,"    public String getAuthValue() {
        return this.auth;
    }","  public void test46()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null, false);
      boolean boolean0 = fTPSClient0.getUseClientMode();
}"
3454,"    public boolean getUseClientMode() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getUseClientMode();
        }
        return false;
    }","  public void test47()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((String) null, false);
      boolean boolean0 = fTPSClient0.getUseClientMode();
}"
3455,"    public boolean getWantClientAuth() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getWantClientAuth();
        }
        return false;
    }","  public void test48()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("" JM{0a8$Xd 17Gp"");
      boolean boolean0 = fTPSClient0.getWantClientAuth();
}"
3456,"    public boolean getWantClientAuth() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getWantClientAuth();
        }
        return false;
    }","  public void test49()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("" JM{0a8$Xd 17Gp"");
      boolean boolean0 = fTPSClient0.getWantClientAuth();
}"
3457,"    public String getAuthValue() {
        return this.auth;
    }","  public void test50()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("" JM{0a8$Xd 17Gp"");
      boolean boolean0 = fTPSClient0.getWantClientAuth();
}"
3458,"    public boolean getNeedClientAuth() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getNeedClientAuth();
        }
        return false;
    }","  public void test51()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""AATH"");
      boolean boolean0 = fTPSClient0.getNeedClientAuth();
}"
3459,"    public String getAuthValue() {
        return this.auth;
    }","  public void test52()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""AATH"");
      boolean boolean0 = fTPSClient0.getNeedClientAuth();
}"
3460,"    public boolean getNeedClientAuth() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getNeedClientAuth();
        }
        return false;
    }","  public void test53()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""AATH"");
      boolean boolean0 = fTPSClient0.getNeedClientAuth();
}"
3461,"    public boolean getEnableSessionCreation() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getEnableSessionCreation();
        }
        return false;
    }","  public void test54()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""$VALUES"");
      boolean boolean0 = fTPSClient0.getEnableSessionCreation();
}"
3462,"    public boolean getEnableSessionCreation() {
        if (_socket_ instanceof SSLSocket) {
            return ((SSLSocket)_socket_).getEnableSessionCreation();
        }
        return false;
    }","  public void test55()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""$VALUES"");
      boolean boolean0 = fTPSClient0.getEnableSessionCreation();
}"
3463,"    public String getAuthValue() {
        return this.auth;
    }","  public void test56()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""$VALUES"");
      boolean boolean0 = fTPSClient0.getEnableSessionCreation();
}"
3464,"    protected void sslNegotiation() throws IOException {
        plainSocket = _socket_;
        initSslContext();
        final SSLSocket socket = createSSLSocket(_socket_);
        socket.setEnableSessionCreation(isCreation);
        socket.setUseClientMode(isClientMode);

        // client mode
        if (isClientMode) {
            if (tlsEndpointChecking) {
                SSLSocketUtils.enableEndpointNameVerification(socket);
            }
        } else { // server mode
            socket.setNeedClientAuth(isNeedClientAuth);
            socket.setWantClientAuth(isWantClientAuth);
        }

        if (protocols != null) {
            socket.setEnabledProtocols(protocols);
        }
        if (suites != null) {
            socket.setEnabledCipherSuites(suites);
        }
        socket.startHandshake();

        // TODO the following setup appears to duplicate that in the super class methods
        _socket_ = socket;
        _controlInput_ = new BufferedReader(new InputStreamReader(
                socket .getInputStream(), getControlEncoding()));
        _controlOutput_ = new BufferedWriter(new OutputStreamWriter(
                socket.getOutputStream(), getControlEncoding()));

        if (isClientMode) {
            if (hostnameVerifier != null &&
                !hostnameVerifier.verify(_hostname_, socket.getSession())) {
                throw new SSLHandshakeException(""Hostname doesn't match certificate"");
            }
        }
    }","  public void test57()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      FTPSClient fTPSClient0 = new FTPSClient(false, sSLContext0);
      // Undeclared exception!
      try { 
        fTPSClient0.sslNegotiation();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPSClient"", e);
      }
  }"
3465,"    protected void _connectAction_() throws IOException {
        // Implicit mode.
        if (isImplicit) {
            applySocketAttributes();
            sslNegotiation();
        }
        super._connectAction_();
        // Explicit mode.
        if (!isImplicit) {
            execAUTH();
            sslNegotiation();
        }
    }","  public void test58()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("".@E6'V1cuo[d J"", true);
      // Undeclared exception!
      try { 
        fTPSClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3466,"    protected void _connectAction_() throws IOException {
        // Implicit mode.
        if (isImplicit) {
            applySocketAttributes();
            sslNegotiation();
        }
        super._connectAction_();
        // Explicit mode.
        if (!isImplicit) {
            execAUTH();
            sslNegotiation();
        }
    }","  public void test59()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      // Undeclared exception!
      try { 
        fTPSClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3467,"    public String getAuthValue() {
        return this.auth;
    }","  public void test60()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""LpE"", false);
      fTPSClient0.getHostnameVerifier();
}"
3468,"    public HostnameVerifier getHostnameVerifier()
    {
        return hostnameVerifier;
    }","  public void test61()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""LpE"", false);
      fTPSClient0.getHostnameVerifier();
}"
3469,"    public String getAuthValue() {
        return this.auth;
    }","  public void test62()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""$VALUES"");
      String string0 = fTPSClient0.getAuthValue();
}"
3470,"    public String getAuthValue() {
        return this.auth;
    }","  public void test63()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""$VALUES"");
      String string0 = fTPSClient0.getAuthValue();
}"
3471,"    public String getAuthValue() {
        return this.auth;
    }","  public void test64()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""$VALUES"");
      String string0 = fTPSClient0.getAuthValue();
}"
3472,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test65()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""", false);
      fTPSClient0.isEndpointCheckingEnabled();
}"
3473,"    public String getAuthValue() {
        return this.auth;
    }","  public void test66()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""", false);
      fTPSClient0.isEndpointCheckingEnabled();
}"
3474,"    public void execPROT(String prot) throws SSLException, IOException {
        if (prot == null) {
            prot = DEFAULT_PROT;
        }
        if (!checkPROTValue(prot)) {
            throw new IllegalArgumentException();
        }
        if (FTPReply.COMMAND_OK != sendCommand(CMD_PROT, prot)) {
            throw new SSLException(getReplyString());
        }
        if (DEFAULT_PROT.equals(prot)) {
            setSocketFactory(null);
            setServerSocketFactory(null);
        } else {
            setSocketFactory(new FTPSSocketFactory(context));
            setServerSocketFactory(new FTPSServerSocketFactory(context));
            initSslContext();
        }
    }","  public void test67()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient((SSLContext) null);
      try { 
        fTPSClient0.execPROT((String) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3475,"    public void setEnabledSessionCreation(final boolean isCreation) {
        this.isCreation = isCreation;
    }","  public void test68()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""");
      fTPSClient0.setEnabledSessionCreation(true);
}"
3476,"    public String getAuthValue() {
        return this.auth;
    }","  public void test69()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("""");
      fTPSClient0.setEnabledSessionCreation(true);
}"
3477,"    public String getAuthValue() {
        return this.auth;
    }","  public void test70()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("".@E6'V1cuo[d J"", true);
      String[] stringArray0 = new String[2];
      fTPSClient0.setEnabledCipherSuites(stringArray0);
}"
3478,"    public void setEnabledCipherSuites(final String[] cipherSuites) {
        suites = cipherSuites.clone();
    }","  public void test71()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("".@E6'V1cuo[d J"", true);
      String[] stringArray0 = new String[2];
      fTPSClient0.setEnabledCipherSuites(stringArray0);
}"
3479,"    public void setUseClientMode(final boolean isClientMode) {
        this.isClientMode = isClientMode;
    }","  public void test72()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("".@E6'V1cuo[d J"", true);
      fTPSClient0.setUseClientMode(true);
}"
3480,"    public String getAuthValue() {
        return this.auth;
    }","  public void test73()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("".@E6'V1cuo[d J"", true);
      fTPSClient0.setUseClientMode(true);
}"
3481,"    public int execCCC() throws IOException
    {
        final int repCode = sendCommand(CMD_CCC);
// This will be performed by sendCommand(String, String)
//        if (FTPReply.isPositiveCompletion(repCode)) {
//            _socket_.close();
//            _socket_ = plainSocket;
//            _controlInput_ = new BufferedReader(
//                new InputStreamReader(
//                    _socket_.getInputStream(), getControlEncoding()));
//            _controlOutput_ = new BufferedWriter(
//                new OutputStreamWriter(
//                    _socket_.getOutputStream(), getControlEncoding()));
//        }
        return repCode;
    }","  public void test74()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("" JM{0a8$Xd 17Gp"");
      try { 
        fTPSClient0.execCCC();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Connection is not open
         //
         verifyException(""org.apache.commons.net.ftp.FTP"", e);
      }
  }"
3482,"    public String getAuthValue() {
        return this.auth;
    }","  public void test75()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""LpE"", false);
      fTPSClient0.setAuthValue(""/systemType.properties"");
}"
3483,"    protected void _prepareDataSocket_(final Socket socket)
            throws IOException {
    }","  public void test76()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      MockSocket mockSocket0 = new MockSocket();
      fTPSClient0._prepareDataSocket_(mockSocket0);
}"
3484,"    public String getAuthValue() {
        return this.auth;
    }","  public void test77()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      MockSocket mockSocket0 = new MockSocket();
      fTPSClient0._prepareDataSocket_(mockSocket0);
}"
3485,"    public String getAuthValue() {
        return this.auth;
    }","  public void test78()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""`"");
      String[] stringArray0 = new String[2];
      fTPSClient0.setEnabledProtocols(stringArray0);
}"
3486,"    public void setEnabledProtocols(final String[] protocolVersions) {
        protocols = protocolVersions.clone();
    }","  public void test79()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""`"");
      String[] stringArray0 = new String[2];
      fTPSClient0.setEnabledProtocols(stringArray0);
}"
3487,"    public void setHostnameVerifier(final HostnameVerifier newHostnameVerifier)
    {
        hostnameVerifier = newHostnameVerifier;
    }","  public void test80()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.setHostnameVerifier((HostnameVerifier) null);
}"
3488,"    public String getAuthValue() {
        return this.auth;
    }","  public void test81()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      fTPSClient0.setHostnameVerifier((HostnameVerifier) null);
}"
3489,"    public String getAuthValue() {
        return this.auth;
    }","  public void test82()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      TrustManager trustManager0 = fTPSClient0.getTrustManager();
      fTPSClient0.setTrustManager(trustManager0);
}"
3490,"    public void setTrustManager(final TrustManager trustManager) {
        this.trustManager = trustManager;
    }","  public void test83()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient();
      TrustManager trustManager0 = fTPSClient0.getTrustManager();
      fTPSClient0.setTrustManager(trustManager0);
}"
3491,"    protected void sslNegotiation() throws IOException {
        plainSocket = _socket_;
        initSslContext();
        final SSLSocket socket = createSSLSocket(_socket_);
        socket.setEnableSessionCreation(isCreation);
        socket.setUseClientMode(isClientMode);

        // client mode
        if (isClientMode) {
            if (tlsEndpointChecking) {
                SSLSocketUtils.enableEndpointNameVerification(socket);
            }
        } else { // server mode
            socket.setNeedClientAuth(isNeedClientAuth);
            socket.setWantClientAuth(isWantClientAuth);
        }

        if (protocols != null) {
            socket.setEnabledProtocols(protocols);
        }
        if (suites != null) {
            socket.setEnabledCipherSuites(suites);
        }
        socket.startHandshake();

        // TODO the following setup appears to duplicate that in the super class methods
        _socket_ = socket;
        _controlInput_ = new BufferedReader(new InputStreamReader(
                socket .getInputStream(), getControlEncoding()));
        _controlOutput_ = new BufferedWriter(new OutputStreamWriter(
                socket.getOutputStream(), getControlEncoding()));

        if (isClientMode) {
            if (hostnameVerifier != null &&
                !hostnameVerifier.verify(_hostname_, socket.getSession())) {
                throw new SSLHandshakeException(""Hostname doesn't match certificate"");
            }
        }
    }","  public void test84()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient("".@E6'V1cuo[d J"", true);
      try { 
        fTPSClient0.sslNegotiation();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Could not initialize SSL context
         //
         verifyException(""org.apache.commons.net.util.SSLContextUtils"", e);
      }
  }"
3492,"    public String getAuthValue() {
        return this.auth;
    }","  public void test85()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""AATH"");
      fTPSClient0.setKeyManager((KeyManager) null);
}"
3493,"    public void setKeyManager(final KeyManager keyManager) {
        this.keyManager = keyManager;
    }","  public void test86()  throws Throwable  {
      FTPSClient fTPSClient0 = new FTPSClient(""AATH"");
      fTPSClient0.setKeyManager((KeyManager) null);
}"
3494,"    public FTPFile[] getPrevious(final int quantityRequested) {
        final List<FTPFile> tmpResults = new LinkedList<>();
        int count = quantityRequested;
        while (count > 0 && this.internalIterator.hasPrevious()) {
            final String entry = this.internalIterator.previous();
            FTPFile temp = this.parser.parseFTPEntry(entry);
            if (temp == null && saveUnparseableEntries) {
                temp = new FTPFile(entry);
            }
            tmpResults.add(0,temp);
            count--;
        }
        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
    }","  public void test0()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      FTPFile[] fTPFileArray0 = fTPListParseEngine0.getPrevious((-1));
}"
3495,"    public FTPFile[] getNext(final int quantityRequested) {
        final List<FTPFile> tmpResults = new LinkedList<>();
        int count = quantityRequested;
        while (count > 0 && this.internalIterator.hasNext()) {
            final String entry = this.internalIterator.next();
            FTPFile temp = this.parser.parseFTPEntry(entry);
            if (temp == null && saveUnparseableEntries) {
                temp = new FTPFile(entry);
            }
            tmpResults.add(temp);
            count--;
        }
        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);

    }","  public void test1()  throws Throwable  {
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser((FTPClientConfig) null, false);
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(unixFTPEntryParser0, unixFTPEntryParser0.NUMERIC_DATE_CONFIG);
      FTPFile[] fTPFileArray0 = fTPListParseEngine0.getNext((-1908));
}"
3496,"    public boolean hasNext() {
        return internalIterator.hasNext();
    }","  public void test2()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0, (String) null);
}"
3497,"    public boolean hasPrevious() {
        return internalIterator.hasPrevious();
    }","  public void test3()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0);
      fTPListParseEngine0.getNext(147);
      boolean boolean0 = fTPListParseEngine0.hasPrevious();
}"
3498,"    public boolean hasNext() {
        return internalIterator.hasNext();
    }","  public void test4()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0);
      boolean boolean0 = fTPListParseEngine0.hasNext();
}"
3499,"    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
        this.entries = new LinkedList<>();
        read(inputStream, charsetName);
        this.parser.preParse(this.entries);
        resetIterator();
    }","  public void test5()  throws Throwable  {
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser();
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(vMSFTPEntryParser0);
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      // Undeclared exception!
      try { 
        fTPListParseEngine0.readServerList((InputStream) sequenceInputStream0, ""org.apache.commons.net.ftp.FTPFileFilters"");
        fail(""Expecting exception: UnsupportedCharsetException"");
      } catch(UnsupportedCharsetException e) {
         //
         // org.apache.commons.net.ftp.FTPFileFilters
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
3500,"    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
        this.entries = new LinkedList<>();
        read(inputStream, charsetName);
        this.parser.preParse(this.entries);
        resetIterator();
    }","  public void test6()  throws Throwable  {
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine((FTPFileEntryParser) null);
      // Undeclared exception!
      try { 
        fTPListParseEngine0.readServerList((InputStream) null, (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Reader"", e);
      }
  }"
3501,"    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
        this.entries = new LinkedList<>();
        read(inputStream, charsetName);
        this.parser.preParse(this.entries);
        resetIterator();
    }","  public void test7()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", """", (String) null, "".c+z/>"");
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine((FTPFileEntryParser) null, fTPClientConfig0);
      byte[] byteArray0 = new byte[2];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)100, (-1));
      // Undeclared exception!
      try { 
        fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0, (String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPListParseEngine"", e);
      }
  }"
3502,"    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
        this.entries = new LinkedList<>();
        read(inputStream, charsetName);
        this.parser.preParse(this.entries);
        resetIterator();
    }","  public void test8()  throws Throwable  {
      EnterpriseUnixFTPEntryParser enterpriseUnixFTPEntryParser0 = new EnterpriseUnixFTPEntryParser();
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(enterpriseUnixFTPEntryParser0);
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      try { 
        fTPListParseEngine0.readServerList((InputStream) pipedInputStream0, (String) null);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedInputStream"", e);
      }
  }"
3503,"    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
        this.entries = new LinkedList<>();
        read(inputStream, charsetName);
        this.parser.preParse(this.entries);
        resetIterator();
    }","  public void test9()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS400FTPEntryParser0);
      // Undeclared exception!
      try { 
        fTPListParseEngine0.readServerList((InputStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Reader"", e);
      }
  }"
3504,"    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
        this.entries = new LinkedList<>();
        read(inputStream, charsetName);
        this.parser.preParse(this.entries);
        resetIterator();
    }","  public void test10()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      NTFTPEntryParser nTFTPEntryParser0 = new NTFTPEntryParser(fTPClientConfig0);
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(nTFTPEntryParser0, fTPClientConfig0);
      DataInputStream dataInputStream0 = new DataInputStream((InputStream) null);
      // Undeclared exception!
      try { 
        fTPListParseEngine0.readServerList((InputStream) dataInputStream0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.DataInputStream"", e);
      }
  }"
3505,"    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
        this.entries = new LinkedList<>();
        read(inputStream, charsetName);
        this.parser.preParse(this.entries);
        resetIterator();
    }","  public void test11()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""#f(Qz}(w}c&"", (String) null, ""5K"", """", ""5K"", (String) null, false, true);
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(mLSxEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[9];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (-2401), (byte)119);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      // Undeclared exception!
      try { 
        fTPListParseEngine0.readServerList((InputStream) sequenceInputStream0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ByteArrayInputStream"", e);
      }
  }"
3506,"    public FTPFile[] getFiles()
    throws IOException // TODO remove; not actually thrown
    {
        return getFiles(FTPFileFilters.NON_NULL);
    }","  public void test12()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0);
      // Undeclared exception!
      try { 
        fTPListParseEngine0.getFiles((FTPFileFilter) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.FTPListParseEngine"", e);
      }
  }"
3507,"    public boolean hasNext() {
        return internalIterator.hasNext();
    }","  public void test13()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0);
      FTPFileFilter fTPFileFilter0 = mock(FTPFileFilter.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(fTPFileFilter0).accept(any(org.apache.commons.net.ftp.FTPFile.class));
      fTPListParseEngine0.getFiles(fTPFileFilter0);
}"
3508,"    public boolean hasNext() {
        return internalIterator.hasNext();
    }","  public void test14()  throws Throwable  {
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser((FTPClientConfig) null);
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(netwareFTPEntryParser0, (FTPClientConfig) null);
}"
3509,"    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
        this.entries = new LinkedList<>();
        read(inputStream, charsetName);
        this.parser.preParse(this.entries);
        resetIterator();
    }","  public void test15()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      // Undeclared exception!
      try { 
        fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0, ""I`-Xn)zhidgk^:$v$d"");
        fail(""Expecting exception: IllegalCharsetNameException"");
      } catch(IllegalCharsetNameException e) {
         //
         // I`-Xn)zhidgk^:$v$d
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
3510,"    public boolean hasNext() {
        return internalIterator.hasNext();
    }","  public void test16()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0);
      FTPFileFilter fTPFileFilter0 = mock(FTPFileFilter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(fTPFileFilter0).accept(any(org.apache.commons.net.ftp.FTPFile.class));
      fTPListParseEngine0.getFiles(fTPFileFilter0);
}"
3511,"    public boolean hasNext() {
        return internalIterator.hasNext();
    }","  public void test17()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0);
      fTPListParseEngine0.getFiles();
}"
3512,"    public FTPFile[] getPrevious(final int quantityRequested) {
        final List<FTPFile> tmpResults = new LinkedList<>();
        int count = quantityRequested;
        while (count > 0 && this.internalIterator.hasPrevious()) {
            final String entry = this.internalIterator.previous();
            FTPFile temp = this.parser.parseFTPEntry(entry);
            if (temp == null && saveUnparseableEntries) {
                temp = new FTPFile(entry);
            }
            tmpResults.add(0,temp);
            count--;
        }
        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
    }","  public void test18()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      FTPFile[] fTPFileArray0 = fTPListParseEngine0.getPrevious((byte)36);
}"
3513,"    public boolean hasNext() {
        return internalIterator.hasNext();
    }","  public void test19()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS2FTPEntryParser0, fTPClientConfig0);
      byte[] byteArray0 = new byte[6];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      fTPListParseEngine0.readServerList((InputStream) byteArrayInputStream0);
      fTPListParseEngine0.getNext(1);
      fTPListParseEngine0.getPrevious(1);
}"
3514,"    public boolean hasNext() {
        return internalIterator.hasNext();
    }","  public void test20()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS400FTPEntryParser0);
      boolean boolean0 = fTPListParseEngine0.hasNext();
}"
3515,"    public boolean hasNext() {
        return internalIterator.hasNext();
    }","  public void test21()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS400FTPEntryParser0);
      fTPListParseEngine0.resetIterator();
}"
3516,"    public boolean hasPrevious() {
        return internalIterator.hasPrevious();
    }","  public void test22()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(oS400FTPEntryParser0);
      boolean boolean0 = fTPListParseEngine0.hasPrevious();
}"
3517,"    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
        this.entries = new LinkedList<>();
        read(inputStream, charsetName);
        this.parser.preParse(this.entries);
        resetIterator();
    }","  public void test23()  throws Throwable  {
      EnterpriseUnixFTPEntryParser enterpriseUnixFTPEntryParser0 = new EnterpriseUnixFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""D"");
      FTPListParseEngine fTPListParseEngine0 = new FTPListParseEngine(enterpriseUnixFTPEntryParser0, fTPClientConfig0);
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      BufferedInputStream bufferedInputStream0 = new BufferedInputStream(pipedInputStream0, 793);
      try { 
        fTPListParseEngine0.readServerList((InputStream) bufferedInputStream0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedInputStream"", e);
      }
  }"
3518,"    public static String getCommand(final int command) {
        return commands[command];
    }","  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        FTPSCommand.getCommand(214);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 214
         //
         verifyException(""org.apache.commons.net.ftp.FTPSCommand"", e);
      }
  }"
3519,,"  public void test1()  throws Throwable  {
      FTPSCommand fTPSCommand0 = new FTPSCommand();
}"
3520,"    public static String getCommand(final int command) {
        return commands[command];
    }","  public void test2()  throws Throwable  {
      String string0 = FTPSCommand.getCommand(1);
}"
3521,"    public Throwable getRootCause() {
        return super.getCause();
    }","  public void test0()  throws Throwable  {
      MockThrowable mockThrowable0 = new MockThrowable((Throwable) null);
      ParserInitializationException parserInitializationException0 = new ParserInitializationException("""", mockThrowable0);
      Throwable throwable0 = parserInitializationException0.getRootCause();
}"
3522,"    public Throwable getRootCause() {
        return super.getCause();
    }","  public void test1()  throws Throwable  {
      ParserInitializationException parserInitializationException0 = new ParserInitializationException("""");
      Throwable throwable0 = parserInitializationException0.getRootCause();
}"
3523,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test0()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      // Undeclared exception!
      try { 
        mLSxEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3524,"    public static FTPFile parseEntry(final String entry) {
        return INSTANCE.parseFTPEntry(entry);
    }","  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        MLSxEntryParser.parseEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3525,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test2()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""=; ]u0Nm,;ij9Atm+_-"");
}"
3526,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test3()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""=; ]u0Nm,;ij9Atm+_-"");
}"
3527,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test4()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""=; ]u0Nm,;ij9Atm+_-"");
}"
3528,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test5()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = new MLSxEntryParser();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""N; }u0iVm,Z9A+_<--."");
}"
3529,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test6()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = new MLSxEntryParser();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""TYQe=(; >"");
}"
3530,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test7()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = new MLSxEntryParser();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""TYQe=(; >"");
}"
3531,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test8()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = new MLSxEntryParser();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""TYQe=(; >"");
}"
3532,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test9()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""_8.[N "");
}"
3533,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test10()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""X"");
}"
3534,"    public static Calendar parseGMTdateTime(final String timestamp) {
        final SimpleDateFormat sdf;
        final boolean hasMillis;
        if (timestamp.contains(""."")){
            sdf = new SimpleDateFormat(""yyyyMMddHHmmss.SSS"");
            hasMillis = true;
        } else {
            sdf = new SimpleDateFormat(""yyyyMMddHHmmss"");
            hasMillis = false;
        }
        final TimeZone GMT = TimeZone.getTimeZone(""GMT"");
        // both time zones need to be set for the parse to work OK
        sdf.setTimeZone(GMT);
        final GregorianCalendar gc = new GregorianCalendar(GMT);
        final ParsePosition pos = new ParsePosition(0);
        sdf.setLenient(false); // We want to parse the whole string
        final Date parsed = sdf.parse(timestamp, pos);
        if (pos.getIndex()  != timestamp.length()) {
            return null; // did not fully parse the input
        }
        gc.setTime(parsed);
        if (!hasMillis) {
            gc.clear(Calendar.MILLISECOND); // flag up missing ms units
        }
        return gc;
    }","  public void test11()  throws Throwable  {
      // Undeclared exception!
      try { 
        MLSxEntryParser.parseGMTdateTime("""");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3535,"    public static Calendar parseGMTdateTime(final String timestamp) {
        final SimpleDateFormat sdf;
        final boolean hasMillis;
        if (timestamp.contains(""."")){
            sdf = new SimpleDateFormat(""yyyyMMddHHmmss.SSS"");
            hasMillis = true;
        } else {
            sdf = new SimpleDateFormat(""yyyyMMddHHmmss"");
            hasMillis = false;
        }
        final TimeZone GMT = TimeZone.getTimeZone(""GMT"");
        // both time zones need to be set for the parse to work OK
        sdf.setTimeZone(GMT);
        final GregorianCalendar gc = new GregorianCalendar(GMT);
        final ParsePosition pos = new ParsePosition(0);
        sdf.setLenient(false); // We want to parse the whole string
        final Date parsed = sdf.parse(timestamp, pos);
        if (pos.getIndex()  != timestamp.length()) {
            return null; // did not fully parse the input
        }
        gc.setTime(parsed);
        if (!hasMillis) {
            gc.clear(Calendar.MILLISECOND); // flag up missing ms units
        }
        return gc;
    }","  public void test12()  throws Throwable  {
      Calendar calendar0 = MLSxEntryParser.parseGMTdateTime(""!-Wpn]&sj\"".: em:"");
}"
3536,"    public static FTPFile parseEntry(final String entry) {
        return INSTANCE.parseFTPEntry(entry);
    }","  public void test13()  throws Throwable  {
      FTPFile fTPFile0 = MLSxEntryParser.parseEntry(""=; ]u0Nm,;ij9Atm+_-"");
}"
3537,"    public static FTPFile parseEntry(final String entry) {
        return INSTANCE.parseFTPEntry(entry);
    }","  public void test14()  throws Throwable  {
      FTPFile fTPFile0 = MLSxEntryParser.parseEntry(""=; ]u0Nm,;ij9Atm+_-"");
}"
3538,"    public static FTPFile parseEntry(final String entry) {
        return INSTANCE.parseFTPEntry(entry);
    }","  public void test15()  throws Throwable  {
      FTPFile fTPFile0 = MLSxEntryParser.parseEntry(""=; ]u0Nm,;ij9Atm+_-"");
}"
3539,"    public static FTPFile parseEntry(final String entry) {
        return INSTANCE.parseFTPEntry(entry);
    }","  public void test16()  throws Throwable  {
      FTPFile fTPFile0 = MLSxEntryParser.parseEntry(""d; Di8h~)[8n+9AI-."");
}"
3540,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test17()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = new MLSxEntryParser();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry(""bu2G#G#88Q-M P"");
}"
3541,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test18()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry("" %8d"");
}"
3542,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test19()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry("" %8d"");
}"
3543,"    public FTPFile parseFTPEntry(final String entry) {
        if (entry.startsWith("" "")) {// leading space means no facts are present
            if (entry.length() > 1) { // is there a path name?
                final FTPFile file = new FTPFile();
                file.setRawListing(entry);
                file.setName(entry.substring(1));
                return file;
            }
            return null; // Invalid - no pathname

        }
        final String parts[] = entry.split("" "",2); // Path may contain space
        if (parts.length != 2 || parts[1].isEmpty()) {
            return null; // no space found or no file name
        }
        final String factList = parts[0];
        if (!factList.endsWith("";"")) {
            return null;
        }
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        file.setName(parts[1]);
        final String[] facts = factList.split("";"");
        final boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
        for(final String fact : facts) {
            final String []factparts = fact.split(""="", -1); // Don't drop empty values
// Sample missing permission
// drwx------   2 mirror   mirror       4096 Mar 13  2010 subversion
// modify=20100313224553;perm=;type=dir;unique=811U282598;UNIX.group=500;UNIX.mode=0700;UNIX.owner=500; subversion
            if (factparts.length != 2) {
                return null; // invalid - there was no ""="" sign
            }
            final String factname = factparts[0].toLowerCase(Locale.ENGLISH);
            final String factvalue = factparts[1];
            if (factvalue.isEmpty()) {
                continue; // nothing to see here
            }
            final String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
            if (""size"".equals(factname) || ""sizd"".equals(factname)) {
                file.setSize(Long.parseLong(factvalue));
            }
            else if (""modify"".equals(factname)) {
                final Calendar parsed = parseGMTdateTime(factvalue);
                if (parsed == null) {
                    return null;
                }
                file.setTimestamp(parsed);
            }
            else if (""type"".equals(factname)) {
                    final Integer intType = TYPE_TO_INT.get(valueLowerCase);
                    if (intType == null) {
                        file.setType(FTPFile.UNKNOWN_TYPE);
                    } else {
                        file.setType(intType.intValue());
                    }
            }
            else if (factname.startsWith(""unix."")) {
                final String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
                if (""group"".equals(unixfact)){
                    file.setGroup(factvalue);
                } else if (""owner"".equals(unixfact)){
                    file.setUser(factvalue);
                } else if (""mode"".equals(unixfact)){ // e.g. 0[1]755
                    final int off = factvalue.length()-3; // only parse last 3 digits
                    for(int i=0; i < 3; i++){
                        final int ch = factvalue.charAt(off+i)-'0';
                        if (ch >= 0 && ch <= 7) { // Check it's valid octal
                            for(final int p : UNIX_PERMS[ch]) {
                                file.setPermission(UNIX_GROUPS[i], p, true);
                            }
                        } else {
                            // TODO should this cause failure, or can it be reported somehow?
                        }
                    } // digits
                } // mode
            } // unix.
            else if (!hasUnixMode && ""perm"".equals(factname)) { // skip if we have the UNIX.mode
                doUnixPerms(file, valueLowerCase);
            } // process ""perm""
        } // each fact
        return file;
    }","  public void test20()  throws Throwable  {
      MLSxEntryParser mLSxEntryParser0 = new MLSxEntryParser();
      FTPFile fTPFile0 = mLSxEntryParser0.parseFTPEntry("" "");
}"
3544,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_UNIX,
                DEFAULT_DATE_FORMAT,
                DEFAULT_RECENT_DATE_FORMAT);
    }","  public void test0()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0, false);
      FTPClientConfig fTPClientConfig1 = unixFTPEntryParser0.getDefaultConfiguration();
}"
3545,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_UNIX,
                DEFAULT_DATE_FORMAT,
                DEFAULT_RECENT_DATE_FORMAT);
    }","  public void test1()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0, false);
      FTPClientConfig fTPClientConfig1 = unixFTPEntryParser0.getDefaultConfiguration();
}"
3546,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_UNIX,
                DEFAULT_DATE_FORMAT,
                DEFAULT_RECENT_DATE_FORMAT);
    }","  public void test2()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0, false);
      FTPClientConfig fTPClientConfig1 = unixFTPEntryParser0.getDefaultConfiguration();
}"
3547,"    public List<String> preParse(final List<String> original) {
        final ListIterator<String> iter = original.listIterator();
        while (iter.hasNext()) {
            final String entry = iter.next();
            if (entry.matches(""^total \\d+$"")) { // NET-389
                iter.remove();
            }
        }
        return original;
    }","  public void test3()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      List<String> list0 = linkedList0.subList(0, 0);
      linkedList0.add(""total= 0"");
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser();
      // Undeclared exception!
      try { 
        unixFTPEntryParser0.preParse(list0);
        fail(""Expecting exception: ConcurrentModificationException"");
      } catch(ConcurrentModificationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.SubList"", e);
      }
  }"
3548,"    public List<String> preParse(final List<String> original) {
        final ListIterator<String> iter = original.listIterator();
        while (iter.hasNext()) {
            final String entry = iter.next();
            if (entry.matches(""^total \\d+$"")) { // NET-389
                iter.remove();
            }
        }
        return original;
    }","  public void test4()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0, false);
      // Undeclared exception!
      try { 
        unixFTPEntryParser0.preParse((List<String>) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.parser.UnixFTPEntryParser"", e);
      }
  }"
3549,"    public FTPFile parseFTPEntry(final String entry) {
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        final int type;
        boolean isDevice = false;

        if (matches(entry))
        {
            final String typeStr = group(1);
            final String hardLinkCount = group(15);
            final String usr = group(16);
            final String grp = group(17);
            final String filesize = group(18);
            final String datestr = group(19) + "" "" + group(20);
            String name = group(21);
            if (trimLeadingSpaces) {
                name = name.replaceFirst(""^\\s+"", """");
            }

            try
            {
                if (group(19).contains(JA_MONTH)) { // special processing for Japanese format
                    final FTPTimestampParserImpl jaParser = new FTPTimestampParserImpl();
                    jaParser.configure(new FTPClientConfig(
                            FTPClientConfig.SYST_UNIX, DEFAULT_DATE_FORMAT_JA, DEFAULT_RECENT_DATE_FORMAT_JA));
                    file.setTimestamp(jaParser.parseTimestamp(datestr));
                } else {
                    file.setTimestamp(super.parseTimestamp(datestr));
                }
            }
            catch (final ParseException e)
            {
                 // intentionally do nothing
            }

            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of
            // 'translucent' filesystems, of which a 'union' filesystem is one.

            // bcdelfmpSs-
            switch (typeStr.charAt(0))
            {
            case 'd':
                type = FTPFile.DIRECTORY_TYPE;
                break;
            case 'e': // NET-39 => z/OS external link
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'l':
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'b':
            case 'c':
                isDevice = true;
                type = FTPFile.FILE_TYPE; // TODO change this if DEVICE_TYPE implemented
                break;
            case 'f':
            case '-':
                type = FTPFile.FILE_TYPE;
                break;
            default: // e.g. ? and w = whiteout
                type = FTPFile.UNKNOWN_TYPE;
            }

            file.setType(type);

            int g = 4;
            for (int access = 0; access < 3; access++, g += 4)
            {
                // Use != '-' to avoid having to check for suid and sticky bits
                file.setPermission(access, FTPFile.READ_PERMISSION,
                                   !group(g).equals(""-""));
                file.setPermission(access, FTPFile.WRITE_PERMISSION,
                                   !group(g + 1).equals(""-""));

                final String execPerm = group(g + 2);
                if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0)))
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
                }
                else
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
                }
            }

            if (!isDevice)
            {
                try
                {
                    file.setHardLinkCount(Integer.parseInt(hardLinkCount));
                }
                catch (final NumberFormatException e)
                {
                    // intentionally do nothing
                }
            }

            file.setUser(usr);
            file.setGroup(grp);

            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            // oddball cases like symbolic links, file names
            // with spaces in them.
            if (type == FTPFile.SYMBOLIC_LINK_TYPE)
            {

                final int end = name.indexOf("" -> "");
                // Give up if no link indicator is present
                if (end == -1)
                {
                    file.setName(name);
                }
                else
                {
                    file.setName(name.substring(0, end));
                    file.setLink(name.substring(end + 4));
                }

            }
            else
            {
                file.setName(name);
            }
            return file;
        }
        return null;
    }","  public void test5()  throws Throwable  {
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser();
      // Undeclared exception!
      try { 
        unixFTPEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3550,"    public UnixFTPEntryParser()
    {
        this(null);
    }","  public void test6()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""_hk(*v%aLo{kO"", ""_hk(*v%aLo{kO"", ""_hk(*v%aLo{kO"");
      UnixFTPEntryParser unixFTPEntryParser0 = null;
      try {
        unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0, true);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'v'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3551,"    public UnixFTPEntryParser()
    {
        this(null);
    }","  public void test7()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""?K5zEI[_4Hm9\""1Qa"", ""?K5zEI[_4Hm9\""1Qa"", "":%1$tM"", ""?K5zEI[_4Hm9\""1Qa"", ""^s+"", "":%1$tM"", false, false);
      UnixFTPEntryParser unixFTPEntryParser0 = null;
      try {
        unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0, false);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3552,"    public UnixFTPEntryParser()
    {
        this(null);
    }","  public void test8()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""sv"", ""sv"", ""X2;l8&/\"""");
      UnixFTPEntryParser unixFTPEntryParser0 = null;
      try {
        unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'l'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3553,"    public UnixFTPEntryParser()
    {
        this(null);
    }","  public void test9()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""2Zyo@6;q0O_>RIk{b"", ""2Zyo@6;q0O_>RIk{b"", ""2Zyo@6;q0O_>RIk{b"", ""UNIX"", ""^total d+$"", ""TrPwGnt|;G7Va"", true, false);
      UnixFTPEntryParser unixFTPEntryParser0 = null;
      try {
        unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3554,"    public UnixFTPEntryParser()
    {
        this(null);
    }","  public void test10()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0);
}"
3555,"    public UnixFTPEntryParser()
    {
        this(null);
    }","  public void test11()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0);
}"
3556,"    public FTPFile parseFTPEntry(final String entry) {
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        final int type;
        boolean isDevice = false;

        if (matches(entry))
        {
            final String typeStr = group(1);
            final String hardLinkCount = group(15);
            final String usr = group(16);
            final String grp = group(17);
            final String filesize = group(18);
            final String datestr = group(19) + "" "" + group(20);
            String name = group(21);
            if (trimLeadingSpaces) {
                name = name.replaceFirst(""^\\s+"", """");
            }

            try
            {
                if (group(19).contains(JA_MONTH)) { // special processing for Japanese format
                    final FTPTimestampParserImpl jaParser = new FTPTimestampParserImpl();
                    jaParser.configure(new FTPClientConfig(
                            FTPClientConfig.SYST_UNIX, DEFAULT_DATE_FORMAT_JA, DEFAULT_RECENT_DATE_FORMAT_JA));
                    file.setTimestamp(jaParser.parseTimestamp(datestr));
                } else {
                    file.setTimestamp(super.parseTimestamp(datestr));
                }
            }
            catch (final ParseException e)
            {
                 // intentionally do nothing
            }

            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of
            // 'translucent' filesystems, of which a 'union' filesystem is one.

            // bcdelfmpSs-
            switch (typeStr.charAt(0))
            {
            case 'd':
                type = FTPFile.DIRECTORY_TYPE;
                break;
            case 'e': // NET-39 => z/OS external link
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'l':
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'b':
            case 'c':
                isDevice = true;
                type = FTPFile.FILE_TYPE; // TODO change this if DEVICE_TYPE implemented
                break;
            case 'f':
            case '-':
                type = FTPFile.FILE_TYPE;
                break;
            default: // e.g. ? and w = whiteout
                type = FTPFile.UNKNOWN_TYPE;
            }

            file.setType(type);

            int g = 4;
            for (int access = 0; access < 3; access++, g += 4)
            {
                // Use != '-' to avoid having to check for suid and sticky bits
                file.setPermission(access, FTPFile.READ_PERMISSION,
                                   !group(g).equals(""-""));
                file.setPermission(access, FTPFile.WRITE_PERMISSION,
                                   !group(g + 1).equals(""-""));

                final String execPerm = group(g + 2);
                if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0)))
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
                }
                else
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
                }
            }

            if (!isDevice)
            {
                try
                {
                    file.setHardLinkCount(Integer.parseInt(hardLinkCount));
                }
                catch (final NumberFormatException e)
                {
                    // intentionally do nothing
                }
            }

            file.setUser(usr);
            file.setGroup(grp);

            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            // oddball cases like symbolic links, file names
            // with spaces in them.
            if (type == FTPFile.SYMBOLIC_LINK_TYPE)
            {

                final int end = name.indexOf("" -> "");
                // Give up if no link indicator is present
                if (end == -1)
                {
                    file.setName(name);
                }
                else
                {
                    file.setName(name.substring(0, end));
                    file.setLink(name.substring(end + 4));
                }

            }
            else
            {
                file.setName(name);
            }
            return file;
        }
        return null;
    }","  public void test12()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0, false);
      unixFTPEntryParser0.setRegex(""AS/400"", 0);
      // Undeclared exception!
      try { 
        unixFTPEntryParser0.parseFTPEntry(""AS/400"");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 1
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3557,"    public List<String> preParse(final List<String> original) {
        final ListIterator<String> iter = original.listIterator();
        while (iter.hasNext()) {
            final String entry = iter.next();
            if (entry.matches(""^total \\d+$"")) { // NET-389
                iter.remove();
            }
        }
        return original;
    }","  public void test13()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""total 0"");
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser();
      unixFTPEntryParser0.preParse(linkedList0);
}"
3558,"    public List<String> preParse(final List<String> original) {
        final ListIterator<String> iter = original.listIterator();
        while (iter.hasNext()) {
            final String entry = iter.next();
            if (entry.matches(""^total \\d+$"")) { // NET-389
                iter.remove();
            }
        }
        return original;
    }","  public void test14()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""total 0"");
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser();
      unixFTPEntryParser0.preParse(linkedList0);
}"
3559,"    public List<String> preParse(final List<String> original) {
        final ListIterator<String> iter = original.listIterator();
        while (iter.hasNext()) {
            final String entry = iter.next();
            if (entry.matches(""^total \\d+$"")) { // NET-389
                iter.remove();
            }
        }
        return original;
    }","  public void test15()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""tota= 0"");
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser();
      unixFTPEntryParser0.preParse(linkedList0);
}"
3560,"    public FTPFile parseFTPEntry(final String entry) {
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        final int type;
        boolean isDevice = false;

        if (matches(entry))
        {
            final String typeStr = group(1);
            final String hardLinkCount = group(15);
            final String usr = group(16);
            final String grp = group(17);
            final String filesize = group(18);
            final String datestr = group(19) + "" "" + group(20);
            String name = group(21);
            if (trimLeadingSpaces) {
                name = name.replaceFirst(""^\\s+"", """");
            }

            try
            {
                if (group(19).contains(JA_MONTH)) { // special processing for Japanese format
                    final FTPTimestampParserImpl jaParser = new FTPTimestampParserImpl();
                    jaParser.configure(new FTPClientConfig(
                            FTPClientConfig.SYST_UNIX, DEFAULT_DATE_FORMAT_JA, DEFAULT_RECENT_DATE_FORMAT_JA));
                    file.setTimestamp(jaParser.parseTimestamp(datestr));
                } else {
                    file.setTimestamp(super.parseTimestamp(datestr));
                }
            }
            catch (final ParseException e)
            {
                 // intentionally do nothing
            }

            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of
            // 'translucent' filesystems, of which a 'union' filesystem is one.

            // bcdelfmpSs-
            switch (typeStr.charAt(0))
            {
            case 'd':
                type = FTPFile.DIRECTORY_TYPE;
                break;
            case 'e': // NET-39 => z/OS external link
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'l':
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'b':
            case 'c':
                isDevice = true;
                type = FTPFile.FILE_TYPE; // TODO change this if DEVICE_TYPE implemented
                break;
            case 'f':
            case '-':
                type = FTPFile.FILE_TYPE;
                break;
            default: // e.g. ? and w = whiteout
                type = FTPFile.UNKNOWN_TYPE;
            }

            file.setType(type);

            int g = 4;
            for (int access = 0; access < 3; access++, g += 4)
            {
                // Use != '-' to avoid having to check for suid and sticky bits
                file.setPermission(access, FTPFile.READ_PERMISSION,
                                   !group(g).equals(""-""));
                file.setPermission(access, FTPFile.WRITE_PERMISSION,
                                   !group(g + 1).equals(""-""));

                final String execPerm = group(g + 2);
                if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0)))
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
                }
                else
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
                }
            }

            if (!isDevice)
            {
                try
                {
                    file.setHardLinkCount(Integer.parseInt(hardLinkCount));
                }
                catch (final NumberFormatException e)
                {
                    // intentionally do nothing
                }
            }

            file.setUser(usr);
            file.setGroup(grp);

            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            // oddball cases like symbolic links, file names
            // with spaces in them.
            if (type == FTPFile.SYMBOLIC_LINK_TYPE)
            {

                final int end = name.indexOf("" -> "");
                // Give up if no link indicator is present
                if (end == -1)
                {
                    file.setName(name);
                }
                else
                {
                    file.setName(name.substring(0, end));
                    file.setLink(name.substring(end + 4));
                }

            }
            else
            {
                file.setName(name);
            }
            return file;
        }
        return null;
    }","  public void test16()  throws Throwable  {
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser();
      FTPFile fTPFile0 = unixFTPEntryParser0.parseFTPEntry(""total 0"");
}"
3561,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test0()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = (VMSVersioningFTPEntryParser)defaultFTPFileEntryParserFactory0.createFileEntryParser(""[wQ!`vms7}Lzg[("");
}"
3562,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test1()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      // Undeclared exception!
      try { 
        defaultFTPFileEntryParserFactory0.createFileEntryParser(""org.apache.commons.net.ftp.systemType.default"");
        fail(""Expecting exception: RuntimeException"");
      } catch(RuntimeException e) {
         //
         // Unknown parser type: org.apache.commons.net.ftp.systemType.default
         //
         verifyException(""org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory"", e);
      }
  }"
3563,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test2()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory"");
      try { 
        defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
        fail(""Expecting exception: RuntimeException"");
      } catch(RuntimeException e) {
         //
         // org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory does not implement the interface org.apache.commons.net.ftp.FTPFileEntryParser.
         //
         verifyException(""org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory"", e);
      }
  }"
3564,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test3()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, (String) null, ""^Rd^SJ"", "":\""sd6eK^bf6*X&*"", ""^Rd^SJ"", """");
      // Undeclared exception!
      try { 
        defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3565,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test4()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      fTPClientConfig0.setDefaultDateFormatStr(""(p{javaJavaIdentifierStart}(p{javaJavaIdentifierPart})*.)+p{javaJavaIdentifierStart}(p{javaJavaIdentifierPart})*"");
      // Undeclared exception!
      try { 
        defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'p'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3566,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test5()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""WINDOWS"", ""WINDOWS"", ""WINDOWS"", ""WINDOWS"", ""WINDOWS"", ""WINDOWS"");
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      // Undeclared exception!
      try { 
        defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3567,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test6()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      UnixFTPEntryParser unixFTPEntryParser0 = (UnixFTPEntryParser)defaultFTPFileEntryParserFactory0.createFileEntryParser(""TYPE: L8"");
}"
3568,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test7()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = (MacOsPeterFTPEntryParser)defaultFTPFileEntryParserFactory0.createFileEntryParser(""MACOS PETER"");
}"
3569,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test8()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      NetwareFTPEntryParser netwareFTPEntryParser0 = (NetwareFTPEntryParser)defaultFTPFileEntryParserFactory0.createFileEntryParser(""NETWARE"");
}"
3570,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test9()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""OS/400"", ""NETWARE"", ""OS/400"", ""NETWARE"", ""NETWARE"", ""NETWARE"", false, false);
      // Undeclared exception!
      try { 
        defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3571,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test10()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      OS2FTPEntryParser oS2FTPEntryParser0 = (OS2FTPEntryParser)defaultFTPFileEntryParserFactory0.createFileEntryParser(""OS/2"");
}"
3572,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test11()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""pWINDOWS"");
      FTPFileEntryParser fTPFileEntryParser0 = defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
}"
3573,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test12()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""pWINDOWS"");
      FTPFileEntryParser fTPFileEntryParser0 = defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
}"
3574,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test13()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = (VMSVersioningFTPEntryParser)defaultFTPFileEntryParserFactory0.createFileEntryParser(""VMS"");
}"
3575,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test14()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      UnixFTPEntryParser unixFTPEntryParser0 = (UnixFTPEntryParser)defaultFTPFileEntryParserFactory0.createFileEntryParser(""UNIX_LTRIM"");
}"
3576,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test15()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      NetwareFTPEntryParser netwareFTPEntryParser0 = (NetwareFTPEntryParser)defaultFTPFileEntryParserFactory0.createFileEntryParser(""org.apache.commons.net.ftp.parser.NetwareFTPEntryParser"");
}"
3577,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test16()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      // Undeclared exception!
      try { 
        defaultFTPFileEntryParserFactory0.createFileEntryParser(""org.apache.commons.io.filefilter.FileFileFilter"");
        fail(""Expecting exception: RuntimeException"");
      } catch(RuntimeException e) {
         //
         // Error initializing parser
         //
         verifyException(""org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory"", e);
      }
  }"
3578,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test17()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      // Undeclared exception!
      try { 
        defaultFTPFileEntryParserFactory0.createFileEntryParser((String) null);
        fail(""Expecting exception: RuntimeException"");
      } catch(RuntimeException e) {
         //
         // Parser key cannot be null
         //
         verifyException(""org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory"", e);
      }
  }"
3579,"    public FTPFileEntryParser createOS400FTPEntryParser()
    {
        return createOS400FTPEntryParser(null);
    }","  public void test18()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPFileEntryParser fTPFileEntryParser0 = defaultFTPFileEntryParserFactory0.createOS400FTPEntryParser();
}"
3580,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test19()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      MVSFTPEntryParser mVSFTPEntryParser0 = (MVSFTPEntryParser)defaultFTPFileEntryParserFactory0.createMVSEntryParser();
      FTPClientConfig fTPClientConfig0 = mVSFTPEntryParser0.getDefaultConfiguration();
      MVSFTPEntryParser mVSFTPEntryParser1 = (MVSFTPEntryParser)defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
}"
3581,"    public FTPFileEntryParser createVMSVersioningFTPEntryParser()
    {
        return new VMSVersioningFTPEntryParser();
    }","  public void test20()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = (VMSVersioningFTPEntryParser)defaultFTPFileEntryParserFactory0.createVMSVersioningFTPEntryParser();
}"
3582,"    public FTPFileEntryParser createNTFTPEntryParser()
    {
        return createNTFTPEntryParser(null);
    }","  public void test21()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPFileEntryParser fTPFileEntryParser0 = defaultFTPFileEntryParserFactory0.createNTFTPEntryParser();
}"
3583,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test22()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""LHGGAS/400"");
      FTPFileEntryParser fTPFileEntryParser0 = defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
}"
3584,"    public FTPFileEntryParser createFileEntryParser(final String key)
    {
        if (key == null) {
            throw new ParserInitializationException(""Parser key cannot be null"");
        }
        return createFileEntryParser(key, null);
    }","  public void test23()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""LHGGAS/400"");
      FTPFileEntryParser fTPFileEntryParser0 = defaultFTPFileEntryParserFactory0.createFileEntryParser(fTPClientConfig0);
}"
3585,"    public FTPFileEntryParser createUnixFTPEntryParser()
    {
        return new UnixFTPEntryParser();
    }","  public void test24()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      UnixFTPEntryParser unixFTPEntryParser0 = (UnixFTPEntryParser)defaultFTPFileEntryParserFactory0.createUnixFTPEntryParser();
}"
3586,"    public FTPFileEntryParser createNetwareFTPEntryParser() {
        return new NetwareFTPEntryParser();
    }","  public void test25()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      NetwareFTPEntryParser netwareFTPEntryParser0 = (NetwareFTPEntryParser)defaultFTPFileEntryParserFactory0.createNetwareFTPEntryParser();
}"
3587,"     public FTPFileEntryParser createOS2FTPEntryParser()
    {
        return new OS2FTPEntryParser();
    }","  public void test26()  throws Throwable  {
      DefaultFTPFileEntryParserFactory defaultFTPFileEntryParserFactory0 = new DefaultFTPFileEntryParserFactory();
      OS2FTPEntryParser oS2FTPEntryParser0 = (OS2FTPEntryParser)defaultFTPFileEntryParserFactory0.createOS2FTPEntryParser();
}"
3588,"    public FTPFile parseFTPEntry(final String listEntry)
    {
        if (cachedFtpFileEntryParser != null)
        {
            final FTPFile matched = cachedFtpFileEntryParser.parseFTPEntry(listEntry);
            if (matched != null)
            {
                return matched;
            }
        }
        else
        {
            for (final FTPFileEntryParser ftpFileEntryParser : ftpFileEntryParsers)
            {
                final FTPFile matched = ftpFileEntryParser.parseFTPEntry(listEntry);
                if (matched != null)
                {
                    cachedFtpFileEntryParser = ftpFileEntryParser;
                    return matched;
                }
            }
        }
        return null;
    }","  public void test0()  throws Throwable  {
      FTPFileEntryParser[] fTPFileEntryParserArray0 = new FTPFileEntryParser[1];
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      fTPFileEntryParserArray0[0] = (FTPFileEntryParser) vMSFTPEntryParser0;
      vMSFTPEntryParser0.setRegex(""AS/400"");
      CompositeFileEntryParser compositeFileEntryParser0 = new CompositeFileEntryParser(fTPFileEntryParserArray0);
      // Undeclared exception!
      try { 
        compositeFileEntryParser0.parseFTPEntry(""AS/400"");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 1
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3589,"    public FTPFile parseFTPEntry(final String listEntry)
    {
        if (cachedFtpFileEntryParser != null)
        {
            final FTPFile matched = cachedFtpFileEntryParser.parseFTPEntry(listEntry);
            if (matched != null)
            {
                return matched;
            }
        }
        else
        {
            for (final FTPFileEntryParser ftpFileEntryParser : ftpFileEntryParsers)
            {
                final FTPFile matched = ftpFileEntryParser.parseFTPEntry(listEntry);
                if (matched != null)
                {
                    cachedFtpFileEntryParser = ftpFileEntryParser;
                    return matched;
                }
            }
        }
        return null;
    }","  public void test1()  throws Throwable  {
      FTPFileEntryParser[] fTPFileEntryParserArray0 = new FTPFileEntryParser[1];
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      fTPFileEntryParserArray0[0] = (FTPFileEntryParser) mLSxEntryParser0;
      CompositeFileEntryParser compositeFileEntryParser0 = new CompositeFileEntryParser(fTPFileEntryParserArray0);
      FTPFile fTPFile0 = compositeFileEntryParser0.parseFTPEntry(""TYPE: L8"");
}"
3590,"    public FTPFile parseFTPEntry(final String listEntry)
    {
        if (cachedFtpFileEntryParser != null)
        {
            final FTPFile matched = cachedFtpFileEntryParser.parseFTPEntry(listEntry);
            if (matched != null)
            {
                return matched;
            }
        }
        else
        {
            for (final FTPFileEntryParser ftpFileEntryParser : ftpFileEntryParsers)
            {
                final FTPFile matched = ftpFileEntryParser.parseFTPEntry(listEntry);
                if (matched != null)
                {
                    cachedFtpFileEntryParser = ftpFileEntryParser;
                    return matched;
                }
            }
        }
        return null;
    }","  public void test2()  throws Throwable  {
      FTPFileEntryParser[] fTPFileEntryParserArray0 = new FTPFileEntryParser[1];
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      fTPFileEntryParserArray0[0] = (FTPFileEntryParser) mLSxEntryParser0;
      CompositeFileEntryParser compositeFileEntryParser0 = new CompositeFileEntryParser(fTPFileEntryParserArray0);
      compositeFileEntryParser0.parseFTPEntry("" */gjN*H"");
      FTPFile fTPFile0 = compositeFileEntryParser0.parseFTPEntry("" */gjN*H"");
}"
3591,"    public FTPFile parseFTPEntry(final String listEntry)
    {
        if (cachedFtpFileEntryParser != null)
        {
            final FTPFile matched = cachedFtpFileEntryParser.parseFTPEntry(listEntry);
            if (matched != null)
            {
                return matched;
            }
        }
        else
        {
            for (final FTPFileEntryParser ftpFileEntryParser : ftpFileEntryParsers)
            {
                final FTPFile matched = ftpFileEntryParser.parseFTPEntry(listEntry);
                if (matched != null)
                {
                    cachedFtpFileEntryParser = ftpFileEntryParser;
                    return matched;
                }
            }
        }
        return null;
    }","  public void test3()  throws Throwable  {
      FTPFileEntryParser[] fTPFileEntryParserArray0 = new FTPFileEntryParser[1];
      MLSxEntryParser mLSxEntryParser0 = MLSxEntryParser.getInstance();
      fTPFileEntryParserArray0[0] = (FTPFileEntryParser) mLSxEntryParser0;
      CompositeFileEntryParser compositeFileEntryParser0 = new CompositeFileEntryParser(fTPFileEntryParserArray0);
      compositeFileEntryParser0.parseFTPEntry("" */gjN*H"");
      FTPFile fTPFile0 = compositeFileEntryParser0.parseFTPEntry(""MVS"");
}"
3592,"    public FTPFile parseFTPEntry(final String listEntry)
    {
        if (cachedFtpFileEntryParser != null)
        {
            final FTPFile matched = cachedFtpFileEntryParser.parseFTPEntry(listEntry);
            if (matched != null)
            {
                return matched;
            }
        }
        else
        {
            for (final FTPFileEntryParser ftpFileEntryParser : ftpFileEntryParsers)
            {
                final FTPFile matched = ftpFileEntryParser.parseFTPEntry(listEntry);
                if (matched != null)
                {
                    cachedFtpFileEntryParser = ftpFileEntryParser;
                    return matched;
                }
            }
        }
        return null;
    }","  public void test4()  throws Throwable  {
      CompositeFileEntryParser compositeFileEntryParser0 = new CompositeFileEntryParser((FTPFileEntryParser[]) null);
      // Undeclared exception!
      try { 
        compositeFileEntryParser0.parseFTPEntry(""9:fZ!5o?R;^KvhG"");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.parser.CompositeFileEntryParser"", e);
      }
  }"
3593,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_VMS,
                DEFAULT_DATE_FORMAT,
                null);
    }","  public void test0()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      FTPClientConfig fTPClientConfig1 = vMSFTPEntryParser0.getDefaultConfiguration();
}"
3594,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_VMS,
                DEFAULT_DATE_FORMAT,
                null);
    }","  public void test1()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      FTPClientConfig fTPClientConfig1 = vMSFTPEntryParser0.getDefaultConfiguration();
}"
3595,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        String line = reader.readLine();
        final StringBuilder entry = new StringBuilder();
        while (line != null)
        {
            if (line.startsWith(""Directory"") || line.startsWith(""Total"")) {
                line = reader.readLine();
                continue;
            }

            entry.append(line);
            if (line.trim().endsWith("")""))
            {
                break;
            }
            line = reader.readLine();
        }
        return entry.length() == 0 ? null : entry.toString();
    }","  public void test2()  throws Throwable  {
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser();
      // Undeclared exception!
      try { 
        vMSFTPEntryParser0.readNextEntry((BufferedReader) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.parser.VMSFTPEntryParser"", e);
      }
  }"
3596,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        String line = reader.readLine();
        final StringBuilder entry = new StringBuilder();
        while (line != null)
        {
            if (line.startsWith(""Directory"") || line.startsWith(""Total"")) {
                line = reader.readLine();
                continue;
            }

            entry.append(line);
            if (line.trim().endsWith("")""))
            {
                break;
            }
            line = reader.readLine();
        }
        return entry.length() == 0 ? null : entry.toString();
    }","  public void test3()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      StringReader stringReader0 = new StringReader("";"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 1);
      bufferedReader0.close();
      try { 
        vMSFTPEntryParser0.readNextEntry(bufferedReader0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""java.io.BufferedReader"", e);
      }
  }"
3597,"    public FTPFile[] parseFileList(final java.io.InputStream listStream) throws IOException {
        final org.apache.commons.net.ftp.FTPListParseEngine engine = new org.apache.commons.net.ftp.FTPListParseEngine(this);
        engine.readServerList(listStream, null);
        return engine.getFiles();
    }","  public void test4()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      // Undeclared exception!
      try { 
        vMSFTPEntryParser0.parseFileList((InputStream) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.Reader"", e);
      }
  }"
3598,"    public FTPFile[] parseFileList(final java.io.InputStream listStream) throws IOException {
        final org.apache.commons.net.ftp.FTPListParseEngine engine = new org.apache.commons.net.ftp.FTPListParseEngine(this);
        engine.readServerList(listStream, null);
        return engine.getFiles();
    }","  public void test5()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("">mh-SOQ"");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      DataInputStream dataInputStream0 = new DataInputStream((InputStream) null);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(dataInputStream0, dataInputStream0);
      // Undeclared exception!
      try { 
        vMSFTPEntryParser0.parseFileList(sequenceInputStream0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.DataInputStream"", e);
      }
  }"
3599,"    public FTPFile[] parseFileList(final java.io.InputStream listStream) throws IOException {
        final org.apache.commons.net.ftp.FTPListParseEngine engine = new org.apache.commons.net.ftp.FTPListParseEngine(this);
        engine.readServerList(listStream, null);
        return engine.getFiles();
    }","  public void test6()  throws Throwable  {
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser((FTPClientConfig) null);
      byte[] byteArray0 = new byte[5];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (-1273), (byte)11);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, (byte)12);
      // Undeclared exception!
      try { 
        vMSFTPEntryParser0.parseFileList(pushbackInputStream0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.ByteArrayInputStream"", e);
      }
  }"
3600,"    public FTPFile parseFTPEntry(final String entry)
    {
        //one block in VMS equals 512 bytes
        final long longBlock = 512;

        if (matches(entry))
        {
            final FTPFile f = new FTPFile();
            f.setRawListing(entry);
            String name = group(1);
            final String size = group(2);
            final String datestr = group(3)+"" ""+group(4);
            final String owner = group(5);
            final String permissions[] = new String[3];
            permissions[0]= group(9);
            permissions[1]= group(10);
            permissions[2]= group(11);
            try
            {
                f.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                 // intentionally do nothing
            }


            final String grp;
            final String user;
            final StringTokenizer t = new StringTokenizer(owner, "","");
            switch (t.countTokens()) {
                case 1:
                    grp  = null;
                    user = t.nextToken();
                    break;
                case 2:
                    grp  = t.nextToken();
                    user = t.nextToken();
                    break;
                default:
                    grp  = null;
                    user = null;
            }

            if (name.lastIndexOf("".DIR"") != -1)
            {
                f.setType(FTPFile.DIRECTORY_TYPE);
            }
            else
            {
                f.setType(FTPFile.FILE_TYPE);
            }
            //set FTPFile name
            //Check also for versions to be returned or not
            if (isVersioning())
            {
                f.setName(name);
            }
            else
            {
                name = name.substring(0, name.lastIndexOf(';'));
                f.setName(name);
            }
            //size is retreived in blocks and needs to be put in bytes
            //for us humans and added to the FTPFile array
            final long sizeInBytes = Long.parseLong(size) * longBlock;
            f.setSize(sizeInBytes);

            f.setGroup(grp);
            f.setUser(user);
            //set group and owner

            //Set file permission.
            //VMS has (SYSTEM,OWNER,GROUP,WORLD) users that can contain
            //R (read) W (write) E (execute) D (delete)

            //iterate for OWNER GROUP WORLD permissions
            for (int access = 0; access < 3; access++)
            {
                final String permission = permissions[access];

                f.setPermission(access, FTPFile.READ_PERMISSION, permission.indexOf('R')>=0);
                f.setPermission(access, FTPFile.WRITE_PERMISSION, permission.indexOf('W')>=0);
                f.setPermission(access, FTPFile.EXECUTE_PERMISSION, permission.indexOf('E')>=0);
            }

            return f;
        }
        return null;
    }","  public void test7()  throws Throwable  {
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser();
      // Undeclared exception!
      try { 
        vMSFTPEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3601,"    public VMSFTPEntryParser()
    {
        this(null);
    }","  public void test8()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""cFAKKFxlFEcYp"", """");
      VMSFTPEntryParser vMSFTPEntryParser0 = null;
      try {
        vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'c'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3602,"    public VMSFTPEntryParser()
    {
        this(null);
    }","  public void test9()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""<sJ#!ZzQlh!\""a^|\"""", ""<sJ#!ZzQlh!\""a^|\"""", ""<sJ#!ZzQlh!\""a^|\"""", ""k_i"", ""<sJ#!ZzQlh!\""a^|\"""", ""k_i"");
      VMSFTPEntryParser vMSFTPEntryParser0 = null;
      try {
        vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3603,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        String line = reader.readLine();
        final StringBuilder entry = new StringBuilder();
        while (line != null)
        {
            if (line.startsWith(""Directory"") || line.startsWith(""Total"")) {
                line = reader.readLine();
                continue;
            }

            entry.append(line);
            if (line.trim().endsWith("")""))
            {
                break;
            }
            line = reader.readLine();
        }
        return entry.length() == 0 ? null : entry.toString();
    }","  public void test10()  throws Throwable  {
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser();
      StringReader stringReader0 = new StringReader(""J0MqZR}/0zC*)"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 1185);
      String string0 = vMSFTPEntryParser0.readNextEntry(bufferedReader0);
}"
3604,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        String line = reader.readLine();
        final StringBuilder entry = new StringBuilder();
        while (line != null)
        {
            if (line.startsWith(""Directory"") || line.startsWith(""Total"")) {
                line = reader.readLine();
                continue;
            }

            entry.append(line);
            if (line.trim().endsWith("")""))
            {
                break;
            }
            line = reader.readLine();
        }
        return entry.length() == 0 ? null : entry.toString();
    }","  public void test11()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""Dkrctory&ZR}/0zC*"");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser();
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      String string0 = vMSFTPEntryParser0.readNextEntry(bufferedReader0);
}"
3605,"    public FTPFile[] parseFileList(final java.io.InputStream listStream) throws IOException {
        final org.apache.commons.net.ftp.FTPListParseEngine engine = new org.apache.commons.net.ftp.FTPListParseEngine(this);
        engine.readServerList(listStream, null);
        return engine.getFiles();
    }","  public void test12()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""Total"");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      byte[] byteArray0 = new byte[1];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      vMSFTPEntryParser0.parseFileList(byteArrayInputStream0);
}"
3606,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        String line = reader.readLine();
        final StringBuilder entry = new StringBuilder();
        while (line != null)
        {
            if (line.startsWith(""Directory"") || line.startsWith(""Total"")) {
                line = reader.readLine();
                continue;
            }

            entry.append(line);
            if (line.trim().endsWith("")""))
            {
                break;
            }
            line = reader.readLine();
        }
        return entry.length() == 0 ? null : entry.toString();
    }","  public void test13()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""TotalDkrctory&ZR}/0zC*"");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser();
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      String string0 = vMSFTPEntryParser0.readNextEntry(bufferedReader0);
}"
3607,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        String line = reader.readLine();
        final StringBuilder entry = new StringBuilder();
        while (line != null)
        {
            if (line.startsWith(""Directory"") || line.startsWith(""Total"")) {
                line = reader.readLine();
                continue;
            }

            entry.append(line);
            if (line.trim().endsWith("")""))
            {
                break;
            }
            line = reader.readLine();
        }
        return entry.length() == 0 ? null : entry.toString();
    }","  public void test14()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      StringReader stringReader0 = new StringReader(""DirectoryMqZR}/0zC*"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 1);
      String string0 = vMSFTPEntryParser0.readNextEntry(bufferedReader0);
}"
3608,"    public String readNextEntry(final BufferedReader reader) throws IOException
    {
        String line = reader.readLine();
        final StringBuilder entry = new StringBuilder();
        while (line != null)
        {
            if (line.startsWith(""Directory"") || line.startsWith(""Total"")) {
                line = reader.readLine();
                continue;
            }

            entry.append(line);
            if (line.trim().endsWith("")""))
            {
                break;
            }
            line = reader.readLine();
        }
        return entry.length() == 0 ? null : entry.toString();
    }","  public void test15()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      StringReader stringReader0 = new StringReader(""DirectoryMqZR}/0zC*"");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 1);
      String string0 = vMSFTPEntryParser0.readNextEntry(bufferedReader0);
}"
3609,"    public FTPFile parseFTPEntry(final String entry)
    {
        //one block in VMS equals 512 bytes
        final long longBlock = 512;

        if (matches(entry))
        {
            final FTPFile f = new FTPFile();
            f.setRawListing(entry);
            String name = group(1);
            final String size = group(2);
            final String datestr = group(3)+"" ""+group(4);
            final String owner = group(5);
            final String permissions[] = new String[3];
            permissions[0]= group(9);
            permissions[1]= group(10);
            permissions[2]= group(11);
            try
            {
                f.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                 // intentionally do nothing
            }


            final String grp;
            final String user;
            final StringTokenizer t = new StringTokenizer(owner, "","");
            switch (t.countTokens()) {
                case 1:
                    grp  = null;
                    user = t.nextToken();
                    break;
                case 2:
                    grp  = t.nextToken();
                    user = t.nextToken();
                    break;
                default:
                    grp  = null;
                    user = null;
            }

            if (name.lastIndexOf("".DIR"") != -1)
            {
                f.setType(FTPFile.DIRECTORY_TYPE);
            }
            else
            {
                f.setType(FTPFile.FILE_TYPE);
            }
            //set FTPFile name
            //Check also for versions to be returned or not
            if (isVersioning())
            {
                f.setName(name);
            }
            else
            {
                name = name.substring(0, name.lastIndexOf(';'));
                f.setName(name);
            }
            //size is retreived in blocks and needs to be put in bytes
            //for us humans and added to the FTPFile array
            final long sizeInBytes = Long.parseLong(size) * longBlock;
            f.setSize(sizeInBytes);

            f.setGroup(grp);
            f.setUser(user);
            //set group and owner

            //Set file permission.
            //VMS has (SYSTEM,OWNER,GROUP,WORLD) users that can contain
            //R (read) W (write) E (execute) D (delete)

            //iterate for OWNER GROUP WORLD permissions
            for (int access = 0; access < 3; access++)
            {
                final String permission = permissions[access];

                f.setPermission(access, FTPFile.READ_PERMISSION, permission.indexOf('R')>=0);
                f.setPermission(access, FTPFile.WRITE_PERMISSION, permission.indexOf('W')>=0);
                f.setPermission(access, FTPFile.EXECUTE_PERMISSION, permission.indexOf('E')>=0);
            }

            return f;
        }
        return null;
    }","  public void test16()  throws Throwable  {
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser();
      vMSFTPEntryParser0.setRegex(""J0MqZR}/0"");
      // Undeclared exception!
      try { 
        vMSFTPEntryParser0.parseFTPEntry(""J0MqZR}/0"");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 1
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3610,"    public FTPFile parseFTPEntry(final String entry)
    {
        //one block in VMS equals 512 bytes
        final long longBlock = 512;

        if (matches(entry))
        {
            final FTPFile f = new FTPFile();
            f.setRawListing(entry);
            String name = group(1);
            final String size = group(2);
            final String datestr = group(3)+"" ""+group(4);
            final String owner = group(5);
            final String permissions[] = new String[3];
            permissions[0]= group(9);
            permissions[1]= group(10);
            permissions[2]= group(11);
            try
            {
                f.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                 // intentionally do nothing
            }


            final String grp;
            final String user;
            final StringTokenizer t = new StringTokenizer(owner, "","");
            switch (t.countTokens()) {
                case 1:
                    grp  = null;
                    user = t.nextToken();
                    break;
                case 2:
                    grp  = t.nextToken();
                    user = t.nextToken();
                    break;
                default:
                    grp  = null;
                    user = null;
            }

            if (name.lastIndexOf("".DIR"") != -1)
            {
                f.setType(FTPFile.DIRECTORY_TYPE);
            }
            else
            {
                f.setType(FTPFile.FILE_TYPE);
            }
            //set FTPFile name
            //Check also for versions to be returned or not
            if (isVersioning())
            {
                f.setName(name);
            }
            else
            {
                name = name.substring(0, name.lastIndexOf(';'));
                f.setName(name);
            }
            //size is retreived in blocks and needs to be put in bytes
            //for us humans and added to the FTPFile array
            final long sizeInBytes = Long.parseLong(size) * longBlock;
            f.setSize(sizeInBytes);

            f.setGroup(grp);
            f.setUser(user);
            //set group and owner

            //Set file permission.
            //VMS has (SYSTEM,OWNER,GROUP,WORLD) users that can contain
            //R (read) W (write) E (execute) D (delete)

            //iterate for OWNER GROUP WORLD permissions
            for (int access = 0; access < 3; access++)
            {
                final String permission = permissions[access];

                f.setPermission(access, FTPFile.READ_PERMISSION, permission.indexOf('R')>=0);
                f.setPermission(access, FTPFile.WRITE_PERMISSION, permission.indexOf('W')>=0);
                f.setPermission(access, FTPFile.EXECUTE_PERMISSION, permission.indexOf('E')>=0);
            }

            return f;
        }
        return null;
    }","  public void test17()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      vMSFTPEntryParser0.parseFTPEntry(""NETWARE"");
}"
3611,"    protected boolean isVersioning() {
        return false;
    }","  public void test18()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      boolean boolean0 = vMSFTPEntryParser0.isVersioning();
}"
3612,"    protected boolean isVersioning() {
        return false;
    }","  public void test19()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser(fTPClientConfig0);
      boolean boolean0 = vMSFTPEntryParser0.isVersioning();
}"
3613,"    public FTPFile[] parseFileList(final java.io.InputStream listStream) throws IOException {
        final org.apache.commons.net.ftp.FTPListParseEngine engine = new org.apache.commons.net.ftp.FTPListParseEngine(this);
        engine.readServerList(listStream, null);
        return engine.getFiles();
    }","  public void test20()  throws Throwable  {
      VMSFTPEntryParser vMSFTPEntryParser0 = new VMSFTPEntryParser();
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      try { 
        vMSFTPEntryParser0.parseFileList(pipedInputStream0);
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedInputStream"", e);
      }
  }"
3614,"    public MacOsPeterFTPEntryParser()
    {
        this(null);
    }","  public void test0()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser(fTPClientConfig0);
}"
3615,"    public MacOsPeterFTPEntryParser()
    {
        this(null);
    }","  public void test1()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser(fTPClientConfig0);
}"
3616,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_UNIX,
                DEFAULT_DATE_FORMAT,
                DEFAULT_RECENT_DATE_FORMAT);
    }","  public void test2()  throws Throwable  {
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = macOsPeterFTPEntryParser0.getDefaultConfiguration();
}"
3617,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_UNIX,
                DEFAULT_DATE_FORMAT,
                DEFAULT_RECENT_DATE_FORMAT);
    }","  public void test3()  throws Throwable  {
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = macOsPeterFTPEntryParser0.getDefaultConfiguration();
}"
3618,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_UNIX,
                DEFAULT_DATE_FORMAT,
                DEFAULT_RECENT_DATE_FORMAT);
    }","  public void test4()  throws Throwable  {
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = macOsPeterFTPEntryParser0.getDefaultConfiguration();
}"
3619,"    public FTPFile parseFTPEntry(final String entry) {
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        final int type;
        boolean isDevice = false;

        if (matches(entry))
        {
            final String typeStr = group(1);
            final String hardLinkCount = ""0"";
            final String usr = null;
            final String grp = null;
            final String filesize = group(20);
            final String datestr = group(21) + "" "" + group(22);
            String name = group(23);
            final String endtoken = group(24);

            try
            {
                file.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                 // intentionally do nothing
            }

            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of
            // 'translucent' filesystems, of which a 'union' filesystem is one.

            // bcdelfmpSs-
            switch (typeStr.charAt(0))
            {
            case 'd':
                type = FTPFile.DIRECTORY_TYPE;
                break;
            case 'e': // NET-39 => z/OS external link
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'l':
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'b':
            case 'c':
                isDevice = true;
                type = FTPFile.FILE_TYPE; // TODO change this if DEVICE_TYPE implemented
                break;
            case 'f':
            case '-':
                type = FTPFile.FILE_TYPE;
                break;
            default: // e.g. ? and w = whiteout
                type = FTPFile.UNKNOWN_TYPE;
            }

            file.setType(type);

            int g = 4;
            for (int access = 0; access < 3; access++, g += 4)
            {
                // Use != '-' to avoid having to check for suid and sticky bits
                file.setPermission(access, FTPFile.READ_PERMISSION,
                                   (!group(g).equals(""-"")));
                file.setPermission(access, FTPFile.WRITE_PERMISSION,
                                   (!group(g + 1).equals(""-"")));

                final String execPerm = group(g + 2);
                if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0)))
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
                }
                else
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
                }
            }

            if (!isDevice)
            {
                try
                {
                    file.setHardLinkCount(Integer.parseInt(hardLinkCount));
                }
                catch (final NumberFormatException e)
                {
                    // intentionally do nothing
                }
            }

            file.setUser(usr);
            file.setGroup(grp);

            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            if (null == endtoken)
            {
                file.setName(name);
            }
            else
            {
                // oddball cases like symbolic links, file names
                // with spaces in them.
                name += endtoken;
                if (type == FTPFile.SYMBOLIC_LINK_TYPE)
                {

                    final int end = name.indexOf("" -> "");
                    // Give up if no link indicator is present
                    if (end == -1)
                    {
                        file.setName(name);
                    }
                    else
                    {
                        file.setName(name.substring(0, end));
                        file.setLink(name.substring(end + 4));
                    }

                }
                else
                {
                    file.setName(name);
                }
            }
            return file;
        }
        return null;
    }","  public void test5()  throws Throwable  {
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser();
      // Undeclared exception!
      try { 
        macOsPeterFTPEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3620,"    public MacOsPeterFTPEntryParser()
    {
        this(null);
    }","  public void test6()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setShortMonthNames(""))[-lM;LTS3L"");
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = null;
      try {
        macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3621,"    public MacOsPeterFTPEntryParser()
    {
        this(null);
    }","  public void test7()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""kkC:sr"", (String) null);
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = null;
      try {
        macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'C'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3622,"    public FTPFile parseFTPEntry(final String entry) {
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        final int type;
        boolean isDevice = false;

        if (matches(entry))
        {
            final String typeStr = group(1);
            final String hardLinkCount = ""0"";
            final String usr = null;
            final String grp = null;
            final String filesize = group(20);
            final String datestr = group(21) + "" "" + group(22);
            String name = group(23);
            final String endtoken = group(24);

            try
            {
                file.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                 // intentionally do nothing
            }

            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of
            // 'translucent' filesystems, of which a 'union' filesystem is one.

            // bcdelfmpSs-
            switch (typeStr.charAt(0))
            {
            case 'd':
                type = FTPFile.DIRECTORY_TYPE;
                break;
            case 'e': // NET-39 => z/OS external link
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'l':
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'b':
            case 'c':
                isDevice = true;
                type = FTPFile.FILE_TYPE; // TODO change this if DEVICE_TYPE implemented
                break;
            case 'f':
            case '-':
                type = FTPFile.FILE_TYPE;
                break;
            default: // e.g. ? and w = whiteout
                type = FTPFile.UNKNOWN_TYPE;
            }

            file.setType(type);

            int g = 4;
            for (int access = 0; access < 3; access++, g += 4)
            {
                // Use != '-' to avoid having to check for suid and sticky bits
                file.setPermission(access, FTPFile.READ_PERMISSION,
                                   (!group(g).equals(""-"")));
                file.setPermission(access, FTPFile.WRITE_PERMISSION,
                                   (!group(g + 1).equals(""-"")));

                final String execPerm = group(g + 2);
                if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0)))
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
                }
                else
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
                }
            }

            if (!isDevice)
            {
                try
                {
                    file.setHardLinkCount(Integer.parseInt(hardLinkCount));
                }
                catch (final NumberFormatException e)
                {
                    // intentionally do nothing
                }
            }

            file.setUser(usr);
            file.setGroup(grp);

            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            if (null == endtoken)
            {
                file.setName(name);
            }
            else
            {
                // oddball cases like symbolic links, file names
                // with spaces in them.
                name += endtoken;
                if (type == FTPFile.SYMBOLIC_LINK_TYPE)
                {

                    final int end = name.indexOf("" -> "");
                    // Give up if no link indicator is present
                    if (end == -1)
                    {
                        file.setName(name);
                    }
                    else
                    {
                        file.setName(name.substring(0, end));
                        file.setLink(name.substring(end + 4));
                    }

                }
                else
                {
                    file.setName(name);
                }
            }
            return file;
        }
        return null;
    }","  public void test8()  throws Throwable  {
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser();
      macOsPeterFTPEntryParser0.setRegex(""NETWARE"");
      // Undeclared exception!
      try { 
        macOsPeterFTPEntryParser0.parseFTPEntry(""NETWARE"");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 1
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3623,"    public FTPFile parseFTPEntry(final String entry) {
        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        final int type;
        boolean isDevice = false;

        if (matches(entry))
        {
            final String typeStr = group(1);
            final String hardLinkCount = ""0"";
            final String usr = null;
            final String grp = null;
            final String filesize = group(20);
            final String datestr = group(21) + "" "" + group(22);
            String name = group(23);
            final String endtoken = group(24);

            try
            {
                file.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                 // intentionally do nothing
            }

            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of
            // 'translucent' filesystems, of which a 'union' filesystem is one.

            // bcdelfmpSs-
            switch (typeStr.charAt(0))
            {
            case 'd':
                type = FTPFile.DIRECTORY_TYPE;
                break;
            case 'e': // NET-39 => z/OS external link
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'l':
                type = FTPFile.SYMBOLIC_LINK_TYPE;
                break;
            case 'b':
            case 'c':
                isDevice = true;
                type = FTPFile.FILE_TYPE; // TODO change this if DEVICE_TYPE implemented
                break;
            case 'f':
            case '-':
                type = FTPFile.FILE_TYPE;
                break;
            default: // e.g. ? and w = whiteout
                type = FTPFile.UNKNOWN_TYPE;
            }

            file.setType(type);

            int g = 4;
            for (int access = 0; access < 3; access++, g += 4)
            {
                // Use != '-' to avoid having to check for suid and sticky bits
                file.setPermission(access, FTPFile.READ_PERMISSION,
                                   (!group(g).equals(""-"")));
                file.setPermission(access, FTPFile.WRITE_PERMISSION,
                                   (!group(g + 1).equals(""-"")));

                final String execPerm = group(g + 2);
                if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0)))
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
                }
                else
                {
                    file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
                }
            }

            if (!isDevice)
            {
                try
                {
                    file.setHardLinkCount(Integer.parseInt(hardLinkCount));
                }
                catch (final NumberFormatException e)
                {
                    // intentionally do nothing
                }
            }

            file.setUser(usr);
            file.setGroup(grp);

            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            if (null == endtoken)
            {
                file.setName(name);
            }
            else
            {
                // oddball cases like symbolic links, file names
                // with spaces in them.
                name += endtoken;
                if (type == FTPFile.SYMBOLIC_LINK_TYPE)
                {

                    final int end = name.indexOf("" -> "");
                    // Give up if no link indicator is present
                    if (end == -1)
                    {
                        file.setName(name);
                    }
                    else
                    {
                        file.setName(name.substring(0, end));
                        file.setLink(name.substring(end + 4));
                    }

                }
                else
                {
                    file.setName(name);
                }
            }
            return file;
        }
        return null;
    }","  public void test9()  throws Throwable  {
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser();
      FTPFile fTPFile0 = macOsPeterFTPEntryParser0.parseFTPEntry(""MVS"");
}"
3624,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test0()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""RJOBNAME"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3625,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test1()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""RJOBNAME"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3626,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test2()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""^total d+$"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3627,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test3()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""^total d+$"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3628,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test4()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""aName"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3629,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test5()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""aName"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3630,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test6()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""GVolume"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3631,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test7()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""GVolume"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3632,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test8()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(30);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry(""PP_J+j)=.d|oj[-uF"");
}"
3633,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test9()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""JOBNAME"");
      linkedList0.add("" %1$tZ"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3634,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test10()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""JOBNAME"");
      linkedList0.add("" %1$tZ"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3635,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(FTPClientConfig.SYST_MVS,
                DEFAULT_DATE_FORMAT, null);
    }","  public void test11()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = mVSFTPEntryParser0.getDefaultConfiguration();
}"
3636,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(FTPClientConfig.SYST_MVS,
                DEFAULT_DATE_FORMAT, null);
    }","  public void test12()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = mVSFTPEntryParser0.getDefaultConfiguration();
}"
3637,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test13()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.push((String) null);
      // Undeclared exception!
      try { 
        mVSFTPEntryParser0.preParse(linkedList0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.parser.MVSFTPEntryParser"", e);
      }
  }"
3638,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test14()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(1);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry(""TYPE: L8"");
}"
3639,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test15()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(1);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry(""TYPE: L8"");
}"
3640,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test16()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(1);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry(""TYPE: L8"");
}"
3641,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test17()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(1);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry(""TYPE: L8"");
}"
3642,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test18()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""Name"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3643,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test19()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""Name"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3644,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test20()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""Volume"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3645,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test21()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""Volume"");
      mVSFTPEntryParser0.preParse(linkedList0);
}"
3646,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test22()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      List<String> list0 = mVSFTPEntryParser0.preParse(linkedList0);
}"
3647,"    public List<String> preParse(final List<String> orig) {
        // simply remove the header line. Composite logic will take care of the
        // two different types of
        // list in short order.
        if (orig != null && !orig.isEmpty()) {
            final String header = orig.get(0);
            if (header.indexOf(""Volume"") >= 0 && header.indexOf(""Dsname"") >= 0) {
                setType(FILE_LIST_TYPE);
                super.setRegex(FILE_LIST_REGEX);
            } else if (header.indexOf(""Name"") >= 0 && header.indexOf(""Id"") >= 0) {
                setType(MEMBER_LIST_TYPE);
                super.setRegex(MEMBER_LIST_REGEX);
            } else if (header.indexOf(""total"") == 0) {
                setType(UNIX_LIST_TYPE);
                unixFTPEntryParser = new UnixFTPEntryParser();
            } else if (header.indexOf(""Spool Files"") >= 30) {
                setType(JES_LEVEL_1_LIST_TYPE);
                super.setRegex(JES_LEVEL_1_LIST_REGEX);
            } else if (header.indexOf(""JOBNAME"") == 0
                    && header.indexOf(""JOBID"") > 8) {// header contains JOBNAME JOBID OWNER // STATUS CLASS
                setType(JES_LEVEL_2_LIST_TYPE);
                super.setRegex(JES_LEVEL_2_LIST_REGEX);
            } else {
                setType(UNKNOWN_LIST_TYPE);
            }

            if (isType != JES_LEVEL_1_LIST_TYPE) { // remove header is necessary
                orig.remove(0);
            }
        }

        return orig;
    }","  public void test23()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      List<String> list0 = mVSFTPEntryParser0.preParse((List<String>) null);
}"
3648,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test24()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(4);
      // Undeclared exception!
      try { 
        mVSFTPEntryParser0.parseFTPEntry("""");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 4
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3649,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test25()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setRegex(""Spool Files"", 3);
      mVSFTPEntryParser0.setType(3);
      // Undeclared exception!
      try { 
        mVSFTPEntryParser0.parseFTPEntry(""Spool Files"");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 3
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3650,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test26()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setRegex(""UNIX_LTRIM"");
      mVSFTPEntryParser0.setType(1);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry("""");
}"
3651,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test27()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(0);
      // Undeclared exception!
      try { 
        mVSFTPEntryParser0.parseFTPEntry("""");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 2
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3652,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test28()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(0);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry(""TYPE: L8"");
}"
3653,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test29()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(4);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry(""dN6j9WeF5*biL"");
}"
3654,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test30()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(3);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry(""NETWARE"");
}"
3655,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test31()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""total"");
      mVSFTPEntryParser0.preParse(linkedList0);
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry(""total"");
}"
3656,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test32()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(1);
      // Undeclared exception!
      try { 
        mVSFTPEntryParser0.parseFTPEntry("""");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 1
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3657,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test33()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      FTPFile fTPFile0 = mVSFTPEntryParser0.parseFTPEntry("",VFK.455x[O{Y"");
}"
3658,"    public FTPFile parseFTPEntry(final String entry) {
        if (isType == FILE_LIST_TYPE) {
            return parseFileList(entry);
        } else if (isType == MEMBER_LIST_TYPE) {
            return parseMemberList(entry);
        } else if (isType == UNIX_LIST_TYPE) {
             return unixFTPEntryParser.parseFTPEntry(entry);
        } else if (isType == JES_LEVEL_1_LIST_TYPE) {
            return parseJeslevel1List(entry);
        } else if (isType == JES_LEVEL_2_LIST_TYPE) {
            return parseJeslevel2List(entry);
        }

        return null;
    }","  public void test34()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.setType(0);
      // Undeclared exception!
      try { 
        mVSFTPEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3659,"    public OS400FTPEntryParser()
    {
        this(null);
    }","  public void test0()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser(fTPClientConfig0);
}"
3660,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_OS400,
                DEFAULT_DATE_FORMAT,
                null);
    }","  public void test1()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = oS400FTPEntryParser0.getDefaultConfiguration();
}"
3661,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_OS400,
                DEFAULT_DATE_FORMAT,
                null);
    }","  public void test2()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = oS400FTPEntryParser0.getDefaultConfiguration();
}"
3662,"    public FTPFile parseFTPEntry(final String entry)
    {

        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        final int type;

        if (matches(entry))
        {
            final String usr = group(1);
            final String filesize = group(2);
            String datestr = """";
            if (!isNullOrEmpty(group(3)) || !isNullOrEmpty(group(4)))
            {
                datestr = group(3)+"" ""+group(4);
            }
            final String typeStr = group(5);
            String name = group(6);

            boolean mustScanForPathSeparator = true;

            try
            {
                file.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                // intentionally do nothing
            }


            if (typeStr.equalsIgnoreCase(""*STMF""))
            {
                type = FTPFile.FILE_TYPE;
                if (isNullOrEmpty(filesize) || isNullOrEmpty(name))
                {
                    return null;
                }
            }
            else if (typeStr.equalsIgnoreCase(""*DIR""))
            {
                type = FTPFile.DIRECTORY_TYPE;
                if (isNullOrEmpty(filesize) || isNullOrEmpty(name))
                {
                    return null;
                }
            }
            else if (typeStr.equalsIgnoreCase(""*FILE""))
            {
                // File, defines the structure of the data (columns of a row)
                // but the data is stored in one or more members. Typically a
                // source file contains multiple members whereas it is
                // recommended (but not enforced) to use one member per data
                // file.
                // Save files are a special type of files which are used
                // to save objects, e.g. for backups.
                if (name != null && name.toUpperCase(Locale.ROOT).endsWith("".SAVF""))
                {
                    mustScanForPathSeparator = false;
                    type = FTPFile.FILE_TYPE;
                }
                else
                {
                    return null;
                }
            }
            else if (typeStr.equalsIgnoreCase(""*MEM""))
            {
                mustScanForPathSeparator = false;
                type = FTPFile.FILE_TYPE;

                if (isNullOrEmpty(name))
                {
                    return null;
                }
                if (!(isNullOrEmpty(filesize) && isNullOrEmpty(datestr)))
                {
                    return null;
                }

                // Quick and dirty bug fix to make SelectorUtils work.
                // Class SelectorUtils uses 'File.separator' to splitt
                // a given path into pieces. But actually it had to
                // use the separator of the FTP server, which is a forward
                // slash in case of an AS/400.
                name = name.replace('/', File.separatorChar);
            }
            else
            {
                type = FTPFile.UNKNOWN_TYPE;
            }

            file.setType(type);

            file.setUser(usr);

            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            if (name.endsWith(""/""))
            {
                name = name.substring(0, name.length() - 1);
            }
            if (mustScanForPathSeparator)
            {
                final int pos = name.lastIndexOf('/');
                if (pos > -1)
                {
                    name = name.substring(pos + 1);
                }
            }

            file.setName(name);

            return file;
        }
        return null;
    }","  public void test3()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      // Undeclared exception!
      try { 
        oS400FTPEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3663,"    public OS400FTPEntryParser()
    {
        this(null);
    }","  public void test4()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""rXX$"", ""B"", ""B"", """", """", ""XMH+"");
      OS400FTPEntryParser oS400FTPEntryParser0 = null;
      try {
        oS400FTPEntryParser0 = new OS400FTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3664,"    public FTPFile parseFTPEntry(final String entry)
    {

        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        final int type;

        if (matches(entry))
        {
            final String usr = group(1);
            final String filesize = group(2);
            String datestr = """";
            if (!isNullOrEmpty(group(3)) || !isNullOrEmpty(group(4)))
            {
                datestr = group(3)+"" ""+group(4);
            }
            final String typeStr = group(5);
            String name = group(6);

            boolean mustScanForPathSeparator = true;

            try
            {
                file.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                // intentionally do nothing
            }


            if (typeStr.equalsIgnoreCase(""*STMF""))
            {
                type = FTPFile.FILE_TYPE;
                if (isNullOrEmpty(filesize) || isNullOrEmpty(name))
                {
                    return null;
                }
            }
            else if (typeStr.equalsIgnoreCase(""*DIR""))
            {
                type = FTPFile.DIRECTORY_TYPE;
                if (isNullOrEmpty(filesize) || isNullOrEmpty(name))
                {
                    return null;
                }
            }
            else if (typeStr.equalsIgnoreCase(""*FILE""))
            {
                // File, defines the structure of the data (columns of a row)
                // but the data is stored in one or more members. Typically a
                // source file contains multiple members whereas it is
                // recommended (but not enforced) to use one member per data
                // file.
                // Save files are a special type of files which are used
                // to save objects, e.g. for backups.
                if (name != null && name.toUpperCase(Locale.ROOT).endsWith("".SAVF""))
                {
                    mustScanForPathSeparator = false;
                    type = FTPFile.FILE_TYPE;
                }
                else
                {
                    return null;
                }
            }
            else if (typeStr.equalsIgnoreCase(""*MEM""))
            {
                mustScanForPathSeparator = false;
                type = FTPFile.FILE_TYPE;

                if (isNullOrEmpty(name))
                {
                    return null;
                }
                if (!(isNullOrEmpty(filesize) && isNullOrEmpty(datestr)))
                {
                    return null;
                }

                // Quick and dirty bug fix to make SelectorUtils work.
                // Class SelectorUtils uses 'File.separator' to splitt
                // a given path into pieces. But actually it had to
                // use the separator of the FTP server, which is a forward
                // slash in case of an AS/400.
                name = name.replace('/', File.separatorChar);
            }
            else
            {
                type = FTPFile.UNKNOWN_TYPE;
            }

            file.setType(type);

            file.setUser(usr);

            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            if (name.endsWith(""/""))
            {
                name = name.substring(0, name.length() - 1);
            }
            if (mustScanForPathSeparator)
            {
                final int pos = name.lastIndexOf('/');
                if (pos > -1)
                {
                    name = name.substring(pos + 1);
                }
            }

            file.setName(name);

            return file;
        }
        return null;
    }","  public void test5()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      oS400FTPEntryParser0.setRegex(""MACOS PETER"", 3);
      // Undeclared exception!
      try { 
        oS400FTPEntryParser0.parseFTPEntry(""MACOS PETER"");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 1
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3665,"    public FTPFile parseFTPEntry(final String entry)
    {

        final FTPFile file = new FTPFile();
        file.setRawListing(entry);
        final int type;

        if (matches(entry))
        {
            final String usr = group(1);
            final String filesize = group(2);
            String datestr = """";
            if (!isNullOrEmpty(group(3)) || !isNullOrEmpty(group(4)))
            {
                datestr = group(3)+"" ""+group(4);
            }
            final String typeStr = group(5);
            String name = group(6);

            boolean mustScanForPathSeparator = true;

            try
            {
                file.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                // intentionally do nothing
            }


            if (typeStr.equalsIgnoreCase(""*STMF""))
            {
                type = FTPFile.FILE_TYPE;
                if (isNullOrEmpty(filesize) || isNullOrEmpty(name))
                {
                    return null;
                }
            }
            else if (typeStr.equalsIgnoreCase(""*DIR""))
            {
                type = FTPFile.DIRECTORY_TYPE;
                if (isNullOrEmpty(filesize) || isNullOrEmpty(name))
                {
                    return null;
                }
            }
            else if (typeStr.equalsIgnoreCase(""*FILE""))
            {
                // File, defines the structure of the data (columns of a row)
                // but the data is stored in one or more members. Typically a
                // source file contains multiple members whereas it is
                // recommended (but not enforced) to use one member per data
                // file.
                // Save files are a special type of files which are used
                // to save objects, e.g. for backups.
                if (name != null && name.toUpperCase(Locale.ROOT).endsWith("".SAVF""))
                {
                    mustScanForPathSeparator = false;
                    type = FTPFile.FILE_TYPE;
                }
                else
                {
                    return null;
                }
            }
            else if (typeStr.equalsIgnoreCase(""*MEM""))
            {
                mustScanForPathSeparator = false;
                type = FTPFile.FILE_TYPE;

                if (isNullOrEmpty(name))
                {
                    return null;
                }
                if (!(isNullOrEmpty(filesize) && isNullOrEmpty(datestr)))
                {
                    return null;
                }

                // Quick and dirty bug fix to make SelectorUtils work.
                // Class SelectorUtils uses 'File.separator' to splitt
                // a given path into pieces. But actually it had to
                // use the separator of the FTP server, which is a forward
                // slash in case of an AS/400.
                name = name.replace('/', File.separatorChar);
            }
            else
            {
                type = FTPFile.UNKNOWN_TYPE;
            }

            file.setType(type);

            file.setUser(usr);

            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            if (name.endsWith(""/""))
            {
                name = name.substring(0, name.length() - 1);
            }
            if (mustScanForPathSeparator)
            {
                final int pos = name.lastIndexOf('/');
                if (pos > -1)
                {
                    name = name.substring(pos + 1);
                }
            }

            file.setName(name);

            return file;
        }
        return null;
    }","  public void test6()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      FTPFile fTPFile0 = oS400FTPEntryParser0.parseFTPEntry(""UNIX"");
}"
3666,"    public OS400FTPEntryParser()
    {
        this(null);
    }","  public void test7()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""R!o]a#py/Z"", ""R!o]a#py/Z"", ""R!o]a#py/Z"");
      OS400FTPEntryParser oS400FTPEntryParser0 = null;
      try {
        oS400FTPEntryParser0 = new OS400FTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'R'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3667,"    public OS2FTPEntryParser()
    {
        this(null);
    }","  public void test0()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser(fTPClientConfig0);
}"
3668,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_OS2,
                DEFAULT_DATE_FORMAT,
                null);
    }","  public void test1()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = oS2FTPEntryParser0.getDefaultConfiguration();
}"
3669,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_OS2,
                DEFAULT_DATE_FORMAT,
                null);
    }","  public void test2()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPClientConfig fTPClientConfig0 = oS2FTPEntryParser0.getDefaultConfiguration();
}"
3670,"    public FTPFile parseFTPEntry(final String entry)
    {

        final FTPFile f = new FTPFile();
        if (matches(entry))
        {
            final String size = group(1);
            final String attrib = group(2);
            final String dirString = group(3);
            final String datestr = group(4)+"" ""+group(5);
            final String name = group(6);
            try
            {
                f.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                // intentionally do nothing
            }


            //is it a DIR or a file
            if (dirString.trim().equals(""DIR"") || attrib.trim().equals(""DIR""))
            {
                f.setType(FTPFile.DIRECTORY_TYPE);
            }
            else
            {
                f.setType(FTPFile.FILE_TYPE);
            }


            //set the name
            f.setName(name.trim());

            //set the size
            f.setSize(Long.parseLong(size.trim()));

            return f;
        }
        return null;

    }","  public void test3()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      // Undeclared exception!
      try { 
        oS2FTPEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3671,"    public OS2FTPEntryParser()
    {
        this(null);
    }","  public void test4()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""?GVy~vB{`IT&[2^AFI"", ""?GVy~vB{`IT&[2^AFI"", "", GXF"", """", (String) null, "", GXF"", false, false);
      OS2FTPEntryParser oS2FTPEntryParser0 = null;
      try {
        oS2FTPEntryParser0 = new OS2FTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'V'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3672,"    public OS2FTPEntryParser()
    {
        this(null);
    }","  public void test5()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""R[D yl9lc:,W!Nj"", ""R[D yl9lc:,W!Nj"", ""R[D yl9lc:,W!Nj"", ""R[D yl9lc:,W!Nj"", ""ku&c2"", "" "", false, false);
      OS2FTPEntryParser oS2FTPEntryParser0 = null;
      try {
        oS2FTPEntryParser0 = new OS2FTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3673,"    public FTPFile parseFTPEntry(final String entry)
    {

        final FTPFile f = new FTPFile();
        if (matches(entry))
        {
            final String size = group(1);
            final String attrib = group(2);
            final String dirString = group(3);
            final String datestr = group(4)+"" ""+group(5);
            final String name = group(6);
            try
            {
                f.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                // intentionally do nothing
            }


            //is it a DIR or a file
            if (dirString.trim().equals(""DIR"") || attrib.trim().equals(""DIR""))
            {
                f.setType(FTPFile.DIRECTORY_TYPE);
            }
            else
            {
                f.setType(FTPFile.FILE_TYPE);
            }


            //set the name
            f.setName(name.trim());

            //set the size
            f.setSize(Long.parseLong(size.trim()));

            return f;
        }
        return null;

    }","  public void test6()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      oS2FTPEntryParser0.setRegex(""#A=b2WvX| ayd0n=|z"", 836);
      // Undeclared exception!
      try { 
        oS2FTPEntryParser0.parseFTPEntry("""");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 1
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3674,"    public FTPFile parseFTPEntry(final String entry)
    {

        final FTPFile f = new FTPFile();
        if (matches(entry))
        {
            final String size = group(1);
            final String attrib = group(2);
            final String dirString = group(3);
            final String datestr = group(4)+"" ""+group(5);
            final String name = group(6);
            try
            {
                f.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                // intentionally do nothing
            }


            //is it a DIR or a file
            if (dirString.trim().equals(""DIR"") || attrib.trim().equals(""DIR""))
            {
                f.setType(FTPFile.DIRECTORY_TYPE);
            }
            else
            {
                f.setType(FTPFile.FILE_TYPE);
            }


            //set the name
            f.setName(name.trim());

            //set the size
            f.setSize(Long.parseLong(size.trim()));

            return f;
        }
        return null;

    }","  public void test7()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      FTPFile fTPFile0 = oS2FTPEntryParser0.parseFTPEntry(""OS/2"");
}"
3675,"    public FTPFile parseFTPEntry(final String entry)
    {
        final FTPFile f = new FTPFile();
        f.setRawListing(entry);

        if (matches(entry))
        {
            final String datestr = group(1)+"" ""+group(2);
            final String dirString = group(3);
            final String size = group(4);
            final String name = group(5);
            try
            {
                f.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                // parsing fails, try the other date format
                try
                {
                    f.setTimestamp(timestampParser.parseTimestamp(datestr));
                }
                catch (final ParseException e2)
                {
                    // intentionally do nothing
                }
            }

            if (null == name || name.equals(""."") || name.equals(""..""))
            {
                return null;
            }
            f.setName(name);


            if (""<DIR>"".equals(dirString))
            {
                f.setType(FTPFile.DIRECTORY_TYPE);
                f.setSize(0);
            }
            else
            {
                f.setType(FTPFile.FILE_TYPE);
                if (null != size)
                {
                  f.setSize(Long.parseLong(size));
                }
            }
            return f;
        }
        return null;
    }","  public void test0()  throws Throwable  {
      NTFTPEntryParser nTFTPEntryParser0 = new NTFTPEntryParser((FTPClientConfig) null);
      // Undeclared exception!
      try { 
        nTFTPEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3676,"    public NTFTPEntryParser()
    {
        this(null);
    }","  public void test1()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""+y$"", """", ""n0g?h)C5~P@E"", ""2"", ""n0g?h)C5~P@E"", ""2"", true, true);
      NTFTPEntryParser nTFTPEntryParser0 = null;
      try {
        nTFTPEntryParser0 = new NTFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3677,"    public FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_NT,
                DEFAULT_DATE_FORMAT,
                null);
    }","  public void test2()  throws Throwable  {
      NTFTPEntryParser nTFTPEntryParser0 = new NTFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = nTFTPEntryParser0.getDefaultConfiguration();
}"
3678,"    public FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(
                FTPClientConfig.SYST_NT,
                DEFAULT_DATE_FORMAT,
                null);
    }","  public void test3()  throws Throwable  {
      NTFTPEntryParser nTFTPEntryParser0 = new NTFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = nTFTPEntryParser0.getDefaultConfiguration();
}"
3679,"    public FTPFile parseFTPEntry(final String entry)
    {
        final FTPFile f = new FTPFile();
        f.setRawListing(entry);

        if (matches(entry))
        {
            final String datestr = group(1)+"" ""+group(2);
            final String dirString = group(3);
            final String size = group(4);
            final String name = group(5);
            try
            {
                f.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                // parsing fails, try the other date format
                try
                {
                    f.setTimestamp(timestampParser.parseTimestamp(datestr));
                }
                catch (final ParseException e2)
                {
                    // intentionally do nothing
                }
            }

            if (null == name || name.equals(""."") || name.equals(""..""))
            {
                return null;
            }
            f.setName(name);


            if (""<DIR>"".equals(dirString))
            {
                f.setType(FTPFile.DIRECTORY_TYPE);
                f.setSize(0);
            }
            else
            {
                f.setType(FTPFile.FILE_TYPE);
                if (null != size)
                {
                  f.setSize(Long.parseLong(size));
                }
            }
            return f;
        }
        return null;
    }","  public void test4()  throws Throwable  {
      NTFTPEntryParser nTFTPEntryParser0 = new NTFTPEntryParser();
      nTFTPEntryParser0.setRegex(""MIC"");
      // Undeclared exception!
      try { 
        nTFTPEntryParser0.parseFTPEntry(""MIC"");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 1
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3680,"    public FTPFile parseFTPEntry(final String entry)
    {
        final FTPFile f = new FTPFile();
        f.setRawListing(entry);

        if (matches(entry))
        {
            final String datestr = group(1)+"" ""+group(2);
            final String dirString = group(3);
            final String size = group(4);
            final String name = group(5);
            try
            {
                f.setTimestamp(super.parseTimestamp(datestr));
            }
            catch (final ParseException e)
            {
                // parsing fails, try the other date format
                try
                {
                    f.setTimestamp(timestampParser.parseTimestamp(datestr));
                }
                catch (final ParseException e2)
                {
                    // intentionally do nothing
                }
            }

            if (null == name || name.equals(""."") || name.equals(""..""))
            {
                return null;
            }
            f.setName(name);


            if (""<DIR>"".equals(dirString))
            {
                f.setType(FTPFile.DIRECTORY_TYPE);
                f.setSize(0);
            }
            else
            {
                f.setType(FTPFile.FILE_TYPE);
                if (null != size)
                {
                  f.setSize(Long.parseLong(size));
                }
            }
            return f;
        }
        return null;
    }","  public void test5()  throws Throwable  {
      NTFTPEntryParser nTFTPEntryParser0 = new NTFTPEntryParser();
      FTPFile fTPFile0 = nTFTPEntryParser0.parseFTPEntry(""MIC"");
}"
3681,"    public NTFTPEntryParser()
    {
        this(null);
    }","  public void test6()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""r*T7yI4|o"", """");
      NTFTPEntryParser nTFTPEntryParser0 = null;
      try {
        nTFTPEntryParser0 = new NTFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'r'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3682,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test0()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      Calendar calendar0 = fTPTimestampParserImpl0.parseTimestamp("""");
      calendar0.setMinimalDaysInFirstWeek((-6192));
      fTPTimestampParserImpl0.parseTimestamp("""", calendar0);
}"
3683,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        final Calendar now = Calendar.getInstance();
        return parseTimestamp(timestampStr, now);
    }","  public void test1()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      Calendar calendar0 = fTPTimestampParserImpl0.parseTimestamp("""");
      calendar0.setFirstDayOfWeek(0);
      fTPTimestampParserImpl0.parseTimestamp("""", calendar0);
}"
3684,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test2()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      Calendar calendar0 = fTPTimestampParserImpl0.parseTimestamp("""");
      calendar0.setFirstDayOfWeek(0);
      fTPTimestampParserImpl0.parseTimestamp("""", calendar0);
}"
3685,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test3()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      Calendar calendar0 = fTPTimestampParserImpl0.parseTimestamp("""");
      calendar0.setFirstDayOfWeek((-2622));
      fTPTimestampParserImpl0.parseTimestamp("""", calendar0);
}"
3686,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test4()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
}"
3687,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test5()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      fTPTimestampParserImpl0.isLenientFutureDates();
}"
3688,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test6()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
}"
3689,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test7()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      String string0 = fTPTimestampParserImpl0.getRecentDateFormatString();
}"
3690,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test8()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
}"
3691,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test9()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPClientConfig0.setRecentDateFormatStr((String) null);
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      fTPTimestampParserImpl0.getRecentDateFormat();
}"
3692,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test10()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
}"
3693,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test11()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      String string0 = fTPTimestampParserImpl0.getDefaultDateFormatString();
}"
3694,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        final Calendar now = Calendar.getInstance();
        return parseTimestamp(timestampStr, now);
    }","  public void test12()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      Calendar calendar0 = fTPTimestampParserImpl0.parseTimestamp("""");
      // Undeclared exception!
      try { 
        fTPTimestampParserImpl0.parseTimestamp((String) null, calendar0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3695,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        final Calendar now = Calendar.getInstance();
        return parseTimestamp(timestampStr, now);
    }","  public void test13()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(19, 19, 19, (-388), 19);
      mockGregorianCalendar0.setLenient(false);
      // Undeclared exception!
      try { 
        fTPTimestampParserImpl0.parseTimestamp("""", (Calendar) mockGregorianCalendar0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // MONTH
         //
         verifyException(""java.util.GregorianCalendar"", e);
      }
  }"
3696,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        final Calendar now = Calendar.getInstance();
        return parseTimestamp(timestampStr, now);
    }","  public void test14()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      // Undeclared exception!
      try { 
        fTPTimestampParserImpl0.parseTimestamp((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3697,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test15()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      fTPClientConfig0.setDefaultDateFormatStr("""");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      // Undeclared exception!
      try { 
        fTPTimestampParserImpl0.getRecentDateFormatString();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3698,"    public void configure(final FTPClientConfig config) {
        DateFormatSymbols dfs = null;

        final String languageCode = config.getServerLanguageCode();
        final String shortmonths = config.getShortMonthNames();
        if (shortmonths != null) {
            dfs = FTPClientConfig.getDateFormatSymbols(shortmonths);
        } else if (languageCode != null) {
            dfs = FTPClientConfig.lookupDateFormatSymbols(languageCode);
        } else {
            dfs = FTPClientConfig.lookupDateFormatSymbols(""en"");
        }


        final String recentFormatString = config.getRecentDateFormatStr();
        setRecentDateFormat(recentFormatString, dfs);

        final String defaultFormatString = config.getDefaultDateFormatStr();
        if (defaultFormatString == null) {
            throw new IllegalArgumentException(""defaultFormatString cannot be null"");
        }
        setDefaultDateFormat(defaultFormatString, dfs);

        setServerTimeZone(config.getServerTimeZoneId());

        this.lenientFutureDates = config.isLenientFutureDates();
    }","  public void test16()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      // Undeclared exception!
      try { 
        fTPTimestampParserImpl0.configure((FTPClientConfig) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.parser.FTPTimestampParserImpl"", e);
      }
  }"
3699,"    public void configure(final FTPClientConfig config) {
        DateFormatSymbols dfs = null;

        final String languageCode = config.getServerLanguageCode();
        final String shortmonths = config.getShortMonthNames();
        if (shortmonths != null) {
            dfs = FTPClientConfig.getDateFormatSymbols(shortmonths);
        } else if (languageCode != null) {
            dfs = FTPClientConfig.lookupDateFormatSymbols(languageCode);
        } else {
            dfs = FTPClientConfig.lookupDateFormatSymbols(""en"");
        }


        final String recentFormatString = config.getRecentDateFormatStr();
        setRecentDateFormat(recentFormatString, dfs);

        final String defaultFormatString = config.getDefaultDateFormatStr();
        if (defaultFormatString == null) {
            throw new IllegalArgumentException(""defaultFormatString cannot be null"");
        }
        setDefaultDateFormat(defaultFormatString, dfs);

        setServerTimeZone(config.getServerTimeZoneId());

        this.lenientFutureDates = config.isLenientFutureDates();
    }","  public void test17()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""V1a~jGv/cOw1i}vu3l"", ""V1a~jGv/cOw1i}vu3l"", ""|NV0bRB0v01kr- 8z"");
      // Undeclared exception!
      try { 
        fTPTimestampParserImpl0.configure(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'N'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3700,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        final Calendar now = Calendar.getInstance();
        return parseTimestamp(timestampStr, now);
    }","  public void test18()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
      try { 
        fTPTimestampParserImpl0.parseTimestamp(""S} 7DYn1t"", (Calendar) mockGregorianCalendar0);
        fail(""Expecting exception: ParseException"");
      } catch(ParseException e) {
         //
         // Timestamp 'S} 7DYn1t' could not be parsed using a server time of Fri Feb 14 20:21:21 GMT 2014
         //
         verifyException(""org.apache.commons.net.ftp.parser.FTPTimestampParserImpl"", e);
      }
  }"
3701,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        final Calendar now = Calendar.getInstance();
        return parseTimestamp(timestampStr, now);
    }","  public void test19()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(19, 19, 19, (-388), 19);
      try { 
        fTPTimestampParserImpl0.parseTimestamp("""", (Calendar) mockGregorianCalendar0);
        fail(""Expecting exception: ParseException"");
      } catch(ParseException e) {
         //
         // Timestamp '' could not be parsed using a server time of Thu Jan 01 00:00:00 GMT 1970
         //
         verifyException(""org.apache.commons.net.ftp.parser.FTPTimestampParserImpl"", e);
      }
  }"
3702,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test20()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      fTPTimestampParserImpl0.getServerTimeZone();
}"
3703,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test21()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      fTPTimestampParserImpl0.getServerTimeZone();
}"
3704,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test22()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""u;!OO^XImW"", ""S}"", ""kXs"", ""u;!OO^XImW"", (String) null, (String) null);
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
}"
3705,"    public void configure(final FTPClientConfig config) {
        DateFormatSymbols dfs = null;

        final String languageCode = config.getServerLanguageCode();
        final String shortmonths = config.getShortMonthNames();
        if (shortmonths != null) {
            dfs = FTPClientConfig.getDateFormatSymbols(shortmonths);
        } else if (languageCode != null) {
            dfs = FTPClientConfig.lookupDateFormatSymbols(languageCode);
        } else {
            dfs = FTPClientConfig.lookupDateFormatSymbols(""en"");
        }


        final String recentFormatString = config.getRecentDateFormatStr();
        setRecentDateFormat(recentFormatString, dfs);

        final String defaultFormatString = config.getDefaultDateFormatStr();
        if (defaultFormatString == null) {
            throw new IllegalArgumentException(""defaultFormatString cannot be null"");
        }
        setDefaultDateFormat(defaultFormatString, dfs);

        setServerTimeZone(config.getServerTimeZoneId());

        this.lenientFutureDates = config.isLenientFutureDates();
    }","  public void test23()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """", (String) null, """", """", true, false);
      // Undeclared exception!
      try { 
        fTPTimestampParserImpl0.configure(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3706,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test24()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
}"
3707,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test25()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPClientConfig0.setServerTimeZoneId("""");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
}"
3708,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        final Calendar now = Calendar.getInstance();
        return parseTimestamp(timestampStr, now);
    }","  public void test26()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      try { 
        fTPTimestampParserImpl0.parseTimestamp(""WINDOWS"");
        fail(""Expecting exception: ParseException"");
      } catch(ParseException e) {
         //
         // Timestamp 'WINDOWS' could not be parsed using a server time of Fri Feb 14 20:21:21 GMT 2014
         //
         verifyException(""org.apache.commons.net.ftp.parser.FTPTimestampParserImpl"", e);
      }
  }"
3709,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test27()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      Calendar calendar0 = fTPTimestampParserImpl0.parseTimestamp("""");
      calendar0.set(87, 87, 87, 87, 87, 87);
      fTPTimestampParserImpl0.parseTimestamp("""", calendar0);
}"
3710,"    public void configure(final FTPClientConfig config) {
        DateFormatSymbols dfs = null;

        final String languageCode = config.getServerLanguageCode();
        final String shortmonths = config.getShortMonthNames();
        if (shortmonths != null) {
            dfs = FTPClientConfig.getDateFormatSymbols(shortmonths);
        } else if (languageCode != null) {
            dfs = FTPClientConfig.lookupDateFormatSymbols(languageCode);
        } else {
            dfs = FTPClientConfig.lookupDateFormatSymbols(""en"");
        }


        final String recentFormatString = config.getRecentDateFormatStr();
        setRecentDateFormat(recentFormatString, dfs);

        final String defaultFormatString = config.getDefaultDateFormatStr();
        if (defaultFormatString == null) {
            throw new IllegalArgumentException(""defaultFormatString cannot be null"");
        }
        setDefaultDateFormat(defaultFormatString, dfs);

        setServerTimeZone(config.getServerTimeZoneId());

        this.lenientFutureDates = config.isLenientFutureDates();
    }","  public void test28()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, (String) null, ""kXs"");
      // Undeclared exception!
      try { 
        fTPTimestampParserImpl0.configure(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // defaultFormatString cannot be null
         //
         verifyException(""org.apache.commons.net.ftp.parser.FTPTimestampParserImpl"", e);
      }
  }"
3711,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test29()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""MXz="", ""MXz="", ""MXz="");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
}"
3712,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test30()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""MHXzk=)"", ""MHXzk=)"", ""MHXzk=)"");
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
}"
3713,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test31()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPClientConfig0.setRecentDateFormatStr((String) null);
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
}"
3714,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        final Calendar now = Calendar.getInstance();
        return parseTimestamp(timestampStr, now);
    }","  public void test32()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", """");
      fTPClientConfig0.setRecentDateFormatStr((String) null);
      fTPTimestampParserImpl0.configure(fTPClientConfig0);
      Calendar calendar0 = fTPTimestampParserImpl0.parseTimestamp("""");
      fTPTimestampParserImpl0.parseTimestamp("""", calendar0);
}"
3715,"    public SimpleDateFormat getRecentDateFormat() {
        return recentDateFormat;
    }","  public void test33()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      SimpleDateFormat simpleDateFormat0 = fTPTimestampParserImpl0.getRecentDateFormat();
}"
3716,"    public SimpleDateFormat getRecentDateFormat() {
        return recentDateFormat;
    }","  public void test34()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      SimpleDateFormat simpleDateFormat0 = fTPTimestampParserImpl0.getRecentDateFormat();
}"
3717,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test35()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      SimpleDateFormat simpleDateFormat0 = fTPTimestampParserImpl0.getRecentDateFormat();
}"
3718,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test36()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      String string0 = fTPTimestampParserImpl0.getRecentDateFormatString();
}"
3719,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test37()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      String string0 = fTPTimestampParserImpl0.getRecentDateFormatString();
}"
3720,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test38()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      fTPTimestampParserImpl0.isLenientFutureDates();
}"
3721,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test39()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      fTPTimestampParserImpl0.isLenientFutureDates();
}"
3722,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test40()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      String string0 = fTPTimestampParserImpl0.getDefaultDateFormatString();
}"
3723,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test41()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      String string0 = fTPTimestampParserImpl0.getDefaultDateFormatString();
}"
3724,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test42()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      fTPTimestampParserImpl0.getShortMonths();
}"
3725,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test43()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      fTPTimestampParserImpl0.getShortMonths();
}"
3726,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test44()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      SimpleDateFormat simpleDateFormat0 = fTPTimestampParserImpl0.getDefaultDateFormat();
}"
3727,"    public SimpleDateFormat getDefaultDateFormat() {
        return defaultDateFormat;
    }","  public void test45()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      SimpleDateFormat simpleDateFormat0 = fTPTimestampParserImpl0.getDefaultDateFormat();
}"
3728,"    public SimpleDateFormat getDefaultDateFormat() {
        return defaultDateFormat;
    }","  public void test46()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      SimpleDateFormat simpleDateFormat0 = fTPTimestampParserImpl0.getDefaultDateFormat();
}"
3729,"    public SimpleDateFormat getDefaultDateFormat() {
        return defaultDateFormat;
    }","  public void test47()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      SimpleDateFormat simpleDateFormat0 = fTPTimestampParserImpl0.getDefaultDateFormat();
}"
3730,"    public String getDefaultDateFormatString() {
        return defaultDateFormat.toPattern();
    }","  public void test48()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      fTPTimestampParserImpl0.setLenientFutureDates(false);
}"
3731,"    public String getRecentDateFormatString() {
        return recentDateFormat.toPattern();
    }","  public void test49()  throws Throwable  {
      FTPTimestampParserImpl fTPTimestampParserImpl0 = new FTPTimestampParserImpl();
      fTPTimestampParserImpl0.setLenientFutureDates(false);
}"
3732,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        return this.timestampParser.parseTimestamp(timestampStr);
    }","  public void test0()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", (String) null);
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser(fTPClientConfig0);
      Calendar calendar0 = oS400FTPEntryParser0.parseTimestamp("""");
}"
3733,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        return this.timestampParser.parseTimestamp(timestampStr);
    }","  public void test1()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = UnixFTPEntryParser.NUMERIC_DATE_CONFIG;
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0, false);
      // Undeclared exception!
      try { 
        unixFTPEntryParser0.parseTimestamp((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3734,"    public void configure(final FTPClientConfig config)
    {
        if (this.timestampParser instanceof Configurable) {
            final FTPClientConfig defaultCfg = getDefaultConfiguration();
            if (config != null) {
                if (null == config.getDefaultDateFormatStr()) {
                    config.setDefaultDateFormatStr(defaultCfg.getDefaultDateFormatStr());
                }
                if (null == config.getRecentDateFormatStr()) {
                    config.setRecentDateFormatStr(defaultCfg.getRecentDateFormatStr());
                }
                ((Configurable)this.timestampParser).configure(config);
            } else {
                ((Configurable)this.timestampParser).configure(defaultCfg);
            }
        }
    }","  public void test2()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig((String) null, ""~TKsQX6m584\""y0pHC"", ""FzG$f$R]vl}]"", """", """", ""PnfqBpJMK*,n2m#5@"", false, false);
      // Undeclared exception!
      try { 
        mVSFTPEntryParser0.configure(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3735,"    public void configure(final FTPClientConfig config)
    {
        if (this.timestampParser instanceof Configurable) {
            final FTPClientConfig defaultCfg = getDefaultConfiguration();
            if (config != null) {
                if (null == config.getDefaultDateFormatStr()) {
                    config.setDefaultDateFormatStr(defaultCfg.getDefaultDateFormatStr());
                }
                if (null == config.getRecentDateFormatStr()) {
                    config.setRecentDateFormatStr(defaultCfg.getRecentDateFormatStr());
                }
                ((Configurable)this.timestampParser).configure(config);
            } else {
                ((Configurable)this.timestampParser).configure(defaultCfg);
            }
        }
    }","  public void test3()  throws Throwable  {
      NTFTPEntryParser nTFTPEntryParser0 = new NTFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      nTFTPEntryParser0.configure(fTPClientConfig0);
}"
3736,"    public void configure(final FTPClientConfig config)
    {
        if (this.timestampParser instanceof Configurable) {
            final FTPClientConfig defaultCfg = getDefaultConfiguration();
            if (config != null) {
                if (null == config.getDefaultDateFormatStr()) {
                    config.setDefaultDateFormatStr(defaultCfg.getDefaultDateFormatStr());
                }
                if (null == config.getRecentDateFormatStr()) {
                    config.setRecentDateFormatStr(defaultCfg.getRecentDateFormatStr());
                }
                ((Configurable)this.timestampParser).configure(config);
            } else {
                ((Configurable)this.timestampParser).configure(defaultCfg);
            }
        }
    }","  public void test4()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser();
      oS2FTPEntryParser0.configure((FTPClientConfig) null);
}"
3737,"    public void configure(final FTPClientConfig config)
    {
        if (this.timestampParser instanceof Configurable) {
            final FTPClientConfig defaultCfg = getDefaultConfiguration();
            if (config != null) {
                if (null == config.getDefaultDateFormatStr()) {
                    config.setDefaultDateFormatStr(defaultCfg.getDefaultDateFormatStr());
                }
                if (null == config.getRecentDateFormatStr()) {
                    config.setRecentDateFormatStr(defaultCfg.getRecentDateFormatStr());
                }
                ((Configurable)this.timestampParser).configure(config);
            } else {
                ((Configurable)this.timestampParser).configure(defaultCfg);
            }
        }
    }","  public void test5()  throws Throwable  {
      NTFTPEntryParser nTFTPEntryParser0 = new NTFTPEntryParser();
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.parser.ConfigurableFTPFileEntryParserImpl"", ""org.apache.commons.net.ftp.parser.ConfigurableFTPFileEntryParserImpl"", ""org.apache.commons.net.ftp.parser.ConfigurableFTPFileEntryParserImpl"");
      // Undeclared exception!
      try { 
        nTFTPEntryParser0.configure(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'o'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3738,"    public Calendar parseTimestamp(final String timestampStr) throws ParseException {
        return this.timestampParser.parseTimestamp(timestampStr);
    }","  public void test6()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser(fTPClientConfig0);
      try { 
        unixFTPEntryParser0.parseTimestamp(""The size must be non-negative"");
        fail(""Expecting exception: ParseException"");
      } catch(ParseException e) {
         //
         // Timestamp 'The size must be non-negative' could not be parsed using a server time of Fri Feb 14 20:21:21 GMT 2014
         //
         verifyException(""org.apache.commons.net.ftp.parser.FTPTimestampParserImpl"", e);
      }
  }"
3739,"    public VMSVersioningFTPEntryParser()
    {
        this(null);
    }","  public void test0()  throws Throwable  {
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = new VMSVersioningFTPEntryParser((FTPClientConfig) null);
}"
3740,"    public List<String> preParse(final List<String> original) {
        final HashMap<String, Integer> existingEntries = new HashMap<>();
        final ListIterator<String> iter = original.listIterator();
        while (iter.hasNext()) {
            final String entry = iter.next().trim();
            MatchResult result = null;
            final Matcher _preparse_matcher_ = preparsePattern.matcher(entry);
            if (_preparse_matcher_.matches()) {
                result = _preparse_matcher_.toMatchResult();
                final String name = result.group(1);
                final String version = result.group(2);
                final Integer nv = Integer.valueOf(version);
                final Integer existing = existingEntries.get(name);
                if (null != existing) {
                    if (nv.intValue() < existing.intValue()) {
                        iter.remove();  // removes older version from original list.
                        continue;
                    }
                }
                existingEntries.put(name, nv);
            }

        }
        // we've now removed all entries less than with less than the largest
        // version number for each name that were listed after the largest.
        // we now must remove those with smaller than the largest version number
        // for each name that were found before the largest
        while (iter.hasPrevious()) {
            final String entry = iter.previous().trim();
            MatchResult result = null;
            final Matcher _preparse_matcher_ = preparsePattern.matcher(entry);
            if (_preparse_matcher_.matches()) {
                result = _preparse_matcher_.toMatchResult();
                final String name = result.group(1);
                final String version = result.group(2);
                final Integer nv = Integer.valueOf(version);
                final Integer existing = existingEntries.get(name);
                if (null != existing) {
                    if (nv.intValue() < existing.intValue()) {
                        iter.remove(); // removes older version from original list.
                    }
                }
            }

        }
        return original;
    }","  public void test1()  throws Throwable  {
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = new VMSVersioningFTPEntryParser();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add((String) null);
      // Undeclared exception!
      try { 
        vMSVersioningFTPEntryParser0.preParse(linkedList0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.parser.VMSVersioningFTPEntryParser"", e);
      }
  }"
3741,"    public VMSVersioningFTPEntryParser()
    {
        this(null);
    }","  public void test2()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""org.apache.commons.net.ftp.parser.VMSVersioningFTPEntryParser"");
      fTPClientConfig0.setRecentDateFormatStr(""org.apache.commons.net.ftp.parser.VMSVersioningFTPEntryParser"");
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = null;
      try {
        vMSVersioningFTPEntryParser0 = new VMSVersioningFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'o'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3742,"    public List<String> preParse(final List<String> original) {
        final HashMap<String, Integer> existingEntries = new HashMap<>();
        final ListIterator<String> iter = original.listIterator();
        while (iter.hasNext()) {
            final String entry = iter.next().trim();
            MatchResult result = null;
            final Matcher _preparse_matcher_ = preparsePattern.matcher(entry);
            if (_preparse_matcher_.matches()) {
                result = _preparse_matcher_.toMatchResult();
                final String name = result.group(1);
                final String version = result.group(2);
                final Integer nv = Integer.valueOf(version);
                final Integer existing = existingEntries.get(name);
                if (null != existing) {
                    if (nv.intValue() < existing.intValue()) {
                        iter.remove();  // removes older version from original list.
                        continue;
                    }
                }
                existingEntries.put(name, nv);
            }

        }
        // we've now removed all entries less than with less than the largest
        // version number for each name that were listed after the largest.
        // we now must remove those with smaller than the largest version number
        // for each name that were found before the largest
        while (iter.hasPrevious()) {
            final String entry = iter.previous().trim();
            MatchResult result = null;
            final Matcher _preparse_matcher_ = preparsePattern.matcher(entry);
            if (_preparse_matcher_.matches()) {
                result = _preparse_matcher_.toMatchResult();
                final String name = result.group(1);
                final String version = result.group(2);
                final Integer nv = Integer.valueOf(version);
                final Integer existing = existingEntries.get(name);
                if (null != existing) {
                    if (nv.intValue() < existing.intValue()) {
                        iter.remove(); // removes older version from original list.
                    }
                }
            }

        }
        return original;
    }","  public void test3()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""(.*)[09Ys*."");
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = new VMSVersioningFTPEntryParser();
      List<String> list0 = vMSVersioningFTPEntryParser0.preParse(linkedList0);
}"
3743,"    public List<String> preParse(final List<String> original) {
        final HashMap<String, Integer> existingEntries = new HashMap<>();
        final ListIterator<String> iter = original.listIterator();
        while (iter.hasNext()) {
            final String entry = iter.next().trim();
            MatchResult result = null;
            final Matcher _preparse_matcher_ = preparsePattern.matcher(entry);
            if (_preparse_matcher_.matches()) {
                result = _preparse_matcher_.toMatchResult();
                final String name = result.group(1);
                final String version = result.group(2);
                final Integer nv = Integer.valueOf(version);
                final Integer existing = existingEntries.get(name);
                if (null != existing) {
                    if (nv.intValue() < existing.intValue()) {
                        iter.remove();  // removes older version from original list.
                        continue;
                    }
                }
                existingEntries.put(name, nv);
            }

        }
        // we've now removed all entries less than with less than the largest
        // version number for each name that were listed after the largest.
        // we now must remove those with smaller than the largest version number
        // for each name that were found before the largest
        while (iter.hasPrevious()) {
            final String entry = iter.previous().trim();
            MatchResult result = null;
            final Matcher _preparse_matcher_ = preparsePattern.matcher(entry);
            if (_preparse_matcher_.matches()) {
                result = _preparse_matcher_.toMatchResult();
                final String name = result.group(1);
                final String version = result.group(2);
                final Integer nv = Integer.valueOf(version);
                final Integer existing = existingEntries.get(name);
                if (null != existing) {
                    if (nv.intValue() < existing.intValue()) {
                        iter.remove(); // removes older version from original list.
                    }
                }
            }

        }
        return original;
    }","  public void test4()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = new VMSVersioningFTPEntryParser();
      List<String> list0 = vMSVersioningFTPEntryParser0.preParse(linkedList0);
}"
3744,"    protected boolean isVersioning() {
        return true;
    }","  public void test5()  throws Throwable  {
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = new VMSVersioningFTPEntryParser();
      boolean boolean0 = vMSVersioningFTPEntryParser0.isVersioning();
}"
3745,"    public VMSVersioningFTPEntryParser()
    {
        this(null);
    }","  public void test6()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig(""Hb[4$t!oqhj2Np]!~"", ""Hb[4$t!oqhj2Np]!~"", ""Hb[4$t!oqhj2Np]!~"", ""Hb[4$t!oqhj2Np]!~"", """", ""Hb[4$t!oqhj2Np]!~"", true, true);
      VMSVersioningFTPEntryParser vMSVersioningFTPEntryParser0 = null;
      try {
        vMSVersioningFTPEntryParser0 = new VMSVersioningFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3746,"    public FTPFile parseFTPEntry(final String entry)
    {

        final FTPFile file = new FTPFile();
        file.setRawListing(entry);

        if (matches(entry))
        {
            final String usr = group(14);
            final String grp = group(15);
            final String filesize = group(16);
            final String mo = group(17);
            final String da = group(18);
            final String yr = group(20);
            final String hr = group(21);
            final String min = group(22);
            final String name = group(23);

            file.setType(FTPFile.FILE_TYPE);
            file.setUser(usr);
            file.setGroup(grp);
            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            final Calendar cal = Calendar.getInstance();
            cal.set(Calendar.MILLISECOND, 0);
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MINUTE, 0);
            cal.set(Calendar.HOUR_OF_DAY, 0);

            final int pos = MONTHS.indexOf(mo);
            final int month = pos / 4;
            final int missingUnit; // the first missing unit
            try
            {

                if (yr != null)
                {
                    // it's a year; there are no hours and minutes
                    cal.set(Calendar.YEAR, Integer.parseInt(yr));
                    missingUnit = Calendar.HOUR_OF_DAY;
                }
                else
                {
                    // it must be  hour/minute or we wouldn't have matched
                    missingUnit = Calendar.SECOND;
                    int year = cal.get(Calendar.YEAR);

                    // if the month we're reading is greater than now, it must
                    // be last year
                    if (cal.get(Calendar.MONTH) < month)
                    {
                        year--;
                    }
                    cal.set(Calendar.YEAR, year);
                    cal.set(Calendar.HOUR_OF_DAY, Integer.parseInt(hr));
                    cal.set(Calendar.MINUTE, Integer.parseInt(min));
                }
                cal.set(Calendar.MONTH, month);
                cal.set(Calendar.DAY_OF_MONTH, Integer.parseInt(da));
                cal.clear(missingUnit);
                file.setTimestamp(cal);
            }
            catch (final NumberFormatException e)
            {
                // do nothing, date will be uninitialized
            }
            file.setName(name);

            return file;
        }
        return null;
    }","  public void test0()  throws Throwable  {
      EnterpriseUnixFTPEntryParser enterpriseUnixFTPEntryParser0 = new EnterpriseUnixFTPEntryParser();
      // Undeclared exception!
      try { 
        enterpriseUnixFTPEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3747,"    public FTPFile parseFTPEntry(final String entry)
    {

        final FTPFile file = new FTPFile();
        file.setRawListing(entry);

        if (matches(entry))
        {
            final String usr = group(14);
            final String grp = group(15);
            final String filesize = group(16);
            final String mo = group(17);
            final String da = group(18);
            final String yr = group(20);
            final String hr = group(21);
            final String min = group(22);
            final String name = group(23);

            file.setType(FTPFile.FILE_TYPE);
            file.setUser(usr);
            file.setGroup(grp);
            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            final Calendar cal = Calendar.getInstance();
            cal.set(Calendar.MILLISECOND, 0);
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MINUTE, 0);
            cal.set(Calendar.HOUR_OF_DAY, 0);

            final int pos = MONTHS.indexOf(mo);
            final int month = pos / 4;
            final int missingUnit; // the first missing unit
            try
            {

                if (yr != null)
                {
                    // it's a year; there are no hours and minutes
                    cal.set(Calendar.YEAR, Integer.parseInt(yr));
                    missingUnit = Calendar.HOUR_OF_DAY;
                }
                else
                {
                    // it must be  hour/minute or we wouldn't have matched
                    missingUnit = Calendar.SECOND;
                    int year = cal.get(Calendar.YEAR);

                    // if the month we're reading is greater than now, it must
                    // be last year
                    if (cal.get(Calendar.MONTH) < month)
                    {
                        year--;
                    }
                    cal.set(Calendar.YEAR, year);
                    cal.set(Calendar.HOUR_OF_DAY, Integer.parseInt(hr));
                    cal.set(Calendar.MINUTE, Integer.parseInt(min));
                }
                cal.set(Calendar.MONTH, month);
                cal.set(Calendar.DAY_OF_MONTH, Integer.parseInt(da));
                cal.clear(missingUnit);
                file.setTimestamp(cal);
            }
            catch (final NumberFormatException e)
            {
                // do nothing, date will be uninitialized
            }
            file.setName(name);

            return file;
        }
        return null;
    }","  public void test1()  throws Throwable  {
      EnterpriseUnixFTPEntryParser enterpriseUnixFTPEntryParser0 = new EnterpriseUnixFTPEntryParser();
      enterpriseUnixFTPEntryParser0.setRegex(""Ss1a"", 0);
      // Undeclared exception!
      try { 
        enterpriseUnixFTPEntryParser0.parseFTPEntry(""Ss1a"");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 14
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3748,"    public FTPFile parseFTPEntry(final String entry)
    {

        final FTPFile file = new FTPFile();
        file.setRawListing(entry);

        if (matches(entry))
        {
            final String usr = group(14);
            final String grp = group(15);
            final String filesize = group(16);
            final String mo = group(17);
            final String da = group(18);
            final String yr = group(20);
            final String hr = group(21);
            final String min = group(22);
            final String name = group(23);

            file.setType(FTPFile.FILE_TYPE);
            file.setUser(usr);
            file.setGroup(grp);
            try
            {
                file.setSize(Long.parseLong(filesize));
            }
            catch (final NumberFormatException e)
            {
                // intentionally do nothing
            }

            final Calendar cal = Calendar.getInstance();
            cal.set(Calendar.MILLISECOND, 0);
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MINUTE, 0);
            cal.set(Calendar.HOUR_OF_DAY, 0);

            final int pos = MONTHS.indexOf(mo);
            final int month = pos / 4;
            final int missingUnit; // the first missing unit
            try
            {

                if (yr != null)
                {
                    // it's a year; there are no hours and minutes
                    cal.set(Calendar.YEAR, Integer.parseInt(yr));
                    missingUnit = Calendar.HOUR_OF_DAY;
                }
                else
                {
                    // it must be  hour/minute or we wouldn't have matched
                    missingUnit = Calendar.SECOND;
                    int year = cal.get(Calendar.YEAR);

                    // if the month we're reading is greater than now, it must
                    // be last year
                    if (cal.get(Calendar.MONTH) < month)
                    {
                        year--;
                    }
                    cal.set(Calendar.YEAR, year);
                    cal.set(Calendar.HOUR_OF_DAY, Integer.parseInt(hr));
                    cal.set(Calendar.MINUTE, Integer.parseInt(min));
                }
                cal.set(Calendar.MONTH, month);
                cal.set(Calendar.DAY_OF_MONTH, Integer.parseInt(da));
                cal.clear(missingUnit);
                file.setTimestamp(cal);
            }
            catch (final NumberFormatException e)
            {
                // do nothing, date will be uninitialized
            }
            file.setName(name);

            return file;
        }
        return null;
    }","  public void test2()  throws Throwable  {
      EnterpriseUnixFTPEntryParser enterpriseUnixFTPEntryParser0 = new EnterpriseUnixFTPEntryParser();
      FTPFile fTPFile0 = enterpriseUnixFTPEntryParser0.parseFTPEntry(""Ss1a"");
}"
3749,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(FTPClientConfig.SYST_NETWARE,
                DEFAULT_DATE_FORMAT, DEFAULT_RECENT_DATE_FORMAT);
    }","  public void test0()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser(fTPClientConfig0);
      FTPClientConfig fTPClientConfig1 = netwareFTPEntryParser0.getDefaultConfiguration();
}"
3750,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(FTPClientConfig.SYST_NETWARE,
                DEFAULT_DATE_FORMAT, DEFAULT_RECENT_DATE_FORMAT);
    }","  public void test1()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser(fTPClientConfig0);
      FTPClientConfig fTPClientConfig1 = netwareFTPEntryParser0.getDefaultConfiguration();
}"
3751,"    protected FTPClientConfig getDefaultConfiguration() {
        return new FTPClientConfig(FTPClientConfig.SYST_NETWARE,
                DEFAULT_DATE_FORMAT, DEFAULT_RECENT_DATE_FORMAT);
    }","  public void test2()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser(fTPClientConfig0);
      FTPClientConfig fTPClientConfig1 = netwareFTPEntryParser0.getDefaultConfiguration();
}"
3752,"    public FTPFile parseFTPEntry(final String entry) {

        final FTPFile f = new FTPFile();
        if (matches(entry)) {
            final String dirString = group(1);
            final String attrib = group(2);
            final String user = group(3);
            final String size = group(4);
            final String datestr = group(5);
            final String name = group(9);

            try {
                f.setTimestamp(super.parseTimestamp(datestr));
            } catch (final ParseException e) {
                 // intentionally do nothing
            }

            //is it a DIR or a file
            if (dirString.trim().equals(""d"")) {
                f.setType(FTPFile.DIRECTORY_TYPE);
            } else // Should be ""-""
            {
                f.setType(FTPFile.FILE_TYPE);
            }

            f.setUser(user);

            //set the name
            f.setName(name.trim());

            //set the size
            f.setSize(Long.parseLong(size.trim()));

            // Now set the permissions (or at least a subset thereof - full permissions would probably require
            // subclassing FTPFile and adding extra metainformation there)
            if (attrib.indexOf('R') != -1) {
                f.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION,
                        true);
            }
            if (attrib.indexOf('W') != -1) {
                f.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION,
                        true);
            }

            return f;
        }
        return null;

    }","  public void test3()  throws Throwable  {
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser();
      // Undeclared exception!
      try { 
        netwareFTPEntryParser0.parseFTPEntry((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3753,"    public NetwareFTPEntryParser() {
        this(null);
    }","  public void test4()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", ""IK[|<B"", ""IK[|<B"", (String) null, ""IK[|<B"", ""IK[|<B"", true, true);
      NetwareFTPEntryParser netwareFTPEntryParser0 = null;
      try {
        netwareFTPEntryParser0 = new NetwareFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // expecting a pipe-delimited string containing 12 tokens
         //
         verifyException(""org.apache.commons.net.ftp.FTPClientConfig"", e);
      }
  }"
3754,"    public NetwareFTPEntryParser() {
        this(null);
    }","  public void test5()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""", """", ""isyon]=?"");
      NetwareFTPEntryParser netwareFTPEntryParser0 = null;
      try {
        netwareFTPEntryParser0 = new NetwareFTPEntryParser(fTPClientConfig0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Illegal pattern character 'i'
         //
         verifyException(""java.text.SimpleDateFormat"", e);
      }
  }"
3755,"    public FTPFile parseFTPEntry(final String entry) {

        final FTPFile f = new FTPFile();
        if (matches(entry)) {
            final String dirString = group(1);
            final String attrib = group(2);
            final String user = group(3);
            final String size = group(4);
            final String datestr = group(5);
            final String name = group(9);

            try {
                f.setTimestamp(super.parseTimestamp(datestr));
            } catch (final ParseException e) {
                 // intentionally do nothing
            }

            //is it a DIR or a file
            if (dirString.trim().equals(""d"")) {
                f.setType(FTPFile.DIRECTORY_TYPE);
            } else // Should be ""-""
            {
                f.setType(FTPFile.FILE_TYPE);
            }

            f.setUser(user);

            //set the name
            f.setName(name.trim());

            //set the size
            f.setSize(Long.parseLong(size.trim()));

            // Now set the permissions (or at least a subset thereof - full permissions would probably require
            // subclassing FTPFile and adding extra metainformation there)
            if (attrib.indexOf('R') != -1) {
                f.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION,
                        true);
            }
            if (attrib.indexOf('W') != -1) {
                f.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION,
                        true);
            }

            return f;
        }
        return null;

    }","  public void test6()  throws Throwable  {
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser();
      netwareFTPEntryParser0.setRegex(""_4t]~"");
      // Undeclared exception!
      try { 
        netwareFTPEntryParser0.parseFTPEntry(""_4t]~"");
        fail(""Expecting exception: IndexOutOfBoundsException"");
      } catch(IndexOutOfBoundsException e) {
         //
         // No group 1
         //
         verifyException(""java.util.regex.Matcher"", e);
      }
  }"
3756,"    public FTPFile parseFTPEntry(final String entry) {

        final FTPFile f = new FTPFile();
        if (matches(entry)) {
            final String dirString = group(1);
            final String attrib = group(2);
            final String user = group(3);
            final String size = group(4);
            final String datestr = group(5);
            final String name = group(9);

            try {
                f.setTimestamp(super.parseTimestamp(datestr));
            } catch (final ParseException e) {
                 // intentionally do nothing
            }

            //is it a DIR or a file
            if (dirString.trim().equals(""d"")) {
                f.setType(FTPFile.DIRECTORY_TYPE);
            } else // Should be ""-""
            {
                f.setType(FTPFile.FILE_TYPE);
            }

            f.setUser(user);

            //set the name
            f.setName(name.trim());

            //set the size
            f.setSize(Long.parseLong(size.trim()));

            // Now set the permissions (or at least a subset thereof - full permissions would probably require
            // subclassing FTPFile and adding extra metainformation there)
            if (attrib.indexOf('R') != -1) {
                f.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION,
                        true);
            }
            if (attrib.indexOf('W') != -1) {
                f.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION,
                        true);
            }

            return f;
        }
        return null;

    }","  public void test7()  throws Throwable  {
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser();
      FTPFile fTPFile0 = netwareFTPEntryParser0.parseFTPEntry(""org.apache.commons.net.ftp.parser.NetwareFTPEntryParser"");
}"
3757,"    public boolean setRegex(final String regex) {
        compileRegex(regex, 0);
        return true;
    }","  public void test0()  throws Throwable  {
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser();
      boolean boolean0 = macOsPeterFTPEntryParser0.setRegex("""");
}"
3758,"    public boolean setRegex(final String regex) {
        compileRegex(regex, 0);
        return true;
    }","  public void test1()  throws Throwable  {
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser();
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser(unixFTPEntryParser0.NUMERIC_DATE_CONFIG);
      // Undeclared exception!
      try { 
        oS400FTPEntryParser0.setRegex((String) null, (-578));
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3759,"    public boolean setRegex(final String regex) {
        compileRegex(regex, 0);
        return true;
    }","  public void test2()  throws Throwable  {
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser((FTPClientConfig) null);
      // Undeclared exception!
      try { 
        oS2FTPEntryParser0.setRegex(""KX>co>GACrWHlu[d"");
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Unparseable regex supplied: KX>co>GACrWHlu[d
         //
         verifyException(""org.apache.commons.net.ftp.parser.RegexFTPFileEntryParserImpl"", e);
      }
  }"
3760,"    public boolean matches(final String s) {
        this.result = null;
        _matcher_ = pattern.matcher(s);
        if (_matcher_.matches()) {
            this.result = _matcher_.toMatchResult();
        }
        return null != this.result;
    }","  public void test3()  throws Throwable  {
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser();
      // Undeclared exception!
      try { 
        netwareFTPEntryParser0.matches((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3761,"    public String getGroupsAsString() {
        final StringBuilder b = new StringBuilder();
        for (int i = 1; i <= this.result.groupCount(); i++) {
            b.append(i).append("") "").append(this.result.group(i)).append(
                    System.getProperty(""line.separator""));
        }
        return b.toString();
    }","  public void test4()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig();
      OS2FTPEntryParser oS2FTPEntryParser0 = new OS2FTPEntryParser(fTPClientConfig0);
      // Undeclared exception!
      try { 
        oS2FTPEntryParser0.getGroupsAsString();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.ftp.parser.RegexFTPFileEntryParserImpl"", e);
      }
  }"
3762,"    public boolean matches(final String s) {
        this.result = null;
        _matcher_ = pattern.matcher(s);
        if (_matcher_.matches()) {
            this.result = _matcher_.toMatchResult();
        }
        return null != this.result;
    }","  public void test5()  throws Throwable  {
      OS400FTPEntryParser oS400FTPEntryParser0 = new OS400FTPEntryParser();
      boolean boolean0 = oS400FTPEntryParser0.matches(""kk]#?r7j]dP"");
}"
3763,"    public String getGroupsAsString() {
        final StringBuilder b = new StringBuilder();
        for (int i = 1; i <= this.result.groupCount(); i++) {
            b.append(i).append("") "").append(this.result.group(i)).append(
                    System.getProperty(""line.separator""));
        }
        return b.toString();
    }","  public void test6()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.matches("""");
      String string0 = mVSFTPEntryParser0.getGroupsAsString();
}"
3764,"    public String group(final int matchnum) {
        if (this.result == null) {
            return null;
        }
        return this.result.group(matchnum);
    }","  public void test7()  throws Throwable  {
      UnixFTPEntryParser unixFTPEntryParser0 = new UnixFTPEntryParser();
      String string0 = unixFTPEntryParser0.group(2414);
}"
3765,"    public int getGroupCnt() {
        if (this.result == null) {
            return 0;
        }
        return this.result.groupCount();
    }","  public void test8()  throws Throwable  {
      MVSFTPEntryParser mVSFTPEntryParser0 = new MVSFTPEntryParser();
      mVSFTPEntryParser0.matches("""");
      int int0 = mVSFTPEntryParser0.getGroupCnt();
}"
3766,"    public boolean setRegex(final String regex) {
        compileRegex(regex, 0);
        return true;
    }","  public void test9()  throws Throwable  {
      NetwareFTPEntryParser netwareFTPEntryParser0 = new NetwareFTPEntryParser();
      // Undeclared exception!
      try { 
        netwareFTPEntryParser0.setRegex(""p)(SS<M7%3r@g"", 0);
        fail(""Expecting exception: IllegalArgumentException"");
      } catch(IllegalArgumentException e) {
         //
         // Unparseable regex supplied: p)(SS<M7%3r@g
         //
         verifyException(""org.apache.commons.net.ftp.parser.RegexFTPFileEntryParserImpl"", e);
      }
  }"
3767,"    public int getGroupCnt() {
        if (this.result == null) {
            return 0;
        }
        return this.result.groupCount();
    }","  public void test10()  throws Throwable  {
      NTFTPEntryParser nTFTPEntryParser0 = new NTFTPEntryParser();
      int int0 = nTFTPEntryParser0.getGroupCnt();
}"
3768,"    public boolean setRegex(final String regex) {
        compileRegex(regex, 0);
        return true;
    }","  public void test11()  throws Throwable  {
      FTPClientConfig fTPClientConfig0 = new FTPClientConfig("""");
      MacOsPeterFTPEntryParser macOsPeterFTPEntryParser0 = new MacOsPeterFTPEntryParser(fTPClientConfig0);
      // Undeclared exception!
      try { 
        macOsPeterFTPEntryParser0.setRegex((String) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }"
3769,"    public POP3MessageInfo()
    {
        this(0, null, 0);
    }","  public void test0()  throws Throwable  {
      POP3MessageInfo pOP3MessageInfo0 = new POP3MessageInfo();
}"
3770,"    public POP3MessageInfo()
    {
        this(0, null, 0);
    }","  public void test1()  throws Throwable  {
      POP3MessageInfo pOP3MessageInfo0 = new POP3MessageInfo();
}"
3771,"    public POP3MessageInfo()
    {
        this(0, null, 0);
    }","  public void test2()  throws Throwable  {
      POP3MessageInfo pOP3MessageInfo0 = new POP3MessageInfo((-2063), (-2063));
}"
3772,"    public POP3MessageInfo()
    {
        this(0, null, 0);
    }","  public void test3()  throws Throwable  {
      POP3MessageInfo pOP3MessageInfo0 = new POP3MessageInfo((-2063), (-2063));
}"
3773,"    public String toString() {
        return ""Number: "" + number + "". Size: "" + size + "". Id: "" + identifier;
    }","  public void test4()  throws Throwable  {
      POP3MessageInfo pOP3MessageInfo0 = new POP3MessageInfo((-21), "",a"");
      String string0 = pOP3MessageInfo0.toString();
}"
3774,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test0()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient();
      pOP3SClient0.setEndpointCheckingEnabled(true);
      boolean boolean0 = pOP3SClient0.isEndpointCheckingEnabled();
}"
3775,"    public void setEnabledCipherSuites(final String[] cipherSuites)
    {
        suites = cipherSuites.clone();
    }","  public void test1()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient();
      // Undeclared exception!
      try { 
        pOP3SClient0.setEnabledCipherSuites((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.pop3.POP3SClient"", e);
      }
  }"
3776,"    public POP3SClient()
    {
        this(DEFAULT_PROTOCOL, false);
    }","  public void test2()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      POP3SClient pOP3SClient0 = new POP3SClient(""(>G"", true, sSLContext0);
}"
3777,"    public POP3SClient()
    {
        this(DEFAULT_PROTOCOL, false);
    }","  public void test3()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(""The offset cannot be negative"", false, (SSLContext) null);
}"
3778,"    public void setEnabledProtocols(final String[] protocolVersions)
    {
        protocols = protocolVersions.clone();
    }","  public void test4()  throws Throwable  {
      SSLContext sSLContext0 = SSLContext.getDefault();
      POP3SClient pOP3SClient0 = new POP3SClient(false, sSLContext0);
      // Undeclared exception!
      try { 
        pOP3SClient0.setEnabledProtocols((String[]) null);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.pop3.POP3SClient"", e);
      }
  }"
3779,"    public boolean execTLS() throws SSLException, IOException
    {
        if (sendCommand(""STLS"") != POP3Reply.OK)
        {
            return false;
            //throw new SSLException(getReplyString());
        }
        performSSLNegotiation();
        return true;
    }","  public void test5()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(""STLS"", true);
      // Undeclared exception!
      try { 
        pOP3SClient0.execTLS();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3780,"    public String[] getEnabledProtocols()
    {
        if (_socket_ instanceof SSLSocket)
        {
            return ((SSLSocket)_socket_).getEnabledProtocols();
        }
        return null;
    }","  public void test6()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(true);
      pOP3SClient0.getEnabledProtocols();
}"
3781,"    public String[] getEnabledCipherSuites()
    {
        if (_socket_ instanceof SSLSocket)
        {
            return ((SSLSocket)_socket_).getEnabledCipherSuites();
        }
        return null;
    }","  public void test7()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(""f7FZ:gK/"");
      pOP3SClient0.getEnabledCipherSuites();
}"
3782,"    protected void _connectAction_() throws IOException
    {
        // Implicit mode.
        if (isImplicit) {
            applySocketAttributes();
            performSSLNegotiation();
        }
        super._connectAction_();
        // Explicit mode - don't do anything. The user calls execTLS()
    }","  public void test8()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient();
      // Undeclared exception!
      try { 
        pOP3SClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3783,"    protected void _connectAction_() throws IOException
    {
        // Implicit mode.
        if (isImplicit) {
            applySocketAttributes();
            performSSLNegotiation();
        }
        super._connectAction_();
        // Explicit mode - don't do anything. The user calls execTLS()
    }","  public void test9()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(true);
      // Undeclared exception!
      try { 
        pOP3SClient0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3784,"    public void setHostnameVerifier(final HostnameVerifier newHostnameVerifier)
    {
        hostnameVerifier = newHostnameVerifier;
    }","  public void test10()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient();
      pOP3SClient0.setHostnameVerifier((HostnameVerifier) null);
}"
3785,"    public void setTrustManager(final TrustManager newTrustManager)
    {
        trustManager = newTrustManager;
    }","  public void test11()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(""f7FZ:gK/"");
      pOP3SClient0.setTrustManager((TrustManager) null);
}"
3786,"    public TrustManager getTrustManager()
    {
        return trustManager;
    }","  public void test12()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(""f7FZ:gK/"");
      pOP3SClient0.getTrustManager();
}"
3787,"    public HostnameVerifier getHostnameVerifier()
    {
        return hostnameVerifier;
    }","  public void test13()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient();
      pOP3SClient0.getHostnameVerifier();
}"
3788,"    public POP3SClient()
    {
        this(DEFAULT_PROTOCOL, false);
    }","  public void test14()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient((SSLContext) null);
}"
3789,"    public boolean isEndpointCheckingEnabled()
    {
        return tlsEndpointChecking;
    }","  public void test15()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(""f7FZ:gK/"");
      pOP3SClient0.isEndpointCheckingEnabled();
}"
3790,"    public void setEnabledCipherSuites(final String[] cipherSuites)
    {
        suites = cipherSuites.clone();
    }","  public void test16()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(""f7FZ:gK/"");
      String[] stringArray0 = new String[1];
      pOP3SClient0.setEnabledCipherSuites(stringArray0);
}"
3791,"    public void setEnabledProtocols(final String[] protocolVersions)
    {
        protocols = protocolVersions.clone();
    }","  public void test17()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient(""f7FZ:gK/"");
      String[] stringArray0 = new String[1];
      pOP3SClient0.setEnabledProtocols(stringArray0);
}"
3792,"    public void setKeyManager(final KeyManager newKeyManager)
    {
        keyManager = newKeyManager;
    }","  public void test18()  throws Throwable  {
      POP3SClient pOP3SClient0 = new POP3SClient();
      pOP3SClient0.setKeyManager((KeyManager) null);
}"
3793,"    public static String getCommand(final int command)
    {
        return commands[command];
    }","  public void test0()  throws Throwable  {
      String string0 = POP3Command.getCommand(0);
}"
3794,"    public static String getCommand(final int command)
    {
        return commands[command];
    }","  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        POP3Command.getCommand((-18));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -18
         //
         verifyException(""org.apache.commons.net.pop3.POP3Command"", e);
      }
  }"
3795,"    public boolean auth(final AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        if (sendCommand(POP3Command.AUTH, method.getAuthName())
        != POP3Reply.OK_INT) {
            return false;
        }

        switch(method) {
            case PLAIN:
                // the server sends an empty response (""+ ""), so we don't have to read it.
                return sendCommand(
                    new String(
                        Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes(getCharset())),
                        getCharset())
                    ) == POP3Reply.OK;
            case CRAM_MD5:
                // get the CRAM challenge
                final byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
                // get the Mac instance
                final Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
                hmac_md5.init(new SecretKeySpec(password.getBytes(getCharset()), ""HmacMD5""));
                // compute the result:
                final byte[] hmacResult = convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes(getCharset());
                // join the byte arrays to form the reply
                final byte[] usernameBytes = username.getBytes(getCharset());
                final byte[] toEncode = new byte[usernameBytes.length + 1 /* the space */ + hmacResult.length];
                System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
                toEncode[usernameBytes.length] = ' ';
                System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
                // send the reply and read the server code:
                return sendCommand(Base64.encodeBase64StringUnChunked(toEncode)) == POP3Reply.OK;
            default:
                return false;
        }
    }","  public void test0()  throws Throwable  {
      ExtendedPOP3Client extendedPOP3Client0 = new ExtendedPOP3Client();
      // Undeclared exception!
      try { 
        extendedPOP3Client0.auth((ExtendedPOP3Client.AUTH_METHOD) null, (String) null, """");
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.pop3.ExtendedPOP3Client"", e);
      }
  }"
3796,,"  public void test1()  throws Throwable  {
      ExtendedPOP3Client.AUTH_METHOD extendedPOP3Client_AUTH_METHOD0 = ExtendedPOP3Client.AUTH_METHOD.CRAM_MD5;
      String string0 = extendedPOP3Client_AUTH_METHOD0.getAuthName();
}"
3797,"    public boolean auth(final AUTH_METHOD method,
                        final String username, final String password)
                        throws IOException, NoSuchAlgorithmException,
                        InvalidKeyException, InvalidKeySpecException
    {
        if (sendCommand(POP3Command.AUTH, method.getAuthName())
        != POP3Reply.OK_INT) {
            return false;
        }

        switch(method) {
            case PLAIN:
                // the server sends an empty response (""+ ""), so we don't have to read it.
                return sendCommand(
                    new String(
                        Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes(getCharset())),
                        getCharset())
                    ) == POP3Reply.OK;
            case CRAM_MD5:
                // get the CRAM challenge
                final byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
                // get the Mac instance
                final Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
                hmac_md5.init(new SecretKeySpec(password.getBytes(getCharset()), ""HmacMD5""));
                // compute the result:
                final byte[] hmacResult = convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes(getCharset());
                // join the byte arrays to form the reply
                final byte[] usernameBytes = username.getBytes(getCharset());
                final byte[] toEncode = new byte[usernameBytes.length + 1 /* the space */ + hmacResult.length];
                System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
                toEncode[usernameBytes.length] = ' ';
                System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
                // send the reply and read the server code:
                return sendCommand(Base64.encodeBase64StringUnChunked(toEncode)) == POP3Reply.OK;
            default:
                return false;
        }
    }","  public void test2()  throws Throwable  {
      ExtendedPOP3Client extendedPOP3Client0 = new ExtendedPOP3Client();
      ExtendedPOP3Client.AUTH_METHOD extendedPOP3Client_AUTH_METHOD0 = ExtendedPOP3Client.AUTH_METHOD.PLAIN;
      // Undeclared exception!
      try { 
        extendedPOP3Client0.auth(extendedPOP3Client_AUTH_METHOD0, ""\r\n"", ""\r\n"");
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3798,"    public int getState()
    {
        return popState;
    }","  public void test0()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
}"
3799,"    public int getState()
    {
        return popState;
    }","  public void test1()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.setState(0);
      int int0 = pOP3_0.getState();
}"
3800,"    public int getState()
    {
        return popState;
    }","  public void test2()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""\r\n"");
      pOP3_0.replyLines = (List<String>) linkedList0;
      pOP3_0.getReplyStrings();
}"
3801,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test3()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""\r\n"");
      pOP3_0.replyLines = (List<String>) linkedList0;
      pOP3_0.getReplyStrings();
}"
3802,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test4()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0._commandSupport_ = null;
      pOP3_0.getCommandSupport();
}"
3803,"    public int getState()
    {
        return popState;
    }","  public void test5()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0._commandSupport_ = null;
      pOP3_0.getCommandSupport();
}"
3804,"    public int getState()
    {
        return popState;
    }","  public void test6()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.getCommandSupport();
}"
3805,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test7()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.getCommandSupport();
}"
3806,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (writer == null) {
            throw new IllegalStateException(""Socket is not connected"");
        }
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        getReply();
        return replyCode;
    }","  public void test8()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      // Undeclared exception!
      try { 
        pOP3_0.sendCommand(110, ""bh/hGZ f-!4|9ecX*"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 110
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3807,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (writer == null) {
            throw new IllegalStateException(""Socket is not connected"");
        }
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        getReply();
        return replyCode;
    }","  public void test9()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      // Undeclared exception!
      try { 
        pOP3_0.sendCommand((-1728));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1728
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3808,"    public void removeProtocolCommandistener(final org.apache.commons.net.ProtocolCommandListener listener){
        removeProtocolCommandListener(listener);
    }","  public void test10()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      MockPrintStream mockPrintStream0 = new MockPrintStream(""\r\n"");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockPrintStream0);
      pOP3_0._commandSupport_ = null;
      PrintCommandListener printCommandListener0 = new PrintCommandListener(mockPrintWriter0, false, 'H');
      // Undeclared exception!
      try { 
        pOP3_0.removeProtocolCommandistener(printCommandListener0);
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3809,"    public String[] getReplyStrings()
    {
        return replyLines.toArray(NetConstants.EMPTY_STRING_ARRAY);
    }","  public void test11()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.replyLines = null;
      // Undeclared exception!
      try { 
        pOP3_0.getReplyStrings();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3810,"    public void getAdditionalReply() throws IOException
    {
        String line;

        line = reader.readLine();
        while (line != null)
        {
            replyLines.add(line);
            if (line.equals(""."")) {
                break;
            }
            line = reader.readLine();
        }
    }","  public void test12()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      // Undeclared exception!
      try { 
        pOP3_0.getAdditionalReply();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3811,"    public void getAdditionalReply() throws IOException
    {
        String line;

        line = reader.readLine();
        while (line != null)
        {
            replyLines.add(line);
            if (line.equals(""."")) {
                break;
            }
            line = reader.readLine();
        }
    }","  public void test13()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      PipedReader pipedReader0 = new PipedReader(1);
      BufferedReader bufferedReader0 = new BufferedReader(pipedReader0);
      pOP3_0.reader = bufferedReader0;
      try { 
        pOP3_0.getAdditionalReply();
        fail(""Expecting exception: IOException"");
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedReader"", e);
      }
  }"
3812,"    public void disconnect() throws IOException
    {
        super.disconnect();
        reader = null;
        writer = null;
        lastReplyLine = null;
        replyLines.clear();
        setState(DISCONNECTED_STATE);
    }","  public void test14()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.replyLines = null;
      // Undeclared exception!
      try { 
        pOP3_0.disconnect();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3813,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (writer == null) {
            throw new IllegalStateException(""Socket is not connected"");
        }
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        getReply();
        return replyCode;
    }","  public void test15()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      // Undeclared exception!
      try { 
        pOP3_0.sendCommand(""SYSTEM"", ""SYSTEM"");
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3814,"    public int getState()
    {
        return popState;
    }","  public void test16()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.setState(859);
      int int0 = pOP3_0.getState();
}"
3815,"    public String getReplyString()
    {
        final StringBuilder buffer = new StringBuilder(256);

        for (final String entry : replyLines)
        {
            buffer.append(entry);
            buffer.append(SocketClient.NETASCII_EOL);
        }

        return buffer.toString();
    }","  public void test17()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""\r\n"");
      pOP3_0.replyLines = (List<String>) linkedList0;
      String string0 = pOP3_0.getReplyString();
}"
3816,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test18()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""\r\n"");
      pOP3_0.replyLines = (List<String>) linkedList0;
      String string0 = pOP3_0.getReplyString();
}"
3817,"    public int getState()
    {
        return popState;
    }","  public void test19()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""\r\n"");
      pOP3_0.replyLines = (List<String>) linkedList0;
      String string0 = pOP3_0.getReplyString();
}"
3818,"    public int getState()
    {
        return popState;
    }","  public void test20()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.getReplyString();
}"
3819,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test21()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.getReplyString();
}"
3820,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (writer == null) {
            throw new IllegalStateException(""Socket is not connected"");
        }
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        getReply();
        return replyCode;
    }","  public void test22()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      // Undeclared exception!
      try { 
        pOP3_0.sendCommand(""\r\n\r\n"");
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3821,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (writer == null) {
            throw new IllegalStateException(""Socket is not connected"");
        }
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        getReply();
        return replyCode;
    }","  public void test23()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      // Undeclared exception!
      try { 
        pOP3_0.sendCommand(0, """");
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3822,"    public int sendCommand(final String command, final String args) throws IOException
    {
        if (writer == null) {
            throw new IllegalStateException(""Socket is not connected"");
        }
        final StringBuilder __commandBuffer = new StringBuilder();
        __commandBuffer.append(command);

        if (args != null)
        {
            __commandBuffer.append(' ');
            __commandBuffer.append(args);
        }
        __commandBuffer.append(SocketClient.NETASCII_EOL);

        final String message = __commandBuffer.toString();
        writer.write(message);
        writer.flush();

        fireCommandSent(command, message);

        getReply();
        return replyCode;
    }","  public void test24()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      // Undeclared exception!
      try { 
        pOP3_0.sendCommand(2);
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3823,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test25()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.disconnect();
}"
3824,"    public int getState()
    {
        return popState;
    }","  public void test26()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.disconnect();
}"
3825,"    public int getState()
    {
        return popState;
    }","  public void test27()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.removeProtocolCommandistener((ProtocolCommandListener) null);
}"
3826,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test28()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.removeProtocolCommandistener((ProtocolCommandListener) null);
}"
3827,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test29()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.getReplyStrings();
}"
3828,"    public int getState()
    {
        return popState;
    }","  public void test30()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      pOP3_0.getReplyStrings();
}"
3829,"    protected void _connectAction_() throws IOException
    {
        super._connectAction_();
        reader =
          new CRLFLineReader(new InputStreamReader(_input_,
                                                   DEFAULT_ENCODING));
        writer =
          new BufferedWriter(new OutputStreamWriter(_output_,
                                                    DEFAULT_ENCODING));
        getReply();
        setState(AUTHORIZATION_STATE);
    }","  public void test31()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      // Undeclared exception!
      try { 
        pOP3_0._connectAction_();
        fail(""Expecting exception: NullPointerException"");
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.net.SocketClient"", e);
      }
  }"
3830,"    public int getState()
    {
        return popState;
    }","  public void test32()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      int int0 = pOP3_0.getState();
}"
3831,"    public int getDefaultPort()
    {
        return _defaultPort_;
    }","  public void test33()  throws Throwable  {
      POP3 pOP3_0 = new POP3();
      int int0 = pOP3_0.getState();
}"
3832,"    public Reader retrieveMessageTop(final int messageId, final int numLines)
    throws IOException
    {
        if (numLines < 0 || getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.TOP, Integer.toString(messageId) + "" "" +
                        Integer.toString(numLines)) != POP3Reply.OK) {
            return null;
        }

        return new DotTerminatedMessageReader(reader);
    }","  public void test0()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.retrieveMessageTop((-2733), 8);
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3833,"    public Reader retrieveMessageTop(final int messageId, final int numLines)
    throws IOException
    {
        if (numLines < 0 || getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.TOP, Integer.toString(messageId) + "" "" +
                        Integer.toString(numLines)) != POP3Reply.OK) {
            return null;
        }

        return new DotTerminatedMessageReader(reader);
    }","  public void test1()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      Reader reader0 = pOP3Client0.retrieveMessageTop(800, 0);
}"
3834,"    public Reader retrieveMessage(final int messageId) throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.RETR, Integer.toString(messageId)) != POP3Reply.OK) {
            return null;
        }

        return new DotTerminatedMessageReader(reader);
    }","  public void test2()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.retrieveMessage(0);
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3835,"    public POP3MessageInfo listUniqueIdentifier(final int messageId)
    throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.UIDL, Integer.toString(messageId))
                != POP3Reply.OK) {
            return null;
        }
        return parseUID(lastReplyLine.substring(3));
    }","  public void test3()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.listUniqueIdentifier((-13));
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3836,"    public POP3MessageInfo listMessage(final int messageId) throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.LIST, Integer.toString(messageId))
                != POP3Reply.OK) {
            return null;
        }
        return parseStatus(lastReplyLine.substring(3));
    }","  public void test4()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.listMessage(0);
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3837,"    public boolean deleteMessage(final int messageId) throws IOException
    {
        if (getState() == TRANSACTION_STATE) {
            return sendCommand(POP3Command.DELE, Integer.toString(messageId))
                    == POP3Reply.OK;
        }
        return false;
    }","  public void test5()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.deleteMessage(13);
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3838,"    public boolean login(final String username, final String password) throws IOException
    {
        if (getState() != AUTHORIZATION_STATE) {
            return false;
        }

        if (sendCommand(POP3Command.USER, username) != POP3Reply.OK) {
            return false;
        }

        if (sendCommand(POP3Command.PASS, password) != POP3Reply.OK) {
            return false;
        }

        setState(TRANSACTION_STATE);

        return true;
    }","  public void test6()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(0);
      // Undeclared exception!
      try { 
        pOP3Client0.login(""\r\n"", (String) null, (String) null);
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3839,"    public boolean login(final String username, final String password) throws IOException
    {
        if (getState() != AUTHORIZATION_STATE) {
            return false;
        }

        if (sendCommand(POP3Command.USER, username) != POP3Reply.OK) {
            return false;
        }

        if (sendCommand(POP3Command.PASS, password) != POP3Reply.OK) {
            return false;
        }

        setState(TRANSACTION_STATE);

        return true;
    }","  public void test7()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(0);
      // Undeclared exception!
      try { 
        pOP3Client0.login(""UZ4!;m1x-&7og"", """", ""UZ4!;m1x-&7og"");
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3840,"    public boolean login(final String username, final String password) throws IOException
    {
        if (getState() != AUTHORIZATION_STATE) {
            return false;
        }

        if (sendCommand(POP3Command.USER, username) != POP3Reply.OK) {
            return false;
        }

        if (sendCommand(POP3Command.PASS, password) != POP3Reply.OK) {
            return false;
        }

        setState(TRANSACTION_STATE);

        return true;
    }","  public void test8()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(110);
      boolean boolean0 = pOP3Client0.login("""", ""?!!O>wWs$*$5%89,J}"", ""\r\n"");
}"
3841,"    public boolean login(final String username, final String password) throws IOException
    {
        if (getState() != AUTHORIZATION_STATE) {
            return false;
        }

        if (sendCommand(POP3Command.USER, username) != POP3Reply.OK) {
            return false;
        }

        if (sendCommand(POP3Command.PASS, password) != POP3Reply.OK) {
            return false;
        }

        setState(TRANSACTION_STATE);

        return true;
    }","  public void test9()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(0);
      // Undeclared exception!
      try { 
        pOP3Client0.login("",1d2GM4cnn{L<w"", """");
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3842,"    public boolean login(final String username, final String password) throws IOException
    {
        if (getState() != AUTHORIZATION_STATE) {
            return false;
        }

        if (sendCommand(POP3Command.USER, username) != POP3Reply.OK) {
            return false;
        }

        if (sendCommand(POP3Command.PASS, password) != POP3Reply.OK) {
            return false;
        }

        setState(TRANSACTION_STATE);

        return true;
    }","  public void test10()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(2);
      boolean boolean0 = pOP3Client0.login(""The FilenameFilter must not be null"", ""The FilenameFilter must not be null"");
}"
3843,"    public boolean capa() throws IOException
    {
        if (sendCommand(POP3Command.CAPA) == POP3Reply.OK) {
            getAdditionalReply();
            return true;
        }
        return false;

    }","  public void test11()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      // Undeclared exception!
      try { 
        pOP3Client0.capa();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3844,"    public Reader retrieveMessageTop(final int messageId, final int numLines)
    throws IOException
    {
        if (numLines < 0 || getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.TOP, Integer.toString(messageId) + "" "" +
                        Integer.toString(numLines)) != POP3Reply.OK) {
            return null;
        }

        return new DotTerminatedMessageReader(reader);
    }","  public void test12()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      Reader reader0 = pOP3Client0.retrieveMessageTop(0, (-388));
}"
3845,"    public Reader retrieveMessage(final int messageId) throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.RETR, Integer.toString(messageId)) != POP3Reply.OK) {
            return null;
        }

        return new DotTerminatedMessageReader(reader);
    }","  public void test13()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      Reader reader0 = pOP3Client0.retrieveMessage(293);
}"
3846,"    public Reader retrieveMessage(final int messageId) throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.RETR, Integer.toString(messageId)) != POP3Reply.OK) {
            return null;
        }

        return new DotTerminatedMessageReader(reader);
    }","  public void test14()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.retrieveMessage(2);
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3847,"    public POP3MessageInfo[] listUniqueIdentifiers() throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
            return null;
        }
        getAdditionalReply();

        // This could be a zero length array if no messages present
        final POP3MessageInfo[] messages = new POP3MessageInfo[replyLines.size() - 2]; // skip first and last lines

        final ListIterator<String> en = replyLines.listIterator(1); // skip first line

        // Fetch lines.
        for (int line = 0; line < messages.length; line++) {
            messages[line] = parseUID(en.next());
        }

        return messages;
    }","  public void test15()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      POP3MessageInfo[] pOP3MessageInfoArray0 = pOP3Client0.listUniqueIdentifiers();
}"
3848,"    public POP3MessageInfo[] listUniqueIdentifiers() throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
            return null;
        }
        getAdditionalReply();

        // This could be a zero length array if no messages present
        final POP3MessageInfo[] messages = new POP3MessageInfo[replyLines.size() - 2]; // skip first and last lines

        final ListIterator<String> en = replyLines.listIterator(1); // skip first line

        // Fetch lines.
        for (int line = 0; line < messages.length; line++) {
            messages[line] = parseUID(en.next());
        }

        return messages;
    }","  public void test16()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.listUniqueIdentifiers();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3849,"    public POP3MessageInfo listUniqueIdentifier(final int messageId)
    throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.UIDL, Integer.toString(messageId))
                != POP3Reply.OK) {
            return null;
        }
        return parseUID(lastReplyLine.substring(3));
    }","  public void test17()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      POP3MessageInfo pOP3MessageInfo0 = pOP3Client0.listUniqueIdentifier(0);
}"
3850,"    public POP3MessageInfo[] listMessages() throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
            return null;
        }
        getAdditionalReply();

        // This could be a zero length array if no messages present
        final POP3MessageInfo[] messages = new POP3MessageInfo[replyLines.size() - 2]; // skip first and last lines

        final ListIterator<String> en = replyLines.listIterator(1); // Skip first line

        // Fetch lines.
        for (int line = 0; line < messages.length; line++) {
            messages[line] = parseStatus(en.next());
        }

        return messages;
    }","  public void test18()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      POP3MessageInfo[] pOP3MessageInfoArray0 = pOP3Client0.listMessages();
}"
3851,"    public POP3MessageInfo[] listMessages() throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
            return null;
        }
        getAdditionalReply();

        // This could be a zero length array if no messages present
        final POP3MessageInfo[] messages = new POP3MessageInfo[replyLines.size() - 2]; // skip first and last lines

        final ListIterator<String> en = replyLines.listIterator(1); // Skip first line

        // Fetch lines.
        for (int line = 0; line < messages.length; line++) {
            messages[line] = parseStatus(en.next());
        }

        return messages;
    }","  public void test19()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.listMessages();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3852,"    public POP3MessageInfo listMessage(final int messageId) throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.LIST, Integer.toString(messageId))
                != POP3Reply.OK) {
            return null;
        }
        return parseStatus(lastReplyLine.substring(3));
    }","  public void test20()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      POP3MessageInfo pOP3MessageInfo0 = pOP3Client0.listMessage(1);
}"
3853,"    public POP3MessageInfo listMessage(final int messageId) throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.LIST, Integer.toString(messageId))
                != POP3Reply.OK) {
            return null;
        }
        return parseStatus(lastReplyLine.substring(3));
    }","  public void test21()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.listMessage(2);
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3854,"    public POP3MessageInfo status() throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.STAT) != POP3Reply.OK) {
            return null;
        }
        return parseStatus(lastReplyLine.substring(3));
    }","  public void test22()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      POP3MessageInfo pOP3MessageInfo0 = pOP3Client0.status();
}"
3855,"    public POP3MessageInfo status() throws IOException
    {
        if (getState() != TRANSACTION_STATE) {
            return null;
        }
        if (sendCommand(POP3Command.STAT) != POP3Reply.OK) {
            return null;
        }
        return parseStatus(lastReplyLine.substring(3));
    }","  public void test23()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.status();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3856,"    public boolean reset() throws IOException
    {
        if (getState() == TRANSACTION_STATE) {
            return sendCommand(POP3Command.RSET) == POP3Reply.OK;
        }
        return false;
    }","  public void test24()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.reset();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3857,"    public boolean reset() throws IOException
    {
        if (getState() == TRANSACTION_STATE) {
            return sendCommand(POP3Command.RSET) == POP3Reply.OK;
        }
        return false;
    }","  public void test25()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      boolean boolean0 = pOP3Client0.reset();
}"
3858,"    public boolean deleteMessage(final int messageId) throws IOException
    {
        if (getState() == TRANSACTION_STATE) {
            return sendCommand(POP3Command.DELE, Integer.toString(messageId))
                    == POP3Reply.OK;
        }
        return false;
    }","  public void test26()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      boolean boolean0 = pOP3Client0.deleteMessage(2);
}"
3859,"    public boolean noop() throws IOException
    {
        if (getState() == TRANSACTION_STATE) {
            return sendCommand(POP3Command.NOOP) == POP3Reply.OK;
        }
        return false;
    }","  public void test27()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.noop();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3860,"    public boolean noop() throws IOException
    {
        if (getState() == TRANSACTION_STATE) {
            return sendCommand(POP3Command.NOOP) == POP3Reply.OK;
        }
        return false;
    }","  public void test28()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      boolean boolean0 = pOP3Client0.noop();
}"
3861,"    public boolean logout() throws IOException
    {
        if (getState() == TRANSACTION_STATE) {
            setState(UPDATE_STATE);
        }
        sendCommand(POP3Command.QUIT);
        return replyCode == POP3Reply.OK;
    }","  public void test29()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      pOP3Client0.setState(1);
      // Undeclared exception!
      try { 
        pOP3Client0.logout();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3862,"    public boolean logout() throws IOException
    {
        if (getState() == TRANSACTION_STATE) {
            setState(UPDATE_STATE);
        }
        sendCommand(POP3Command.QUIT);
        return replyCode == POP3Reply.OK;
    }","  public void test30()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      // Undeclared exception!
      try { 
        pOP3Client0.logout();
        fail(""Expecting exception: IllegalStateException"");
      } catch(IllegalStateException e) {
         //
         // Socket is not connected
         //
         verifyException(""org.apache.commons.net.pop3.POP3"", e);
      }
  }"
3863,"    public boolean login(final String username, final String password) throws IOException
    {
        if (getState() != AUTHORIZATION_STATE) {
            return false;
        }

        if (sendCommand(POP3Command.USER, username) != POP3Reply.OK) {
            return false;
        }

        if (sendCommand(POP3Command.PASS, password) != POP3Reply.OK) {
            return false;
        }

        setState(TRANSACTION_STATE);

        return true;
    }","  public void test31()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      boolean boolean0 = pOP3Client0.login("""", ""?!!O>wWs$*$5%89,J}"", ""\r\n"");
}"
3864,"    public boolean login(final String username, final String password) throws IOException
    {
        if (getState() != AUTHORIZATION_STATE) {
            return false;
        }

        if (sendCommand(POP3Command.USER, username) != POP3Reply.OK) {
            return false;
        }

        if (sendCommand(POP3Command.PASS, password) != POP3Reply.OK) {
            return false;
        }

        setState(TRANSACTION_STATE);

        return true;
    }","  public void test32()  throws Throwable  {
      POP3Client pOP3Client0 = new POP3Client();
      boolean boolean0 = pOP3Client0.login("""", """");
}"

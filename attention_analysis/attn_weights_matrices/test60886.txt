60886
Test: public void testBackslashEscapingOld() throws IOException { final String code = "one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n" + "one,\"tw\\\"o\"\n" + "one,\"t\\,wo\"\n" + "one,two,\"th,ree\"\n" + "\"a\\\\\"\n" + "a\\,b\n" + "\"a\\\\,b\""; final String[][] res = { {"one", "two", "three"}, {"on\\\"e", "two"}, {"on\"e", "two"}, {"one", "tw\"o"}, {"one", "t\\,wo"}, {"one", "two", "th,ree"}, {"a\\\\"}, {"a\\", "b"}, {"a\\\\,b"} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } @Test public void testBackslashEscaping() throws IOException { final String code = "one,two,three\n" + "'',''\n" + "/',/'\n" + "'/'','/''\n" + "'''',''''\n" + "/,,/,\n" + " + "' + " 8 , \"quoted \"\" /\" + "9, /\n \n" + ""; final String[][] res = { {"one", "two", "three"}, {"", ""}, {"'", "'"}, {"'", "'"}, {"'", "'"}, {",", ","}, {"/", "/"}, {"/", "/"}, {" 8 ", " \"quoted \"\" /\" / string\" "}, {"9", " \n "}, }; final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\'') .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true); final CSVParser parser = CSVParser.parse(code, format); final List<CSVRecord> records = parser.getRecords(); Utils.compare("Records do not match expected result", res, records); } @Test public void testBackslashEscaping2() throws IOException { final String code = "" + " , , \n" + " \t , , \n" + " + ""; final String[][] res = { {" ", " ", " "}, {" \t ", " ", " "}, {" / ", " , ", " ,"}, }; final CSVFormat format = CSVFormat.newFormat(',') .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true); final CSVParser parser = CSVParser.parse(code, format); final List<CSVRecord> records = parser.getRecords(); Utils.compare("", res, records); } @Test public void testDefaultFormat() throws IOException { final String code = "" + "a,b#\n" + "\"\n\",\" \",#\n" + "#,\"\"\n" + "# Final comment\n" ; final String[][] res = { {"a", "b#"}, {"\n", " ", "#"}, {"#", ""}, {"# Final comment"} }; CSVFormat format = CSVFormat.DEFAULT; CSVParser parser = CSVParser.parse(code, format); List<CSVRecord> records = parser.getRecords(); Utils.compare("Failed to parse without comments", res, records); final String[][] res_comments = { {"a", "b#"}, {"\n", " ", "#"}, }; format = CSVFormat.DEFAULT.withCommentStart('#'); parser = CSVParser.parse(code, format); records = parser.getRecords(); Utils.compare("Failed to parse with comments", res_comments, records); } @Test public void testCarriageReturnLineFeedEndings() throws IOException { final String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test(expected = NoSuchElementException.class) public void testClose() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final CSVParser parser = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in); final Iterator<CSVRecord> records = parser.iterator(); parser.close(); records.next(); } @Test public void testCarriageReturnEndings() throws IOException { final String code = "foo\rbaar,\rhello,world\r,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test public void testLineFeedEndings() throws IOException { final String code = "foo\nbaar,\nhello,world\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test public void testIgnoreEmptyLines() throws IOException { final String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test public void testForEach() throws Exception { final List<CSVRecord> records = new ArrayList<CSVRecord>(); final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) { records.add(record); } } @Test public void testRoundtrip() throws Exception { final StringWriter out = new StringWriter(); final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT); final String input = "a,b,c\r\n1,2,3\r\nx,y,z\r\n"; for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) { printer.printRecord(record); } printer.close(); } @Test public void testIterator() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator(); try { iterator.remove(); fail("expected UnsupportedOperationException"); } catch (final UnsupportedOperationException expected) { } try { iterator.next(); fail("NoSuchElementException expected"); } catch (final NoSuchElementException e) { } } @Test public void testMultipleIterators() throws Exception { CSVParser parser = CSVParser.parse("a,b,c" + CR + "d,e,f", CSVFormat.DEFAULT); Iterator<CSVRecord> itr1 = parser.iterator(); Iterator<CSVRecord> itr2 = parser.iterator(); CSVRecord first = itr1.next(); CSVRecord second = itr2.next(); } @Test public void testHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testSkipSetHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("a", "b", "c").withSkipHeaderRecord(true) .parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testSkipAutoHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testHeaderComment() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").parse(in).iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeaderAuto() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception { final Reader in = new StringReader("a,b,c\n1,2\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").withSkipHeaderRecord(true) .parse(in).iterator(); CSVRecord record; record = records.next(); record = records.next(); } @Test public void testGetHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader("A", "B", "C")); final Map<String, Integer> headerMap = parser.getHeaderMap(); final Iterator<String> columnNames = headerMap.keySet().iterator(); final Iterator<CSVRecord> records = parser.iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testNoHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT); } @Test public void testGetLineNumberWithLF() throws Exception { this.validateLineNumbers(String.valueOf(LF)); } @Test public void testGetLineNumberWithCRLF() throws Exception { this.validateLineNumbers(CRLF); } @Test public void testGetLineNumberWithCR() throws Exception { this.validateLineNumbers(String.valueOf(CR)); } @Test public void testGetRecordNumberWithLF() throws Exception { this.validateRecordNumbers(String.valueOf(LF)); } @Test public void testGetRecordWithMultiLineValues() throws Exception { final CSVParser parser = CSVParser.parse("\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\"" + CRLF + "\"c\r\n1\",\"c\r\n2\"", CSVFormat.DEFAULT.withRecordSeparator(CRLF)); CSVRecord record; } @Test public void testGetRecordNumberWithCRLF() throws Exception { this.validateRecordNumbers(CRLF); } @Test public void testGetRecordNumberWithCR() throws Exception { this.validateRecordNumbers(String.valueOf(CR)); } @Test(expected = IllegalArgumentException.class) public void testInvalidFormat() throws Exception { final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR); new CSVParser(null, invalidFormat).close(); } @Test(expected = IllegalArgumentException.class) public void testParseNullFileFormat() throws Exception { CSVParser.parse((File) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseFileNullFormat() throws Exception { CSVParser.parse(new File(""), null); } @Test(expected = IllegalArgumentException.class) public void testParseNullStringFormat() throws Exception { CSVParser.parse((String) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseStringNullFormat() throws Exception { CSVParser.parse("csv data", null); } @Test(expected = IllegalArgumentException.class) public void testParseNullUrlCharsetFormat() throws Exception { CSVParser.parse(null, Charset.defaultCharset(), CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParserUrlNullCharsetFormat() throws Exception { CSVParser.parse(new URL("http: } @Test(expected = IllegalArgumentException.class) public void testParseUrlCharsetNullFormat() throws Exception { CSVParser.parse(new URL("http: } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserNullReaderFormat() throws Exception { new CSVParser(null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserReaderNullFormat() throws Exception { new CSVParser(new StringReader(""), null); } private void validateRecordNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); CSVRecord record; } private void validateLineNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); }}
Code: public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); }
[[0.05198041 0.09485255 0.12401982 0.06536103 0.08051092 0.05858985
 0.03092108 0.07879402 0.05636829 0.08212578 0.05636829 0.05266444
 0.02544313 0.07335463 0.04404769 0.02459802]
[0.0357319  0.08877708 0.19502692 0.0793462  0.08189169 0.05254283
 0.02393285 0.07739931 0.04085156 0.08642577 0.04085156 0.04123895
 0.01762952 0.0817203  0.03641327 0.02022028]
[0.0389564  0.10303893 0.14037484 0.09081842 0.09220015 0.05932518
 0.02629459 0.07227578 0.04978964 0.08601966 0.04978964 0.03770859
 0.02238095 0.07237889 0.03616957 0.0224788 ]
[0.04436782 0.0992939  0.1323761  0.08833019 0.09470863 0.0694076
 0.02387881 0.06916736 0.05338185 0.07773218 0.05338185 0.03932381
 0.02135655 0.07295461 0.03830172 0.02203705]
[0.05810118 0.10533378 0.09799965 0.08157544 0.09342213 0.06686561
 0.03720241 0.06216685 0.0473867  0.07545871 0.0473867  0.04767982
 0.03241625 0.06573806 0.04832766 0.03293903]
[0.04031067 0.09249616 0.15722379 0.08587298 0.08693102 0.05713095
 0.02544667 0.07275225 0.0473719  0.10022658 0.0473719  0.03921894
 0.02359576 0.06258572 0.03805353 0.02341118]
[0.03844686 0.10779039 0.13719669 0.09116348 0.09042472 0.05726738
 0.02576194 0.06437496 0.04706016 0.10727952 0.04706016 0.03223203
 0.02473334 0.07141173 0.03833825 0.01945842]
[0.03380292 0.10335876 0.14566198 0.09151421 0.09387578 0.0560907
 0.02370527 0.08242077 0.04038549 0.09495917 0.04038549 0.04714949
 0.02274311 0.06528287 0.0397408  0.01892325]
[0.04457158 0.11539032 0.10517107 0.07528505 0.11089499 0.07303389
 0.03011953 0.06974052 0.04059987 0.09541243 0.04059987 0.03805314
 0.03155285 0.07066265 0.04222621 0.01668605]
[0.04408978 0.10329313 0.14700615 0.08732106 0.11539462 0.06171016
 0.02189578 0.0539145  0.04152359 0.09300318 0.04152359 0.04805279
 0.02022762 0.0587083  0.04079233 0.0215434 ]
[0.04457158 0.11539032 0.10517107 0.07528505 0.11089499 0.07303389
 0.03011953 0.06974052 0.04059987 0.09541243 0.04059987 0.03805314
 0.03155285 0.07066265 0.04222621 0.01668605]
[0.05225872 0.09766825 0.08986827 0.09649681 0.08507682 0.0656887
 0.03274211 0.06301767 0.05190282 0.11119244 0.05190282 0.03705266
 0.02700505 0.06145459 0.04777781 0.02889455]
[0.04574826 0.07517865 0.13800271 0.0815645  0.08938694 0.06454553
 0.02997624 0.0789681  0.05226405 0.08398801 0.05226405 0.05540809
 0.02898787 0.05732729 0.04089824 0.02549148]
[0.04479377 0.09509856 0.1250689  0.08729917 0.1089474  0.07186402
 0.02948593 0.06455235 0.04759308 0.09135512 0.04759308 0.03590797
 0.02284645 0.07401957 0.03750772 0.01606689]
[0.03657227 0.09869656 0.12798108 0.09505768 0.08445244 0.05905171
 0.02923621 0.07096958 0.0439725  0.10327652 0.0439725  0.03310742
 0.02407226 0.0831238  0.04049535 0.02596214]
[0.03909774 0.1107301  0.1003487  0.08917665 0.10530584 0.08678605
 0.02587156 0.06816472 0.04398426 0.09592887 0.04398426 0.03781319
 0.02193883 0.06320935 0.04523131 0.02242863]]
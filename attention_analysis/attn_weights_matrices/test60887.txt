60887
Test: public void testBackslashEscapingOld() throws IOException { final String code = "one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n" + "one,\"tw\\\"o\"\n" + "one,\"t\\,wo\"\n" + "one,two,\"th,ree\"\n" + "\"a\\\\\"\n" + "a\\,b\n" + "\"a\\\\,b\""; final String[][] res = { {"one", "two", "three"}, {"on\\\"e", "two"}, {"on\"e", "two"}, {"one", "tw\"o"}, {"one", "t\\,wo"}, {"one", "two", "th,ree"}, {"a\\\\"}, {"a\\", "b"}, {"a\\\\,b"} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } @Test public void testBackslashEscaping() throws IOException { final String code = "one,two,three\n" + "'',''\n" + "/',/'\n" + "'/'','/''\n" + "'''',''''\n" + "/,,/,\n" + " + "' + " 8 , \"quoted \"\" /\" + "9, /\n \n" + ""; final String[][] res = { {"one", "two", "three"}, {"", ""}, {"'", "'"}, {"'", "'"}, {"'", "'"}, {",", ","}, {"/", "/"}, {"/", "/"}, {" 8 ", " \"quoted \"\" /\" / string\" "}, {"9", " \n "}, }; final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\'') .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true); final CSVParser parser = CSVParser.parse(code, format); final List<CSVRecord> records = parser.getRecords(); Utils.compare("Records do not match expected result", res, records); } @Test public void testBackslashEscaping2() throws IOException { final String code = "" + " , , \n" + " \t , , \n" + " + ""; final String[][] res = { {" ", " ", " "}, {" \t ", " ", " "}, {" / ", " , ", " ,"}, }; final CSVFormat format = CSVFormat.newFormat(',') .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true); final CSVParser parser = CSVParser.parse(code, format); final List<CSVRecord> records = parser.getRecords(); Utils.compare("", res, records); } @Test public void testDefaultFormat() throws IOException { final String code = "" + "a,b#\n" + "\"\n\",\" \",#\n" + "#,\"\"\n" + "# Final comment\n" ; final String[][] res = { {"a", "b#"}, {"\n", " ", "#"}, {"#", ""}, {"# Final comment"} }; CSVFormat format = CSVFormat.DEFAULT; CSVParser parser = CSVParser.parse(code, format); List<CSVRecord> records = parser.getRecords(); Utils.compare("Failed to parse without comments", res, records); final String[][] res_comments = { {"a", "b#"}, {"\n", " ", "#"}, }; format = CSVFormat.DEFAULT.withCommentStart('#'); parser = CSVParser.parse(code, format); records = parser.getRecords(); Utils.compare("Failed to parse with comments", res_comments, records); } @Test public void testCarriageReturnLineFeedEndings() throws IOException { final String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test(expected = NoSuchElementException.class) public void testClose() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final CSVParser parser = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in); final Iterator<CSVRecord> records = parser.iterator(); parser.close(); records.next(); } @Test public void testCarriageReturnEndings() throws IOException { final String code = "foo\rbaar,\rhello,world\r,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test public void testLineFeedEndings() throws IOException { final String code = "foo\nbaar,\nhello,world\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test public void testIgnoreEmptyLines() throws IOException { final String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); } @Test public void testForEach() throws Exception { final List<CSVRecord> records = new ArrayList<CSVRecord>(); final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) { records.add(record); } } @Test public void testRoundtrip() throws Exception { final StringWriter out = new StringWriter(); final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT); final String input = "a,b,c\r\n1,2,3\r\nx,y,z\r\n"; for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) { printer.printRecord(record); } printer.close(); } @Test public void testIterator() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator(); try { iterator.remove(); fail("expected UnsupportedOperationException"); } catch (final UnsupportedOperationException expected) { } try { iterator.next(); fail("NoSuchElementException expected"); } catch (final NoSuchElementException e) { } } @Test public void testMultipleIterators() throws Exception { CSVParser parser = CSVParser.parse("a,b,c" + CR + "d,e,f", CSVFormat.DEFAULT); Iterator<CSVRecord> itr1 = parser.iterator(); Iterator<CSVRecord> itr2 = parser.iterator(); CSVRecord first = itr1.next(); CSVRecord second = itr2.next(); } @Test public void testHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testSkipSetHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("a", "b", "c").withSkipHeaderRecord(true) .parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testSkipAutoHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); final CSVRecord record = records.next(); } @Test public void testHeaderComment() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").parse(in).iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeaderAuto() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception { final Reader in = new StringReader("a,b,c\n1,2\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").withSkipHeaderRecord(true) .parse(in).iterator(); CSVRecord record; record = records.next(); record = records.next(); } @Test public void testGetHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader("A", "B", "C")); final Map<String, Integer> headerMap = parser.getHeaderMap(); final Iterator<String> columnNames = headerMap.keySet().iterator(); final Iterator<CSVRecord> records = parser.iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testNoHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT); } @Test public void testGetLineNumberWithLF() throws Exception { this.validateLineNumbers(String.valueOf(LF)); } @Test public void testGetLineNumberWithCRLF() throws Exception { this.validateLineNumbers(CRLF); } @Test public void testGetLineNumberWithCR() throws Exception { this.validateLineNumbers(String.valueOf(CR)); } @Test public void testGetRecordNumberWithLF() throws Exception { this.validateRecordNumbers(String.valueOf(LF)); } @Test public void testGetRecordWithMultiLineValues() throws Exception { final CSVParser parser = CSVParser.parse("\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\"" + CRLF + "\"c\r\n1\",\"c\r\n2\"", CSVFormat.DEFAULT.withRecordSeparator(CRLF)); CSVRecord record; } @Test public void testGetRecordNumberWithCRLF() throws Exception { this.validateRecordNumbers(CRLF); } @Test public void testGetRecordNumberWithCR() throws Exception { this.validateRecordNumbers(String.valueOf(CR)); } @Test(expected = IllegalArgumentException.class) public void testInvalidFormat() throws Exception { final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR); new CSVParser(null, invalidFormat).close(); } @Test(expected = IllegalArgumentException.class) public void testParseNullFileFormat() throws Exception { CSVParser.parse((File) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseFileNullFormat() throws Exception { CSVParser.parse(new File(""), null); } @Test(expected = IllegalArgumentException.class) public void testParseNullStringFormat() throws Exception { CSVParser.parse((String) null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParseStringNullFormat() throws Exception { CSVParser.parse("csv data", null); } @Test(expected = IllegalArgumentException.class) public void testParseNullUrlCharsetFormat() throws Exception { CSVParser.parse(null, Charset.defaultCharset(), CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testParserUrlNullCharsetFormat() throws Exception { CSVParser.parse(new URL("http: } @Test(expected = IllegalArgumentException.class) public void testParseUrlCharsetNullFormat() throws Exception { CSVParser.parse(new URL("http: } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserNullReaderFormat() throws Exception { new CSVParser(null, CSVFormat.DEFAULT); } @Test(expected = IllegalArgumentException.class) public void testNewCSVParserReaderNullFormat() throws Exception { new CSVParser(new StringReader(""), null); } private void validateRecordNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); CSVRecord record; } private void validateLineNumbers(final String lineSeparator) throws IOException { final CSVParser parser = CSVParser.parse("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator)); }}
Code: public Map<String, Integer> getHeaderMap() { return new LinkedHashMap<String, Integer>(this.headerMap); }
tensor([[0.0807, 0.1471, 0.2037, 0.1005, 0.1182, 0.0901, 0.0400, 0.1123, 0.0707,
         0.0367],
        [0.0515, 0.1290, 0.2906, 0.1141, 0.1154, 0.0755, 0.0253, 0.1166, 0.0534,
         0.0286],
        [0.0576, 0.1500, 0.2207, 0.1320, 0.1274, 0.0868, 0.0332, 0.1047, 0.0558,
         0.0317],
        [0.0642, 0.1455, 0.2055, 0.1280, 0.1309, 0.1005, 0.0316, 0.1050, 0.0577,
         0.0310],
        [0.0853, 0.1524, 0.1527, 0.1180, 0.1280, 0.0993, 0.0489, 0.0950, 0.0739,
         0.0466],
        [0.0594, 0.1380, 0.2477, 0.1280, 0.1235, 0.0850, 0.0350, 0.0917, 0.0583,
         0.0335],
        [0.0696, 0.1151, 0.2285, 0.1242, 0.1286, 0.0980, 0.0449, 0.0883, 0.0656,
         0.0372],
        [0.0656, 0.1401, 0.1996, 0.1258, 0.1460, 0.1034, 0.0337, 0.1056, 0.0575,
         0.0227],
        [0.0538, 0.1439, 0.2029, 0.1400, 0.1163, 0.0881, 0.0357, 0.1208, 0.0622,
         0.0364],
        [0.0585, 0.1631, 0.1580, 0.1279, 0.1419, 0.1254, 0.0328, 0.0917, 0.0698,
         0.0309]])
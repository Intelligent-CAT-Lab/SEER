60794
Test: public void testBackslashEscapingOld() throws IOException { final String code = "one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n" + "one,\"tw\\\"o\"\n" + "one,\"t\\,wo\"\n" + "one,two,\"th,ree\"\n" + "\"a\\\\\"\n" + "a\\,b\n" + "\"a\\\\,b\""; final String[][] res = { {"one", "two", "three"}, {"on\\\"e", "two"}, {"on\"e", "two"}, {"one", "tw\"o"}, {"one", "t\\,wo"}, {"one", "two", "th,ree"}, {"a\\\\"}, {"a\\", "b"}, {"a\\\\,b"} }; final CSVParser parser = new CSVParser(new StringReader(code)); final List<CSVRecord> records = parser.getRecords(); for (int i = 0; i < res.length; i++) { } } @Test public void testBackslashEscaping() throws IOException { final String code = "one,two,three\n" + "'',''\n" + "/',/'\n" + "'/'','/''\n" + "'''',''''\n" + "/,,/,\n" + " + "' + " 8 , \"quoted \"\" /\" + "9, /\n \n" + ""; final String[][] res = { {"one", "two", "three"}, {"", ""}, {"'", "'"}, {"'", "'"}, {"'", "'"}, {",", ","}, {"/", "/"}, {"/", "/"}, {" 8 ", " \"quoted \"\" \" / string\" "}, {"9", " \n "}, }; final CSVFormat format = CSVFormat.newBuilder(',').withQuoteChar('\'').withEscape('/') .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build(); final CSVParser parser = new CSVParser(code, format); final List<CSVRecord> records = parser.getRecords(); Utils.compare("Records do not match expected result", res, records); } @Test public void testBackslashEscaping2() throws IOException { final String code = "" + " , , \n" + " \t , , \n" + " + ""; final String[][] res = { {" ", " ", " "}, {" \t ", " ", " "}, {" / ", " , ", " ,"}, }; final CSVFormat format = CSVFormat.newBuilder(',').withEscape('/') .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build(); final CSVParser parser = new CSVParser(code, format); final List<CSVRecord> records = parser.getRecords(); Utils.compare("", res, records); } @Test public void testDefaultFormat() throws IOException { final String code = "" + "a,b#\n" + "\"\n\",\" \",#\n" + "#,\"\"\n" + "# Final comment\n" ; final String[][] res = { {"a", "b#"}, {"\n", " ", "#"}, {"#", ""}, {"# Final comment"} }; CSVFormat format = CSVFormat.DEFAULT; CSVParser parser = new CSVParser(code, format); List<CSVRecord> records = parser.getRecords(); Utils.compare("Failed to parse without comments", res, records); final String[][] res_comments = { {"a", "b#"}, {"\n", " ", "#"}, }; format = CSVFormat.newBuilder().withCommentStart('#').build(); parser = new CSVParser(code, format); records = parser.getRecords(); Utils.compare("Failed to parse with comments", res_comments, records); } @Test public void testCarriageReturnLineFeedEndings() throws IOException { final String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; final CSVParser parser = new CSVParser(new StringReader(code)); final List<CSVRecord> records = parser.getRecords(); } @Test public void testCarriageReturnEndings() throws IOException { final String code = "foo\rbaar,\rhello,world\r,kanu"; final CSVParser parser = new CSVParser(new StringReader(code)); final List<CSVRecord> records = parser.getRecords(); } @Test public void testLineFeedEndings() throws IOException { final String code = "foo\nbaar,\nhello,world\n,kanu"; final CSVParser parser = new CSVParser(new StringReader(code)); final List<CSVRecord> records = parser.getRecords(); } @Test public void testIgnoreEmptyLines() throws IOException { final String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n"; final CSVParser parser = new CSVParser(new StringReader(code)); final List<CSVRecord> records = parser.getRecords(); } @Test public void testForEach() throws Exception { final List<CSVRecord> records = new ArrayList<CSVRecord>(); final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) { records.add(record); } } @Test public void testRoundtrip() throws Exception { final StringWriter out = new StringWriter(); final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT); final String input = "a,b,c\r\n1,2,3\r\nx,y,z\r\n"; for (final CSVRecord record : CSVFormat.DEFAULT.parse(new StringReader(input))) { printer.printRecord(record); } printer.close(); } @Test public void testIterator() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator(); try { iterator.remove(); fail("expected UnsupportedOperationException"); } catch (final UnsupportedOperationException expected) { } try { iterator.next(); fail("NoSuchElementException expected"); } catch (final NoSuchElementException e) { } } @Test public void testHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testHeaderComment() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.newBuilder().withCommentStart('#').withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { final CSVRecord record = records.next(); } } @Test public void testProvidedHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader("A", "B", "C").parse(in).iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception { final Reader in = new StringReader("a,b,c\n1,2\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader("A", "B", "C").parse(in).iterator(); CSVRecord record = records.next(); record = records.next(); record = records.next(); } @Test public void testGetHeaderMap() throws Exception { final CSVParser parser = new CSVParser("a,b,c\n1,2,3\nx,y,z", CSVFormat.newBuilder().withHeader("A", "B", "C").build()); final Map<String, Integer> headerMap = parser.getHeaderMap(); final Iterator<String> columnNames = headerMap.keySet().iterator(); final Iterator<CSVRecord> records = parser.iterator(); for (int i = 0; i < 3; i++) { final CSVRecord record = records.next(); } } @Test public void testGetLineNumberWithLF() throws Exception { validateLineNumbers(String.valueOf(LF)); } @Test public void testGetLineNumberWithCRLF() throws Exception { validateLineNumbers(CRLF); } @Test public void testGetLineNumberWithCR() throws Exception { validateLineNumbers(String.valueOf(CR)); } @Test public void testGetRecordNumberWithLF() throws Exception { validateRecordNumbers(String.valueOf(LF)); } @Test public void testGetRecordWithMultiiLineValues() throws Exception { final CSVParser parser = new CSVParser("\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\"" + CRLF + "\"c\r\n1\",\"c\r\n2\"", CSVFormat.newBuilder().withRecordSeparator(CRLF).build()); CSVRecord record; } @Test public void testGetRecordNumberWithCRLF() throws Exception { validateRecordNumbers(CRLF); } @Test public void testGetRecordNumberWithCR() throws Exception { validateRecordNumbers(String.valueOf(CR)); } private void validateRecordNumbers(final String lineSeparator) throws IOException { final CSVParser parser = new CSVParser("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.newBuilder().withRecordSeparator(lineSeparator).build()); CSVRecord record; } private void validateLineNumbers(final String lineSeparator) throws IOException { final CSVParser parser = new CSVParser("a" + lineSeparator + "b" + lineSeparator + "c", CSVFormat.newBuilder().withRecordSeparator(lineSeparator).build()); }}
Code: public String get(final String name) { if (mapping == null) { throw new IllegalStateException( "No header mapping was specified, the record values can't be accessed by name"); } final Integer index = mapping.get(name); try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( "Index for header '%s' is %d but CSVRecord only has %d values!", name, index.intValue(), values.length)); } }
tensor([[0.0114, 0.0147, 0.0030,  ..., 0.0070, 0.0048, 0.0048],
        [0.0119, 0.0141, 0.0035,  ..., 0.0075, 0.0042, 0.0042],
        [0.0103, 0.0195, 0.0026,  ..., 0.0063, 0.0045, 0.0045],
        ...,
        [0.0114, 0.0200, 0.0027,  ..., 0.0079, 0.0038, 0.0038],
        [0.0084, 0.0154, 0.0023,  ..., 0.0063, 0.0041, 0.0041],
        [0.0084, 0.0154, 0.0023,  ..., 0.0063, 0.0041, 0.0041]])